<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="这一篇介绍 java 并发的底层原理。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发系列（三）：底层原理">
<meta property="og:url" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="飙戈的博客">
<meta property="og:description" content="这一篇介绍 java 并发的底层原理。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154344258.png">
<meta property="og:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154404719.png">
<meta property="og:image" content="evernotecid://1A77DB63-CEBF-4C5E-B653-7DD2D90B3827/appyinxiangcom/9108333/ENResource/p7260">
<meta property="og:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154443435.png">
<meta property="og:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154457719.png">
<meta property="og:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154511606.png">
<meta property="og:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154523435.png">
<meta property="og:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154534411.png">
<meta property="og:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154608534.png">
<meta property="og:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154618354.png">
<meta property="og:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154630431.png">
<meta property="og:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154646082.png">
<meta property="og:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154706243.png">
<meta property="og:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154721517.png">
<meta property="og:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154736955.png">
<meta property="article:published_time" content="2021-03-07T07:39:07.000Z">
<meta property="article:modified_time" content="2023-03-27T11:54:31.761Z">
<meta property="article:author" content="mcbilla">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154344258.png">

<link rel="canonical" href="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java并发系列（三）：底层原理 | 飙戈的博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c54cee131e68bbf3e1a2ae155d8aa5ca";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">飙戈的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="mcbilla">
      <meta itemprop="description" content="Constant dropping wears the stone">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飙戈的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发系列（三）：底层原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-07 15:39:07" itemprop="dateCreated datePublished" datetime="2021-03-07T15:39:07+08:00">2021-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-27 19:54:31" itemprop="dateModified" datetime="2023-03-27T19:54:31+08:00">2023-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Java%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a>
                </span>
            </span>

          
            <span id="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-meta-item leancloud_visitors" data-flag-title="Java并发系列（三）：底层原理" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>这一篇介绍 java 并发的底层原理。</p>
</blockquote>
<span id="more"></span>

<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><p>Unsafe类位于rt.jar包，Unsafe类提供了硬件级别的原子操作，类中的方法都是native方法，它们使用JNI的方式访问本地C++实现库。由此提供了一些绕开JVM的更底层功能，可以提高程序效率。</p>
<blockquote>
<p>JNI：Java Native Interface。使得Java 与 本地其他类型语言（如C、C++）直接交互。</p>
</blockquote>
<p>Unsafe 是用于扩展 Java 语言表达能力、便于在更高层（Java 层）代码里实现原本要在更低层（C 层）实现的核心库功能用的。这些功能包括直接内存的申请&#x2F;释放&#x2F;访问，低层硬件的 atomic&#x2F;volatile 支持，创建未初始化对象，通过偏移量操作对象字段、方法、实现线程无锁挂起和恢复等功能。</p>
<p>Unsafe作用可以大致归纳为：</p>
<ul>
<li>内存管理，包括分配内存、释放内存等。</li>
<li>非常规的对象实例化。</li>
<li>操作类、对象、变量。</li>
<li>自定义超大数组操作。</li>
<li>多线程同步。包括锁机制、CAS操作等。</li>
<li>线程挂起与恢复。</li>
<li>内存屏障。</li>
</ul>
<p>一般可以通过单例模式获取 unsafe 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">    f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) f.get(<span class="literal">null</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43767015/article/details/104643890">Java Unsafe类的原理详解与使用案例</a></p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS（Compare and Swap），翻译过来就是“比较并交换”。CAS 操作包含三个操作数 —— 要更新的字段内存位置V（它的值是我们想要去更新的）、预期原值A（前面从内存中读取的值）和新值B(将要写入的新值)。</p>
<p>CAS操作过程：首先读取预期原值A，然后在要更新数据的时候再次读取内存位置V的值，如果该值与预期原值A相匹配，那么处理器会自动将该位置V值更新为新值B；如果失败并且允许再次尝试，直到成功，或者允许失败的线程放弃操作。</p>
<p>JUC 提供了一些类来支持原子操作，如AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值），这些类内部就是使用 CAS 操作来实现的，而这些 CAS 操作 都是基于 Unsafe 类来实现的，Unsafe类也是 JUC 包的实现的基石。例如 AtomicInteger 类的 <code>compareAndSet</code> 方法就调用了 Unsafe 的 <code>compareAndSwapInt</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Unsafe 的 <code>compareAndSwapInt</code> 方法是一个native的方法，一般是 Java 通过借助C、C++来实现直接操作底层系统、直接内存的方法。Unsafe的具体实现是和虚拟机实现相关的，不同的虚拟机具有不同的实现。在openjdk8的hotspot源码(unsafe.cpp)中能看到unsafe的源码，由于hotspot使用C++编写，那么unsafe的对应方法的C++源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class="line"><span class="comment">//获取obj这个对象在jvm里面的对应的内存对象实例</span></span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line"><span class="comment">//通过对象实例和偏移量获取字段在对象中的偏移地址</span></span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line"><span class="comment">// 通过判断调用Atomic.cmpxchg方法的结果返回值是不是原来的e值，如果是表示更新成功，否则更新失败。</span></span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>
<p>我们可以看到在该方法的最后调用了Atomic::cmpxchg的方法，但是你如果直接去atomic.cpp中是找不到的，并且上面的方法只是C++的源码并没有具体的汇编指令,但是我们在atomic.cpp中能够找到很多预处理指令,即#include “”，该指令会在实现定义的位置查找文件，并将其包含。我们找到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;runtime/atomic.inline.hpp&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>进入atomic.inline.hpp，这里面又有很多预处理指令，这些包含的文件均具有Atomic::cmpxchg的不同实现，有windows的也有linux的，一般生产应用运行在linux环境中，因此我们找到其中一个-我们分析Linux的x86的环境：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;atomic_linux_x86.inline.hpp&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>在atomic_linux_x86.hpp的源码中，终于能找到该方法，汇编指令（CPU指令）可以自由的嵌入C&#x2F;C++，下面的方法就是最好的证明，接下来进入汇编指令的世界：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint     <span class="title function_">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value, cmpxchg_memory_order order)</span> &#123;</span><br><span class="line">  <span class="type">int</span> mp = os::is_MP();</span><br><span class="line">  __asm__ <span class="title function_">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span><br><span class="line"><span class="params">                    : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span><br><span class="line"><span class="params">                    : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span><br><span class="line"><span class="params">                    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中__asm__表示汇编指令开始，volatile禁止优化重排序，MP表示multiprocessor，LOCK_IF_MP开始时表示它会判断当前系统是否是多核处理器，如果是，那么就在cmpxchg指令前面加上lock指令前缀，否则就使用cmpxchg一条指令。可以看到Java的CAS操作的最终实现，是通过 <code>lock cmpxchg</code> 汇编指令实现的。这两条指令的解释如下：</p>
<blockquote>
<p>cmpxchg</p>
<p>作用：汇编指令，比较并交换操作数</p>
<p>该指令只能用于486及其后继机型。第2操作数（源操作数）只能用8位、16位或32位寄存器。第1操作数（目地操作数）则可用寄存器或任一种存储器寻址方式。</p>
<p>注意：虽然cmpxchg看起来只有一条指令，但在多核cpu下仅比较交换的指令仍然不具有原子性，因为cmpxchg作为复杂指令，同时带有读写操作，在执行时会被分解为一条条的更小的微码（微指令），一般来说只有单一的load、stroe等指令是真正原子性的。</p>
<p>但是该指令可以与lock同步一起使用，以允许以原子方式执行该指令（来自Intel手册）。</p>
</blockquote>
<blockquote>
<p>lock<br>前缀指令，通常可以与某些指令连用（ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG等指令），它具有如下特性（来自Intel手册）：</p>
<ul>
<li><p>确保对内存的读-改-写操作原子执行，即确保lock后面的指令变成一个原子操作。 在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问共享内存，保证内存独占。很显然，这会带来昂贵的开销。从Pentium4、Intel Xeon及P6处理器开始，Intel使用缓存锁定（Cache Locking）来保证指令执行的原子性。缓存锁定将大大降低lock前缀指令的执行开销。这实际上也算一种CPU指令级别的同步。</p>
</li>
<li><p>不是内存屏障，但是具有内存屏障的功能，能够禁止该指令与之前和之后的读和写指令重排序。</p>
</li>
<li><p>如果lock后面的指令具有写操作，那么lock会导致把写缓冲区中的所有数据刷新到主存中，同时让其它CPU相关缓存行失效，从而重新从主存中加载最新的数据。</p>
</li>
</ul>
</blockquote>
<p>CAS的三大问题：</p>
<ol>
<li><code>ABA问题</code>：CAS需要再操作值的时候，检查值有没有发生变化，如果没有发生变化则更新。但是一个值，如果原来为A，变成了B，又变成了A，那么使用CAS进行compare and set的时候，会发现它的值根本没变化过，但实际上是变化过的。ABA问题的解决思路就是使用版本号，1A-&gt;2B-&gt;3A，在Atomic包中（JDK5），提供了一个现成的AtomicStampedReference类来解决ABA问题，使用的就是添加版本号的方法。</li>
<li><code>循环时间长开销大</code>：由于线程并不会阻塞，如果CAS自旋长时间不成功，这会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。</li>
<li><code>只能保证一个共享变量的原子操作</code>：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，由于CAS底层只能锁定单个指令，均是针对单个变量的操作，对多个共享变量操作时意味着多个指令，此时CAS就无法保证所有操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j&#x3D;a，合并一下ij&#x3D;2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</li>
</ol>
<p>参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43767015/article/details/106342879">Java CAS操作的实现原理深度解析与应用案例</a></p>
<h2 id="CLH"><a href="#CLH" class="headerlink" title="CLH"></a>CLH</h2><p>CLH是一个基于链表（队列）非线程饥饿的自旋（公平）锁，由于是 Craig、Landin 和 Hagersten三人的发明，因此命名为CLH锁。每一个等待锁的线程封装成节点，不断自旋判断前一个节点的状态，如果前一个节点释放锁就结束自旋。</p>
<p>CLH锁原理如下：</p>
<ol>
<li>首先有一个尾节点指针，通过这个尾结点指针来构建等待线程的逻辑队列（所有每个线程还应该保存前面Node的状态，链表形式），因此能确保线程线程先到先服务的公平性，因此尾指针可以说是构建逻辑队列的桥梁；此外这个尾节点指针是原子引用类型，避免了多线程并发操作的线程安全性问题。</li>
<li>每个等待锁的线程在自己的前驱节点某个变量上自旋等待，等待前驱解锁之后即可去获取锁。</li>
</ol>
<p><img src="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154344258.png" alt="image-20230307154344258"></p>
<p>参考 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1690060">AQS基础——多图详解CLH锁的原理与实现</a><br><a target="_blank" rel="noopener" href="https://funzzz.fun/2021/05/19/CLH%E9%94%81/">CLH lock</a></p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AQS全称为AbstractQueuedSynchronizer，可以叫做队列同步器，为线程的同步和等待等操作提供一个基础模板类。Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AQS的。</p>
<p><code>一般来说，使用AQS的时候先继承AQS，继承子类应以其他类的内部类的形式存在，然后使用代理模式调用子类和AQS本身的方法实现线程的同步</code>。使用ReentrantLock举例，外界调用ReentrantLock，ReentrantLock内部定义Sync，Sync是AQS的子类，在ReentrantLock的内部实现中调用Sync的方法，最后完成最终的功能，当然ReentrantLock内部稍复杂，又加入和公平锁和非公平锁。</p>
<h2 id="AQS架构"><a href="#AQS架构" class="headerlink" title="AQS架构"></a>AQS架构</h2><p>AQS 的设计基于「<code>模板模式</code>」。AQS 把大部分底层细节已经封装好了，使用者继承 AQS 后只需要实现几个方法，AQS 在运行的时候会自动调用到作者实现的方法。<br><img src="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154404719.png" alt="image-20230307154404719"></p>
<ul>
<li>上图中有颜色的为Method，无颜色的为Attribution。</li>
<li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li>
<li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li>
</ul>
<h2 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h2><p>AQS 主要由三部分组成：</p>
<ul>
<li>state 同步状态</li>
<li>Node 组成的 CLH 队列</li>
<li>ConditionObject 条件变量（包含 Node 组成的条件单向队列）。</li>
</ul>
<p>线程通过 CAS 尝试完成对 State 值的修改，如果修改成功就表示获取锁成功，如果修改失败就把线程封装成一个 Node 节点添加到 CLH 队列；如果是被 Condition 阻塞了，就添加到 ConditionObject 队列。<br><img src="evernotecid://1A77DB63-CEBF-4C5E-B653-7DD2D90B3827/appyinxiangcom/9108333/ENResource/p7260" alt="f2585562b0912a10a04058293dadc0d0.png"></p>
<h3 id="同步状态State"><a href="#同步状态State" class="headerlink" title="同步状态State"></a>同步状态State</h3><p><code>state 是一个 Volatile 修饰的 int 变量，是 AQS 的核心变量</code>。所有通过 AQS 实现功能的类都是通过修改 state 的状态来操作线程的同步状态。</p>
<p>AQS提供了操作state的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式：</p>
<ul>
<li>独占模式：只有一个线程可以获取锁，如果是不可重入锁，state的值只能为0或1；如果是可重入锁，state的值可以为0、1或者大于1（持有锁的线程重入state会累加1）。</li>
<li>共享模式：多个线程可以获取锁，state的值表示可以同时持有锁的线程数。<br><img src="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154443435.png" alt="image-20230307154443435"><br><img src="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154457719.png" alt="image-20230307154457719"></li>
</ul>
<h3 id="Node组成的CLH队列"><a href="#Node组成的CLH队列" class="headerlink" title="Node组成的CLH队列"></a>Node组成的CLH队列</h3><p>上面我们有提到 CLH 队列是一个虚拟的单向链表。虚拟的意思是即不存在队列实例，每个节点通过保存前一个节点的引用来形成链表关系，后一个节点阻塞在前一个节点的某个状态变量上。</p>
<p>AQS 中的队列是 CLH 变体的虚拟双向队列（FIFO）。</p>
<ul>
<li>AQS 的节点同时保存了前后两个节点的引用（除了首尾两个边缘节点）。</li>
<li>AQS 的节点没有阻塞在前一个节点的某个变量上，而是阻塞在前一个节点是否头节点这种状态上。</li>
</ul>
<p>CLH 变体队列中的节点数据结构为 <code>Node</code>。获取锁失败的线程被封装成 Node 节点，添加到 CLH 变体队列的队尾。<br><img src="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154511606.png" alt="image-20230307154511606"></p>
<p>Node 的几个重要变量：</p>
<ul>
<li>waitStatus	当前节点在队列中的状态</li>
<li>thread	表示处于该节点的线程</li>
<li>prev	前驱指针</li>
<li>next	后继指针</li>
<li>predecessor	返回前驱节点，没有的话抛出npe</li>
<li>nextWaiter	指向下一个处于CONDITION状态的节点</li>
</ul>
<p>线程两种锁的模式：</p>
<ul>
<li>SHARED	表示线程以共享的模式等待锁</li>
<li>EXCLUSIVE	表示线程正在以独占的方式等待锁</li>
</ul>
<p>waitStatus 的枚举值：</p>
<ul>
<li>0	当一个Node被初始化的时候的默认值</li>
<li>CANCELLED	为1，表示线程获取锁的请求已经取消了</li>
<li>CONDITION	为-2，表示节点在等待队列中，节点线程等待唤醒</li>
<li>PROPAGATE	为-3，当前线程处在SHARED情况下，该字段才会使用</li>
<li>SIGNAL	为-1，表示线程已经准备好了，就等资源释放了</li>
</ul>
<p>AQS 类成员变量 head 和 tail 字段分别指向 CLH 同步队列的头 Node 和尾 Node。head 节点是虚节点（哨兵节点），不保存除 waitStatus 的其他信息。<br><img src="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154523435.png" alt="image-20230307154523435"></p>
<p>当调用 AQS 的 acquire 方法获取资源时，如果资源不足则当前线程会被封装成 Node 结点添加到同步队列的末端（入队），头结点 head 用于记录当前正在持有资源的线程结点，而 head 的后继结点就是下一个将要被调度的线程结点，当 release 方法被调用时，该结点上的线程将被唤醒（出队），继续获取资源。</p>
<ul>
<li>入队：获取资源失败的线程需要封装成 Node 节点，接着尾部入队，在 AQS 中提供 addWaiter 函数完成 Node 节点的创建与入队。添加节点的时候，如 CLH 队列已经存在，通过 CAS 快速将当前节点添加到队列尾部，如果添加失败或队列不存在，则初始化同步队列。</li>
<li>出队：CLH 队列中的节点都是获取资源失败的线程节点，当持有资源的线程释放资源时，会将 head.next 指向的线程节点唤醒（CLH 队列的第二个节点），如果唤醒的线程节点获取资源成功，线程节点清空信息设置为头部节点（新哨兵节点），原头部节点出队（原哨兵节点）。</li>
</ul>
<p><img src="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154534411.png" alt="image-20230307154534411"></p>
<h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3><p>上面我们提到的 CLH 变体队列，实际上是 AQS 的<code>同步队列（Sync Queue）</code>，是双向链表，用于存储获取锁失败的线程。</p>
<p>AQS 内部还有数据结构 <code>ConditionObject</code>，称作<code>等待队列（Wait Queue）</code>，用于存储被阻塞在某个 Condition 上的线程。ConditionObject 复用了 Node 的数据结构，不过是一个单向链表。<br><img src="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154608534.png" alt="image-20230307154608534"></p>
<p>因为可以定义多个 Condition，每个 Condition 对应一个等待队列，所以可能存在多个等待队列。<br><img src="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154618354.png" alt="image-20230307154618354"></p>
<p>等待队列中通过 signal() 被唤醒的节点，会加入到同步队列的队尾；如果是 signalAll() 唤醒，就把等待队列的所有节点加入同步队列（没有特殊原因尽量别用 signalAll 方法）。<br><img src="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154630431.png" alt="image-20230307154630431"></p>
<h2 id="AQS使用"><a href="#AQS使用" class="headerlink" title="AQS使用"></a>AQS使用</h2><h3 id="同步器可重写的方法"><a href="#同步器可重写的方法" class="headerlink" title="同步器可重写的方法"></a>同步器可重写的方法</h3><p>AQS 提供的可重写方法只有5个，这大大方便了锁的使用者。<br><img src="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154646082.png" alt="image-20230307154646082"></p>
<p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。为了避免强制重写不相干方法，所以就没有 abstract 来修饰了，但要抛出异常告知不能直接使用该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。</p>
<h3 id="同步器提供的模版方法"><a href="#同步器提供的模版方法" class="headerlink" title="同步器提供的模版方法"></a>同步器提供的模版方法</h3><p>上面我们将同步器的实现方法分为独占式和共享式两类，模版方法其实除了提供以上两类模版方法之外，只是多了响应中断和超时限制 的模版方法供 Lock 使用。<code>这些模板方法都有 final 关键字修饰，说明子类不能重写这个方法，但是模板方法方法最终会调用到上面重写的方法</code>。<br><img src="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154706243.png" alt="image-20230307154706243"></p>
<p>实际应用的时候，他们的关系大概如下：<br><img src="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154721517.png" alt="image-20230307154721517"></p>
<h3 id="共享模式和独占模式"><a href="#共享模式和独占模式" class="headerlink" title="共享模式和独占模式"></a>共享模式和独占模式</h3><p><code>AbstractQueuedSynchronizer</code> 类继承了 <code>AbstractOwnableSynchronizer</code> 类，后者提供了 <code>exclusiveOwnerThread</code> 属性，用来记录当前持有锁的线程。</p>
<p>当独占锁已经被某个线程持有时，其他线程只能等待它被释放后，才能去争锁，并且同一时刻只有一个线程能争锁成功。</p>
<p>而对于共享锁而言，由于锁是可以被共享的，因此它可以被多个线程同时持有。换句话说，如果一个线程成功获取了共享锁，那么其他等待在这个共享锁上的线程就也可以尝试去获取锁，并且极有可能获取成功。</p>
<p>共享锁的实现和独占锁是对应的，我们可以从下面这张表中看出：<br><img src="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154736955.png" alt="image-20230307154736955"></p>
<p>除了最后一个属于共享锁的 doReleaseShared() 方法没有对应外，其他的方法，独占锁和共享锁都是一一对应的。</p>
<p>在独占锁模式中，我们只有在获取了独占锁的节点释放锁时，才会唤醒后继节点；在共享锁模式下，当一个节点获取到了共享锁，我们在获取成功后就可以调用 doReleaseShared() 唤醒后继节点了，而不需要等到该节点释放锁的时候。这是因为共享锁可以被多个线程同时持有，一个锁获取到了，则后继的节点都可以直接来获取。<code>所以在独占模式下，释放锁的时候才会唤醒后继节点；在共享锁模式下，在获取锁和释放锁结束时，都会唤醒后继节点</code>。</p>
<p>参考 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1639473">万字超强图文讲解AQS以及ReentrantLock应用</a><br><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016447307">逐行分析AQS源码(3)——共享锁的获取与释放</a><br><a target="_blank" rel="noopener" href="https://www.modb.pro/db/151391">彻底理解 AQS 我是懂了，你呢？</a><br><a target="_blank" rel="noopener" href="https://www.modb.pro/db/56987">1.5w字，30图带你彻底掌握 AQS！</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/" rel="prev" title="Java并发系列（二）：线程模型">
      <i class="fa fa-chevron-left"></i> Java并发系列（二）：线程模型
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/08/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/" rel="next" title="Java并发系列（四）：并发容器">
      Java并发系列（四）：并发容器 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsafe"><span class="nav-number">1.1.</span> <span class="nav-text">Unsafe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS"><span class="nav-number">1.2.</span> <span class="nav-text">CAS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CLH"><span class="nav-number">1.3.</span> <span class="nav-text">CLH</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AQS"><span class="nav-number">2.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS%E6%9E%B6%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">AQS架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">AQS原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81State"><span class="nav-number">2.2.1.</span> <span class="nav-text">同步状态State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node%E7%BB%84%E6%88%90%E7%9A%84CLH%E9%98%9F%E5%88%97"><span class="nav-number">2.2.2.</span> <span class="nav-text">Node组成的CLH队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConditionObject"><span class="nav-number">2.2.3.</span> <span class="nav-text">ConditionObject</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS%E4%BD%BF%E7%94%A8"><span class="nav-number">2.3.</span> <span class="nav-text">AQS使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%99%A8%E5%8F%AF%E9%87%8D%E5%86%99%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.1.</span> <span class="nav-text">同步器可重写的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%99%A8%E6%8F%90%E4%BE%9B%E7%9A%84%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.2.</span> <span class="nav-text">同步器提供的模版方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.3.3.</span> <span class="nav-text">共享模式和独占模式</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mcbilla"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">mcbilla</p>
  <div class="site-description" itemprop="description">Constant dropping wears the stone</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/mcbilla" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mcbilla" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mcbilla</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'NL3uHcex1UcrXkcOvkLDH1p8-gzGzoHsz',
      appKey     : 'lBSzvyvWKyPT9clWgSrVZxzF',
      placeholder: "一起来讨论吧～",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
