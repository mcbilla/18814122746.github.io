<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Linux系列（一）：硬件结构">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系列（一）：硬件结构">
<meta property="og:url" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="飙戈的博客">
<meta property="og:description" content="Linux系列（一）：硬件结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115502558.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115546761.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115601204.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115617135.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115631476.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115647816.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115702867.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115718432.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115735878.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115751158.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115812304.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115824899.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115845086.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115856919.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115909199.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115923946.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319120000708.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319120012283.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319120031295.png">
<meta property="og:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319120044434.png">
<meta property="article:published_time" content="2021-03-18T19:43:53.000Z">
<meta property="article:modified_time" content="2023-03-27T11:54:31.848Z">
<meta property="article:author" content="mcbilla">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115502558.png">

<link rel="canonical" href="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux系列（一）：硬件结构 | 飙戈的博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c54cee131e68bbf3e1a2ae155d8aa5ca";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">飙戈的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="mcbilla">
      <meta itemprop="description" content="Constant dropping wears the stone">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飙戈的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux系列（一）：硬件结构
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-19 03:43:53" itemprop="dateCreated datePublished" datetime="2021-03-19T03:43:53+08:00">2021-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-27 19:54:31" itemprop="dateModified" datetime="2023-03-27T19:54:31+08:00">2023-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          
            <span id="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/" class="post-meta-item leancloud_visitors" data-flag-title="Linux系列（一）：硬件结构" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>Linux系列（一）：硬件结构</p>
</blockquote>
<span id="more"></span>

<h2 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h2><p><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115502558.png" alt="image-20230319115502558"></p>
<p>冯诺依曼模型定义计算机基本结构为 5 个部分， 分别是<code>中央处理器(CPU)</code>、<code>内存</code>、<code>输入设备</code>、<code>输出设备</code>、<code>总线</code>。</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>中央处理器也就是我们常说的 CPU，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：</p>
<ul>
<li>32 位 CPU 一次可以计算 4 个字节</li>
<li>64 位 CPU 一次可以计算 8 个字节</li>
</ul>
<p>CPU 内部还有一些组件：</p>
<ul>
<li><code>控制单元</code>负责控制 CPU 工作</li>
<li><code>逻辑运算单元</code>负责计算</li>
<li><code>寄存器</code>存储计算时的数据</li>
</ul>
<p>而寄存器可以分为多种类，每种寄存器的功能又不尽相同。</p>
<ul>
<li><code>通用寄存器</code>，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。</li>
<li><code>程序计数器（PC）</code>，用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。</li>
<li><code>指令寄存器</code>，用来存放程序计数器指向的指令，也就是当前正在执行的指令本身，指令被执行完成之前，指令都存储在这里。</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>我们的程序和数据都是存储在内存，存储的区域是线性的。</p>
<p>数据存储的单位是一个二进制位(bit)，即 0 或 1。最小的存储单位是字节(byte)，1 字节等于 8 位。</p>
<p>内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。</p>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：</p>
<ul>
<li><code>地址总线</code>：用于指定 CPU 将要操作的内存地址。</li>
<li><code>数据总线</code>：用于读写内存的数据。</li>
<li><code>控制总线</code>：用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线。</li>
</ul>
<p>当 CPU 要读写内存数据的时候，一般需要通过两个总线：首先要通过「地址总线」来指定内存的地址，再通过「数据总线」来传输数据。</p>
<h3 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h3><p>输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘， 按下按键时是需要和 CPU 进行交互的，这时就需要用到「控制总线」了。</p>
<h3 id="程序执行"><a href="#程序执行" class="headerlink" title="程序执行"></a>程序执行</h3><p>程序实际上是一条一条指令，一个通用 CPU 要完成各类计算、推理、判断和控制工作，它的指令种类少则几十种，多则数百种，CPU的各种指令的集合称为CPU的<code>指令集</code>。</p>
<p>指令集决定了处理器的架构，处理器架构就是处理器的硬件架构，称为<code>微架构</code>。是一堆硬件电路，去实现指令集所规定的操作运算。</p>
<p>简单来说，指令集是CPU的顶层设计规范，微架构是这个顶层规范的物理实现，这种实现可以有多种，实现方法可以有变化。<code>一般说的CPU架构包含了CPU指令集和微架构两个东西</code>。</p>
<h3 id="指令集类型"><a href="#指令集类型" class="headerlink" title="指令集类型"></a>指令集类型</h3><p>指令集分为两种主流类型：</p>
<ul>
<li><code>CISC</code>(Complex Instruction Set Computers，复杂指令集)</li>
<li><code>RISC</code>(Reduced Instruction Set Computers，精简指令集)</li>
</ul>
<p>CISC指令集：CISC的指令能力强，指令长度变长，但多数指令使用率低，增加了CPU的复杂度，增加CPU功耗和发热。</p>
<ul>
<li><code>x86</code>：x86 是典型的CISC指令集，适用于PC机，桌面等设备。</li>
</ul>
<p>RISC指令集：大部分为单周期指令，指令长度固定，操作寄存器，只有Load&#x2F;Store操作内存，适用于移动端设备。</p>
<ul>
<li><code>ARM</code>：最流行的RISC指令集，占移动设备端90%以上的市场。</li>
<li><code>MIPS</code>：MIPS是RISC的开山之作，但是生态没有起来。</li>
<li><code>RISC-V</code>：综合以上特点新开发的，完全开源，但是生态链还在路上。</li>
</ul>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>上面我们提到程序执行的过程实际上是执行一条一条指令，负责执行指令的就是 CPU 了。<br><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115546761.png" alt="image-20230319115546761"></p>
<ol>
<li>第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作 「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总 线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。</li>
<li>第二步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把 指令交给「逻辑运算单元」运算;如果是存储类型的指令，则交由「控制单元」执行。</li>
<li>第三步，CPU 执行完指令后，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数 器」的值会自增 4。</li>
</ol>
<h3 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h3><p>指令执行是按照周期来执行的，CPU 的工作就是一个周期接着一个周期，周而复始。<br><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115601204.png" alt="image-20230319115601204"></p>
<ol>
<li>CPU 通过程序计数器读取对应内存地址的指令，这个部分称为 Fetch(取得指令)。</li>
<li>CPU 对指令进行解码，这个部分称为 Decode(指令译码)。</li>
<li>CPU 执行指令，这个部分称为 Execution(执行指令)。</li>
<li>CPU 将计算结果存回寄存器或者将寄存器的值存入内存，这个部分称为 Store(数据回写)。</li>
</ol>
<p>对CPU整个生命周期的不同粒度的划分，可以划分为：</p>
<ul>
<li><code>时钟周期</code></li>
<li><code>机器周期</code></li>
<li><code>指令周期</code></li>
</ul>
<p>CPU的最小生命单位就是时钟周期，一个机器周期包括若干个时钟周期，一个指令周期包含若干个机器周期。所以按粒度排序，<code>指令周期 &gt; 机器周期 &gt; 时钟周期</code>。</p>
<h4 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h4><p><code>时钟周期</code>也称为振荡周期，代表完成一次脉冲信号高低电平的转换，是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。</p>
<p>时钟周期定义为<code>1/时钟脉冲频率</code>，比如我们有一个 1 GHz 的 CPU，指的是时钟频率是 1 G，代表着 1 秒 会产生 1G 次数的脉冲信号，每一次脉冲信号高低电平的转换就是一个周期，所以时间周期市场为 1s&#x2F;1G &#x3D; 1ms。</p>
<p>在8051单片机中把一个时钟周期定义为一个节拍(用P表示)，二个节拍定义为一个状态周期(用S表示)。</p>
<h4 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h4><p>在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段，每一阶段完成一项工作。例如，取指令、存储器读、存储器写等，这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为<code>机器周期</code>。</p>
<p>一般情况下，一个机器周期由若干个S周期(状态周期)组成。8051系列单片机的一个机器周期同6个S周期(状态周期)组成。前面已说过一个时钟周期定义为一个节拍(用P表示)，二个节拍定义为一个<code>状态周期</code>(用S表示)，8051单片机的机器周期由6个状态周期组成，也就是说<code>一个机器周期=6个状态周期=12个时钟周期</code>。</p>
<h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><p><code>指令周期</code>是执行一条指令所需要的时间，一般由若干个机器周期组成。指令不同，所需的机器周期数也不同。对于一些简单的的单字节指令，在取指令周期中，指令取出到指令寄存器后，立即译码执行，不再需要其它的机器周期。对于一些比较复杂的指令，例如转移指令、乘法指令，则需要两个或者两个以上的机器周期。</p>
<p>通常含一个机器周期的指令称为单周期指令，包含两个机器周期的指令称为双周期指令。</p>
<h4 id="相互关系"><a href="#相互关系" class="headerlink" title="相互关系"></a>相互关系</h4><p><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115617135.png" alt="image-20230319115617135"></p>
<h3 id="硬中断和软中断"><a href="#硬中断和软中断" class="headerlink" title="硬中断和软中断"></a>硬中断和软中断</h3><p>有时候我们向cpu发出一些指令的时候希望得到cpu的快速响应执行。比如我们从键盘上输入文字的时候，肯定是希望屏幕上立刻显示出来，而不是等电脑播放完当前的音乐后再显示出来。这时候我们就需要引入<code>中断机制</code>。</p>
<p>中断是系统用来响应硬件设备请求的一种机制，<code>操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求</code>。</p>
<p>中断处理程序在响应中断时，会「打断其他进程的运行」，可能还会「临时关闭中断」，系统中其他的中断请求都无法被响应，也就说中断有可能会丢失，所以我们要求中断处理程序尽快执行完。</p>
<p>为了解决中断处理程序执行时长过长的问题，linux将中断过程分成两个阶段：</p>
<ul>
<li>上半部对应<code>硬中断</code>，由<code>硬件</code>触发中断，<code>会打断 CPU 正在执行的任务，然后立即执行中断处理程序</code>。主要是负责耗时短的工作，特点是快速执行。</li>
<li>下半部对应<code>软中断</code>，由<code>内核</code>触发中断，<code>负责上半部未完成的工作，以内核线程的方式执行</code>，并且每一个 CPU 都对应一个软中断内核线程，名字通常为 「ksoftirqd&#x2F;CPU 编号」。通常都是耗时比较⻓的事情，特点是延迟执行。</li>
</ul>
<p>常⻅的网卡接收网络包的例子。网卡收到网络包后，会通过硬件中断通知内核有新的数据到了，于是内核就会调用对应的中断处理程序来 响应该事件，这个事件的处理也是会分成上半部和下半部。</p>
<ul>
<li>上部分要做到快速处理，所以只要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态，比如把状态更新为表示数据已经读到内存中的状态值。接着内核会触发一个软中断，就可以返回硬中断响应了。</li>
<li>下半部分把一些处理比较耗时且复杂的事情，交给「软中断处理程序」去做，其主要是需要从内存中找到网络数据，再按照网络协议栈，对网络数据进行逐层解析和 处理，最后把数据送给应用程序。</li>
</ul>
<h2 id="存储器结构"><a href="#存储器结构" class="headerlink" title="存储器结构"></a>存储器结构</h2><p><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115631476.png" alt="image-20230319115631476"></p>
<p>存储器通常可以分为这么几个级别：</p>
<ul>
<li>寄存器</li>
<li>CPU Cache<ul>
<li>1-Cache</li>
<li>L2-Cache</li>
<li>L3-Cahce</li>
</ul>
</li>
<li>内存</li>
<li>SSD&#x2F;HDD 硬盘</li>
</ul>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p><code>寄存器</code>是最靠近 CPU 的控制单元和逻辑计算单元的存储器。存储器的数量通常在几十到几百之间，32 位 CPU 中单个寄存器可以存储 4 个字节，64 位 CPU 中大多数寄存器可以存储 8 个字节，所以寄存器的总大小大概是<code>几百个字节</code>。</p>
<p>寄存器的访问速度非常快，一般要求在<code>半个 CPU 时钟周期</code>内完成读写。</p>
<h3 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h3><p><code>CPU Cache</code> 也存在 CPU 内部，处理速度相比寄存器慢了一点，但是能存储的数据也稍微多了一些。</p>
<p>CPU Cache 用的是一种叫 <code>SRAM</code>(Static Random-Access Memory，静态随机存储器) 的芯片。SRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。</p>
<p>CPU Cache 通常会分为 L1、L2、L3 三层。<br><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115647816.png" alt="image-20230319115647816"></p>
<ul>
<li><code>L1 高速缓存</code>：访问速度几乎和寄存器一样快，通常只需要 <code>2~4 个时钟周期</code>，大小在<code>几十 KB 到几百 KB</code> 不等，每个 CPU 都有<code>单独的 L1 高速缓存</code>。L1 高速缓存通常分成<code>指令缓存</code>和<code>数据缓存</code>。分别存储指令和数据。</li>
<li><code>L2 高速缓存</code>：访问速度为 <code>10~20 个时钟周期</code>，大小在<code>几百 KB 到几 MB</code> 不等，每个 CPU 都有<code>单独的 L2 高速缓存</code>。</li>
<li><code>L3 高速缓存</code>：访问速度在 <code>20~60 个时钟周期</code>，大小在<code>几 MB 到几十 MB</code> 不等，多个 CPU <code>共享</code>相同的 L3 高速缓存。</li>
</ul>
<h3 id="内存-1"><a href="#内存-1" class="headerlink" title="内存"></a>内存</h3><p><code>内存</code>存在 CPU 外部，使用的是 <code>DRAM</code> (Dynamic Random Access Memory，动态随机存取存储器) 的芯片。</p>
<p>DRAM 存储一个 bit 数据，只需要一个晶体管和一个电容就能存储，但是因为数据会被存储在电容里，电 容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。</p>
<p>DRAM 的访问的速度会更慢，内存速度大概在 <code>200~300 个时钟周期</code>之间。</p>
<h3 id="SSD-x2F-HDD硬盘"><a href="#SSD-x2F-HDD硬盘" class="headerlink" title="SSD&#x2F;HDD硬盘"></a>SSD&#x2F;HDD硬盘</h3><p><code>SSD</code>(Solid-state disk) 就是我们常说的固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。内存的读写速度比 SSD 大概快 <code>10~1000</code> 倍。</p>
<p>SSD由<code>主控芯片</code>、<code>闪存颗粒</code>和<code>缓存芯片</code>三部分组成。</p>
<p><strong>主控芯片</strong><br>当前主流的主控芯片厂商有 marvell 迈威（俗称“马牌”）、SandForce、siliconmotion慧荣、phison群联、jmicron智微等。</p>
<p><strong>闪存颗粒</strong><br>闪存(Flash Memory)颗粒本质上是一种长寿命的非易失性(在断电情况下仍能保持所存储的数据信息)的存储器，其中<code>NAND闪存</code>是应用规模最广泛的颗粒。</p>
<p>根据NAND闪存中电子单元密度的差异，又可以分为SLC、MLC、TLC和QLC颗粒。</p>
<ul>
<li><code>SLC</code>：每个Cell单元存储<code>1bit</code>信息，也就是只有0、1两种电压变化，结构简单，电压控制也快速，写入数据时电压变化区间小，寿命长，读写次数在10万次以上，造价高，多用于企业级高端产品。</li>
<li><code>MLC</code>：每个cell单元存储<code>2bit</code>信息，需要更复杂的电压控制，有00,01,10,11四种变化，寿命长，造价可接受，多用民用高端产品，读写次数在5000左右。</li>
<li><code>TLC</code>：每个cell单元存储<code>3bit</code>信息，电压从000到001有8种变化，容量比MLC再次增加1&#x2F;3，成本更低，但是架构更复杂，使命寿命低，读写次数在1000~2000左右，是当下主流厂商首选闪存颗粒。</li>
<li><code>QLC</code>：每个cell单元存储<code>4bit</code>信息，电压有16种变化，但是容量能增加33%，就是写入性能、P&#x2F;E寿命与TLC相比会进一步降低，主要应用于低端市场。</li>
</ul>
<p><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115702867.png" alt="image-20230319115702867"></p>
<p><strong>缓存芯片</strong><br>缓存芯片在SSD中属于锦上添花的作用，部分低端的SSD出于成本控制可能都没有缓存芯片。</p>
<p>由于固态硬盘内部的磨损机制，就导致固态硬盘在读写小文件和常用文件时，会不断进行数据的整块的写入缓存，然而导出到闪存颗粒，这个过程需要大量缓存维系。特别是在进行大数量级的碎片文件的读写进程，高缓存的作用更是明显。<code>而没有缓存芯片的固态硬盘在用了一段时间后，开始掉速</code>。</p>
<p>当然，还有一款传统的硬盘，也就是机械硬盘(Hard Disk Drive, HDD)，它是通过物理读写的方式来访问 数据的，因此它访问速度是非常慢的，它的速度比内存慢 <code>10W</code> 倍左右。由于 SSD 的价格快接近机械硬盘了，因此机械硬盘已经逐渐被 SSD 替代了。</p>
<h3 id="相互关系-1"><a href="#相互关系-1" class="headerlink" title="相互关系"></a>相互关系</h3><p><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115718432.png" alt="image-20230319115718432"></p>
<p>当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即 可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还 是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据。</p>
<h2 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h2><h3 id="CPU-Cache-Line"><a href="#CPU-Cache-Line" class="headerlink" title="CPU Cache Line"></a>CPU Cache Line</h3><p>CPU Cache 的数据是从内存中读取过来的，它是以一小块一小块读取数据的，每一小块称为 <code>Cache Line</code>(缓存块)。<code>CPU Line 是 CPU 从内存读取数据的基本单位</code>。一般来说，L1 Cache Line 大小是 64 字节，也就意味着 <code>L1 Cache 一次载入数据的大小是 64 字节</code>。</p>
<p>比如，有一个 int array[100] 的数组，当载入 array[0] 时，由于这个数组元素的大小在内存只占 4 字节，不足 64 字节，CPU 就会顺序加载数组元素到 array[15] ，意味着 array[0]~array[15] 数组元素都会被缓存在 CPU Cache 中了，因此当下次访问这些数组元素时，会直接从 CPU Cache 读取，而不用再从内存中读取。</p>
<p>每一行 CPU Line 都和一块内存地址形成映射。CPU 要根据内存地址读取数据的时候，无论数据是否存放到 Cache 中，CPU 都是先访问 Cache，只有当 Cache 中找不到数据时，才会去访问内存，并把内存中的数据读入到 Cache 中，CPU 再从 CPU Cache 读取数据。</p>
<p>CPU 在从 CPU Cache 读取数据的时候，并不是读取 CPU Line 中的整个数据块，而是读取 CPU 所需要的一个数据片段，这样的数据统称为一个<code>字(Word)</code>。CPU 通过包括<code>组标记</code>、<code>CPU Line 索引</code>、<code>偏移量</code>这三种信息，在 CPU Cache Line 中查找需要的字。而对于 CPU Cache 里的数据结构，则是由<code>索引</code> + <code>有效位</code> + <code>组标记</code> + <code>数据块</code>组成。<br><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115735878.png" alt="image-20230319115735878"></p>
<p>如果内存中的数据已经在 CPU Cache 中了，那 CPU 访问一个内存地址的时候，会经历这 4 个步骤：</p>
<ol>
<li>根据内存地址中索引信息，计算在 CPU Cahe 中的索引，也就是找出对应的 CPU Line 的地址。</li>
<li>找到对应 CPU Line 后，判断 CPU Line 中的有效位，确认 CPU Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行。</li>
<li>对比内存地址中组标记和 CPU Line 中的组标记，确认 CPU Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行。</li>
<li>根据内存地址中偏移量信息，从 CPU Line 的数据块中，读取对应的字。</li>
</ol>
<h3 id="写回策略"><a href="#写回策略" class="headerlink" title="写回策略"></a>写回策略</h3><p>当我们更新了 CPU Cache Line 的内容时，需要在适当的时机把更新的内容写回内存。根据更新的时机，可以分为：</p>
<ul>
<li><code>写直达</code>(Write Through)：把数据同时写入内存和 Cache 中。安全性高，但性能较差。</li>
<li><code>写回</code>(Write Back)：当发生写操作时，只有在缓存不命中，同时数据对应的 Cache 中 的 Cache Block 为脏标记的情况下，才会将数据写到内存中；而在缓存命中的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。减少了数据写回内存的频率，这样便可以提高系统的性能。</li>
</ul>
<h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>现代 CPU 都是多核的，每个核心都会有单独的 L1&#x2F;L2 缓存，<code>同一块内存地址的数据可能会被读取到不同个核心的 CPU Cache Line 上</code>，如果不能处理好 CPU Cache Line 上的数据写回内存的时机，容易发生<code>缓存一致性问题</code>。</p>
<p>假设 A 号核心和 B 号核心同时运行两个线程，都操作共同的变量 i(初始值为 0 )。<br><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115751158.png" alt="image-20230319115751158"></p>
<ol>
<li>A 号核心执行了 i++ 语句的时候，为了考虑性能，使用了我们前面所说的写回策略，先把值为 1 的执行结果写入到 L1&#x2F;L2 Cache 中，然后把 L1&#x2F;L2 Cache 中对应的 Block 标记为脏的，这个时候数据其实没有被同步到内存中的，因为写回策略，只有在 A 号核心中的这个 Cache Block 要被替换的时候，数据才会写入到内存里。</li>
<li>B 号核心尝试从内存读取 i 变量的值，则读到的将会是错误的值，因为刚才 A 号核心更新 i 值还没写入到内存中，内存中的值还依然是 0。</li>
</ol>
<p>这个就是所谓的缓存一致性问题。要解决这一问题，就需要一种机制，来同步两个不同核心里面的缓存数据。要实现的这个机制的话，要保证做到下面这 2 点：</p>
<ul>
<li>某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为写传播 (Wreite Propagation)。</li>
<li>某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串形化(Transaction Serialization)。</li>
</ul>
<h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>早期有一种<code>总线嗅探(Bus Snooping)</code>的技术来保证写传播：</p>
<ul>
<li>当 A 号 CPU 核心修改了 L1 Cache 中 i 变量的值，通过总线把这个事件广播通知给其他所有的核心，然后每个 CPU 核心都会监听总线上的广播事件，并 检查是否有相同的数据在自己的 L1 Cache 里面，如果 B 号 CPU 核心的 L1 Cache 中有该数据，那么也需要把该数据更新到自己的 L1 Cache。</li>
</ul>
<p>总线嗅探的原理非常简单，但是缺点也很明显：</p>
<ul>
<li>CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，这无疑会加重总线的负载。</li>
<li>只是保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串形化。</li>
</ul>
<p><code>MESI 协议</code>基于总线嗅探机制实现了事务串形化，也用状态机机制降低了总线带宽压力，实现了 CPU 缓存一致性。</p>
<p><code>MESI 协议把 Cache Line 标记为 4 种不同的状态</code>，MESI 其实是 4 个状态单词的开头字母缩写：</p>
<ul>
<li><code>Modified</code>，已修改，代表该 Cache Block 上的数据已经被更新过，但是还没有写 到内存里。</li>
<li><code>Exclusive</code>，独占，代表 Cache Block 里的数据是干净的，且数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。</li>
<li><code>Shared</code>，共享，代表 Cache Block 里的数据是干净的，且相同的数据在多个 CPU 核心的 Cache 里都有。</li>
<li><code>Invalidated</code>，已失效，代表 Cache Block 里的数据已经失效了，不可以读取该状态的数据。</li>
</ul>
<blockquote>
<p>「独占」和「共享」的数据都是干净的，差别在于：</p>
<ul>
<li><code>「独占」状态表示数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据</code>。这个时候，如果要向独占的 Cache 写数据，就可以直接自由地写入，而 不需要通知其他 CPU 核心，因为只有你这有这个数据，就不存在缓存一致性的问题了，于是就可以随便操作该数据。在「独占」状态下的数据，如果有其他核心从内存读取了相同的数据到各自的 Cache ，那么这个时 候，独占状态下的数据就会变成共享状态。</li>
<li><code>「共享」状态代表着相同的数据在多个 CPU 核心的 Cache 里都有</code>。所以当我们要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后再更新当前 Cache 里面的数据。</li>
</ul>
</blockquote>
<p>事实上，整个 MESI 的状态可以用一个<code>有限状态机</code>来表示它的状态流转。还有一点，对于不同状态触发的事件操作，可能是来自本地 CPU 核心发出的广播事件，也可以是来自其他 CPU 核心通过总线发出的广播事件。下图即是 MESI 协议的状态图：<br><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115812304.png" alt="image-20230319115812304"><br><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115824899.png" alt="image-20230319115824899"></p>
<p>可以发现当 Cache Line 状态是「已修改」或者「独占」状态时，修改更新其数据不需要发送广播给其他 CPU 核心，这在一定程度上减少了总线带宽压力。</p>
<h3 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h3><p>上面我们提高 MESI 协议，<code>解决了同一个变量被读取到不同 CPU 的 CPU Cache Line 的一致性问题</code>。</p>
<p>如果两个不同的变量被读取到两个不同 CPU 的 CPU Cache Line，每个 CPU 只读写其 Cache 上的单个变量，理论上，两个变量各自的执行应该没有任何关系，互相也不会受到影响。但是如果使用了 MESI 协议，就会引发新的问题：<code>伪共享问题</code>。</p>
<p><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115845086.png" alt="image-20230319115845086"></p>
<ul>
<li>1 号核心读取变量 A，由于 CPU 从内存读取数据到 Cache 的单位是 Cache Line，也正好变量 A 和 变 量 B 的数据归属于同一个 Cache Line，所以 A 和 B 的数据都会被加载到 Cache，并将此 Cache Line 标 记为「独占」状态。</li>
</ul>
<p><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115856919.png" alt="image-20230319115856919"></p>
<ul>
<li>接着，2 号核心开始从内存里读取变量 B，同样的也是读取 Cache Line 大小的数据到 Cache 中，此 Cache Line 中的数据也包含了变量 A 和 变量 B，此时 1 号和 2 号核心的 Cache Line 状态变为「共享」状 态。</li>
</ul>
<p><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115909199.png" alt="image-20230319115909199"></p>
<ul>
<li>1 号核心需要修改变量 A，发现此 Cache Line 的状态是「共享」状态，所以先需要通过总线发送消息 给 2 号核心，通知 2 号核心把 Cache 中对应的 Cache Line 标记为「已失效」状态，然后 1 号核心对应的 Cache Line 状态变成「已修改」状态，并且修改变量 A。</li>
</ul>
<p><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115923946.png" alt="image-20230319115923946"></p>
<ul>
<li>2 号核心需要修改变量 B，此时 2 号核心的 Cache 中对应的 Cache Line 是已失效状态，另外由 于 1 号核心的 Cache 也有此相同的数据，且状态为「已修改」状态，所以要先把 1 号核心的 Cache 对应 的 Cache Line 写回到内存，然后 2 号核心再从内存读取 Cache Line 大小的数据到 Cache 中，最后把变 量 B 修改到 2 号核心的 Cache 中，并将状态标记为「已修改」状态。</li>
</ul>
<p>可以发现如果 1 号和 2 号 CPU 核心这样持续交替的分别修改变量 A 和 B，Cache 并没有起到缓存的效果，虽然变量 A 和 B 之间其实并没有任何的关系，但是因为同时归属 于一个 Cache Line ，这个 Cache Line 中的任意数据被修改后，都会相互影响。这种因为多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为 <code>伪共享(False Sharing)</code>。</p>
<p><strong>避免伪共享</strong></p>
<ol>
<li><p>使用Linux 内核中的 <code>__cacheline_aligned_in_smp</code> 宏定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 结构体里的两个成员变量 a 和 b 在物理内存地址上是连续的，于是它们可能会位于同一个 Cache Line</span><br><span class="line"> struct test &#123;</span><br><span class="line"> 	int a;</span><br><span class="line"> 	int b;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319120000708.png" alt="image-20230319120000708"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将 b 的地址设置为 Cache Line 对⻬地址，这样 a 和 b 变量就不会在同一个 Cache Line 中</span><br><span class="line"> struct test &#123;</span><br><span class="line"> 	int a;</span><br><span class="line"> 	int b __cacheline_aligned_in_smp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319120012283.png" alt="image-20230319120012283"></p>
</li>
<li><p>手动「字节填充 + 继承」。例如 Java 并发框架 Disruptor 里面的 RingBuffer 类。</p>
</li>
</ol>
<p><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319120031295.png" alt="image-20230319120031295"></p>
<ul>
<li>RingBufferPad 定义了 p1 ～ p7 7 个 long 类型的变量。</li>
<li>RingBufferFields 继承了 RingBufferPad，里面定义的全是 final 类型的字段。</li>
<li>RingBuffer 继承了RingBufferFields，再次定义了 p1 ～ p7 7 个 long 类型的变量。</li>
</ul>
<p>CPU Cache 从内存读取数据的单位是 CPU Line，一般 64 位 CPU 的 CPU Line 的大小是 64 个字节，一个 long 类型的数据是 8 个字节，所以 CPU 一下会加载 8 个 long 类型的数据。</p>
<p>根据 JVM 对象继承关系中父类成员和子类成员，内存地址是连续排列布局的，因此 RingBufferPad 中的 7 个 long 类型数据作为 <code>Cache Line 前置填充</code>，而 RingBuffer 中的 7 个 long 类型数据则作为 <code>Cache Line 后置填充</code>，这 14 个 long 变量没有任何实际用途，更不会对它们进行读写操作。</p>
<p>而且 RingBufferFelds 里面定义的这些变量都是 final 修饰的，意味着第一次加载之后不会再修改， 又 由于「前后」各填充了 7 个不会被读写的 long 类型变量，所以无论怎么加载 Cache Line，这整个 Cache Line 里都没有会发生更新操作的数据，于是只要数据被频繁地读取访问，就自然没有数据被换出 Cache 的可能，也因此不会产生伪共享的问题。<br><img src="/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319120044434.png" alt="image-20230319120044434"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="prev" title="Java并发系列（五）：线程池">
      <i class="fa fa-chevron-left"></i> Java并发系列（五）：线程池
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="next" title="Linux系列（二）：内存管理">
      Linux系列（二）：内存管理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">冯诺依曼模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU"><span class="nav-number">1.1.</span> <span class="nav-text">CPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-number">1.2.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF"><span class="nav-number">1.3.</span> <span class="nav-text">总线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87"><span class="nav-number">1.4.</span> <span class="nav-text">输入输出设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-number">1.5.</span> <span class="nav-text">程序执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.6.</span> <span class="nav-text">指令集类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.7.</span> <span class="nav-text">执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F"><span class="nav-number">1.8.</span> <span class="nav-text">执行周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F"><span class="nav-number">1.8.1.</span> <span class="nav-text">时钟周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F"><span class="nav-number">1.8.2.</span> <span class="nav-text">机器周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="nav-number">1.8.3.</span> <span class="nav-text">指令周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="nav-number">1.8.4.</span> <span class="nav-text">相互关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%B8%AD%E6%96%AD%E5%92%8C%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="nav-number">1.9.</span> <span class="nav-text">硬中断和软中断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">存储器结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-Cache"><span class="nav-number">2.2.</span> <span class="nav-text">CPU Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98-1"><span class="nav-number">2.3.</span> <span class="nav-text">内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSD-x2F-HDD%E7%A1%AC%E7%9B%98"><span class="nav-number">2.4.</span> <span class="nav-text">SSD&#x2F;HDD硬盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB-1"><span class="nav-number">2.5.</span> <span class="nav-text">相互关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">一致性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-Cache-Line"><span class="nav-number">3.1.</span> <span class="nav-text">CPU Cache Line</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="nav-number">3.2.</span> <span class="nav-text">写回策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.</span> <span class="nav-text">缓存一致性问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MESI%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.4.</span> <span class="nav-text">MESI协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="nav-number">3.5.</span> <span class="nav-text">伪共享问题</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mcbilla"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">mcbilla</p>
  <div class="site-description" itemprop="description">Constant dropping wears the stone</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/mcbilla" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mcbilla" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mcbilla</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'NL3uHcex1UcrXkcOvkLDH1p8-gzGzoHsz',
      appKey     : 'lBSzvyvWKyPT9clWgSrVZxzF',
      placeholder: "一起来讨论吧～",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
