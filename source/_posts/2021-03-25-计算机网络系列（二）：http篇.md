---
title: 计算机网络系列（二）：http篇
date: 2021-03-25 21:22:12
categories:
- 计算机网络
tags:
- 计算机网络
---

> 计算机网络系列（二）：http篇

<!--more-->

## http

### http是什么
HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。它可以拆成三个部分：
* 超文本
* 传输
* 协议

重点是什么叫超文本？我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。

再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。例如HTML 就是最常⻅的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网⻚了。

所以综合以上定义，`HTTP 是一个在计算机世界里专⻔在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范`」。

### http状态码
![image-20230319212624188](image-20230319212624188.png)

* `1xx` 类状态码属于`提示信息`，是协议处理中的一种中间状态，实际用到的比较少。
* `2xx` 类状态码表示`成功处理`，服务器成功处理了客户端的请求，也是我们最愿意看到的状态。
    * 「200 OK」是最常⻅的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body
    数据。
    * 「204 No Content」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
    * 「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。
* `3xx` 类状态码表示`重定向`，客户端请求的资源发送了变动，需要客户端用新的 URL 新发送请求获取资源。
    * 「301 Moved Permanently」表示永久定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
    * 「302 Found」表示临时定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。301 和 302 都会在响应头里使用字段 Location ，指明后续要跳转的 URL，浏览器会自动􏰀定向新的 URL。
    * 「304 Not Modified」不具有跳转的含义，表示资源未修改，􏰀定向已存在的缓冲文件，也称缓存定向，用于缓存控制。
* `4xx` 类状态码表示`客户端错误`，客户端发送的报文有误，服务器无法处理。
    * 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。
    * 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。
    * 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
* `5xx` 类状态码表示`服务器错误`，客户端请求报文正确，但是服务器处理时内部发生了错误。
    * 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
    * 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
    * 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
    * 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后试”的意思。

### http常见字段
* Host：客户端指定服务器的域名。
* Content-Length：服务器返回数据的数据长度。
* Connection：客户端要求服务器使用 TCP 持久连接，以便其他请求复用。例如 `Connection: keep-alive`。
* Content-Type：服务器返回数据的格式。例如 `Content-Type: text/html; charset=utf-8`
* Content-Encoding：服务器返回的数据使用的压缩格式。
* Accept-Encoding：客户端可以接受的压缩格式。

### http版本的升级演变
#### http1.1的升级特点
HTTP/1.1 相比 HTTP/1.0 性能上的改进:
* `⻓连接`，改善了 HTTP/1.0 短连接造成的性能开销。
* `管道(pipeline)网络传输`，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

但 HTTP/1.1 还是有性能瓶颈:
* 头部冗长。只能压缩 Body 的部分，请求/响应头部(Header)未经压缩就发送，首部信息越多延迟越大。每次互相发送相同的头部造成的浪费较多。
* 队头阻塞。服务器是按请求的顺序响应的，如果服务器响应慢，会导致客户端一直请求不到数据。
* 没有请求优先级控制。
* 请求只能从客户端开始，服务器只能被动响应。

#### http2的升级特点
那 HTTP/2 相比 HTTP/1.1 性能上的改进:
* `头部压缩`：通过 HPACK 算法，在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，每个字段对应一个索引号，以后就不发送同样字段了，使用索引号代替字段，大大减小头部长度。
* `二进制格式`：不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧(frame):头信息帧和数据帧。
* `Steam设计和多路复用`：每个请求或回应的所有数据包，称为一个数据流(Stream)。每个Stream有独立的编号，客户端可以指定Stream的优先级。优先级高的Stream会被服务器优先响应。多个 Stream 复用一条 TCP 连接，不同 Stream 的帧是可以乱序发送的（Stream内部必须是有序的），达到并发的效果。
* `服务器推送`：服务器可以主动向客户端发送消息。例如在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待
* `引入SSL/TLS提高安全性`：HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。 

![image-20230319212645173](image-20230319212645173.png)

## https
HTTP 是明文传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。HTTPS 在 TCP 三次握手之 后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。

### SSL/TLS协议
SSL/TLS协议采用 `对称加密` + `非对称加密` 结合的「混合加密」方式：
* 在通信建立前采用非对称加密的方式交换「会话秘钥」。服务器保存私钥，客户端保存公钥，双方验证成功后生成「会话秘钥」，
* 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。

SSL/TSL协议基本过程：
1. 客户端向服务器端索要并验证公钥。
2. 双方协商生成"对话密钥"。
3. 双方采用"对话密钥"进行加密通信。

#### 数字证书
客户端验证服务器的公钥的合法性是SSL/TSL交互过程的关键，验证结果可以确定该地址是否正确的服务器地址而不是钓鱼网站地址。

如何保证公钥不被篡改和信任度？为了提高公钥传输的安全性，第三方机构应运而生——证书颁发机构(CA，Certificate Authority)。CA 默认是受信任的第三方。CA 会将服务器公钥放在数字证书，然后向各个服务器颁发证书，证书存储在服务器上，只要证书是可信的，公钥就是可信的。

基于数字证书的通信过程：
1. 服务器把自己的公钥注册到CA。
2. CA对服务器的公钥采用散列技术生成一个摘要，使用 CA 私钥对该摘要进行加密，附在数字证书上，然后向服务器返回数字证书。
3. 客户端向服务器发起请求，在三次握手成功后服务器向客户端返回服务器密钥+数字证书。
4. 客户端使用 CA 公钥（一般已经事先存在系统上或浏览器上）对数字证书进行解密，同时对消息进行散列处理，得到摘要。比较摘要，验证数字证书的真实性。
5. 客户端确认证书真实性后，使用服务器公钥对数据进行加密返回。
6. 服务器收到数据使用服务器私钥进行解密，基于数字证书的通信过程完成。

![image-20230319212738494](image-20230319212738494.png)

#### SSL/TLS四次握手过程
![image-20230319212751943](image-20230319212751943.png)
1. 客户端发出请求（ClientHello），客户端主要向服务器发送以下信息:
    * 客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。
    * 客户端生产的随机数( Client Random )，后面用于生产「会话秘钥」。
    * 客户端支持的加密方法，如 RSA 加密算法。
    * 客户端支持的压缩方法。
2. 服务器回应（SeverHello），服务器回应的内容有：
    * 确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。
    * 服务器生产的随机数( Server Random )，后面用于生产「会话秘钥」。
    * 使用的加密方法，如 RSA 加密算法。
    * 服务器的数字证书。
3. 客户端回应，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。 如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
    * 一个随机数( pre-master key )。该随机数会被服务器公钥加密。 
    * 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
    * 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。
4. 服务器回应，服务器收到客户端的第三个随机数( pre-master key )之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：
    * 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
    * 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘 要，用来供客户端校验。

至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

简单的来说，SSL/TSL通过四次握手，主要交换三个信息：
* `数字证书`：该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；
* `三个随机数`：这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的“对话密钥”。首先客户端先发第一个随机数N1，然后服务器回了第二个随机数N2（这个过程同时把之前提到的证书发给客户端），这两个随机数都是明文的；而第三个随机数N3（这个随机数被称为Premaster secret），客户端用数字证书的公钥进行非对称加密，发给服务器；而服务器用只有自己知道的私钥来解密，获取第三个随机数。这样，服务端和客户端都有了三个随机数N1+N2+N3，然后两端就使用这三个随机数来生成“对话密钥”，在此之后的通信都是使用这个“对话密钥”来进行对称加密解密。因为这个过程中，服务端的私钥只用来解密第三个随机数，从来没有在网络中传输过，这样的话，只要私钥没有被泄露，那么数据就是安全的。
* `加密通信协议`：就是双方商量使用哪一种对称加密方式，假如两者支持的加密方式不匹配，则无法进行通信。常用的对称加密算法有两种，分别是 RSA 和 ECDHE 算法。RSA 是比较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使用的。而 ECDHE 算法 具有前向安全，所以被广泛使用。

### http和https的区别
![image-20230319212807754](image-20230319212807754.png)
