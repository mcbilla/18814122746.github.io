[{"title":"Hexo主题配置","url":"/2018/06/17/Hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","content":"<blockquote>\n<p>Hexo 支持多种主题，NexT 是 Hexo 下最热门的主题之一，下面简单简介 NextT 主题的配置。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 <font color=#5CACEE size=3>站点配置文件</font>，后者称为 <font color=#BF3EFF size=3>主题配置文件</font>。转载请说明出处。</p>\n<h2 id=\"一、安装NextT\"><a href=\"#一、安装NextT\" class=\"headerlink\" title=\"一、安装NextT\"></a>一、安装NextT</h2><h3 id=\"1、下载主题\"><a href=\"#1、下载主题\" class=\"headerlink\" title=\"1、下载主题\"></a>1、下载主题</h3><p>切换到hexo 的安装目录，把主题文件下载到安装目录的 <code>theme/next</code> 目录下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、启用主题\"><a href=\"#2、启用主题\" class=\"headerlink\" title=\"2、启用主题\"></a>2、启用主题</h3><p>打开 <font color=#5CACEE size=3>站点配置文件</font>， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">theme: next</span><br></pre></td></tr></table></figure>\n<p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p>\n<blockquote>\n<p>注意：修改 <font color=#5CACEE size=3>站点配置文件</font> 需求重启服务器才能生效，修改 <font color=#BF3EFF size=3>主题配置文件</font> 不需要重启服务器。重启步骤为在服务器启动控制台 <code>ctrl + c</code>，然后 <code>$ hexo server [--debug]</code></p>\n</blockquote>\n<h2 id=\"二、主题设置\"><a href=\"#二、主题设置\" class=\"headerlink\" title=\"二、主题设置\"></a>二、主题设置</h2><h3 id=\"1、外观-scheme-设置\"><a href=\"#1、外观-scheme-设置\" class=\"headerlink\" title=\"1、外观 scheme 设置\"></a>1、外观 scheme 设置</h3><p>修改 <font color=#BF3EFF size=3>主题配置文件</font>，查找 <code>scheme</code> 关键字，将你需用启用的 <code>scheme</code> 前面注释 <code>#</code> 去除即可</p>\n<ul>\n<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白  </li>\n<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观  </li>\n<li>Pisces - 双栏 Scheme，小家碧玉似的清新  </li>\n<li>Gemini - 紧凑集中版双栏 Scheme，本网站采用的主题</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Schemes</span><br><span class=\"line\">#scheme: Muse</span><br><span class=\"line\">#scheme: Mist</span><br><span class=\"line\">#scheme: Pisces</span><br><span class=\"line\">scheme: Gemini</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、语言-language-设置\"><a href=\"#2、语言-language-设置\" class=\"headerlink\" title=\"2、语言 language 设置\"></a>2、语言 language 设置</h3><p>编辑 <font color=#5CACEE size=3>站点配置文件</font> （针对所有主题下的文件）或 <font color=#BF3EFF size=3>主题配置文件</font> (针对本主题下的文件)下的 <code>language</code>，例如启用简体中文就改成 <code>zh-Hans</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">language: zh-Hans</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、设置菜单\"><a href=\"#3、设置菜单\" class=\"headerlink\" title=\"3、设置菜单\"></a>3、设置菜单</h3><h4 id=\"启用-x2F-禁用菜单\"><a href=\"#启用-x2F-禁用菜单\" class=\"headerlink\" title=\"启用&#x2F;禁用菜单\"></a>启用&#x2F;禁用菜单</h4><p>编辑 <font color=#BF3EFF size=3>主题配置文件</font>，设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：<code>item name: link</code>。其中 <code>item name</code> 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。把需要启动的菜单项前面的 <code>#</code> 去掉。也可以新增自定义菜单项。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: / || home</span><br><span class=\"line\">  #  about: /about/ || user</span><br><span class=\"line\">  tags: /tags/ || tags</span><br><span class=\"line\">  categories: /categories/ || th</span><br><span class=\"line\">  # archives: /archives/ || archive</span><br><span class=\"line\">  # schedule: /schedule/ || calendar</span><br><span class=\"line\">  # sitemap: /sitemap.xml || sitemap</span><br><span class=\"line\">  # commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>\n\n<p>默认的菜单项如下：</p>\n<table>\n<thead>\n<tr>\n<th>键值</th>\n<th>设定值</th>\n<th>显示文本（简体中文）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>home</td>\n<td>home: &#x2F;</td>\n<td>主页</td>\n</tr>\n<tr>\n<td>archives</td>\n<td>archives: &#x2F;archives</td>\n<td>归档页</td>\n</tr>\n<tr>\n<td>categories</td>\n<td>categories: &#x2F;categories</td>\n<td>分类页</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>tags: &#x2F;tags</td>\n<td>标签页</td>\n</tr>\n<tr>\n<td>schedule</td>\n<td>schedule: &#x2F;schedule</td>\n<td>日程表</td>\n</tr>\n<tr>\n<td>about</td>\n<td>about: &#x2F;about</td>\n<td>关于</td>\n</tr>\n<tr>\n<td>sitemap</td>\n<td>sitemap: &#x2F;sitemap</td>\n<td>站点地图</td>\n</tr>\n<tr>\n<td>commonweal</td>\n<td>commonweal: &#x2F;404.html</td>\n<td>公益 404</td>\n</tr>\n</tbody></table>\n<p>其中除了 home 和 archives 页面，其他页面都需要手动创建，例如新建 tags 页面</p>\n<ol>\n<li>切换到 Hexo 根目录下，使用 <code>hexo new page tags</code> 新建 tags 页面</li>\n<li>编辑 <code>/source/tags/index.md</code> 文件，在头文件部分 front-matter 添加 <code>type: &quot;tags&quot;</code>，如需要关闭评论添加 <code>comments: false</code></li>\n</ol>\n<h4 id=\"设置菜单显示文字\"><a href=\"#设置菜单显示文字\" class=\"headerlink\" title=\"设置菜单显示文字\"></a>设置菜单显示文字</h4><p>修改 <code>languages/&#123;language&#125;.yml</code> 文件，如果简体中文对应 <code>languages/zh-Hans.yml</code> 文件下的 <code>menu</code> 字段</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: 首页</span><br><span class=\"line\">  archives: 归档</span><br><span class=\"line\">  categories: 分类</span><br><span class=\"line\">  tags: 标签</span><br><span class=\"line\">  about: 关于</span><br><span class=\"line\">  search: 搜索</span><br><span class=\"line\">  schedule: 日程表</span><br><span class=\"line\">  sitemap: 站点地图</span><br><span class=\"line\">  commonweal: 公益404</span><br></pre></td></tr></table></figure>\n\n<p>修改字段值直接影响页面上菜单文字显示，或者新增字段值，字段名要与上面第一步设置的自定义菜单名称对应。</p>\n<h3 id=\"4、设置侧栏\"><a href=\"#4、设置侧栏\" class=\"headerlink\" title=\"4、设置侧栏\"></a>4、设置侧栏</h3><p>修改 <font color=#BF3EFF size=3>主题配置文件</font> 文件中的 <code>sidebar</code> 字段</p>\n<h4 id=\"设置侧栏位置\"><a href=\"#设置侧栏位置\" class=\"headerlink\" title=\"设置侧栏位置\"></a>设置侧栏位置</h4><ul>\n<li>left - 靠左放置</li>\n<li>right - 靠右放置</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sidebar:</span><br><span class=\"line\">  position: left</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设置侧栏显示的时机\"><a href=\"#设置侧栏显示的时机\" class=\"headerlink\" title=\"设置侧栏显示的时机\"></a>设置侧栏显示的时机</h4><ul>\n<li>post - 默认行为，在文章页面（拥有目录列表）时显示</li>\n<li>always - 在所有页面中都显示</li>\n<li>hide - 在所有页面中都隐藏（可以手动展开）</li>\n<li>remove - 完全移除</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sidebar:</span><br><span class=\"line\">  display: post</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、设置头像\"><a href=\"#5、设置头像\" class=\"headerlink\" title=\"5、设置头像\"></a>5、设置头像</h3><p>修改 <font color=#BF3EFF size=3>主题配置文件</font> 下的 <code>avatar</code> 字段，设成头像的链接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">avatar: images/avatar.png</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、设置作者昵称\"><a href=\"#6、设置作者昵称\" class=\"headerlink\" title=\"6、设置作者昵称\"></a>6、设置作者昵称</h3><p>编辑 <font color=#5CACEE size=3>站点配置文件</font>，设置 <code>author</code> 字段</p>\n<h3 id=\"7、设置站点名称\"><a href=\"#7、设置站点名称\" class=\"headerlink\" title=\"7、设置站点名称\"></a>7、设置站点名称</h3><p>编辑 <font color=#5CACEE size=3>站点配置文件</font>，设置 <code>description</code> 字段</p>\n<h3 id=\"8、设置社交\"><a href=\"#8、设置社交\" class=\"headerlink\" title=\"8、设置社交\"></a>8、设置社交</h3><p>编辑 <font color=#BF3EFF size=3>主题配置文件</font></p>\n<h4 id=\"设置社交链接\"><a href=\"#设置社交链接\" class=\"headerlink\" title=\"设置社交链接\"></a>设置社交链接</h4><p>修改 <code>social</code> 字段，其键值格式是 <code>显示文本: 链接地址</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">social:</span><br><span class=\"line\">  GitHub: https://github.com/mcbilla || github</span><br><span class=\"line\">  #E-Mail: mailto:yourname@gmail.com || envelope</span><br><span class=\"line\">  #Google: https://plus.google.com/yourname || google</span><br><span class=\"line\">  #Twitter: https://twitter.com/yourname || twitter</span><br><span class=\"line\">  #FB Page: https://www.facebook.com/yourname || facebook</span><br><span class=\"line\">  #VK Group: https://vk.com/yourname || vk</span><br><span class=\"line\">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span><br><span class=\"line\">  #YouTube: https://youtube.com/yourname || youtube</span><br><span class=\"line\">  #Instagram: https://instagram.com/yourname || instagram</span><br><span class=\"line\">  #Skype: skype:yourname?call|chat || skype</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设置链接图标\"><a href=\"#设置链接图标\" class=\"headerlink\" title=\"设置链接图标\"></a>设置链接图标</h4><p>修改 <code>social_icons:</code> 字段，其键值格式是 <code>匹配键: Font Awesome 图标名称</code>，<code>匹配键</code> 与上一步所配置的链接的 <code>显示文本</code> 相同（大小写严格匹配）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Social Icons</span><br><span class=\"line\">social_icons:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  # Icon Mappings</span><br><span class=\"line\">  GitHub: github</span><br><span class=\"line\">  Twitter: twitter</span><br><span class=\"line\">  微博: weibo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9、设置背景动画\"><a href=\"#9、设置背景动画\" class=\"headerlink\" title=\"9、设置背景动画\"></a>9、设置背景动画</h3><p>NexT 自带 <code>canvas_nest</code> 和 <code>three_waves</code> 两种背景动画效果，编辑 <font color=#BF3EFF size=3>主题配置文件</font> 将对应的字段改成 <code>true</code> 或 <code>false</code> 即可，只能同时开启一种背景动画效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">canvas_nest: true</span><br><span class=\"line\">#three_waves : false</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、第三方插件\"><a href=\"#三、第三方插件\" class=\"headerlink\" title=\"三、第三方插件\"></a>三、第三方插件</h2><h3 id=\"1、安装评论系统\"><a href=\"#1、安装评论系统\" class=\"headerlink\" title=\"1、安装评论系统\"></a>1、安装评论系统</h3><p>最新版的Next主题支持的评论系统如下：</p>\n<ul>\n<li>changyan ：搜狐畅言，需要网站备案才能使用。</li>\n<li>disqus ：界面漂亮，注册麻烦，仅支持国外一些社交账号登录，如 Fackbook, Google, Twritter 等，需要翻墙才能评论。</li>\n<li>disqusjs ：基于 Disqus API 和 React 开发的评论插件，前端模拟Disqus的评论界面，再使用一个服务器反向代理Disqus API的请求，那么就可以让评论可以在国内网显示出来。</li>\n<li>gitalk ：基于 GitHub Issue 和 Preact 开发的评论插件，需要 github 登陆才能评论，在国内访问速度较慢。</li>\n<li>livere：来必力，来自韩国的评论插件，无需备案即可使用，功能较为完善，但在国内访问速度较慢。</li>\n<li>valine：基于 <a href=\"https://leancloud.cn/\">LeanCloud </a>的快速、简洁且高效的无后端评论系统。在国内访问速度快，页面简单简洁。</li>\n</ul>\n<p>最终选择 <a href=\"https://valine.js.org/\">valine</a> 作为评论系统。安装步骤如下：</p>\n<ol>\n<li><p>注册 <a href=\"https://leancloud.cn/\">LeanCloud</a></p>\n</li>\n<li><p>创建应用，名称任意，例如 Valine-Admin</p>\n</li>\n</ol>\n<p><img src=\"/2018/06/17/Hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/valine1.png\" alt=\"valine1\"></p>\n<ol start=\"3\">\n<li>进入对应的应用，点击 <strong>设置</strong> — <strong>应用凭证</strong>，获取 <code>AppID</code> 和 <code>AppKey</code></li>\n<li>编辑 <font color=#BF3EFF size=3>主题配置文件</font></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">valine:</span><br><span class=\"line\">  enable: true # 设置为true，默认为false</span><br><span class=\"line\">  appid:  # 将应用key的App ID设置在这里</span><br><span class=\"line\">  appkey: # 将应用key的App Key设置在这里</span><br><span class=\"line\">  notify: false# 邮箱通知，已废弃</span><br><span class=\"line\">  verify: false# 验证码，已废弃</span><br><span class=\"line\">  placeholder: Just go go ^_^ # 初始化评论显示，根据自己修改，这里默认，</span><br><span class=\"line\">  avatar: monsterid # 头像风格，默认为mm，可进入网址：https://valine.js.org/avatar.html查看头像设置，这里有许多头像风格，进行设置</span><br><span class=\"line\">  guest_info: nick,mail,link # 自定义评论标题</span><br><span class=\"line\">  pageSize: 10 # 分页大小，10页就自动分页</span><br><span class=\"line\">  visitor: true # 是否开启文章阅读量统计，进入官网查看设置：https://valine.js.org/visitor.html</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>刷新界面（修改主题配置文件不用重启），测试评论效果，效果图如下：</li>\n</ol>\n<p><img src=\"/2018/06/17/Hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/valine2.png\" alt=\"valine2\"></p>\n<ol start=\"6\">\n<li>查看评论数据。由于 valine 是无后台系统，需要自己登陆 leanCloud 后台进行查看。点击 <strong>数据存储</strong> — <strong>结构化数据</strong> — <strong>Comment</strong>。</li>\n</ol>\n<blockquote>\n<p>如果开启了<code>开启了评论功能</code>，Valine 会<code>自动检测</code> leancloud 应用中是否存在<code>Comment</code>类</p>\n<p>如果开启了<code>阅读量统计</code>，Valine 会<code>自动检测</code> leancloud 应用中是否存在<code>Counter</code>类</p>\n<p>如果不存在<code>会自动创建</code>，<strong>无需手动创建</strong></p>\n</blockquote>\n<p><img src=\"/2018/06/17/Hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/valine3.png\" alt=\"valine3\"></p>\n<p>为了方便也可以集成 Valine-Admin 系统。Valine Admin 项目是一个对 Valine 评论系统的拓展应用，实现评论邮件通知、评论管理、自定义邮件通知模板等功能。关于  valine 的其他详细使用可以参考 <a href=\"https://cloud.tencent.com/developer/article/1965154\">Hexo NexT 评论系统 Valine 的使用</a></p>\n<h3 id=\"2、统计访问次数\"><a href=\"#2、统计访问次数\" class=\"headerlink\" title=\"2、统计访问次数\"></a>2、统计访问次数</h3><p>有 <strong>百度统计</strong> 和 <strong>不蒜子</strong> 统计两种方式。两者的区别是：前者可以用来后台统计，数据比较准确可靠；后者用来在页面上显示，根据访问 ip 进行粗略统计。</p>\n<h4 id=\"百度统计\"><a href=\"#百度统计\" class=\"headerlink\" title=\"百度统计\"></a>百度统计</h4><ol>\n<li>登陆 <a href=\"https://tongji.baidu.com/web/welcome/login\">百度统计官网</a>，注册账号</li>\n<li>获取代码。点击 <strong>使用设置</strong> — <strong>代码管理</strong> — <strong>代码获取</strong>，找到类似于 <code>hm.src = &quot;https://hm.baidu.com/hm.js?xxx&quot;;</code> 的代码，复制 <code>.js?</code> 后面的统计脚本id</li>\n<li>编辑 <font color=#BF3EFF size=3>主题配置文件</font> 中的 <code>baidu_analytics</code> 字段，把刚才粘贴的值粘贴进去</li>\n<li>代码安装检查，点击 <strong>使用设置</strong> — <strong>代码管理</strong> — <strong>代码安装检查</strong>，检查页面代码是否安装正确</li>\n</ol>\n<p><img src=\"/2018/06/17/Hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/baiduanalysis1.png\" alt=\"baiduanalysis1\"></p>\n<ol start=\"5\">\n<li>等大概 20 分钟后，点击 <strong>概况</strong> 可以查看页面统计数据。</li>\n</ol>\n<p><img src=\"/2018/06/17/Hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/baiduanalysis2.png\" alt=\"baiduanalysis2\"></p>\n<h4 id=\"不蒜子统计\"><a href=\"#不蒜子统计\" class=\"headerlink\" title=\"不蒜子统计\"></a>不蒜子统计</h4><p>编辑 <font color=#BF3EFF size=3>主题配置文件</font> 中的 <code>busuanzi_count</code> 参数，把 enable 设置为 true。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Show Views / Visitors of the website / page with busuanzi.#展示访问数</span><br><span class=\"line\"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span><br><span class=\"line\">busuanzi_count:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  total_visitors: true   #统计访客数</span><br><span class=\"line\">  total_visitors_icon: user</span><br><span class=\"line\">  total_views: true    #统计访问数</span><br><span class=\"line\">  total_views_icon: eye</span><br><span class=\"line\">  post_views: true   #统计文章阅读数</span><br><span class=\"line\">  post_views_icon: eye</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>pv 和 uv 的区别：</p>\n<ul>\n<li>pv：单个用户连续点击n篇文章，记录n次访问量。  </li>\n<li>uv：单个用户连续点击n篇文章，只记录1次访客数。</li>\n</ul>\n</blockquote>\n<p>在文章开头显示文章阅读次数。</p>\n<p><img src=\"/2018/06/17/Hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/busuanzi1.png\" alt=\"busuanzi1\"></p>\n<p>在页面底部显示访客和访问情况。</p>\n<p><img src=\"/2018/06/17/Hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/busuanzi2.png\" alt=\"busuanzi2\"></p>\n<p>在本地访问 <a href=\"https://link.zhihu.com/?target=http://127.0.0.1:4000/\">http://127.0.0.1:4000</a> 会发现这些值特别大，部署到自己站点后就正常了。</p>\n<h3 id=\"3、百度分享\"><a href=\"#3、百度分享\" class=\"headerlink\" title=\"3、百度分享\"></a>3、百度分享</h3><p>旧版的 Hexo 主题支持百度分享功能。编辑 <font color=#BF3EFF size=3>主题配置文件</font> 中的<code> baidushare</code> 字段，改成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">baidushare:</span><br><span class=\"line\">  type: button</span><br><span class=\"line\">  baidushare: true</span><br></pre></td></tr></table></figure>\n\n<p>注意 <strong>百度分享不支持 Https</strong>，打开开发工具控制台可能会看到 <code>Failed to load resource</code> 的错误信息，原因是通过 Https 请求百度分享的 Http 资源时候被拒绝了。解决办法是直接把这些百度分享的资源文件放到自己的目录下，参考大佬的解决方案 <a href=\"https://www.hrwhisper.me/baidu-share-not-support-https-solution/\">百度分享不支持https的解决方案</a></p>\n<ol>\n<li><p>下载资源文件，GitHub地址为 <a href=\"https://github.com/hrwhisper/baiduShare\">https://github.com/hrwhisper/baiduShare</a></p>\n</li>\n<li><p>把里面的 <code>static</code> 文件夹放在安装目录下的 <code>source</code> 文件夹里面</p>\n</li>\n<li><p>修改 你的安装目录&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;share&#x2F;baidushare.swig 文件如下</p>\n</li>\n</ol>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.src=&#x27;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&#x27;+~(-new Date()/36e5)];&lt;/script&gt;</span><br><span class=\"line\">改为</span><br><span class=\"line\">.src=&#x27;/static/api/js/share.js?v=89860593.js?cdnversion=&#x27;+~(-new Date()/36e5)];&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>编辑 <font color=#5CACEE size=3>站点配置文件</font> 中的 <code>skip_render</code> 字段，Hexo会禁止编译 <code>skip_render</code> 定义的文件&#x2F;文件夹</li>\n</ol>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">skip_render: static/**</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>重启服务器，最好执行一下 <code>hexo clean</code></li>\n</ol>\n<h3 id=\"4、本地搜索-Local-Search\"><a href=\"#4、本地搜索-Local-Search\" class=\"headerlink\" title=\"4、本地搜索 Local Search\"></a>4、本地搜索 Local Search</h3><p>安装 <a href=\"https://www.npmjs.com/package/hexo-generator-searchdb\">hexo-generator-searchdb</a>，在安装目录下执行</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm install hexo-generator-searchdb --save</span></span><br></pre></td></tr></table></figure>\n\n<p>编辑 <font color=#5CACEE size=3>站点配置文件</font>，新增以下内容到任意位置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">  path: search.json</span><br><span class=\"line\">  field: post</span><br><span class=\"line\">  format: html</span><br><span class=\"line\">  limit: 10000</span><br></pre></td></tr></table></figure>\n\n<p>编辑 <font color=#BF3EFF size=3>主题配置文件</font>，查找 <code>local_search</code> 字段，把值改为 <code>true</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">local_search:</span><br><span class=\"line\">  enable: true</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、参考\"><a href=\"#四、参考\" class=\"headerlink\" title=\"四、参考\"></a>四、参考</h2><p><a href=\"http://theme-next.iissnan.com/getting-started.html\">Hexo中文使用文档</a><br><a href=\"https://www.jianshu.com/p/3a05351a37dc\">Hexo的Next主题详细配置</a><br><a href=\"https://blog.csdn.net/qq_33699981/article/details/72716951\">hexo的next主题个性化教程：打造炫酷网站</a><br><a href=\"https://blog.csdn.net/ganzhilin520/article/details/79048010\">hexo添加评论功能</a><br><a href=\"https://blog.csdn.net/lanuage/article/details/78991798\">hexo next主题为博客添加分享功能\n</a><br><a href=\"https://blog.csdn.net/cl534854121/article/details/76121105\">Hexo+Github搭建个人博客(三)——百度分享集成</a><br><a href=\"https://blog.csdn.net/time888/article/details/74203939\">为NexT主题添加文章阅读量统计功能</a></p>\n","categories":["工具","Hexo"],"tags":["Hexo"]},{"title":"Hexo+GitHub搭建个人博客教程","url":"/2018/06/13/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"<blockquote>\n<p><a href=\"https://hexo.io/\">Hexo</a> 是一款基于 Node.js 的支持 Markdown 的静态站点生成框架，利用 Hexo+GitHub 可以轻松打造属于个人的免费博客。经过本人一番摸索最终搭建成功。本人的博客地址为 <a href=\"https://mcbilla.github.io/\">飙戈的博客</a>，欢迎大家前来指导，转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"一、环境配置\"><a href=\"#一、环境配置\" class=\"headerlink\" title=\"一、环境配置\"></a>一、环境配置</h1><p>在搭建之前电脑需要的环境配置如下：</p>\n<ul>\n<li><a href=\"https://git-scm.com/\">git</a></li>\n<li><a href=\"https://nodejs.org/en/\">node.js</a></li>\n</ul>\n<p>我们可以在控制台中输入</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">node -v</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git --version</span></span><br></pre></td></tr></table></figure>\n\n<p>如果没有报错则说明git和node.js已经安装成功，可直接跳过安装教程，如果报错则需要重新安装</p>\n<h2 id=\"1、安装git\"><a href=\"#1、安装git\" class=\"headerlink\" title=\"1、安装git\"></a><strong>1、安装git</strong></h2><ul>\n<li>windows 用户：直接下载<a href=\"https://git-scm.com/downloads\">git安装程序</a>根据提示进行安装</li>\n<li>mac 用户：通过homebrew进行安装，没有安装的需要先安装<a href=\"https://brew.sh/\">homebrew</a>，可以通过命令 <code>$ brew install git</code> 安装，也可通过下载 <a href=\"https://git-scm.com/downloads\">git安装程序</a> 进行安装</li>\n<li>linux 用户：通过命令行安装 <code>$ sudo apt-get install git-core</code></li>\n</ul>\n<p>安装完成后再在控制台输入</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git --version</span></span><br></pre></td></tr></table></figure>\n\n<p>如果没有报错则说明安装成功</p>\n<h2 id=\"2、安装node-js\"><a href=\"#2、安装node-js\" class=\"headerlink\" title=\"2、安装node.js\"></a><strong>2、安装node.js</strong></h2><h3 id=\"下载安装程序（推荐）\"><a href=\"#下载安装程序（推荐）\" class=\"headerlink\" title=\"下载安装程序（推荐）\"></a>下载安装程序（推荐）</h3><p>直接下载 <a href=\"https://nodejs.org/en/\">node.js安装程序</a> 进行安装，比较快捷省事，适用于 mac 和 windows 用户</p>\n<h3 id=\"使用nvm安装\"><a href=\"#使用nvm安装\" class=\"headerlink\" title=\"使用nvm安装\"></a>使用nvm安装</h3><p>cURL:  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">curl https://raw.github.com/creationix/nvm/master/install.sh | sh</span></span><br></pre></td></tr></table></figure>\n\n<p>Wget:  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span></span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">nvm install stable</span></span><br></pre></td></tr></table></figure>\n\n<p>安装完成后再在控制台输入 <code>$ node -v</code> 如果没有报错则说明安装成功</p>\n<h2 id=\"3、github-pages\"><a href=\"#3、github-pages\" class=\"headerlink\" title=\"3、github pages\"></a><strong>3、github pages</strong></h2><p>我们用来托管博客的服务叫做 <a href=\"https://pages.github.com/\">Github Pages</a>，它是 Github 用来提供给个人&#x2F;组织或者项目的网页服务，只需要部署到你的 Github Repository，推送代码，便可以实时呈现。GitHub Pages 有两种类型：User&#x2F;Organization Pages 和 Project Pages，两者的区别是：</p>\n<ul>\n<li>User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。</li>\n<li>用于存放 User Pages 的仓库必须使用 username.github.io 的命名规则，而 Project Pages 则没有特殊的要求。</li>\n<li>User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。</li>\n<li>User Pages 通过 http(s):&#x2F;&#x2F;username.github.io 进行访问，而 Projects Pages通过 http(s):&#x2F;&#x2F;username.github.io&#x2F;projectname 进行访问。</li>\n</ul>\n<h3 id=\"申请github账号\"><a href=\"#申请github账号\" class=\"headerlink\" title=\"申请github账号\"></a>申请github账号</h3><p>首先你需要申请注册一个 <a href=\"https://github.com/\">github</a> 账号</p>\n<h3 id=\"创建托管仓库\"><a href=\"#创建托管仓库\" class=\"headerlink\" title=\"创建托管仓库\"></a>创建托管仓库</h3><p>点击右上角 New Repository 新建一个仓库来作为托管仓库，注意命名为 <strong>username.github.io</strong>（username是你的账号名)。一般搭建个人博客都是用 User Pages，所以命名需要按照规范命名。</p>\n<h3 id=\"配置SSH（可跳过）\"><a href=\"#配置SSH（可跳过）\" class=\"headerlink\" title=\"配置SSH（可跳过）\"></a>配置SSH（可跳过）</h3><p>SSH实现本地 git 项目和远程 github 的连接，github 通过 <em><strong>SSH 密钥识别特定的可信任电脑</strong></em>，该部分电脑在向 github 推送的时候不需要输入用户名和密码</p>\n<ul>\n<li>查看电脑是否已经配置 ssh key</li>\n</ul>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">ls</span> -al ~/.ssh</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>默认情况下，public keys的文件名是以下的格式之一：<strong>id_dsa.pub、id_ecdsa.pub、id_ed25519.pub、id_rsa.pub</strong>。因此，如果列出的文件有public和private钥匙对（例如id_ras.pub和id_rsa），证明已存在SSH keys。如果提示 <code>No such file or directory</code> 则说明未安装</p>\n</blockquote>\n<ul>\n<li>第一次安装完 git 需要先 <em>初始化配置 git</em>（可跳过）</li>\n</ul>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git config –global user.name <span class=\"string\">&quot;yourusername&quot;</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git config --global user.email <span class=\"string\">&quot;youremail@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>生成新的 SSH Key，输入密码之类的可以省略，一路回车就行</li>\n</ul>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">ssh-keygen -t rsa -C <span class=\"string\">&quot;youremail@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>复制执行命令后显示的 key 内容</li>\n</ul>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cat</span> ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>点击右上角的 Settings –&gt; SSH and GPG keys –&gt; New SSH key ，Title 自由填写，Key 粘贴刚才复制的那段代码，点击 Add SSH Key</p>\n</li>\n<li><p>测试连接</p>\n</li>\n</ul>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">ssh -T git@github.com</span></span><br></pre></td></tr></table></figure>\n<p> 如果看到</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">The authenticity of host &#x27;github.com (207.97.227.239)&#x27; can&#x27;t be established.</span><br><span class=\"line\">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>\n\n<p> 输入<code>yes</code>，回车看到</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hi username! You&#x27;ve successfully authenticated, but GitHub does not</span><br><span class=\"line\">provide shell access.</span><br></pre></td></tr></table></figure>\n\n<p> 表示连接成功，ssh的配置至此完成。</p>\n<h1 id=\"二、安装启动Hexo\"><a href=\"#二、安装启动Hexo\" class=\"headerlink\" title=\"二、安装启动Hexo\"></a>二、安装启动Hexo</h1><h2 id=\"1、下载Hexo\"><a href=\"#1、下载Hexo\" class=\"headerlink\" title=\"1、下载Hexo\"></a>1、下载Hexo</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure>\n\n<p>有些教程会用命令 <code>$ npm install -g hexo</code>，作用同上，均为下载Hexo的安装包</p>\n<h2 id=\"2、初始化Hexo\"><a href=\"#2、初始化Hexo\" class=\"headerlink\" title=\"2、初始化Hexo\"></a>2、初始化Hexo</h2><p>执行下面命令把 <code>folder</code> 作为 Hexo 初始化安装目录。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo init &lt;folder&gt;</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cd</span> &lt;folder&gt;</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm install</span></span><br></pre></td></tr></table></figure>\n\n<p>如果以上的安装成功，在安装目录 <code>folder</code> 下将会出现以下的文件结构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>_config.yml：网站的全局配置文件</li>\n<li>package.json：应用程序的信息</li>\n<li>scaffolds：模版文件夹，Hexo的模板是指在新建的markdown文件中默认填充的内容。当您新建文章时，Hexo 会根据 scaffold 来建立文件。例如，如果您修改 scaffold&#x2F;post.md中的Front-matter 内容，那么每次新建一篇文章时都会包含这个修改。</li>\n<li>source：资源文件夹，除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。例如用于域名解析的 CNAME 文件就可以放到该文件夹中，每次部署的时候都会自动添加该文件。</li>\n<li>themes：主题文件夹，Hexo 会根据主题来生成静态页面。</li>\n</ul>\n<h2 id=\"3、启动\"><a href=\"#3、启动\" class=\"headerlink\" title=\"3、启动\"></a>3、启动</h2><p>进入hexo的安装目录，输入命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>进行启动，可简化为 <code>$ hexo s</code> ，也可启动调试模式 <code>$ hexo server --debug</code></p>\n<p>启动完成后访问地址：<a href=\"http://localhost:4000/\">http://localhost:4000/</a></p>\n<h1 id=\"三、编写文章\"><a href=\"#三、编写文章\" class=\"headerlink\" title=\"三、编写文章\"></a>三、编写文章</h1><h2 id=\"1、创建文章\"><a href=\"#1、创建文章\" class=\"headerlink\" title=\"1、创建文章\"></a>1、创建文章</h2><p>执行以下命令可新建文章。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<p> <code>layout</code> 叫做布局，不同的 <code>layout</code> 选项会创建不同类型的文章。hexo有三种默认布局，用户也可以自定义布局，不同布局对应不同的存储路径</p>\n<ul>\n<li>post：一般文章布局，自定义布局和post的对应的存储路径为 <code>source/_posts</code></li>\n<li>page：页面布局，例如可以用于生成标签（tags）或分类（categories）等主页面，就是点击菜单直接显示的页面，对应的存储路径为 <code>source</code></li>\n<li>draft：草稿布局，草稿默认不会显示在页面上，已完成的草稿可用 <code>$ hexo publish &lt;title&gt;</code> 来发布，对应的存储路径为 <code>source/_drafts</code></li>\n</ul>\n<p>Hexo 默认以标题做为文件名称，可以修改<code>_config.yml</code>的 <code>new_post_name</code> 参数来修改新生成的文件名称，例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">:year-:month-:day-:title.md</span><br></pre></td></tr></table></figure>\n\n<p>文件名会带上年月日，<code>:title</code> 表示转为小写，空格将会被替换为短杠。</p>\n<p>例如使用下面命令创建新文章。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new post &quot;hello world&quot;</span><br></pre></td></tr></table></figure>\n\n<p><code>source/_posts</code> 下面会自动生成一个名为 <code>2019-08-02-hello-world.md</code> 文件。</p>\n<h2 id=\"2、编辑文章\"><a href=\"#2、编辑文章\" class=\"headerlink\" title=\"2、编辑文章\"></a>2、编辑文章</h2><p>文章内容分为 <strong>前页</strong> 和 <strong>正文</strong>。文章头部 <code>—</code> 分隔符上方是前页，下面是正文。</p>\n<h3 id=\"前页\"><a href=\"#前页\" class=\"headerlink\" title=\"前页\"></a>前页</h3><p>可以设置的变量有：</p>\n<ul>\n<li>layout：布局</li>\n<li>title：标题</li>\n<li>date：建立日期，默认为文件建立日期</li>\n<li>updated：更新日期，默认为文件更新日期</li>\n<li>comments：开启文章的评论功能，默认为true</li>\n<li>tags：标签，不适用于布局为 <code>page</code> 的的页面</li>\n<li>categories：分类，不适用于布局为 <code>page</code> 的的页面</li>\n<li>permalink：覆盖文章网址</li>\n</ul>\n<blockquote>\n<p>categories 和 tags 的区别：categories 具有顺序性和层次性，tags 没有顺序和层次。例如下面  Life 成为 Diary 的子类。在界面上显示就是 Diary&#x2F;Life。</p>\n<p>categories:</p>\n<ul>\n<li>Dairy</li>\n<li>Life</li>\n</ul>\n</blockquote>\n<p>例如创建一篇文章题目为 hello-world，文章创建时间是 2018-06-10 16:15:04，分类归为 Diary 的子分类 Life，贴上 happy 和 friend 两个标签，最后禁止评论。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: hello-world</span><br><span class=\"line\">date: 2018-06-10 16:15:04</span><br><span class=\"line\">categories:</span><br><span class=\"line\">- Diary</span><br><span class=\"line\">- Life</span><br><span class=\"line\">tags:</span><br><span class=\"line\">- happy</span><br><span class=\"line\">- friend</span><br><span class=\"line\">comments: false</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>正文和普通的 markdown 编辑相同。首页默认会显示全部文章的全部内容，很多情况下我们只想在首页显示每篇文章的序言等部分内容，这样有利于读者总览。我们只需要在文章添加一句 <code>&lt;!--more--&gt;</code> ，例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">文章内容1</span><br><span class=\"line\">&lt;!--more--&gt;</span><br><span class=\"line\">文章内容2</span><br></pre></td></tr></table></figure>\n\n<p><code>&lt;!--more--&gt;</code> 以上的内容1会在首页正常显示，以下的内容2会隐藏，并显示 <code>阅读全文</code> 等链接。</p>\n<h1 id=\"四、部署\"><a href=\"#四、部署\" class=\"headerlink\" title=\"四、部署\"></a>四、部署</h1><h2 id=\"1、部署前配置\"><a href=\"#1、部署前配置\" class=\"headerlink\" title=\"1、部署前配置\"></a>1、部署前配置</h2><p>我们在本地编辑的文章只能在本地查看，如果想把文章发布到网上，我们需要把文章上传到上面配置好的 github pages 中。在发布文章前我们需要进行一些配置。</p>\n<h3 id=\"安装deployer工具\"><a href=\"#安装deployer工具\" class=\"headerlink\" title=\"安装deployer工具\"></a>安装deployer工具</h3><p><a href=\"https://github.com/hexojs/hexo-deployer-git\">hexo-deployer-git</a> 为 hexo 自动部署安装工具，可通过命令安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm install hexo-deployer-git  --save</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置-config-yml文件（旧版）\"><a href=\"#配置-config-yml文件（旧版）\" class=\"headerlink\" title=\"配置_config.yml文件（旧版）\"></a><del>配置_config.yml文件（旧版）</del></h3><p>编辑安装目录下的 _config.yml 文件，找到 <code>deploy</code> 参数，把 <code>type</code> 改成 <code>git</code>，<code>repo</code> 改成你自己的仓库地址，该地址可以直接上 github 上获取。注意<code>type:</code> 和 <code>git</code>之间必须带一个空格。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/mcbilla/mcbilla.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意 github 从2021年8月13日开始不在支持通过输入账号密码的形式 push 代码，在使用账号密码 push 代码时，会提示如下错误：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</span><br></pre></td></tr></table></figure>\n\n<p><strong>现在需要使用 personal access token 个人访问令牌，所以要使用下面新的配置步骤</strong>。</p>\n<h3 id=\"获取-access-token\"><a href=\"#获取-access-token\" class=\"headerlink\" title=\"获取 access token\"></a>获取 access token</h3><p><strong>Settings ——Developer Settings——Tokens</strong>，点击 <strong>Generate new token</strong>。</p>\n<ol>\n<li>在 Note 中填入这个 token 的具体用途（随便填方便记忆即可）</li>\n<li>在 Expiration 中选择 token 的有效时间默认30天。</li>\n<li>在 Select scopes 中设置该 token 的权限，这里我只是需要 push 下代码所以只勾选了 repo，你可以根据自己的需求进行设置。</li>\n<li>点击最下方的 Generate token 按钮即可生成。</li>\n</ol>\n<p>生成 token 之后，注意要把 token 保存下来，页面关闭之后不能再查看 token。而且这个 token 的权限很高，不要直接公布在公网上。</p>\n<p><img src=\"/2018/06/13/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230705183913147.png\" alt=\"image-20230705183913147\"></p>\n<h3 id=\"把-access-token-添加到环境变量\"><a href=\"#把-access-token-添加到环境变量\" class=\"headerlink\" title=\"把 access token 添加到环境变量\"></a>把 access token 添加到环境变量</h3><p>以 mac 为例，这里的 access token 就是上面生成的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ vim ~/.bash_profile</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"># Github Token</span><br><span class=\"line\">GITHUB_TOKEN=&lt;access token&gt;</span><br><span class=\"line\">export GITHUB_TOKEN</span><br><span class=\"line\">... </span><br><span class=\"line\"></span><br><span class=\"line\">$ source ~/.bash_profile</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置-config-yml文件\"><a href=\"#配置-config-yml文件\" class=\"headerlink\" title=\"配置_config.yml文件\"></a>配置_config.yml文件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo:</span><br><span class=\"line\">    github:</span><br><span class=\"line\">      url: https://github.com/mcbilla/mcbilla.github.io.git</span><br><span class=\"line\">      branch: master</span><br><span class=\"line\">      token: $GITHUB_TOKEN</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、部署\"><a href=\"#2、部署\" class=\"headerlink\" title=\"2、部署\"></a>2、部署</h2><h3 id=\"清空\"><a href=\"#清空\" class=\"headerlink\" title=\"清空\"></a>清空</h3><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo clean</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生成静态文件\"><a href=\"#生成静态文件\" class=\"headerlink\" title=\"生成静态文件\"></a>生成静态文件</h3><p>生成 public 静态文件夹</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo generate</span></span><br><span class=\"line\">或者</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo g `</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><p>部署到 github 上面</p>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo deploy</span></span><br><span class=\"line\">或者</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo d</span></span><br></pre></td></tr></table></figure>\n\n<p>执行完以上命令后，在浏览器输入 <a href=\"https://username.github.io/\">https://username.github.io</a> 就可以浏览你的刚才发布的博客，至此 Hexo + Github 的个人博客搭建已经完成。</p>\n<h1 id=\"四、Hexo常用命令\"><a href=\"#四、Hexo常用命令\" class=\"headerlink\" title=\"四、Hexo常用命令\"></a>四、Hexo常用命令</h1><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo init [folder] <span class=\"comment\">#初始化 folder 文件夹为网站根目录，如果没有 folder 默认在目前的文件夹初始化</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo new &lt;title&gt; <span class=\"comment\">#新建文章</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo new page &lt;title&gt; <span class=\"comment\">#新建页面</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo server <span class=\"comment\">#启动服务器，默认情况下，访问网址为： http://localhost:4000/</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo clean <span class=\"comment\">#清空静态文件和缓存文件</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo generate <span class=\"comment\">#生成静态文件到public目录，可简写为 hexo -g</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo deploy <span class=\"comment\">#部署文件到远程服务器，可简写为 hexo -d</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo <span class=\"built_in\">help</span>  <span class=\"comment\">#查看帮助</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo version  <span class=\"comment\">#查看Hexo的版本</span></span></span><br></pre></td></tr></table></figure>\n\n<p>上述 command 可指定模式运行，有三种模式：</p>\n<ul>\n<li>安全模式。在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</li>\n</ul>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo &lt;<span class=\"built_in\">command</span>&gt; --safe</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>调试模式。在终端中显示调试信息并记录到 debug.log。</li>\n</ul>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo &lt;<span class=\"built_in\">command</span>&gt; --debug</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>简洁模式</li>\n</ul>\n <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo &lt;<span class=\"built_in\">command</span>&gt; --silent</span></span><br></pre></td></tr></table></figure>\n\n<p>例如以调试模式启动服务器： </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo s --debug</span></span><br></pre></td></tr></table></figure>\n\n<p>为了快速执行命令，我们可以修改 hexo 根目录下的<code>package.json</code>文件，增加</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;start&quot;</span>: <span class=\"string\">&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;debug&quot;</span>: <span class=\"string\">&quot;hexo clean &amp;&amp; hexo g&quot;</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;deploy&quot;</span>: <span class=\"string\">&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 hexo 根目录下执行 <code>npm run &lt;script&gt;</code>，例如部署到服务器：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm run deploy</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://hexo.io/zh-cn/docs/\">Hexo官方中文文档</a><br><a href=\"http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/\">HEXO搭建个人博客</a><br><a href=\"https://www.jianshu.com/p/189fd945f38f\">搭建个人博客-hexo+github详细完整步骤</a><br><a href=\"https://www.jianshu.com/p/05289a4bc8b2\">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><br><a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\">GitHub Pages + Hexo搭建博客</a><br><a href=\"https://www.jianshu.com/p/70f3cfae1ef4\">使用Hexo搭建个人静态博客</a></p>\n","categories":["工具","Hexo"],"tags":["Hexo"]},{"title":"Hexo插入图片和设置图片大小","url":"/2018/06/21/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F/","content":"<blockquote>\n<p>Hexo 插入图片有两种方式，第一种是网络引用，第二种是本地插入，本文主要介绍本地插入图片方式。另外由于 Hexo 是静态博客框架，所插入的图片默认会按照本身大小自动铺满，如果要设置图片大小需要另外写 css 来进行控制。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Hexo 插入图片有 <strong>网络图片插入</strong> 和 <strong>本地图片插入</strong> 两种方式。</p>\n<p>网络图片插入的做法是先把图片上传到 <a href=\"https://www.qiniu.com/\">七牛云</a> 等云服务商提供的图床，然后通过 <code>![img-title](img-url)</code> 的方式，把 img-url 的地址替换成图片在图床的 url 地址即可。使用网络图片的好处是七牛云的cdn加速效果会大大提高图片的打开速度，缺点是多图片博客的编辑过程会比较繁琐，图片管理比较麻烦。</p>\n<p>本地图片插入把图片和博客保存在一起，方便图片管理，但是图片的网络打开速度会很慢。下面重点介绍本地图片插入。</p>\n<h2 id=\"常规本地图片插入\"><a href=\"#常规本地图片插入\" class=\"headerlink\" title=\"常规本地图片插入\"></a>常规本地图片插入</h2><h3 id=\"1、安装插件\"><a href=\"#1、安装插件\" class=\"headerlink\" title=\"1、安装插件\"></a>1、安装插件</h3><p>安装插件 <a href=\"https://github.com/CodeFalling/hexo-asset-image\">hexo-asset-image</a>，在 hexo 安装目录下运行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm install hexo-asset-image --save</span></span><br></pre></td></tr></table></figure>\n\n<p>安装完成后需要重启一下服务器。</p>\n<p><strong>注意 hexo-asset-image 仓库已经停止维护</strong>。新版使用 <a href=\"https://github.com/hexojs/hexo-renderer-marked\">hexo-renderer-marked</a> 3.1.0 版本以上的插件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm install hexo-renderer-marked --save</span></span><br></pre></td></tr></table></figure>\n\n<p>具体参考 <a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\">资源文件夹</a></p>\n<h3 id=\"2、修改配置文件\"><a href=\"#2、修改配置文件\" class=\"headerlink\" title=\"2、修改配置文件\"></a>2、修改配置文件</h3><p>编辑 <strong>Hexo安装目录下的_config.yml</strong> 文件，找到 <code>post_asset_folder</code>，把值改成 <code>true</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">post_asset_folder: true</span><br><span class=\"line\">marked:</span><br><span class=\"line\">  prependRoot: true</span><br><span class=\"line\">  postAsset: true</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>通过将 config.yml 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开资源文件管理功能。当资源文件管理功能打开后，Hexo 将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p>\n</blockquote>\n<h3 id=\"3、使用插入图片\"><a href=\"#3、使用插入图片\" class=\"headerlink\" title=\"3、使用插入图片\"></a>3、使用插入图片</h3><p>使用 <code>hexo new post &quot;xxxx&quot;</code> 来新建博客时，会发现在 <code>/source/_posts</code> 文件夹下会有一个同名的 <code>xxxx</code> 文件夹，对于已存在的博客可以新建一个同名文件夹。您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。</p>\n<p>先把图片复制到同名文件夹中，然后在文章中使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">![文字](img.jpg)</span><br></pre></td></tr></table></figure>\n\n<p>例如把 example.jpeg 复制到同名文件夹，然后在文章中使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">![赵霁](example.jpeg)</span><br></pre></td></tr></table></figure>\n\n<p>效果图如下：</p>\n<p><img src=\"/2018/06/21/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F/example.jpeg\" alt=\"赵霁\"></p>\n<h2 id=\"设置图片大小\"><a href=\"#设置图片大小\" class=\"headerlink\" title=\"设置图片大小\"></a>设置图片大小</h2><p>图片默认会显示原本的图片大小并居中显示，如果需要对图片大小进行设置，需要另外写 css 样式进行控制。注意：该方法可能会覆盖原来的一些图片样式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img src=&quot;example.jpeg&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>效果图如下：</p>\n<img src=\"example.jpeg\" width=\"50%\" height=\"50%\">\n\n<h2 id=\"Hexo与Typora的结合\"><a href=\"#Hexo与Typora的结合\" class=\"headerlink\" title=\"Hexo与Typora的结合\"></a><strong>Hexo与Typora的结合</strong></h2><p>上述是从文章资源文件夹中引用图片，前提是<strong>先将图片放入到文章资源文件夹</strong>，如果图片数量众多的话，一张一张的放很影响效率。Typora对于插入图片的支持做得非常好，设置 <strong>偏好设置—图片</strong>，设置<strong>复制到指定路径</strong>，值为 <code>./$&#123;filename&#125;</code>，然后勾选下面的按钮。</p>\n<p><img src=\"/2018/06/21/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F/image-20230301123633741.png\" alt=\"image-20230301123633741\"></p>\n<p>使用该配置后，可以直接复制网页中的图片地址，粘贴到Typora中后，会直接复制该图片到文章资源文件夹，同时自动更改路径。</p>\n<p><strong>但我们知道部署后，文件路径是不同的，所以当我们插入完所有的图片后，我们还需要删除每个图片路径中的<code>文件名/</code>。不慌，也很简单。在 Typora 编辑器中，使用<code>&lt;C-f&gt;</code>快捷键，将所有的<code>文件名/</code>替换为空即可删除。</strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://hexo.io/zh-cn/docs/asset-folders.html\">Hexo 官方文档资源文件夹</a><br><a href=\"https://www.jianshu.com/p/c2ba9533088a\">hexo博客图片问题</a><br><a href=\"https://blog.csdn.net/sugar_rainbow/article/details/57415705\">hexo生成博文插入图片</a></p>\n","categories":["工具","Hexo"],"tags":["Hexo"]},{"title":"小程序自定义Modal组件","url":"/2018/06/21/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89Modal%E7%BB%84%E4%BB%B6/","content":"<blockquote>\n<p>在小程序 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/\">官方文档</a> 中可以使用 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/api-react.html#wxshowmodalobject\">wx.showModal()</a> 方法来生成 Modal 蒙层弹框，但是其显示的内容只能为文本格式且由传入参数限定，显示方式比较单一，不能满足日常多样化的需求。本人查阅了相关资料完成一些自定义Modal组件，可以满足个性化需求。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><p>在这里的实现思路主要是通过微信小程序的原生 Modal 组件来实现，这个组件在最新版的官方文档中已经找不到，估计官方是想用 <code>wx.showModal()</code> 方法来代替使用，但是仍然可以向下兼容使用。通过原生的 Modal 组件我们可以自定义自己的内容界面，Modal 组件的 api 文档如下</p>\n<p><img src=\"/2018/06/21/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89Modal%E7%BB%84%E4%BB%B6/docs.png\" alt=\"原生Modal官方文档\"></p>\n<p>再对比 <code>wx.showModal()</code> 的 api 文档不难看出其只是对 Modal 组件的进一步封装。</p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><h3 id=\"wxml\"><a href=\"#wxml\" class=\"headerlink\" title=\"wxml\"></a>wxml</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--打印发货单蒙层--&gt;</span><br><span class=\"line\">  &lt;modal hidden=&quot;&#123;&#123;hideModal&#125;&#125;&quot; class=&#x27;modal&#x27; cancel-text=&#x27;返回&#x27; confirm-text=&#x27;下一步&#x27; bindcancel=&quot;cancelPrint&quot; bindconfirm=&quot;confirmPrint&quot; catchtouchmove=&#x27;preventTouchMove&#x27;&gt;</span><br><span class=\"line\">    &lt;view class=&#x27;modal-box&#x27;&gt;</span><br><span class=\"line\">      &lt;radio-group bindchange=&#x27;radioChange&#x27;&gt;</span><br><span class=\"line\">        &lt;label class=&#x27;radio modal-item&#x27;&gt;</span><br><span class=\"line\">          &lt;view class=&#x27;modal-item-hd&#x27;&gt;</span><br><span class=\"line\">            &lt;radio value=&#x27;1&#x27; checked=&#x27;&#123;&#123;radioIndex == 1&#125;&#125;&#x27;&gt;&lt;/radio&gt;</span><br><span class=\"line\">            &lt;view&gt;根据手机号和提货码发货&lt;/view&gt;</span><br><span class=\"line\">          &lt;/view&gt;</span><br><span class=\"line\">          &lt;view class=&#x27;modal-item-bd&#x27;&gt;</span><br><span class=\"line\">            &lt;view&gt;手机号：&#123;&#123;phone&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">            &lt;view&gt;提货码：&#123;&#123;detail.ladingCode&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">          &lt;/view&gt;</span><br><span class=\"line\">        &lt;/label&gt;</span><br><span class=\"line\">        &lt;label class=&#x27;radio modal-item&#x27;&gt;</span><br><span class=\"line\">          &lt;view class=&#x27;modal-item-hd&#x27;&gt;</span><br><span class=\"line\">            &lt;radio value=&#x27;2&#x27;&gt;&lt;/radio&gt;</span><br><span class=\"line\">            &lt;view&gt;扫描二维码&lt;/view&gt;</span><br><span class=\"line\">          &lt;/view&gt;</span><br><span class=\"line\">          &lt;view class=&#x27;modal-item-bd&#x27;&gt;</span><br><span class=\"line\">            &lt;view&gt;请点击下一步&lt;/view&gt;</span><br><span class=\"line\">          &lt;/view&gt;</span><br><span class=\"line\">        &lt;/label&gt;</span><br><span class=\"line\">      &lt;/radio-group&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">  &lt;/modal&gt;</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>wxml文件最关键部分是 <code>&lt;modal&gt;&lt;/modal&gt;</code> 组件的调用，参数解析如下</p>\n<ul>\n<li>通过 <code>hidden</code> 属性来控制蒙层的显示和隐藏</li>\n<li><code>bindcancel</code> 属性绑定返回时间</li>\n<li><code>bindconfirm</code> 属性绑定确认事件</li>\n<li><code>catchtouchmove</code> 防止触摸滑动穿透，即当 modal 弹层下的页面有滚动条，在 modal 弹层上触摸滑动时下面的页面仍跟着滚动的情况。</li>\n</ul>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">data: &#123;</span><br><span class=\"line\">  phone: null,</span><br><span class=\"line\">  detail: null,</span><br><span class=\"line\">  hideModal: true,</span><br><span class=\"line\">  radioIndex: 1</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 显示modal组件</span><br><span class=\"line\"> */</span><br><span class=\"line\">printDel: function() &#123;</span><br><span class=\"line\">  this.setData(&#123;</span><br><span class=\"line\">    hideModal: false</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 隐藏modal组件</span><br><span class=\"line\"> */</span><br><span class=\"line\">cancelPrint: function() &#123;</span><br><span class=\"line\">  this.setData(&#123;</span><br><span class=\"line\">    hideModal: true</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 阻断蒙层事件向下传递</span><br><span class=\"line\"> */</span><br><span class=\"line\">preventTouchMove: function() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 选择打印发货单方式</span><br><span class=\"line\"> */</span><br><span class=\"line\">radioChange: function(e) &#123;</span><br><span class=\"line\">  this.setData(&#123;</span><br><span class=\"line\">    radioIndex: e.detail.value</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 确认打印</span><br><span class=\"line\"> */</span><br><span class=\"line\">confirmPrint: function() &#123;</span><br><span class=\"line\">  var radioIndex = this.data.radioIndex</span><br><span class=\"line\">  if(radioIndex == 1) &#123;</span><br><span class=\"line\">    //根据手机号和提货码发货</span><br><span class=\"line\">    wx.showToast(&#123;</span><br><span class=\"line\">      title: &#x27;请在终端屏幕上输入手机号和提货码&#x27;,</span><br><span class=\"line\">      icon: &#x27;none&#x27;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;else &#123;</span><br><span class=\"line\">    //扫描二维码</span><br><span class=\"line\">    /** code */</span><br><span class=\"line\">    this.setData(&#123;</span><br><span class=\"line\">      hideModal: true</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n<p>js 文件中最关键的是 <code>this.setData(&#123; hideModal: true / false &#125;)</code> 来控制 Modal 组件的隐藏&#x2F;显示，以及空方法 <code>preventTouchMove()</code> 阻止事件向父节点传递。</p>\n<blockquote>\n<p>以bind或catch开头，然后跟上事件的类型，bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。</p>\n</blockquote>\n<p>详见 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html\">小程序事件</a></p>\n<h3 id=\"wxss\"><a href=\"#wxss\" class=\"headerlink\" title=\"wxss\"></a>wxss</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">.modal-item-hd &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  align-items: center</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.modal-item-hd view &#123;</span><br><span class=\"line\">  font-size: 32rpx;</span><br><span class=\"line\">  color: #000;</span><br><span class=\"line\">  padding-top: 5rpx</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.modal-item-bd &#123;</span><br><span class=\"line\">  margin: 10rpx 0 20rpx 60rpx;</span><br><span class=\"line\">  font-size: 36rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>wxss比较简单，在这里不做详细解析。</p>\n<h2 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h2><p><img src=\"/2018/06/21/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89Modal%E7%BB%84%E4%BB%B6/rs.jpeg\" alt=\"最终效果图\"></p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://blog.csdn.net/zhuyb829/article/details/73349295\">自定义模态对话框实例</a><br><a href=\"https://www.cnblogs.com/liululin/p/6001437.html\">微信小程序之—-弹框组件modal</a><br><a href=\"https://blog.csdn.net/u011072139/article/details/54016575\">小程序 实现遮罩层</a></p>\n","categories":["平台开发","微信小程序"],"tags":["微信小程序"]},{"title":"Hexo多台电脑更新博客","url":"/2018/06/22/Hexo%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/","content":"<blockquote>\n<p>通过 Hexo 和 GitHub 搭建的博客，静态文件会上传到 GitHub 仓库的 master 分支，但是 Hexo 的安装目录还是保存在本地的。如果更换了电脑需要更新博客，我们需要 Hexo 的安装目录来生成&#x2F;编辑&#x2F;上传博客，并且这个安装目录需要随着博客的更新而更新。在这里提供一种便捷的办法来实现不同电脑之间同步更新博客。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><p>在 Github 用于存放博客的仓库 yourname.github.io 下面建立 <strong><code>master</code></strong> 和 <strong><code>hexo</code></strong> 两个分支</p>\n<ul>\n<li><code>master</code> 分支（默认创建），<em>通过 Hexo 命令提交</em>，用于存放上传的 Hexo 静态文件（例如 public 文件夹里面的内容），这个分支用于显示 <a href=\"https://yourname.github.io/\">https://yourname.github.io</a> 打开的内容。</li>\n<li><code>hexo</code> 分支（手动创建），<em>通过 Git 命令提交&#x2F;拉取</em>，用于存放 Hexo 的安装目录，该分支可设为 <strong>默认分支</strong> 。</li>\n</ul>\n<p>这样我们写博客的大概流程就是 <em>在 <code>hexo</code> 分支上写上博客，并把写好的博客内容上传到 <code>master</code> 分支</em>，两个分支都通过 git 进行管理，所有的修改一目了然，非常方便。</p>\n<h2 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h2><h3 id=\"本地电脑\"><a href=\"#本地电脑\" class=\"headerlink\" title=\"本地电脑\"></a>本地电脑</h3><p>如果你的电脑还没配置好 Hexo，请参考以前的教程 <a href=\"https://18814122746.github.io/2018/06/13/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/\">Hexo+GitHub搭建个人博客教程</a><br>当你本地电脑的 Hexo 目录已经安装配置完毕之后，该目录可以 <em>通过 Hexo 命令向 GitHub 仓库的 <code>master</code> 分支提交内容</em>，但是该目录还不是 git 管理的目录，需要把该目录初始化为 git 管理的目录。</p>\n<h4 id=\"1、删除非默认主题文件的-git-目录（可跳过）\"><a href=\"#1、删除非默认主题文件的-git-目录（可跳过）\" class=\"headerlink\" title=\"1、删除非默认主题文件的 .git 目录（可跳过）\"></a>1、删除非默认主题文件的 .git 目录（可跳过）</h4><p>如果你使用的是非默认主题 landscape 的其他主题，而该主题的目录也是在通过 <code>git clone</code> 方式拉取下来的话，需要先取消该目录的 git 管理追踪，否则到时候提交 Hexo 安装目录的时候该文件夹会报类似于 <code>XXX目录: git modified content untracked content</code> 的错误。例如本人使用的是 next 主题，在 Hexo 安装目录下输入命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cd themes/next</span><br><span class=\"line\">$ ls -la # 显示 .git 的隐藏目录</span><br><span class=\"line\">$ rm -rf .git</span><br><span class=\"line\">$ ls -la # 确认 .git 目录是否成功删除 </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、把-Hexo-命令提交的分支改成-master-分支\"><a href=\"#2、把-Hexo-命令提交的分支改成-master-分支\" class=\"headerlink\" title=\"2、把 Hexo 命令提交的分支改成 master 分支\"></a>2、把 Hexo 命令提交的分支改成 <code>master</code> 分支</h4><p>编辑 Hexo 安装目录下的 _config.yaml 文件，在 <code>deploy</code> 参数里面添加 <code>branch: master</code>，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\"> type: git</span><br><span class=\"line\"> repo: https://github.com/yourusername/yourusername.github.io.git</span><br><span class=\"line\"> branch: master</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、初始化-git-仓库\"><a href=\"#3、初始化-git-仓库\" class=\"headerlink\" title=\"3、初始化 git 仓库\"></a>3、初始化 git 仓库</h4><p>在 Hexo 安装目录下输入命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git init</span><br><span class=\"line\">$ git checkout -b hexo</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m &#x27;init&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>初始化为 git 目录并创建 <code>hexo</code> 分支</p>\n<h4 id=\"4、提交到远端服务器\"><a href=\"#4、提交到远端服务器\" class=\"headerlink\" title=\"4、提交到远端服务器\"></a>4、提交到远端服务器</h4><p>在 Hexo 安装目录下输入命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git remote add origin git@github.com:yourusername/yourusername.github.io.git</span><br><span class=\"line\">$ git push -u origin hexo:hexo</span><br></pre></td></tr></table></figure>\n\n<p>与远端主机关联并提交 <code>hexo</code> 分支</p>\n<h3 id=\"另外一台电脑\"><a href=\"#另外一台电脑\" class=\"headerlink\" title=\"另外一台电脑\"></a>另外一台电脑</h3><p>当你在一台新电脑上需要写博客的时候，需要先把 <code>hexo</code> 分支拉取下来，再进行 Hexo 初始化。<em>前提是该电脑需要先安装 git 和 node.js，并与 GitHub 进行 ssh 关联（可选）</em>。如果这些工作还没完成请参考 <a href=\"https://18814122746.github.io/2018/06/13/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/\">Hexo+GitHub搭建个人博客教程</a>  </p>\n<h4 id=\"1、拉取-hexo-分支\"><a href=\"#1、拉取-hexo-分支\" class=\"headerlink\" title=\"1、拉取 hexo 分支\"></a>1、拉取 <code>hexo</code> 分支</h4><p>在任意目录里面输入命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git clone -b hexo git@github.com: yourusername/yourusername.github.io.git</span><br></pre></td></tr></table></figure>\n\n<p>执行完之后你的目录下应该会出现一个 <code>yourusername.github.io</code> 的目录。</p>\n<h4 id=\"2、初始化为-Hexo-目录\"><a href=\"#2、初始化为-Hexo-目录\" class=\"headerlink\" title=\"2、初始化为 Hexo 目录\"></a>2、初始化为 Hexo 目录</h4><p><code>yourusername.github.io</code> 目录只是一个普通的 git 管理目录，需要把该目录初始化为 Hexo 目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cd yourusername.github.io</span><br><span class=\"line\">$ npm install hexo</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、安装插件（可跳过）\"><a href=\"#3、安装插件（可跳过）\" class=\"headerlink\" title=\"3、安装插件（可跳过）\"></a>3、安装插件（可跳过）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-searchdb --save # 本地搜索插件</span><br><span class=\"line\">$ npm install hexo-asset-image --save # 图片插件</span><br><span class=\"line\">$ npm install hexo-generator-sitemap --save # 谷歌站点地图插件</span><br><span class=\"line\">$ npm install hexo-generator-baidu-sitemap --save # 百度站点地图插件</span><br></pre></td></tr></table></figure>\n\n<p>至此这台新电脑的初始化工作也已经完成，可以开始写博客了。</p>\n<h3 id=\"写博客步骤\"><a href=\"#写博客步骤\" class=\"headerlink\" title=\"写博客步骤\"></a>写博客步骤</h3><p>以后我们写博客都在 <code>hexo</code> 分支下进行，<code>master</code> 分支只是用来存放生成的静态文件。确认目前在 <code>hexo</code> 分支下，步骤如下：</p>\n<ol>\n<li><code>git pull</code> 每次写博客前拉取最新的 <code>hexo</code> 分支代码</li>\n<li><code>hexo new post &#39;新文章&#39;</code> 开始写博客</li>\n<li><code>hexo clean &amp;&amp; hexo g</code> 清空并生成新的静态文件和缓存文件</li>\n<li><code>git add .</code></li>\n<li><code>git commit -m &#39;备注&#39;</code></li>\n<li><code>git push</code> 提交到 <code>hexo</code> 分支</li>\n<li><code>hexo d</code> 提交到 <code>master</code> 分支</li>\n</ol>\n<p>至此我们就可以实现在多台电脑上同步更新博客</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://www.ruanyifeng.com/blog/2014/06/git_remote.html\">Git远程操作详解</a><br><a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\">GitHub Pages + Hexo搭建博客</a><br><a href=\"https://blog.csdn.net/mydo/article/details/51588008\">原git中status指令总是提示内容被修改的解决</a><br><a href=\"https://www.zhihu.com/question/38781463?sort=created\">hexo本地测试运行重启后页面空白</a></p>\n","categories":["工具","Hexo"],"tags":["Hexo"]},{"title":"Hexo个人博客绑定域名","url":"/2018/06/24/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/","content":"<blockquote>\n<p>Hexo + Github 搭建的个人博客访问地址默认为 <code>yourname.github.io</code>，这种地址一方面由于太长不容易被人记住，另一方面也难以被谷歌、百度等搜索引擎收录。所以我们可以申请独立的域名指向我们的博客地址，转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"域名\"><a href=\"#域名\" class=\"headerlink\" title=\"域名\"></a>域名</h2><p>目前国内有万网、新网等域名服务商，下面以 万网 为例子说明</p>\n<h3 id=\"购买域名\"><a href=\"#购买域名\" class=\"headerlink\" title=\"购买域名\"></a>购买域名</h3><p>登陆 <a href=\"https://wanwang.aliyun.com/\">万网官网</a>，申请阿里云账号，然后在 <a href=\"https://wanwang.aliyun.com/domain/\">域名注册</a> 页面购买自己的域名</p>\n<p><img src=\"/2018/06/24/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/shenqing.jpeg\" alt=\"购买域名\"></p>\n<blockquote>\n<p>按照工信部 2017 年全面域名实名认证的要求,若域名在规定时间内未通过实名审核，会被注册局暂停解析（Serverhold），无法正常访问，待实名认证通过后方可恢复正常使用。实名认证流程为：</p>\n</blockquote>\n<ol>\n<li>登录 <a href=\"https://dc.console.aliyun.com/next/index#/domain/list/all-domain\">阿里云域名控制台</a>，单击 域名列表 页面的 <strong>未实名认证域名</strong> &gt; <strong>提交资料</strong> 。</li>\n<li>填写实名认证资料，单击 <strong>提交</strong> 。</li>\n</ol>\n<h3 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h3><p>在 <strong>域名列表</strong> 里面找到你注册成功且通过实名认证可正常使用的域名，点击 <strong>解析</strong> 按钮（未实名认证状态异常的域名可能没有该按钮）</p>\n<p><img src=\"/2018/06/24/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/jiexi1.jpeg\" alt=\"解析1\"></p>\n<p>在 <strong>解析设置</strong> 界面点击右上角 <strong>添加记录</strong>，填写内容</p>\n<div style='width: 50%'>![解析2](jiexi2.jpeg)</div>\n* 记录类型：`CNAME` 类型将该域名指向你的 yourname.github.io，也可以用 `A类型`指向 ip 地址：*先 ping 你的 yourusername.github.io，用 `A` 类型指向 ping 得到的 ip 地址*。\n* 主机记录：`www` 解析后的域名为 www.aliyun.com, `@` 直接解析主域名 aliyun.com。一般写这两个就行。\n* 记录值：`CNAME` 解析对应 yourname.github.io，`A` 解析对应 ip 地址。\n\n<p>添加成功后如下图所示：<br><img src=\"/2018/06/24/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/jiexi3.jpeg\" alt=\"jiexi3\"></p>\n<h2 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h2><p>我们要在上传到 GitHub 的静态文件夹里面添加 <code>CNAME</code> 解析文件，对应上面添加的 <code>CNAME</code> 解析记录。</p>\n<h3 id=\"创建-CNAME-文件\"><a href=\"#创建-CNAME-文件\" class=\"headerlink\" title=\"创建 CNAME 文件\"></a>创建 <code>CNAME</code> 文件</h3><p>我们在站点目录的 <code>source</code> 文件夹下面创建 <code>CNAME</code> 文件，这样每次我们生成静态文件的时候都会自动把该文件添加到 <code>public</code> 文件夹。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cd source</span><br><span class=\"line\">$ vim CNAME</span><br></pre></td></tr></table></figure>\n\n<p><em>注意文件名就是 <code>CNAME</code>，不能写错</em>，在文件中添加你注册的域名如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mcbill.cn</span><br></pre></td></tr></table></figure>\n\n<p>注意域名前面不用加任何前缀，保存退出。</p>\n<h3 id=\"发布部署\"><a href=\"#发布部署\" class=\"headerlink\" title=\"发布部署\"></a>发布部署</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>\n\n<p>部署成功再过几分钟访问你的域名，如 <code>mcbill.cn</code> 解析成功就会跳转到你的博客。以后就算是直接访问 <code>yourname.github.io</code> 也会直接解析为你的域名。至此 绑定域名已经完成。</p>\n","categories":["工具","Hexo"],"tags":["Hexo"]},{"title":"Hexo问题及解决办法汇总","url":"/2018/06/25/Hexo%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E6%B1%87%E6%80%BB/","content":"<blockquote>\n<p>对通过 Hexo 搭建博客过程中遇到的问题进行了汇总，以后再遇到相同的问题可以迅速定位解决问题。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h3 id=\"一、点击-Local-Search-本地搜索页面卡住\"><a href=\"#一、点击-Local-Search-本地搜索页面卡住\" class=\"headerlink\" title=\"一、点击 Local Search 本地搜索页面卡住\"></a>一、点击 Local Search 本地搜索页面卡住</h3><p>问题描述：安装教程配置好 Local Search 本地搜索之后，点击 <strong>搜索</strong> 按钮页面一直卡在转圈圈的地方，F12进入开发者工具没有看到错误提示，以 <code>debug</code> 模式启动的服务器也没有错误输出？</p>\n<p>问题解决：<strong>出现这种情况是因为你的某一篇文章中出现了非 UTF-8 编码的字符，解决办法是找到把该异常字符并删除</strong>。</p>\n<ul>\n<li>打开 <code>http://localhost:4000/search.xml</code>，确认错误字符所在的位置。如下图所示就在第6行第35列。</li>\n</ul>\n<p><img src=\"/2018/06/25/Hexo%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E6%B1%87%E6%80%BB/localsearch1.jpeg\" alt=\"localsearch1\"></p>\n<ul>\n<li>通过 <code>$ vim public/search.xml</code> 打开 <code>search.xml</code> 文件，根据刚才的位置定位到出现问题的文章的该行该列。该位置一般会出现一个异常字符，例如 <code>^H</code> 或者 <code>^M</code> 等字符。注意不用直接修改 <code>search.xml</code> 文件。</li>\n<li>编辑出现问题的文章的 <code>md</code> 文件，找到出现问题的行列，把该位置的特殊字符删掉。该字符有可能是一个隐藏的字符如 <code>^H</code>，一般的 markdown 编辑工具可能看不到该字符，可以通过 <code>vim</code> 编辑删除该字符。</li>\n<li>执行 <code>$ hexo clean &amp;&amp; hexo g</code> 后重启服务器，然后再打开 <code>http://localhost:4000/search.xml</code>，看到下图所示表示可以正常使用本地搜索功能。</li>\n</ul>\n<p><img src=\"/2018/06/25/Hexo%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E6%B1%87%E6%80%BB/localsearch2.jpeg\" alt=\"localsearch2\"></p>\n<h3 id=\"二、在执行-hexo-d-部署到-GitHub-上的时候总是卡住\"><a href=\"#二、在执行-hexo-d-部署到-GitHub-上的时候总是卡住\" class=\"headerlink\" title=\"二、在执行 hexo d 部署到 GitHub 上的时候总是卡住\"></a>二、在执行 <code>hexo d</code> 部署到 GitHub 上的时候总是卡住</h3><p>问题描述：在执行 <code>hexo d</code> 部署到 GitHub 上的时候总是卡住没有往下面执行，这时候只能 <code>ctrl + c</code> 中断或等待很久一段时间后才执行完毕。</p>\n<p>问题解决：这是由于国内墙对 GitHub 的阻挡影响，导致国内用户在向 GitHub 仓库 <code>pull</code> 或者 <code>push</code> 的时候速度都会受到不同程度的影响。解决办法是<strong>使用 vpn，然后设置 git 代理</strong>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 查看当前代理设置</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git config --global http.proxy</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git config --global https.proxy</span></span><br><span class=\"line\"></span><br><span class=\"line\">// 设置当前代理为 http://127.0.0.1:1080 或 socket5://127.0.0.1:1080</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git config --global http.proxy <span class=\"string\">&#x27;http://127.0.0.1:1080&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git config --global https.proxy <span class=\"string\">&#x27;http://127.0.0.1:1080&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git config --global http.proxy <span class=\"string\">&#x27;socks5://127.0.0.1:1080&#x27;</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git config --global https.proxy <span class=\"string\">&#x27;socks5://127.0.0.1:1080&#x27;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">// 删除 proxy</span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git config --global --<span class=\"built_in\">unset</span> http.proxy</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git config --global --<span class=\"built_in\">unset</span> https.proxy</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"三、Hexo-文件名大小写不敏感的问题\"><a href=\"#三、Hexo-文件名大小写不敏感的问题\" class=\"headerlink\" title=\"三、Hexo 文件名大小写不敏感的问题\"></a>三、Hexo 文件名大小写不敏感的问题</h3><p>有时候经常会出现文章部署后又修改了 Tag 或 Categories，而恰好修改的内容涉及到英文字母大写改小写或小写改大写，譬如 news 改为 News，修改后确发现部署到 Github 上无法生效，当点击对应的Tag或Categories时会出现路径无法找到从而跳转到404页面，但本地预览确一切正常。</p>\n<p><img src=\"/2018/06/25/Hexo%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E6%B1%87%E6%80%BB/404.png\" alt=\"404\"></p>\n<p>这个现象的问题是由于git 默认是大小写不敏感，而且如果你使用的是mac，系统默认也是大小写不敏感的。因此即便文件夹的大小写发生了变更，git 也会表现出置之不理。解决思路如下：</p>\n<h4 id=\"1、使用-git-修改文件名大小写。\"><a href=\"#1、使用-git-修改文件名大小写。\" class=\"headerlink\" title=\"1、使用 git 修改文件名大小写。\"></a>1、使用 git 修改文件名大小写。</h4><p>有两种方式。第一种是设置 git 为大小写敏感。用这种方法进行重命名，用git status就可以识别出修改了，但是不推荐用这种方式，因为在更新这种修改的时候会有麻烦（比如会 git push 创建一个新命名的文件，而且不是直接修改原来文件的命名）。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git config core.ignorecase <span class=\"literal\">false</span></span></span><br></pre></td></tr></table></figure>\n\n<p>第二种方式，使用 git mv 命令（仅当core.ignorecase为true时可用）。此时的状态是 renamed，git commit 即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"built_in\">mv</span> ABC.java Abc.java</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、清空部署目录-deploy-git\"><a href=\"#2、清空部署目录-deploy-git\" class=\"headerlink\" title=\"2、清空部署目录 .deploy_git\"></a>2、清空部署目录 .deploy_git</h4><p><code>.deploy_git</code> 在 hexo 的安装目录下面，是一个隐藏文件夹。在执行 <code>hexo deploy</code> 的时候会先清空 <code>.deploy_git</code>，然后把 <code>public</code> 目录下的文件拷到<code>.deploy_git</code>，再把 <code>.deploy_git</code>的、 的内容推送到 master 分支上面。</p>\n<p>接下来删除 <code>.deploy_git</code>文件夹内的所有文件，并 push 到 Github 仓库（默认是 master 分支），完成后你的 github.io 项目中没有任何文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\"><span class=\"built_in\">cd</span> .deploy_git</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"built_in\">rm</span> -rf *</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git commit -m <span class=\"string\">&quot;clean all file&quot;</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git push</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、重新部署并发布\"><a href=\"#3、重新部署并发布\" class=\"headerlink\" title=\"3、重新部署并发布\"></a>3、重新部署并发布</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo clean &amp;&amp; hexo g -d</span></span><br></pre></td></tr></table></figure>","categories":["工具","Hexo"],"tags":["Hexo","问题汇总"]},{"title":"小程序自定义tabBar","url":"/2018/06/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89tabBar/","content":"<blockquote>\n<p>tabBar 是指小程序底部的导航栏，微信小程序官方提供了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/config.html?search-key=tabbar\">多 tabBar 设置</a>，但是官方提供的 tabBar 最多支持 5 个 tab，而且是全局共用的，这意味着并不支持 <em>有时候我们想跳到不同的页面显示不同的 tabBar 导航栏</em> 这样的功能。所以本人尝试着手实现自定义的 tabBar 导航栏。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><p>参考过网上自定义 tabBar 的一些资料，例如这位仁兄的 <a href=\"https://blog.csdn.net/qq_29729735/article/details/78933721\">微信小程序自定义tabBar组件开发</a>，发现大部分资料都是 <em>通过 <code>navigateTo</code> 的方式进行 tab 切换</em>。这种实现方式有一个很明显的缺点：在 tab 切换的时候整个页面都会刷新一次，这意味着页面底下的 tabBar 导航栏也会跟着刷新，这样会很影响用户体验。官网的 tabBar 导航栏是在底层实现，所以不会出现这种刷新情况。</p>\n<p>因为没有办法解决这种通过 <code>navigateTo </code> 实现 tabBar 的刷新问题，本人转换了一种思路。<em>这种办法适合于每个 tab 页面数据量不是很大的情况</em>，如果你每个页面的数据量都非常大而且需要实时刷新的话可能不太适合这种方法。</p>\n<ol>\n<li>所有的 tab 页面和底下 tabBar 导航栏都写在同一个 wxml 页面里面，每个 tab 页面跟导航栏的一个按钮对应。</li>\n<li>在打开页面时所有 tab 页面的数据通过一个路由取回，然后渲染到各个 tab 页面里面。然后只把第一个 tab 页面的内容显示出来，其他 tab 页面都隐藏。</li>\n<li>每次点击下面的 tabBar 导航栏，只把点击按钮对应的 tab 页面显示出来，其他的 tab 页面都隐藏。</li>\n</ol>\n<p>这样实现的好处是 tab 切换时底部导航栏不会刷新，而且切换非常流畅，缺点是切换时 tab 页面不能实现实时刷新。如果你觉得这种实现方法能满足你的需求，请继续往下看。</p>\n<h2 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h2><p>下面显示每部分的核心代码。</p>\n<h3 id=\"wxml\"><a href=\"#wxml\" class=\"headerlink\" title=\"wxml\"></a>wxml</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;view class=&#x27;container&#x27;&gt;</span><br><span class=\"line\">  &lt;view class=&#x27;del-list&#x27;&gt;</span><br><span class=\"line\">    &lt;view class=&quot;page__bd&quot;&gt;</span><br><span class=\"line\">      &lt;block wx:if=&#x27;&#123;&#123;tabbarIndex == 0&#125;&#125;&#x27;&gt;</span><br><span class=\"line\">      // tab 页面1代码</span><br><span class=\"line\">      &lt;/block&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &lt;block wx:if=&#x27;&#123;&#123;tabbarIndex == 1&#125;&#125;&#x27;&gt;</span><br><span class=\"line\">      // tab 页面2代码</span><br><span class=\"line\">      &lt;/block&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;!--自定义导航栏--&gt;</span><br><span class=\"line\">  &lt;view class=&#x27;tabbar&#x27;&gt;</span><br><span class=\"line\">    &lt;view class=&#x27;tabbar-box&#x27;&gt;</span><br><span class=\"line\">      &lt;view class=&#x27;tabbar-item&#x27; wx:for=&quot;&#123;&#123;tabbarList&#125;&#125;&quot; bindtap=&#x27;tapTabbar&#x27; id=&quot;&#123;&#123;item.index&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;view class=&#x27;tabbar-item-icon&#x27;&gt;</span><br><span class=\"line\">          &lt;image src=&#x27;&#123;&#123;item.icon&#125;&#125;&#x27;&gt;&lt;/image&gt;</span><br><span class=\"line\">        &lt;/view&gt;</span><br><span class=\"line\">        &lt;view class=&#x27;tabbar-item-text&#x27;&gt;&#123;&#123;item.text&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">      &lt;/view&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n<p><em>底部导航栏为 <code>tabbarList </code> 的一个 list 数组，每个 tab 页面的 <code>tabbarIndex</code> 跟 list 数组的 <code>index</code> 对应</em>。这样就可以根据 <code>index</code> 来显示对应的 tab 页面。</p>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">\t</span><br><span class=\"line\">  tabbarList: [&#123;</span><br><span class=\"line\">    index: 0,</span><br><span class=\"line\">    icon: &#x27;/images/driver/deliver-select.png&#x27;,</span><br><span class=\"line\">    text: &#x27;发货单&#x27;</span><br><span class=\"line\">  &#125;, &#123;</span><br><span class=\"line\">    index: 1,</span><br><span class=\"line\">    icon: &#x27;/images/driver/my.png&#x27;,</span><br><span class=\"line\">    text: &#x27;我的&#x27;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\">    tabbarIndex: 0,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 点击tabbar导航栏</span><br><span class=\"line\">   */</span><br><span class=\"line\">  tapTabbar: function(e) &#123;</span><br><span class=\"line\">    var index = e.currentTarget.id</span><br><span class=\"line\">    var tabbarList = this.data.tabbarList</span><br><span class=\"line\">    for (var item in tabbarList) &#123;</span><br><span class=\"line\">      if (tabbarList[item].index == index) &#123;</span><br><span class=\"line\">        var icon = tabbarList[item].icon</span><br><span class=\"line\">        var iconList = icon.split(&#x27;.&#x27;)</span><br><span class=\"line\">        if(iconList[0].indexOf(&#x27;select&#x27;) &lt; 0) &#123;</span><br><span class=\"line\">          tabbarList[item].icon = iconList[0] + &#x27;-select.&#x27; + iconList[1]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;else &#123;</span><br><span class=\"line\">        var icon = tabbarList[item].icon</span><br><span class=\"line\">        var iconList = icon.split(&#x27;.&#x27;)</span><br><span class=\"line\">        if (iconList[0].indexOf(&#x27;select&#x27;) &gt; 0) &#123;</span><br><span class=\"line\">          var temp = iconList[0].replace(/-select/g, &#x27;&#x27;)</span><br><span class=\"line\">          tabbarList[item].icon = temp + &#x27;.&#x27; + iconList[1]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.setData(&#123;</span><br><span class=\"line\">      tabbarList: tabbarList,</span><br><span class=\"line\">      tabbarIndex: index</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>点击 tabBar 导航栏时，把当前点击按钮的图片更新为带 <code>-select</code> 后缀表示选中的图片，其他的按钮图片更新为无后缀图片，然后重新渲染 <code>tabbarList</code> 和 <code>tabbarIndex </code>。</p>\n<h3 id=\"wxss\"><a href=\"#wxss\" class=\"headerlink\" title=\"wxss\"></a>wxss</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">.tabbar &#123;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  z-index: 999;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 120rpx;</span><br><span class=\"line\">  background-color: #f8f8f8;</span><br><span class=\"line\">  border-top: 1rpx solid #d9d9d9</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.tabbar-box &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">  justify-content: center</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.tabbar-item &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-direction: column;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\">  margin-top: 10rpx;</span><br><span class=\"line\">  width: 50%</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.tabbar-item image &#123;</span><br><span class=\"line\">  width: 65rpx;</span><br><span class=\"line\">  height: 65rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.tabbar-item-icon &#123;</span><br><span class=\"line\">  height: 65rpx</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.tabbar-item-text &#123;</span><br><span class=\"line\">  font-size: 28rpx;</span><br><span class=\"line\">  color: #999</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.del-list-logout &#123;</span><br><span class=\"line\">  width: 90%;</span><br><span class=\"line\">  margin: 50rpx auto 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"tabBar-图片\"><a href=\"#tabBar-图片\" class=\"headerlink\" title=\"tabBar 图片\"></a>tabBar 图片</h3><div style='width: 50%'>![tabbar](tabbar.jpeg)</div>\n## 实现效果\n\n<div style='width: 45%; display: inline-block; margin-right: 5%'>![rs1](rs1.jpeg)</div>\n<div style='width: 45%; display: inline-block'>![rs2](rs2.jpeg)</div>","categories":["平台开发","微信小程序"],"tags":["微信小程序"]},{"title":"Maven入门","url":"/2018/06/26/Maven%E5%85%A5%E9%97%A8%E5%8F%8APOM%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/","content":"<blockquote>\n<p>Maven 是基于项目对象模型 POM(project object model) 概念的的 <strong>软件项目管理工具</strong>。Maven 提供统一标准的开发项目结构，并使用简单的标签描述来配置项目相关信息和管理项目依赖包，可以使开发人员在非常短的时间内完成配置工作，大大提高开发效率。下面介绍 Maven 的一些入门知识。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h2><h3 id=\"Maven-是什么\"><a href=\"#Maven-是什么\" class=\"headerlink\" title=\"Maven 是什么\"></a>Maven 是什么</h3><p>在不借助项目管理工具的开发过程中我们通常会遇到这样的问题：</p>\n<ul>\n<li>在开发中，为了保证编译通过，我们会到处去寻找 jar 包，当编译通过了，运行的时候，却发现 “ClassNotFoundException” ，我们想到的是，难道还差 jar 包？例如在 spring 框架上开发的过程中我们至少要把 spring 的常用 jar 包和依赖包 common-logging 包下载下来，然后还要加入类路径和输出目录，工作显得非常累赘。</li>\n<li>每个 Java 项目的目录结构都没有一个统一的标准，配置文件到处都是，单元测试代码到底应该放在那里也没有一个权威的规范。</li>\n</ul>\n<p>这时候就需要一个项目管理工具来对项目进行管理。Maven 是一个跨平台的项目管理工具，用于管理项目依赖，项目构建和项目生命周期的全过程。Maven 的作用有：</p>\n<ul>\n<li>统一项目开发目录。例如所有的项目目录结构统一划分成 <code> src/main/java</code> (源代码目录)、<code>src/main/resources</code> (资源目录)、<code>src/test/java</code> (测试代码目录)、 <code>src/test/resources</code> (测试资源目录)、 <code>target</code> (生成文件目录)等目录。</li>\n<li>统一项目的生命周期，规范项目从开始构建到部署的建设过程。</li>\n<li>统一管理项目依赖，开发人员只需要定义所需要的依赖包，Maven 会自动搜索依赖包所依赖的其他包，不需要开发人员关心。</li>\n<li>测试和构建流程自动化和简单化。</li>\n</ul>\n<h3 id=\"Maven-目录\"><a href=\"#Maven-目录\" class=\"headerlink\" title=\"Maven 目录\"></a>Maven 目录</h3><p>参考 <a href=\"http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html\">Maven 标准目录布局</a>，根据 Maven 管理工具构建的项目是有一定的目录结构标准的，这样就很好解决了文件不知道放哪里、文件目录结构杂乱无章的问题。Maven 标准的目录如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">|── pom.xml</span><br><span class=\"line\">|── src</span><br><span class=\"line\">|   ├── main</span><br><span class=\"line\">|   |   ├── java</span><br><span class=\"line\">|   |   ├── resources</span><br><span class=\"line\">|   |   └── filters</span><br><span class=\"line\">|   ├── test</span><br><span class=\"line\">|   |   ├── java</span><br><span class=\"line\">|   |   ├── resources</span><br><span class=\"line\">|   |   └── filters</span><br><span class=\"line\">|   ├── it</span><br><span class=\"line\">|   ├── assembly</span><br><span class=\"line\">|   └── site</span><br><span class=\"line\">├── LICENSE.txt</span><br><span class=\"line\">├── NOTICE.txt</span><br><span class=\"line\">└── README.txt</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>pom.xml</code>：Maven 的核心配置文件</li>\n<li><code>src/main/java</code>：项目的源代码所在的目录</li>\n<li><code>src/main/resources</code>：项目的资源文件所在的目录</li>\n<li><code>src/main/filters</code>：项目的资源过滤文件所在的目录</li>\n<li><code>src/main/webapp</code>：如果是web项目，则该目录是web应用源代码所在的目录，比如html文件和web.xml等都在该目录下。</li>\n<li><code>src/test/java</code>：测试代码所在的目录</li>\n<li><code>src/test/resources</code>：测试相关的资源文件所在的目录</li>\n<li><code>src/test/filters</code>：测试相关的资源过滤文件所在的目录</li>\n</ul>\n<p>下面这些目录平时用的不是很多</p>\n<ul>\n<li><code>src/it</code>：集成测试代码所在的目录，主要是供别的插件使用的。</li>\n<li><code>src/assembly</code>：组件（Assembly）描述符所在的目录</li>\n<li><code>src/site</code>：站点描述文件</li>\n<li><code>LICENSE.txt</code>：项目的许可文件</li>\n<li><code>NOTICE.txt</code>：该项目依赖的库的注意事项</li>\n<li><code>README.txt</code>：项目的readme文件</li>\n</ul>\n<h3 id=\"Maven-插件\"><a href=\"#Maven-插件\" class=\"headerlink\" title=\"Maven 插件\"></a>Maven 插件</h3><h4 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h4><p>参考 <a href=\"http://maven.apache.org/plugins/index.html\">Maven Plugins</a>。Maven 实际上是一个<strong>插件</strong>(plugin)的集成框架，它的核心并不执行任何具体的构建任务，所有这些任务都交给插件来完成。</p>\n<p>每个插件对应一到多个<strong>目标</strong>(global)，每个目标完成一个任务。Maven 的所有任务都是通过插件及其对应的目标来完成的。使用的插件语法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mvn [plugin-name]:[goal-name]</span><br></pre></td></tr></table></figure>\n\n<p>例如使用编译插件 (maven-compiler-plugin) 下的 compile 目标用来编译 <code>src/main/java/</code> 目录下的代码，testCompile 目标用来编译 <code>src/test/java/</code> 下的测试代码，命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mvn compiler:compile</span><br><span class=\"line\">$ mvn compiler:testCompile</span><br></pre></td></tr></table></figure>\n\n<p>参考 <a href=\"https://www.cnblogs.com/avivaye/p/5341341.html\">常用插件分析</a> ，在命令行输入常用的插件有：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">插件</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">maven-archetype-plugin</td>\n<td align=\"left\">生成简单的 Maven 项目骨架，例如初学者常用的 <code>mvn archetype:generate</code></td>\n</tr>\n<tr>\n<td align=\"left\">maven-compiler-plugin</td>\n<td align=\"left\">编译 java 源文件，包括 main&#x2F;java 和 test&#x2F;java&#x2F; 目录下的 java 文件</td>\n</tr>\n<tr>\n<td align=\"left\">maven-resources-plugin</td>\n<td align=\"left\">处理资源文件，例如复制 main&#x2F;resources 和 test&#x2F;resources 下的资源文件</td>\n</tr>\n<tr>\n<td align=\"left\">maven-surefire-plugin</td>\n<td align=\"left\">运行 JUnit 单元测试，其实大部分时间内，只要你的测试类遵循通用的命令约定（以Test结尾、以TestCase结尾、或者以Test开头），就几乎不用知晓该插件的存在</td>\n</tr>\n<tr>\n<td align=\"left\">maven-dependency-plugin</td>\n<td align=\"left\">分析项目依赖并打包项目依赖到指定文件夹等</td>\n</tr>\n</tbody></table>\n<p>命令行输入的插件是可以在 pom.xml 文件里面配置的。pom.xml 文件里面的 &lt; build &gt; 元素对应项目的构建阶段，其中的 &lt; plugin &gt; 元素对应项目会用到的一些插件。例如下面是 pom.xml 文件常定义的的一些插件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">    &lt;finalName&gt;MavenTest&lt;/finalName&gt;</span><br><span class=\"line\">    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span><br><span class=\"line\">        &lt;plugins&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;3.0.0&lt;/version&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;3.0.2&lt;/version&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.20.1&lt;/version&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;3.2.0&lt;/version&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.5.2&lt;/version&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.8.2&lt;/version&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;/plugins&gt;</span><br><span class=\"line\">    &lt;/pluginManagement&gt;</span><br><span class=\"line\">&lt;/build&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"插件参数\"><a href=\"#插件参数\" class=\"headerlink\" title=\"插件参数\"></a>插件参数</h4><p>在使用命令行执行 Maven 命令的时候可以加入参数执行，**-D** 表示配置 &lt; properties &gt; 属性，**-P** 表示配置 &lt; profiles &gt; 属性。</p>\n<p>使用命令行 -D 设置 &lt; properties &gt; 属性的方式是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn -DpropertyName=propertyValue clean package</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果 propertyName 原来在 pom.xml 里面不存在，它将被设置为一个新值。</li>\n<li>如果 propertyName 已经存在 pom.xml，例如 <code>maven.compiler.source</code> 这种有默认值的属性，传递的参数值会覆盖原来的属性值。</li>\n</ul>\n<p>多个 -D 属性之间通过空格分开</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn -DpropA=valueA -DpropB=valueB -DpropC=valueC clean package</span><br></pre></td></tr></table></figure>\n\n<p>也可以在 pom.xml 文件里面通过设置 &lt; configuration &gt; 属性来设置插件属性，例如设置 JDK 的编译版本为 1.8</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;plugin&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class=\"line\">    &lt;configuration&gt;</span><br><span class=\"line\">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class=\"line\">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class=\"line\">    &lt;/configuration&gt;</span><br><span class=\"line\">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>\n\n<p>总的来说，用户调用 Maven 插件目标有两种方式：</p>\n<ol>\n<li><p>输入生命周期调用插件目标。生命周期阶段是与插件目标绑定的，这样用户只需要输入生命周期阶段就可以调用对应的插件目标，如果绑定了多个插件目标将会顺序执行。例如 Maven 默认将 maven-compiler-plugin 的 compile 目标与 compile 生命周期阶段绑定，因此命令 <code>mvn compile</code> 实际上是先定位到 compile 这一生命周期阶段，然后再根据绑定关系调用 maven-compiler-plugin 的 compile 目标。</p>\n</li>\n<li><p>直接在命令行指定要执行的插件目标。例如 mvn archetype:generate 就表示调用 maven-archetype-plugin 的 generate 目标，这种带冒号的调用方式与生命周期无关。</p>\n</li>\n</ol>\n<p>而 Maven 的插件参数的配置也有两种方式：</p>\n<ol>\n<li><p>直接在命令行通过 -D 属性设置。这种相当于修改了 &lt; properties &gt; 元素的属性值。</p>\n</li>\n<li><p>在 pom.xml 文件的 &lt; plugin &gt; 元素里面通过 &lt; configuration &gt; 元素设置。</p>\n</li>\n</ol>\n<p>具体怎么配置插件参数可以参考 <a href=\"https://www.cnblogs.com/EasonJim/p/6865150.html\">这里</a></p>\n<!--Maven 包含核心插件和其他插件，其中两种类型的插件可以在 `pom.xml` 文件配置相关信息：\n\n* Build 插件：在构建过程中执行，并在 `pom.xml` 中的 `<build/>` 元素进行配置\n* Reporting 插件：在生成项目描述网站期间执行，在 `pom.xml` 中的 `<reporting/>` 元素进行配置-->\n\n<h3 id=\"Maven-生命周期\"><a href=\"#Maven-生命周期\" class=\"headerlink\" title=\"Maven 生命周期\"></a>Maven 生命周期</h3><p>参考 <a href=\"http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html\">Maven Lifecycle</a>，Maven 一共有三套<strong>生命周期</strong> (build lifecycle)。每套生命周期会有对应的<strong>构建阶段</strong>(build phases)。运行命令执行某一个构建阶段，该阶段前面的所有阶段都会自动执行。</p>\n<p>Maven 构建阶段和插件目标绑定。一个插件目标可以对应零到多个构建阶段，一个构建阶段可以对应零到多个插件目标，一个构建阶段如果没有绑定插件目标就不会执行。</p>\n<ul>\n<li>default：构建生命周期，包括项目从验证到部署的整体流程。default 生命周期根据打包 (packaging) 类型不同（例如可以打包成 jar, war 和 pom 等），具有不同的构建阶段。下面的 jar 包的生命周期阶段：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">阶段</th>\n<th align=\"left\">插件:目标</th>\n<th align=\"left\">目标作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">process-resources</td>\n<td align=\"left\">resources:resources</td>\n<td align=\"left\">默认处理 src&#x2F;main&#x2F;resources&#x2F; 下的文件，将其输出到测试的 classpath 目录中</td>\n</tr>\n<tr>\n<td align=\"left\">compile</td>\n<td align=\"left\">compiler:compile</td>\n<td align=\"left\">编译 src&#x2F;main&#x2F;java 下的 java 文件，产生对应的class</td>\n</tr>\n<tr>\n<td align=\"left\">process-test-resources</td>\n<td align=\"left\">resources:testResources</td>\n<td align=\"left\">默认处理 src&#x2F;test&#x2F;resources&#x2F; 下的文件，将其输出到测试的 classpath 目录中</td>\n</tr>\n<tr>\n<td align=\"left\">test-compile</td>\n<td align=\"left\">compiler:testCompile</td>\n<td align=\"left\">编译 src&#x2F;test&#x2F;java 下的 java 文件，产生对应的 class</td>\n</tr>\n<tr>\n<td align=\"left\">test</td>\n<td align=\"left\">surefire:test</td>\n<td align=\"left\">运行测试用例</td>\n</tr>\n<tr>\n<td align=\"left\">package</td>\n<td align=\"left\">jar:jar</td>\n<td align=\"left\">打包构件，即生成对应的 jar, war 等</td>\n</tr>\n<tr>\n<td align=\"left\">install</td>\n<td align=\"left\">install:install</td>\n<td align=\"left\">将构件部署到本地仓库</td>\n</tr>\n<tr>\n<td align=\"left\">deploy</td>\n<td align=\"left\">deploy:deploy</td>\n<td align=\"left\">部署构件到远程仓库</td>\n</tr>\n</tbody></table>\n<ul>\n<li>clean：清理生命周期，清空目标文件，也就是清空 target 文件夹。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">阶段</th>\n<th align=\"left\">插件:目标</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">clean</td>\n<td align=\"left\">clean:clean</td>\n</tr>\n</tbody></table>\n<ul>\n<li>site：生成项目描述网站周期，产生项目的站点描述文件。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">阶段</th>\n<th align=\"left\">插件:目标</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">site</td>\n<td align=\"left\">site:site</td>\n<td align=\"left\">产生项目的站点文档</td>\n</tr>\n<tr>\n<td align=\"left\">site-deploy</td>\n<td align=\"left\">site:deploy</td>\n<td align=\"left\">将项目的站点文档部署到服务器</td>\n</tr>\n</tbody></table>\n<h2 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h2><p><code>pom.xml</code> 文件是整个 Maven 项目的核心配置文件。<code>pom.xml</code> 文件记录了整个项目的基础配置信息、相关依赖插件、构建配置和远程库等信息。</p>\n<h3 id=\"整体结构\"><a href=\"#整体结构\" class=\"headerlink\" title=\"整体结构\"></a>整体结构</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class=\"line\">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class=\"line\">            http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 基本设置 --&gt;</span><br><span class=\"line\">    &lt;groupId&gt;...&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;...&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;...&lt;/version&gt;</span><br><span class=\"line\">    &lt;packaging&gt;...&lt;/packaging&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;...&lt;/dependencies&gt;</span><br><span class=\"line\">    &lt;parent&gt;...&lt;/parent&gt;</span><br><span class=\"line\">    &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt;</span><br><span class=\"line\">    &lt;modules&gt;...&lt;/modules&gt;</span><br><span class=\"line\">    &lt;properties&gt;...&lt;/properties&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 构建过程的设置 --&gt;</span><br><span class=\"line\">    &lt;build&gt;...&lt;/build&gt;</span><br><span class=\"line\">    &lt;reporting&gt;...&lt;/reporting&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 项目信息设置 --&gt;</span><br><span class=\"line\">    &lt;name&gt;...&lt;/name&gt;</span><br><span class=\"line\">    &lt;description&gt;...&lt;/description&gt;</span><br><span class=\"line\">    &lt;url&gt;...&lt;/url&gt;</span><br><span class=\"line\">    &lt;inceptionYear&gt;...&lt;/inceptionYear&gt;</span><br><span class=\"line\">    &lt;licenses&gt;...&lt;/licenses&gt;</span><br><span class=\"line\">    &lt;organization&gt;...&lt;/organization&gt;</span><br><span class=\"line\">    &lt;developers&gt;...&lt;/developers&gt;</span><br><span class=\"line\">    &lt;contributors&gt;...&lt;/contributors&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 环境设置 --&gt;</span><br><span class=\"line\">    &lt;issueManagement&gt;...&lt;/issueManagement&gt;</span><br><span class=\"line\">    &lt;ciManagement&gt;...&lt;/ciManagement&gt;</span><br><span class=\"line\">    &lt;mailingLists&gt;...&lt;/mailingLists&gt;</span><br><span class=\"line\">    &lt;scm&gt;...&lt;/scm&gt;</span><br><span class=\"line\">    &lt;prerequisites&gt;...&lt;/prerequisites&gt;</span><br><span class=\"line\">    &lt;repositories&gt;...&lt;/repositories&gt;</span><br><span class=\"line\">    &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt;</span><br><span class=\"line\">    &lt;distributionManagement&gt;...&lt;/distributionManagement&gt;</span><br><span class=\"line\">    &lt;profiles&gt;...&lt;/profiles&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常用标签\"><a href=\"#常用标签\" class=\"headerlink\" title=\"常用标签\"></a>常用标签</h3><h4 id=\"modelVersion\"><a href=\"#modelVersion\" class=\"headerlink\" title=\"modelVersion\"></a>modelVersion</h4><p>必须，POM 模型版本，一般写 <code>4.0.0</code> 版本，该版本是同时被 Maven2 和 Maven3 支持的版本。</p>\n<h4 id=\"groupId\"><a href=\"#groupId\" class=\"headerlink\" title=\"groupId\"></a>groupId</h4><p>必须，组织唯一标识，通常写法是 <code>com.mycompany.app</code>，同时定义了构建时生成的相对路径为 <code>/com/mycompany/app</code>。</p>\n<h4 id=\"artifactId\"><a href=\"#artifactId\" class=\"headerlink\" title=\"artifactId\"></a>artifactId</h4><p>必须，项目名称唯一标识，写法如 <code>consumer-banking</code></p>\n<h4 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h4><p>必须，项目版本，写法如 <code>2.3.4</code></p>\n<blockquote>\n<ul>\n<li>groupId、artifactId 和 version 是所有 POM 文件根节点 <code>&lt;project&gt;</code> 里面必须包含的三个字段，共同定义了该项目在仓库里面的坐标位置，这意味着特定的 groupId 下，artifactId 也必须是唯一的。</li>\n<li>version 定义为 <code>1.0.0</code> 和 <code>1.0.0-SNAPSHOT</code> 的区别：<code>1.0.0</code>是指稳定版本，只要版本号不变，就算远程库中该版本号的项目进行了更新，也不会去远程库中拉取最新版本的项目，除非把版本号改成 <code>1.1.0</code> 等不同版本号；<code>1.0.0-SNAPSHOT</code> 是指开发版本，每次建立项目时都会去远程库中查看是否有最新版本。</li>\n</ul>\n</blockquote>\n<h4 id=\"packaging\"><a href=\"#packaging\" class=\"headerlink\" title=\"packaging\"></a>packaging</h4><p>项目的打包类型，可以为 <code>jar</code>、<code>war</code>、<code>ear</code>、<code>pom</code> 等。</p>\n<h4 id=\"dependencies\"><a href=\"#dependencies\" class=\"headerlink\" title=\"dependencies\"></a>dependencies</h4><p>定义了项目相关的所有依赖，每一个依赖包由 <code>&lt;dependency&gt;</code> 包围，<code>&lt;groupId&gt;</code>、<code>&lt;artifactId&gt;</code>、<code>&lt;version&gt;</code> 标签定义了依赖包在仓库中的唯一坐标，Maven 根据该坐标按照 <strong>本地仓库</strong> &gt; <strong>中央仓库</strong> &gt; <strong>远程仓库</strong> 的查找顺序去查找依赖包。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">      &lt;dependency&gt;</span><br><span class=\"line\">          &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class=\"line\">          &lt;artifactId&gt;httpmime&lt;/artifactId&gt;</span><br><span class=\"line\">          &lt;version&gt;4.5.5&lt;/version&gt;</span><br><span class=\"line\">      &lt;/dependency&gt;</span><br><span class=\"line\">      &lt;dependency&gt;</span><br><span class=\"line\">          &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class=\"line\">          &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class=\"line\">          &lt;version&gt;3.6&lt;/version&gt;</span><br><span class=\"line\">      &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent\"></a>parent</h4><p>父项目坐标，类似于 java 的集成，将继承父项目的依赖和插件等。在这里继承父项目的依赖有两种方式：</p>\n<p>第一种：完全继承父项目的所有依赖。子项目将引入父项目的所有依赖。</p>\n<p>父项目使用 <dependencies> 元素引入依赖，如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt; &lt;!-- 配置共有依赖 --&gt;</span><br><span class=\"line\">    &lt;!-- spring 依赖 --&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- junit 依赖 --&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;4.7&lt;/version&gt;</span><br><span class=\"line\">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n\n<p>子项目通过设置 <parent> 为父项目的坐标即可继承父项目的所有依赖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.youzhibing.account&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;account-aggregator&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">    &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;!-- 与不配置一样，默认就是寻找上级目录下得pom.xml --&gt;</span><br><span class=\"line\">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>\n\n<p>第二种：继承父类的依赖，但是只是作为一个范围约束，只有子项目通过 &lt; dependency &gt; 显示引入该范围内的依赖才算真正引入。这种继承方式更加灵活，而且子项目的 &lt; dependency &gt; 里面不需要说明 version 版本号，可以在父项目里面统一管理版本号。</p>\n<p>父项目通过 &lt; dependencyManagement &gt; 限制依赖范围。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependencyManagement&gt;</span><br><span class=\"line\">    &lt;dependencies&gt; &lt;!-- 配置共有依赖 --&gt;</span><br><span class=\"line\">        &lt;!-- spring 依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- junit 依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;4.7&lt;/version&gt;</span><br><span class=\"line\">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>\n\n<p>子类引入父项目的依赖范围，通过 &lt; dependency &gt; 真正引入依赖，不用添加版本号。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.youzhibing.account&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;account-aggregator&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">&lt;/parent&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    &lt;!--真正引入 spring 依赖 --&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"bulid\"><a href=\"#bulid\" class=\"headerlink\" title=\"bulid\"></a>bulid</h4><p>项目的构建信息</p>\n<ul>\n<li>finalName：构建产生的项目名称，默认为 <code>$&#123;artifactId&#125;-$&#123;version&#125;</code>。</li>\n<li>directory：构建产生的文件的存放目录，默认为 <code>$(basedir&#125;/target</code> ，即项目根目录下的 <code>target</code> 目录。</li>\n<li>plugins：插件列表，如下面第一个插件指定 Maven 插件编译版本，使用 java8 语言，JVM1.8 编译，编译时使用UTF-8编码。</li>\n<li>resources：项目资源列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。如下面就把文件 version.txt、banner.txt 和 templates&#x2F;index.html 打包到 <code>target</code> 目录</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">    &lt;finalName&gt;sale-api&lt;/finalName&gt;</span><br><span class=\"line\">    &lt;plugins&gt;</span><br><span class=\"line\">        &lt;plugin&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;2.3.2&lt;/version&gt;</span><br><span class=\"line\">            &lt;configuration&gt;</span><br><span class=\"line\">                &lt;source&gt;1.8&lt;/source&gt;</span><br><span class=\"line\">                &lt;target&gt;1.8&lt;/target&gt;</span><br><span class=\"line\">                &lt;encoding&gt;UTF8&lt;/encoding&gt;</span><br><span class=\"line\">            &lt;/configuration&gt;</span><br><span class=\"line\">        &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;plugin&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;configuration&gt;</span><br><span class=\"line\">                &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;</span><br><span class=\"line\">            &lt;/configuration&gt;</span><br><span class=\"line\">        &lt;/plugin&gt;</span><br><span class=\"line\">    &lt;/plugins&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;resources&gt;</span><br><span class=\"line\">        &lt;resource&gt;</span><br><span class=\"line\">            &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt;</span><br><span class=\"line\">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class=\"line\">            &lt;includes&gt;</span><br><span class=\"line\">                &lt;include&gt;version.txt&lt;/include&gt;</span><br><span class=\"line\">                &lt;include&gt;banner.txt&lt;/include&gt;</span><br><span class=\"line\">                &lt;include&gt;templates/index.html&lt;/include&gt;</span><br><span class=\"line\">            &lt;/includes&gt;</span><br><span class=\"line\">        &lt;/resource&gt;</span><br><span class=\"line\">    &lt;/resources&gt;</span><br><span class=\"line\">&lt;/build&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"properties\"><a href=\"#properties\" class=\"headerlink\" title=\"properties\"></a>properties</h4><p>POM 定义的常量，可供 POM 文件的其他地方引用，格式是 <code>&lt;name&gt;value&lt;/name&gt;</code>，引用时通过 <code>$&#123;name&#125;</code> 来获取 <code>value</code> 的值。</p>\n<p>Maven 总共有 6 类属性，内置属性、POM 属性、settings 属性、java 系统属性、env 环境变量属性和自定义属性。</p>\n<ul>\n<li>内置属性：两个常用内置属性 ${basedir} 表示项目根目录，即包含 pom.xml 文件的目录；${version} 表示项目版本。</li>\n<li>POM 属性：用户可以使用该类属性引用 POM 文件中对应元素的值。如 ${project.artifactId} 就对应了 <project><artifactId>xxx</artifactId></project> 元素的值，常用的POM属性包括：<br>${project.build.sourceDirectory}:项目的主源码目录，默认为src&#x2F;main&#x2F;java&#x2F;</li>\n</ul>\n<p>　　　　${project.build.testSourceDirectory}:项目的测试源码目录，默认为src&#x2F;test&#x2F;java&#x2F;</p>\n<p>　　　　${project.build.directory} ： 项目构建输出目录，默认为target&#x2F;</p>\n<p>　　　　${project.outputDirectory} : 项目主代码编译输出目录，默认为target&#x2F;classes&#x2F;</p>\n<p>　　　　${project.testOutputDirectory}：项目测试主代码输出目录，默认为target&#x2F;testclasses&#x2F;</p>\n<p>　　　　${project.groupId}：项目的groupId</p>\n<p>　　　　${project.artifactId}：项目的artifactId</p>\n<p>　　　　${project.version}：项目的version,与${version} 等价</p>\n<p>　　　　${project.build.finalName}：项目打包输出文件的名称，默认为${project.artifactId}-${project.version}</p>\n<ul>\n<li>settings 属性：以 settings. 开头的属性，引用 settings.xml 文件中的 XML 元素的值。</li>\n<li>java 属性：以 java. 开头的属性，可引用java 系统属性，如${java.home}指向了 java 根目录。</li>\n<li>env 属性：以 env. 开头的属性，可使用所有环境变量属性，如 ${env.JAVA_HOME} 指代了 JAVA_HOME 环境变量的的值。</li>\n<li>自定义属性。可在其他地方通过 <code>$&#123;&#125;</code> 来引用该属性。</li>\n</ul>\n<p>例如下面就定义了 java 属性的版本号，并自定义了一个 file.encoding 属性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;properties&gt;  </span><br><span class=\"line\">    &lt;file.encoding&gt;UTF-8&lt;/file_encoding&gt;  </span><br><span class=\"line\">    &lt;java.source.version&gt;1.5&lt;/java_source_version&gt;  </span><br><span class=\"line\">    &lt;java.target.version&gt;1.5&lt;/java_target_version&gt;  </span><br><span class=\"line\">&lt;/properties&gt;  </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"repositories\"><a href=\"#repositories\" class=\"headerlink\" title=\"repositories\"></a>repositories</h4><p>远程仓库列表，当 Maven 在本地仓库和中央仓库中找不到所需要的依赖包时就会去远程仓库查找，可通过 <code>&lt;repository&gt;</code> 定义多个远程仓库。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;repositories&gt;</span><br><span class=\"line\">     &lt;repository&gt;</span><br><span class=\"line\">           &lt;id&gt;spring-releases&lt;/id&gt;</span><br><span class=\"line\">           &lt;name&gt;Spring Releases&lt;/name&gt;</span><br><span class=\"line\">           &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt;</span><br><span class=\"line\">     &lt;/repository&gt;</span><br><span class=\"line\">     &lt;repository&gt;</span><br><span class=\"line\">           &lt;id&gt;org.jboss.repository.releases&lt;/id&gt;</span><br><span class=\"line\">           &lt;name&gt;JBoss Maven Release Repository&lt;/name&gt;</span><br><span class=\"line\">           &lt;url&gt;https://repository.jboss.org/nexus/content/repositories/releases&lt;/url&gt;</span><br><span class=\"line\">     &lt;/repository&gt;</span><br><span class=\"line\">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"根-pom-xml\"><a href=\"#根-pom-xml\" class=\"headerlink\" title=\"根 pom.xml\"></a>根 pom.xml</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">\txsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和</span><br><span class=\"line\">\t\tversion。 --&gt;</span><br><span class=\"line\">\t&lt;parent&gt;</span><br><span class=\"line\">\t\t&lt;!--被继承的父项目的构件标识符 --&gt;</span><br><span class=\"line\">\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t&lt;!--被继承的父项目的全球唯一标识符 --&gt;</span><br><span class=\"line\">\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t&lt;!--被继承的父项目的版本 --&gt;</span><br><span class=\"line\">\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项</span><br><span class=\"line\">\t\t\t目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span><br><span class=\"line\">\t\t&lt;relativePath /&gt;</span><br><span class=\"line\">\t&lt;/parent&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span><br><span class=\"line\">\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;asia.banseon&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个</span><br><span class=\"line\">\t\t特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span><br><span class=\"line\">\t&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;</span><br><span class=\"line\">\t&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class=\"line\">\t&lt;!--项目的名称, Maven产生的文档用 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;name&gt;banseon-maven&lt;/name&gt;</span><br><span class=\"line\">\t&lt;!--项目主页的URL, Maven产生的文档用 --&gt;</span><br><span class=\"line\">\t&lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;</span><br><span class=\"line\">\t&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标</span><br><span class=\"line\">\t\t签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;</span><br><span class=\"line\">\t&lt;description&gt;A maven project to study maven.&lt;/description&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--描述了这个项目构建环境中的前提条件。 --&gt;</span><br><span class=\"line\">\t&lt;prerequisites&gt;</span><br><span class=\"line\">\t\t&lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span><br><span class=\"line\">\t\t&lt;maven&gt;&lt;/maven&gt;</span><br><span class=\"line\">\t&lt;/prerequisites&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span><br><span class=\"line\">\t&lt;issueManagement&gt;</span><br><span class=\"line\">\t\t&lt;!--问题管理系统（例如jira）的名字， --&gt;</span><br><span class=\"line\">\t\t&lt;system&gt;jira&lt;/system&gt;</span><br><span class=\"line\">\t\t&lt;!--该项目使用的问题管理系统的URL --&gt;</span><br><span class=\"line\">\t\t&lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt;</span><br><span class=\"line\">\t&lt;/issueManagement&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目持续集成信息 --&gt;</span><br><span class=\"line\">\t&lt;ciManagement&gt;</span><br><span class=\"line\">\t\t&lt;!--持续集成系统的名字，例如continuum --&gt;</span><br><span class=\"line\">\t\t&lt;system /&gt;</span><br><span class=\"line\">\t\t&lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span><br><span class=\"line\">\t\t&lt;url /&gt;</span><br><span class=\"line\">\t\t&lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span><br><span class=\"line\">\t\t&lt;notifiers&gt;</span><br><span class=\"line\">\t\t\t&lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span><br><span class=\"line\">\t\t\t&lt;notifier&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--传送通知的途径 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;type /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--发生错误时是否通知 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;sendOnError /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--构建失败时是否通知 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;sendOnFailure /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--构建成功时是否通知 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;sendOnSuccess /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--发生警告时是否通知 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;sendOnWarning /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--不赞成使用。通知发送到哪里 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;address /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--扩展配置项 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t&lt;/notifier&gt;</span><br><span class=\"line\">\t\t&lt;/notifiers&gt;</span><br><span class=\"line\">\t&lt;/ciManagement&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span><br><span class=\"line\">\t&lt;inceptionYear /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目相关邮件列表信息 --&gt;</span><br><span class=\"line\">\t&lt;mailingLists&gt;</span><br><span class=\"line\">\t\t&lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span><br><span class=\"line\">\t\t&lt;mailingList&gt;</span><br><span class=\"line\">\t\t\t&lt;!--邮件的名称 --&gt;</span><br><span class=\"line\">\t\t\t&lt;name&gt;Demo&lt;/name&gt;</span><br><span class=\"line\">\t\t\t&lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span><br><span class=\"line\">\t\t\t&lt;post&gt;banseon@126.com&lt;/post&gt;</span><br><span class=\"line\">\t\t\t&lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span><br><span class=\"line\">\t\t\t&lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt;</span><br><span class=\"line\">\t\t\t&lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span><br><span class=\"line\">\t\t\t&lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt;</span><br><span class=\"line\">\t\t\t&lt;!--你可以浏览邮件信息的URL --&gt;</span><br><span class=\"line\">\t\t\t&lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt;</span><br><span class=\"line\">\t\t&lt;/mailingList&gt;</span><br><span class=\"line\">\t&lt;/mailingLists&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目开发者列表 --&gt;</span><br><span class=\"line\">\t&lt;developers&gt;</span><br><span class=\"line\">\t\t&lt;!--某个项目开发者的信息 --&gt;</span><br><span class=\"line\">\t\t&lt;developer&gt;</span><br><span class=\"line\">\t\t\t&lt;!--SCM里项目开发者的唯一标识符 --&gt;</span><br><span class=\"line\">\t\t\t&lt;id&gt;HELLO WORLD&lt;/id&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者的全名 --&gt;</span><br><span class=\"line\">\t\t\t&lt;name&gt;banseon&lt;/name&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者的email --&gt;</span><br><span class=\"line\">\t\t\t&lt;email&gt;banseon@126.com&lt;/email&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者的主页的URL --&gt;</span><br><span class=\"line\">\t\t\t&lt;url /&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span><br><span class=\"line\">\t\t\t&lt;roles&gt;</span><br><span class=\"line\">\t\t\t\t&lt;role&gt;Project Manager&lt;/role&gt;</span><br><span class=\"line\">\t\t\t\t&lt;role&gt;Architect&lt;/role&gt;</span><br><span class=\"line\">\t\t\t&lt;/roles&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者所属组织 --&gt;</span><br><span class=\"line\">\t\t\t&lt;organization&gt;demo&lt;/organization&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者所属组织的URL --&gt;</span><br><span class=\"line\">\t\t\t&lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者属性，如即时消息如何处理等 --&gt;</span><br><span class=\"line\">\t\t\t&lt;properties&gt;</span><br><span class=\"line\">\t\t\t\t&lt;dept&gt;No&lt;/dept&gt;</span><br><span class=\"line\">\t\t\t&lt;/properties&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;timezone&gt;-5&lt;/timezone&gt;</span><br><span class=\"line\">\t\t&lt;/developer&gt;</span><br><span class=\"line\">\t&lt;/developers&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目的其他贡献者列表 --&gt;</span><br><span class=\"line\">\t&lt;contributors&gt;</span><br><span class=\"line\">\t\t&lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;</span><br><span class=\"line\">\t\t&lt;contributor&gt;</span><br><span class=\"line\">\t\t\t&lt;name /&gt;</span><br><span class=\"line\">\t\t\t&lt;email /&gt;</span><br><span class=\"line\">\t\t\t&lt;url /&gt;</span><br><span class=\"line\">\t\t\t&lt;organization /&gt;</span><br><span class=\"line\">\t\t\t&lt;organizationUrl /&gt;</span><br><span class=\"line\">\t\t\t&lt;roles /&gt;</span><br><span class=\"line\">\t\t\t&lt;timezone /&gt;</span><br><span class=\"line\">\t\t\t&lt;properties /&gt;</span><br><span class=\"line\">\t\t&lt;/contributor&gt;</span><br><span class=\"line\">\t&lt;/contributors&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span><br><span class=\"line\">\t&lt;licenses&gt;</span><br><span class=\"line\">\t\t&lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span><br><span class=\"line\">\t\t&lt;license&gt;</span><br><span class=\"line\">\t\t\t&lt;!--license用于法律上的名称 --&gt;</span><br><span class=\"line\">\t\t\t&lt;name&gt;Apache 2&lt;/name&gt;</span><br><span class=\"line\">\t\t\t&lt;!--官方的license正文页面的URL --&gt;</span><br><span class=\"line\">\t\t\t&lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;</span><br><span class=\"line\">\t\t\t&lt;distribution&gt;repo&lt;/distribution&gt;</span><br><span class=\"line\">\t\t\t&lt;!--关于license的补充信息 --&gt;</span><br><span class=\"line\">\t\t\t&lt;comments&gt;A business-friendly OSS license&lt;/comments&gt;</span><br><span class=\"line\">\t\t&lt;/license&gt;</span><br><span class=\"line\">\t&lt;/licenses&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span><br><span class=\"line\">\t&lt;scm&gt;</span><br><span class=\"line\">\t\t&lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span><br><span class=\"line\">\t\t&lt;connection&gt;</span><br><span class=\"line\">\t\t\tscm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)</span><br><span class=\"line\">\t\t&lt;/connection&gt;</span><br><span class=\"line\">\t\t&lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span><br><span class=\"line\">\t\t&lt;developerConnection&gt;</span><br><span class=\"line\">\t\t\tscm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk</span><br><span class=\"line\">\t\t&lt;/developerConnection&gt;</span><br><span class=\"line\">\t\t&lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;</span><br><span class=\"line\">\t\t&lt;tag /&gt;</span><br><span class=\"line\">\t\t&lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span><br><span class=\"line\">\t\t&lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt;</span><br><span class=\"line\">\t&lt;/scm&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span><br><span class=\"line\">\t&lt;organization&gt;</span><br><span class=\"line\">\t\t&lt;!--组织的全名 --&gt;</span><br><span class=\"line\">\t\t&lt;name&gt;demo&lt;/name&gt;</span><br><span class=\"line\">\t\t&lt;!--组织主页的URL --&gt;</span><br><span class=\"line\">\t\t&lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;</span><br><span class=\"line\">\t&lt;/organization&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--构建项目需要的信息 --&gt;</span><br><span class=\"line\">\t&lt;build&gt;</span><br><span class=\"line\">\t\t&lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span><br><span class=\"line\">\t\t&lt;sourceDirectory /&gt;</span><br><span class=\"line\">\t\t&lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span><br><span class=\"line\">\t\t&lt;scriptSourceDirectory /&gt;</span><br><span class=\"line\">\t\t&lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span><br><span class=\"line\">\t\t&lt;testSourceDirectory /&gt;</span><br><span class=\"line\">\t\t&lt;!--被编译过的应用程序class文件存放的目录。 --&gt;</span><br><span class=\"line\">\t\t&lt;outputDirectory /&gt;</span><br><span class=\"line\">\t\t&lt;!--被编译过的测试class文件存放的目录。 --&gt;</span><br><span class=\"line\">\t\t&lt;testOutputDirectory /&gt;</span><br><span class=\"line\">\t\t&lt;!--使用来自该项目的一系列构建扩展 --&gt;</span><br><span class=\"line\">\t\t&lt;extensions&gt;</span><br><span class=\"line\">\t\t\t&lt;!--描述使用到的构建扩展。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;extension&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--构建扩展的groupId --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--构建扩展的artifactId --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--构建扩展的版本 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t\t&lt;/extension&gt;</span><br><span class=\"line\">\t\t&lt;/extensions&gt;</span><br><span class=\"line\">\t\t&lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span><br><span class=\"line\">\t\t&lt;defaultGoal /&gt;</span><br><span class=\"line\">\t\t&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span><br><span class=\"line\">\t\t&lt;resources&gt;</span><br><span class=\"line\">\t\t\t&lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span><br><span class=\"line\">\t\t\t&lt;resource&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例</span><br><span class=\"line\">\t\t\t\t\t子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;targetPath /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;filtering /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;directory /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--包含的模式列表，例如**/*.xml. --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;includes /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--排除的模式列表，例如**/*.xml --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;excludes /&gt;</span><br><span class=\"line\">\t\t\t&lt;/resource&gt;</span><br><span class=\"line\">\t\t&lt;/resources&gt;</span><br><span class=\"line\">\t\t&lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;</span><br><span class=\"line\">\t\t&lt;testResources&gt;</span><br><span class=\"line\">\t\t\t&lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;</span><br><span class=\"line\">\t\t\t&lt;testResource&gt;</span><br><span class=\"line\">\t\t\t\t&lt;targetPath /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;filtering /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;directory /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;includes /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;excludes /&gt;</span><br><span class=\"line\">\t\t\t&lt;/testResource&gt;</span><br><span class=\"line\">\t\t&lt;/testResources&gt;</span><br><span class=\"line\">\t\t&lt;!--构建产生的所有文件存放的目录 --&gt;</span><br><span class=\"line\">\t\t&lt;directory /&gt;</span><br><span class=\"line\">\t\t&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;</span><br><span class=\"line\">\t\t&lt;finalName /&gt;</span><br><span class=\"line\">\t\t&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;</span><br><span class=\"line\">\t\t&lt;filters /&gt;</span><br><span class=\"line\">\t\t&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span><br><span class=\"line\">\t\t&lt;pluginManagement&gt;</span><br><span class=\"line\">\t\t\t&lt;!--使用的插件列表 。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;plugins&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--plugin元素包含描述插件所需要的信息。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--插件在仓库里的group ID --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--插件在仓库里的artifact ID --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--被使用的插件的版本（或版本范围） --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;extensions /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;executions&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;!--execution元素包含了插件执行需要的信息 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;execution&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;phase /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;!--配置的执行目标 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;goals /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;!--配置是否被传播到子POM --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;!--作为DOM对象的配置 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;/execution&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/executions&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--项目引入插件所需要的额外依赖 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;!--参见dependencies/dependency元素 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t......</span><br><span class=\"line\">\t\t\t\t\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--任何配置是否被传播到子项目 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--作为DOM对象的配置 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/plugin&gt;</span><br><span class=\"line\">\t\t\t&lt;/plugins&gt;</span><br><span class=\"line\">\t\t&lt;/pluginManagement&gt;</span><br><span class=\"line\">\t\t&lt;!--使用的插件列表 --&gt;</span><br><span class=\"line\">\t\t&lt;plugins&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;extensions /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;executions&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;execution&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;phase /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;goals /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/execution&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/executions&gt;</span><br><span class=\"line\">\t\t\t\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--参见dependencies/dependency元素 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t\t......</span><br><span class=\"line\">\t\t\t\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/dependencies&gt;</span><br><span class=\"line\">\t\t\t\t&lt;goals /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t&lt;/plugin&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&lt;!-- 以下为插件示例 --&gt;</span><br><span class=\"line\">\t\t\t&lt;!-- 指定maven插件编译版本，使用java8语言，JVM1.8编译，编译时使用UTF-8编码 --&gt;</span><br><span class=\"line\">\t\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t\t&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t\t&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t\t&lt;version&gt;2.3.2&lt;/version&gt;</span><br><span class=\"line\">\t\t\t\t&lt;configuration&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;source&gt;1.8&lt;/source&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;target&gt;1.8&lt;/target&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;encoding&gt;UTF8&lt;/encoding&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t&lt;/configuration&gt;</span><br><span class=\"line\">\t\t\t&lt;/plugin&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&lt;!-- 启动jar插件 --&gt;</span><br><span class=\"line\">\t\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t\t&lt;version&gt;1.4.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">\t\t\t\t&lt;executions&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;execution&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;goals&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;/goals&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;configuration&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;classifier&gt;server&lt;/classifier&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;mainClass&gt;com.xx.xxxx.server.startup.StmsStartup&lt;/mainClass&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;/configuration&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/execution&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/executions&gt;</span><br><span class=\"line\">\t\t\t&lt;/plugin&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;/plugins&gt;</span><br><span class=\"line\">\t&lt;/build&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span><br><span class=\"line\">\t&lt;profiles&gt;</span><br><span class=\"line\">\t\t&lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;</span><br><span class=\"line\">\t\t&lt;profile&gt;</span><br><span class=\"line\">\t\t\t&lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t&lt;!-- 声明变量，当该profile被激活时，可以用$&#123;env&#125;引入值 --&gt;</span><br><span class=\"line\">\t\t\t&lt;properties&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!-- env为key（自定义的），相当于声明变量:env=dev --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;env&gt;dev&lt;/env&gt;</span><br><span class=\"line\">\t\t\t&lt;/properties&gt;</span><br><span class=\"line\">\t\t\t&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;activation&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--profile默认是否激活的标志 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;activeByDefault /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;jdk /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;os&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--激活profile的操作系统的名字 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;name&gt;Windows XP&lt;/name&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--激活profile的操作系统所属家族(如 &#x27;windows&#x27;) --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;family&gt;Windows&lt;/family&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--激活profile的操作系统体系结构 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;arch&gt;x86&lt;/arch&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--激活profile的操作系统版本 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;version&gt;5.1.2600&lt;/version&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/os&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;property&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--激活profile的属性的名称 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;name&gt;mavenVersion&lt;/name&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--激活profile的属性的值 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;value&gt;2.0.3&lt;/value&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/property&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;file&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class=\"line\">\t\t\t\t\t&lt;/exists&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class=\"line\">\t\t\t\t\t&lt;/missing&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/file&gt;</span><br><span class=\"line\">\t\t\t&lt;/activation&gt;</span><br><span class=\"line\">\t\t\t&lt;!--构建项目所需要的信息。参见build元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;build&gt;</span><br><span class=\"line\">\t\t\t\t&lt;defaultGoal /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;resources&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;resource&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;targetPath /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;filtering /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;directory /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;includes /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;excludes /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/resource&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/resources&gt;</span><br><span class=\"line\">\t\t\t\t&lt;testResources&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;testResource&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;targetPath /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;filtering /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;directory /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;includes /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;excludes /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/testResource&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/testResources&gt;</span><br><span class=\"line\">\t\t\t\t&lt;directory /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;finalName /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;filters /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;pluginManagement&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;plugins&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;extensions /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;executions&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;execution&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&lt;phase /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&lt;goals /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;/execution&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;/executions&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;!--参见dependencies/dependency元素 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t......</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;/dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;goals /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;/plugin&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/plugins&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/pluginManagement&gt;</span><br><span class=\"line\">\t\t\t\t&lt;plugins&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;extensions /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;executions&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;execution&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;phase /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;goals /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;/execution&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;/executions&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;!--参见dependencies/dependency元素 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t......</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;/dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;goals /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/plugin&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/plugins&gt;</span><br><span class=\"line\">\t\t\t&lt;/build&gt;</span><br><span class=\"line\">\t\t\t&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span><br><span class=\"line\">\t\t\t&lt;modules /&gt;</span><br><span class=\"line\">\t\t\t&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;repositories&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--参见repositories/repository元素 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;repository&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;releases&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;enabled /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;updatePolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;checksumPolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/releases&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;snapshots&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;enabled /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;updatePolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;checksumPolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/snapshots&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;name /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;url /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;layout /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/repository&gt;</span><br><span class=\"line\">\t\t\t&lt;/repositories&gt;</span><br><span class=\"line\">\t\t\t&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span><br><span class=\"line\">\t\t\t&lt;pluginRepositories&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;pluginRepository&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;releases&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;enabled /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;updatePolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;checksumPolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/releases&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;snapshots&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;enabled /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;updatePolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;checksumPolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/snapshots&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;name /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;url /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;layout /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/pluginRepository&gt;</span><br><span class=\"line\">\t\t\t&lt;/pluginRepositories&gt;</span><br><span class=\"line\">\t\t\t&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--参见dependencies/dependency元素 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t......</span><br><span class=\"line\">\t\t\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;/dependencies&gt;</span><br><span class=\"line\">\t\t\t&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span><br><span class=\"line\">\t\t\t&lt;reports /&gt;</span><br><span class=\"line\">\t\t\t&lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;reporting&gt;</span><br><span class=\"line\">\t\t\t\t......</span><br><span class=\"line\">\t\t\t&lt;/reporting&gt;</span><br><span class=\"line\">\t\t\t&lt;!--参见dependencyManagement元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;dependencyManagement&gt;</span><br><span class=\"line\">\t\t\t\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--参见dependencies/dependency元素 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t\t......</span><br><span class=\"line\">\t\t\t\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/dependencies&gt;</span><br><span class=\"line\">\t\t\t&lt;/dependencyManagement&gt;</span><br><span class=\"line\">\t\t\t&lt;!--参见distributionManagement元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;distributionManagement&gt;</span><br><span class=\"line\">\t\t\t\t......</span><br><span class=\"line\">\t\t\t&lt;/distributionManagement&gt;</span><br><span class=\"line\">\t\t\t&lt;!--参见properties元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;properties /&gt;</span><br><span class=\"line\">\t\t&lt;/profile&gt;</span><br><span class=\"line\">\t&lt;/profiles&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span><br><span class=\"line\">\t&lt;modules&gt;&lt;/modules&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span><br><span class=\"line\">\t&lt;repositories&gt;</span><br><span class=\"line\">\t\t&lt;!--包含需要连接到远程仓库的信息 --&gt;</span><br><span class=\"line\">\t\t&lt;repository&gt;</span><br><span class=\"line\">\t\t\t&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span><br><span class=\"line\">\t\t\t&lt;releases&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;enabled /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;updatePolicy /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;checksumPolicy /&gt;</span><br><span class=\"line\">\t\t\t&lt;/releases&gt;</span><br><span class=\"line\">\t\t\t&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的</span><br><span class=\"line\">\t\t\t\t策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;snapshots&gt;</span><br><span class=\"line\">\t\t\t\t&lt;enabled /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;updatePolicy /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;checksumPolicy /&gt;</span><br><span class=\"line\">\t\t\t&lt;/snapshots&gt;</span><br><span class=\"line\">\t\t\t&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span><br><span class=\"line\">\t\t\t&lt;id&gt;banseon-repository-proxy&lt;/id&gt;</span><br><span class=\"line\">\t\t\t&lt;!--远程仓库名称 --&gt;</span><br><span class=\"line\">\t\t\t&lt;name&gt;banseon-repository-proxy&lt;/name&gt;</span><br><span class=\"line\">\t\t\t&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span><br><span class=\"line\">\t\t\t&lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt;</span><br><span class=\"line\">\t\t\t&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然</span><br><span class=\"line\">\t\t\t\t而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;layout&gt;default&lt;/layout&gt;</span><br><span class=\"line\">\t\t&lt;/repository&gt;</span><br><span class=\"line\">\t&lt;/repositories&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span><br><span class=\"line\">\t&lt;pluginRepositories&gt;</span><br><span class=\"line\">\t\t&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span><br><span class=\"line\">\t\t&lt;pluginRepository&gt;</span><br><span class=\"line\">\t\t\t......</span><br><span class=\"line\">\t\t&lt;/pluginRepository&gt;</span><br><span class=\"line\">\t&lt;/pluginRepositories&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span><br><span class=\"line\">\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;!--依赖的group ID --&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;org.apache.maven&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;!--依赖的artifact ID --&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;maven-artifact&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class=\"line\">\t\t\t&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应，</span><br><span class=\"line\">\t\t\t\t尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;type&gt;jar&lt;/type&gt;</span><br><span class=\"line\">\t\t\t&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成</span><br><span class=\"line\">\t\t\t\tJAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;classifier&gt;&lt;/classifier&gt;</span><br><span class=\"line\">\t\t\t&lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath</span><br><span class=\"line\">\t\t\t\t- runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得</span><br><span class=\"line\">\t\t\t\t- systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span><br><span class=\"line\">\t\t\t&lt;scope&gt;test&lt;/scope&gt;</span><br><span class=\"line\">\t\t\t&lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;systemPath&gt;&lt;/systemPath&gt;</span><br><span class=\"line\">\t\t\t&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span><br><span class=\"line\">\t\t\t&lt;exclusions&gt;</span><br><span class=\"line\">\t\t\t\t&lt;exclusion&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/exclusion&gt;</span><br><span class=\"line\">\t\t\t&lt;/exclusions&gt;</span><br><span class=\"line\">\t\t\t&lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;optional&gt;true&lt;/optional&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t&lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span><br><span class=\"line\">\t&lt;reports&gt;&lt;/reports&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;</span><br><span class=\"line\">\t&lt;reporting&gt;</span><br><span class=\"line\">\t\t&lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt;</span><br><span class=\"line\">\t\t&lt;excludeDefaults /&gt;</span><br><span class=\"line\">\t\t&lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt;</span><br><span class=\"line\">\t\t&lt;outputDirectory /&gt;</span><br><span class=\"line\">\t\t&lt;!--使用的报表插件和他们的配置。 --&gt;</span><br><span class=\"line\">\t\t&lt;plugins&gt;</span><br><span class=\"line\">\t\t\t&lt;!--plugin元素包含描述报表插件需要的信息 --&gt;</span><br><span class=\"line\">\t\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--报表插件在仓库里的group ID --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--报表插件在仓库里的artifact ID --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--被使用的报表插件的版本（或版本范围） --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--任何配置是否被传播到子项目 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--报表插件的配置 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;reportSets&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;reportSet&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;!--产生报表集合时，被使用的报表的配置 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;!--配置是否被继承到子POMs --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;!--这个集合里使用到哪些报表 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;reports /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/reportSet&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/reportSets&gt;</span><br><span class=\"line\">\t\t\t&lt;/plugin&gt;</span><br><span class=\"line\">\t\t&lt;/plugins&gt;</span><br><span class=\"line\">\t&lt;/reporting&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact</span><br><span class=\"line\">\t\tID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span><br><span class=\"line\">\t&lt;dependencyManagement&gt;</span><br><span class=\"line\">\t\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t\t&lt;!--参见dependencies/dependency元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t......</span><br><span class=\"line\">\t\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;/dependencies&gt;</span><br><span class=\"line\">\t&lt;/dependencyManagement&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span><br><span class=\"line\">\t&lt;distributionManagement&gt;</span><br><span class=\"line\">\t\t&lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;</span><br><span class=\"line\">\t\t&lt;repository&gt;</span><br><span class=\"line\">\t\t\t&lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;uniqueVersion /&gt;</span><br><span class=\"line\">\t\t\t&lt;id&gt;banseon-maven2&lt;/id&gt;</span><br><span class=\"line\">\t\t\t&lt;name&gt;banseon maven2&lt;/name&gt;</span><br><span class=\"line\">\t\t\t&lt;url&gt;file://$&#123;basedir&#125;/target/deploy&lt;/url&gt;</span><br><span class=\"line\">\t\t\t&lt;layout /&gt;</span><br><span class=\"line\">\t\t&lt;/repository&gt;</span><br><span class=\"line\">\t\t&lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;</span><br><span class=\"line\">\t\t&lt;snapshotRepository&gt;</span><br><span class=\"line\">\t\t\t&lt;uniqueVersion /&gt;</span><br><span class=\"line\">\t\t\t&lt;id&gt;banseon-maven2&lt;/id&gt;</span><br><span class=\"line\">\t\t\t&lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt;</span><br><span class=\"line\">\t\t\t&lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt;</span><br><span class=\"line\">\t\t\t&lt;layout /&gt;</span><br><span class=\"line\">\t\t&lt;/snapshotRepository&gt;</span><br><span class=\"line\">\t\t&lt;!--部署项目的网站需要的信息 --&gt;</span><br><span class=\"line\">\t\t&lt;site&gt;</span><br><span class=\"line\">\t\t\t&lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span><br><span class=\"line\">\t\t\t&lt;id&gt;banseon-site&lt;/id&gt;</span><br><span class=\"line\">\t\t\t&lt;!--部署位置的名称 --&gt;</span><br><span class=\"line\">\t\t\t&lt;name&gt;business api website&lt;/name&gt;</span><br><span class=\"line\">\t\t\t&lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;</span><br><span class=\"line\">\t\t\t&lt;url&gt;</span><br><span class=\"line\">\t\t\t\tscp://svn.baidu.com/banseon:/var/www/localhost/banseon-web</span><br><span class=\"line\">\t\t\t&lt;/url&gt;</span><br><span class=\"line\">\t\t&lt;/site&gt;</span><br><span class=\"line\">\t\t&lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span><br><span class=\"line\">\t\t&lt;downloadUrl /&gt;</span><br><span class=\"line\">\t\t&lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span><br><span class=\"line\">\t\t&lt;relocation&gt;</span><br><span class=\"line\">\t\t\t&lt;!--构件新的group ID --&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t\t&lt;!--构件新的artifact ID --&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t\t&lt;!--构件新的版本号 --&gt;</span><br><span class=\"line\">\t\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t\t&lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;message /&gt;</span><br><span class=\"line\">\t\t&lt;/relocation&gt;</span><br><span class=\"line\">\t\t&lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从</span><br><span class=\"line\">\t\t\tMaven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt;</span><br><span class=\"line\">\t\t&lt;status /&gt;</span><br><span class=\"line\">\t&lt;/distributionManagement&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;</span><br><span class=\"line\">\t&lt;properties&gt;&lt;/properties&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/project&gt;  </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://maven.apache.org/index.html\">Maven 官方文档</a><br><a href=\"https://www.cnblogs.com/hongwz/p/5456578.html\">Maven 详解</a><br><a href=\"http://www.cnblogs.com/now-fighting/p/4858982.html\">Maven学习-目录结构</a><br><a href=\"https://blog.csdn.net/wdx1121/article/details/79664385\">Maven 的 pom 文件详细解析</a><br><a href=\"https://blog.csdn.net/tanga842428/article/details/54574590\">Maven 中 pom 文件详解</a><br><a href=\"https://blog.csdn.net/HaosCoder/article/details/79524629\">maven常用插件解析</a></p>\n","categories":["工具","Maven"],"tags":["Maven"]},{"title":"Hexo博客SEO优化","url":"/2018/06/29/Hexo%E5%8D%9A%E5%AE%A2SEO%E4%BC%98%E5%8C%96/","content":"<blockquote>\n<p>SEO（Search Engine Optimization）即搜索引擎优化，利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名，即让搜索引擎更加容易搜索到我们的网站且结果更加靠前。当我们在网上搭建好自己的博客之后，百度、谷歌等搜索引擎并不能立即搜索到我们的博客。我们需要做一些工作来让搜索引擎更加容易搜到我们的博客。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>为了让搜索引擎更加容易搜索到我们的博客，我们需要做的工作有：</p>\n<ol>\n<li>在搜索引擎收录入口添加我们的网站（同时添加带 www 前缀的和不带 www 前缀的）</li>\n<li>向搜索引擎推送我们的网站，谷歌可以推送 sitemap 文档，百度有主动推送、自动推送和 sitemap 文档等多种方式。</li>\n<li>等待搜索引擎的收录。</li>\n</ol>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p><a href=\"https://www.cnblogs.com/tengj/p/5357879.html\">hexo干货系列：（六）hexo提交搜索引擎（百度+谷歌</a> 这篇文章已经介绍得很详细，在这里只做部分补充。</p>\n<h3 id=\"通过-CNAME-方式验证网站\"><a href=\"#通过-CNAME-方式验证网站\" class=\"headerlink\" title=\"通过 CNAME 方式验证网站\"></a>通过 CNAME 方式验证网站</h3><p>上面的教程中是通过在网站根目录里面添加验证文件的方式来验证网站持有者的身份，如果你拥有独立的域名，通过 CNAME 的方法来验证会更加方便。</p>\n<h4 id=\"1、添加网站\"><a href=\"#1、添加网站\" class=\"headerlink\" title=\"1、添加网站\"></a>1、添加网站</h4><p><a href=\"https://ziyuan.baidu.com/site/index\">百度添加网站入口</a><br><a href=\"https://www.google.com/webmasters/tools/home\">谷歌添加网站入口</a></p>\n<p>添加你的域名地址，<em>注意：最好每个搜索引擎都添加带 www 前缀和不带 www 前缀的两条记录</em>，百度需要添加一些介绍信息之类，最后到验证网站所有权。</p>\n<h4 id=\"2、验证网站\"><a href=\"#2、验证网站\" class=\"headerlink\" title=\"2、验证网站\"></a>2、验证网站</h4><p>谷歌：<strong>备用方法</strong> &gt; <strong>域名提供商</strong> &gt; <strong>添加 CNAME 记录</strong></p>\n<p><img src=\"/2018/06/29/Hexo%E5%8D%9A%E5%AE%A2SEO%E4%BC%98%E5%8C%96/cname1.jpeg\" alt=\"cname1\"></p>\n<p>百度：<strong>CNAME 验证</strong></p>\n<p><img src=\"/2018/06/29/Hexo%E5%8D%9A%E5%AE%A2SEO%E4%BC%98%E5%8C%96/cname2.jpeg\" alt=\"cname2\"></p>\n<p>选择 CNAME 验证会得到两个网址 <code>xxx.你的域名</code> 和 搜索引擎验证网址（百度：<code>ziyuan.baidu.com</code> &#x2F; 谷歌：<code>xxx.dv.googlehosted.com</code>），这两个网址下面需要用到。</p>\n<h4 id=\"3、域名解析添加-CNAME-记录\"><a href=\"#3、域名解析添加-CNAME-记录\" class=\"headerlink\" title=\"3、域名解析添加 CNAME 记录\"></a>3、域名解析添加 CNAME 记录</h4><p>以万网为例，进入 <a href=\"https://dc.console.aliyun.com/next/index#/domain/list/all-domain\">域名列表</a>，点击 <strong>解析</strong> &gt; <strong>添加记录</strong>，记录类型选择 <code>CNAME</code>，主机记录前缀填写上面 <code>xxx.你的域名</code> 中的 <code>xxx</code> 前缀，解析线路默认即可，记录值填写搜索引擎验证网址，以添加谷歌验证为例：</p>\n<div style='width: 70%'>![cname3](cname3.jpeg)</div>\n#### 4、完成\n返回刚才搜索引擎的站点管理网址，点击 **验证**，验证成功，如果失败过一段时间再来点击验证。\n\n<h3 id=\"生成站点地图文件补充\"><a href=\"#生成站点地图文件补充\" class=\"headerlink\" title=\"生成站点地图文件补充\"></a>生成站点地图文件补充</h3><p>按照上面教程成功生成 sitemap.xml 和baidusitemap.xml 文件之后，这两个文件里面的域名默认为 <code>http://yoursite.com</code>，这个域名并不会自动转换成你的域名地址，直接提交给搜索引擎解析会报错，因此需要手动改成我们的域名地址，详细参考 <a href=\"https://blog.csdn.net/qiuchengjia/article/details/52923170\">hexo做SEO（添加sitemap和baidusitemap）</a></p>\n<h3 id=\"百度收录失败问题\"><a href=\"#百度收录失败问题\" class=\"headerlink\" title=\"百度收录失败问题\"></a>百度收录失败问题</h3><p>谷歌收录按照步骤完成之后一般都能正确收录，而且收录速度也很快。但是百度收录就比较难。<strong>注意：如果你的网站是搭建在 GitHub 上面，就不能被百度收录</strong>。</p>\n<blockquote>\n<p>百度爬取 GitHub 太频繁了，甚至引起了 GitHub 的服务不稳定，最后 GitHub 直接把百度屏蔽了，百度爬虫访问直接报 403 错误。也就是说，所有托管到 GitHub Pages 上的静态博客都是无法被百度搜索到。</p>\n</blockquote>\n<p>如果你希望你的博客能被百度收录，可以参考 <a href=\"http://guochenglai.com/2016/09/26/baidu-crow-github-page/\">百度无法爬取Github Pages静态网站解决方案</a></p>\n","categories":["工具","Hexo"],"tags":["Hexo","SEO"]},{"title":"Hadoop入门及安装","url":"/2018/07/01/Hadoop%E5%85%A5%E9%97%A8%E5%8F%8A%E5%AE%89%E8%A3%85/","content":"<blockquote>\n<p>当我们需要从 TB 甚至 PB 级别以上的数据中分析获取我们需要的信息时，如果使用传统的系统架构进行处理速度将会非常慢并且对服务器造成巨大压力。Hadoop 就是用来存储并处理这种巨大数据量的分布式架构平台。用户在该平台上可以在不需要了解底层实现细节的情况下开发高效处理大数据的程序。下面介绍 Hadoop 的一些入门知识和安装配置。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"入门知识\"><a href=\"#入门知识\" class=\"headerlink\" title=\"入门知识\"></a>入门知识</h2><h3 id=\"Hadoop-是什么\"><a href=\"#Hadoop-是什么\" class=\"headerlink\" title=\"Hadoop 是什么\"></a>Hadoop 是什么</h3><p>Hadoop 是一个用来处理大数据的分布式存储和计算平台。简单来说这个平台最重要的两个作用是 <strong>存储</strong> 和 <strong>计算</strong>：</p>\n<ul>\n<li>存储：分布式存储，数据被分散到多台机器上存储，由至少一台机器进行分配管理。该过程对开发人员是透明，也就是说开发人员对数据的存取过程感受不到数据是分散存储的。</li>\n<li>计算：分布式计算，用户请求被分解成多个任务在多台机器上运行，运行结果集汇总成最终结果再返回给用户。该过程对开发人员同样是透明的。</li>\n</ul>\n<p>基于以上分布式的特点 Hadoop 可以在大量廉价的机器上搭建一个分布式集群系统架构。开发人员只要先把巨大数据存储在 Hadoop 平台上，然后根据统计分析需求编写简单的处理程序。<em>Hadoop 平台会自动把数据进行分割存储，把处理程序分解映射成多个任务分配到多台机器上进行并行计算，然后把结果集汇总返回给用户</em>。</p>\n<h3 id=\"Hadoop-生态系统\"><a href=\"#Hadoop-生态系统\" class=\"headerlink\" title=\"Hadoop 生态系统\"></a>Hadoop 生态系统</h3><p>Hadoop 平台和基于该平台的相关模块框架形成一套完善的 <strong>Hadoop生态系统</strong>。该生态系统包含的组件大概如下：</p>\n<p><img src=\"/2018/07/01/Hadoop%E5%85%A5%E9%97%A8%E5%8F%8A%E5%AE%89%E8%A3%85/shengtai.png\" alt=\"shengtai\"></p>\n<p>在该系统中最核心的两大组件是 <strong>HDFS</strong> 和 <strong>MapReduce</strong>，这两个组件是 Hadoop 平台最早推出的体现分布式处理数据思想的组件。此外还有 <strong>YARN</strong> 资源组件。</p>\n<ul>\n<li><strong>HDFS</strong>：Hadoop Distributed File System，分布式文件存储系统。该系统把数据分割成多个部分分别存储到多台机器 (DataNode) 上，然后由一台机器 (NameNode) 进行统一组织管理。该系统只是用来管理数据的存储方式，并不存储数据。详细可参考 <a href=\"http://www.cnblogs.com/edisonchou/p/3485135.html\">基本介绍</a></li>\n</ul>\n<blockquote>\n<p>HDFS 架构采用主从架构（master&#x2F;slave）。一个典型的 HDFS 集群包含一个 NameNode 节点和多个 DataNode 节点。NameNode 节点负责整个 HDFS 文件系统中的文件的元数据保管和管理，集群中通常只有一台机器上运行 NameNode 实例，DataNode 节点保存文件中的数据，集群中的机器分别运行一个 DataNode 实例。在 HDFS 中，NameNode 节点被称为名称节点，DataNode 节点被称为数据节点。DataNode 节点通过心跳机制与 NameNode 节点进行定时的通信。</p>\n</blockquote>\n<ul>\n<li><strong>MapReduce</strong>：一种用于大规模数据集并行计算的编程模型，包含两项重要函数：Map 和 Reduce。简单来说就是先通过 Map 计算把任务分发到集群多个节点上，并行计算，然后再通过 Reduce 计算把计算结果合并，从而得到最终计算结果。详细可参考 <a href=\"http://www.cnblogs.com/edisonchou/p/3485135.html\">基本介绍</a> 和 <a href=\"https://blog.csdn.net/q739404976/article/details/73188645\">MapReduce详解</a></li>\n</ul>\n<blockquote>\n<p>MapReduce由以下四个部分组成：</p>\n<ol>\n<li>Client：面向用户的接口。</li>\n</ol>\n<ul>\n<li>用户编写的 MapReduce 程序通过 Client 提交到 JobTracker 端</li>\n<li>用户可通过 Client 提供的一些接口查看作业运行状态</li>\n</ul>\n<ol start=\"2\">\n<li>JobTracker：负责所有节点的资源监控和作业调度。主节点只有一个 JobTracker。</li>\n</ol>\n<ul>\n<li>监控所有 TaskTracker 与 Job 的健康状况，一旦发现失败，就将相应的任务转移到其他节点。</li>\n<li>跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器（TaskScheduler），而调度器会在资源出现空闲时，选择合适的任务去使用这些资源。</li>\n</ul>\n<ol start=\"3\">\n<li>TaskTracker：负责本节点的资源监控和作业调度。从节点有多个 TaskTracker。</li>\n</ol>\n<ul>\n<li>TaskTracker 会周期性地通过“心跳”将本节点上资源的使用情况和任务的运行进度汇报给 JobTracker，同时接收 JobTracker 发送过来的命令并执行相应的操作（如启动新任务、杀死任务等）</li>\n<li>TaskTracker 使用 slot等量划分本节点上的资源量（CPU、内存等）。一个 Task 获取到一个 slot 后才有机会运行，而 Hadoop 调度器的作用就是将各个 TaskTracker 上的空闲 slot 分配给 Task 使用。slot 分为 Map slot 和 Reduce slot 两种，分别供 MapTask 和 Reduce Task 使用</li>\n</ul>\n<ol start=\"4\">\n<li>Task：分为 Map Task 和 Reduce Task 两种，均由 TaskTracker 启动</li>\n</ol>\n</blockquote>\n<ul>\n<li><p><strong>YARN</strong>：一个通用的资源管理系统，可为各类计算框架提供资源的管理和调度。它的基本设计思想是将 MRv1 中的 JobTracker 拆分成了两个独立的服务：一个全局的资源管理器 ResourceManager 和每个应用程序特有的 ApplicationMaster。其中 ResourceManager 负责整个系统的资源管理和分配，而 ApplicationMaster 负责单个应用程序的管理。详细可参考 <a href=\"https://www.cnblogs.com/chushiyaoyue/p/5784871.html\">Hadoop-Yarn-框架原理及运作机制（原理篇）</a> 和 <a href=\"https://blog.csdn.net/bingduanlbd/article/details/51880019\">理解Hadoop YARN架构</a></p>\n</li>\n<li><p><strong>Hbase</strong>：一个开源的非关系型分布式数据库，可以通过廉价的机器构建集群来处理庞大的数据表，例如超过10亿行数据和数百万列元素组成的数据表。</p>\n<blockquote>\n<p>HDFS 缺乏随机读写操作，HBase 可以用来弥补这种缺陷，其提供可以实时访问一些数据的随机读写功能。HBase 以 Google BigTable 为蓝本，以键值对的形式存储。项目的目标就是快速在主机内数十亿行数据中定位所需的数据并访问它。<br>你可以用 Hadoop 作为静态数据仓库，HBase 作为数据存储，可以放一些需要实时访问和操作的数据。</p>\n</blockquote>\n</li>\n<li><p><strong>Hive</strong>：一个数据仓库工具。可以把用户的 HiveQL（类 SQL）语句自动转换成 MapReduce 任务，这样用户就不用理解 MapReduce API 的接口内容和编写复杂的 MapReduce 程序，只需要编写简单的类 SQL 语句就可以进行数据分析。</p>\n</li>\n<li><p><strong>Pig</strong>：一种数据流语言，用来快速轻松的处理巨大的数据。包含 Pig Interface 和 Pig Latin 两部分。Pig可以非常方便的处理 HDFS 和 HBase 的数据，和 Hive 类似，通过编写简单的 Pig 脚本就可以自动转换成 MapReduce 作业来处理数据。当你想做一些数据处理但又不想编写 MapReduce jobs 就可以用 Pig。</p>\n<blockquote>\n<p>Hive 和 Pig 的区别：</p>\n<ul>\n<li>Hive 更适合于数据仓库的任务，Hive 主要用于静态的结构以及需要经常分析的工作。Hive 与 SQL 相似促使 其成为 Hadoop 与其他 BI 工具结合的理想交集。  </li>\n<li>Pig 赋予开发人员在大数据集领域更多的灵活性，并允许开发简洁的脚本用于转换数据流以便嵌入到较大的应用程序。  </li>\n<li>Pig 相比 Hive 相对轻量，它主要的优势是相比于直接使用Hadoop Java APIs可大幅削减代码量。正因为如此，Pig 仍然是吸引大量的软件开发人员。  </li>\n<li>Hive 和 Pig 都可以与HBase组合使用，Hive 和 Pig 还为 HBase 提供了高层语言支持，使得在 HBase 上进行数据统计处理变的非常简单</li>\n</ul>\n</blockquote>\n</li>\n<li><p><strong>Mahout</strong>：Hadoop 平台上的数据挖掘算法库</p>\n</li>\n<li><p><strong>Zookeeper</strong>：一种分布式的应用程序协调服务。随着计算节点的增多，集群成员需要彼此同步并了解去哪里访问服务和如何配置，ZooKeeper正是为此而生的。</p>\n</li>\n<li><p><strong>Sqoop</strong>：Sqoop 一种数据同步和传输工具，主要用于在 Hadoop(Hive) 与传统的数据库 (mysql、postgresql…) 间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL, Oracle, Postgres等）中的数据导进到 Hadoop 的 HDFS 中，也可以将 HDFS 的数据导进到关系型数据库中。</p>\n</li>\n<li><p><strong>Flume</strong>：一种日志收集工具</p>\n</li>\n<li><p><strong>Ambari</strong>：一个集群的安装和管理工具</p>\n</li>\n</ul>\n<h2 id=\"Hadoop-安装\"><a href=\"#Hadoop-安装\" class=\"headerlink\" title=\"Hadoop 安装\"></a>Hadoop 安装</h2><p>以下配置环境</p>\n<ul>\n<li>Mac OS X 10.13.2</li>\n<li>Java 1.8.0_131</li>\n<li>Hadoop 2.8.4</li>\n</ul>\n<h3 id=\"1、Java-环境\"><a href=\"#1、Java-环境\" class=\"headerlink\" title=\"1、Java 环境\"></a>1、Java 环境</h3><p>在终端输入下面命令进行查看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ java -version</span><br></pre></td></tr></table></figure>\n\n<p>如果没有报错表示 Java 环境配置成功，否则请自行安装 Java<br>环境，在这里不做详细介绍</p>\n<h3 id=\"2、SSH-配置\"><a href=\"#2、SSH-配置\" class=\"headerlink\" title=\"2、SSH 配置\"></a>2、SSH 配置</h3><p>在终端输入下面命令进行查看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh localhost</span><br></pre></td></tr></table></figure>\n\n<p>如果没有报错直接显示登录时间则已经配置成功，一般来说可能会有下面两种异常情况。</p>\n<h4 id=\"用户没有权限\"><a href=\"#用户没有权限\" class=\"headerlink\" title=\"用户没有权限\"></a>用户没有权限</h4><p>进入 <strong>系统偏好设置</strong> &gt; <strong>共享</strong> &gt; <strong>勾选远程登录</strong>，并设置允许访问：所有用户。</p>\n<div style='width: 60%'>![ssh](ssh.jpeg)</div>\n#### 还没生成 ssh 密钥\n可以选择 rsa 或者 dsa 协议来生成，以 rsa 协议为例\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>\n\n<p>一路回车后会在 ~&#x2F;.ssh 目录下生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件，然后执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat ~/.ssh/id_rsa.pub &gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、下载-Hadoop\"><a href=\"#3、下载-Hadoop\" class=\"headerlink\" title=\"3、下载 Hadoop\"></a>3、下载 Hadoop</h3><p>点击 <a href=\"http://hadoop.apache.org/releases.html\">Hadoop 官方下载地址</a>，选择所需版本的 <code>binary</code> 包进行下载（<code>source</code> 包是源代码，<code>binary</code> 包是编译后的文件，一般来说我们直接使用后者即可）。以 2.8.4 版本为例，点击下载后进行解压。我的解压后安装路径为 <code>/Users/mochuangbiao/hadoop-2.8.4</code></p>\n<div style='width: 80%'>![xiazai](xiazai.jpeg)</div>\n### 4、配置 Hadoop\n\n<h4 id=\"配置-Java-环境\"><a href=\"#配置-Java-环境\" class=\"headerlink\" title=\"配置 Java 环境\"></a>配置 Java 环境</h4><p>如果还没有配置 Java 环境，查看 JDK 安装目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ /usr/libexec/java_home -V</span><br></pre></td></tr></table></figure>\n\n<p>添加该目录到环境配置文件 <code>~/.bash_profile</code> 中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置-Hadoop-环境\"><a href=\"#配置-Hadoop-环境\" class=\"headerlink\" title=\"配置 Hadoop 环境\"></a>配置 Hadoop 环境</h4><p>添加你的 Hadoop 安装目录路径到环境配置文件 <code>~/.bash_profile</code> 中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export HADOOP_HOME=/Users/mochuangbiao/hadoop-2.8.4</span><br><span class=\"line\">export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>修改 <code>~/.bash_profile</code> 文件后记得执行 <code>$ source ~/.bash_profile</code> 使其生效</p>\n</blockquote>\n<h4 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h4><p>需要修改的配置文件一共有四个：<strong>core-site.xml</strong>、<strong>hdfs-site.xml</strong>、<strong>mapred-site.xml</strong> 和 <strong>yarn-site.xml</strong>，所有文件均位于 <code>etc/hadoop</code> 目录下。文件的修改均为最简单化，如需要详细配置请参考官方文档。</p>\n<ul>\n<li>core-site.xml</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">   &lt;property&gt;</span><br><span class=\"line\">       &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class=\"line\">       &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class=\"line\">   &lt;/property&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>hdfs-site.xml</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">   &lt;property&gt;</span><br><span class=\"line\">       &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class=\"line\">       &lt;value&gt;1&lt;/value&gt;</span><br><span class=\"line\">   &lt;/property&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>mapred-site.xml</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">   &lt;property&gt;</span><br><span class=\"line\">       &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class=\"line\">       &lt;value&gt;yarn&lt;/value&gt;</span><br><span class=\"line\">   &lt;/property&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>yarn-site.xml <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">   &lt;property&gt;</span><br><span class=\"line\">       &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class=\"line\">       &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class=\"line\">   &lt;/property&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"5、启动\"><a href=\"#5、启动\" class=\"headerlink\" title=\"5、启动\"></a>5、启动</h3><h4 id=\"格式化-HDFS\"><a href=\"#格式化-HDFS\" class=\"headerlink\" title=\"格式化 HDFS\"></a>格式化 HDFS</h4><p>切换到 Hadoop 安装目录，输入命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hdfs namenode -format</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"启动-HDFS\"><a href=\"#启动-HDFS\" class=\"headerlink\" title=\"启动 HDFS\"></a>启动 HDFS</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ start-dfs.sh</span><br></pre></td></tr></table></figure>\n\n<p>可能需要输入三次密码，分别用来启动 NameNode、DataNode 和 SecondaryNameNode 三个线程，访问 <a href=\"http://localhost:50070/\">http://localhost:50070</a>，能看到以下界面表示启动成功</p>\n<p><img src=\"/2018/07/01/Hadoop%E5%85%A5%E9%97%A8%E5%8F%8A%E5%AE%89%E8%A3%85/hdfs.jpeg\" alt=\"hdfs\"></p>\n<h4 id=\"启动-YARN\"><a href=\"#启动-YARN\" class=\"headerlink\" title=\"启动 YARN\"></a>启动 YARN</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ start-yarn.sh</span><br></pre></td></tr></table></figure>\n\n<p>可能需要输入一次到多次密码用来启动 ResourceManager 线程和 Nodemanager 线程，访问 <a href=\"http://localhost:8088/\">http://localhost:8088</a>，能看到以下界面表示启动成功</p>\n<p><img src=\"/2018/07/01/Hadoop%E5%85%A5%E9%97%A8%E5%8F%8A%E5%AE%89%E8%A3%85/yarn.jpeg\" alt=\"yarn\"></p>\n<p>输入命令 <code>$ jps</code>，可以查看到以下节点信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">12963 DataNode</span><br><span class=\"line\">13076 SecondaryNameNode</span><br><span class=\"line\">12651 ResourceManager</span><br><span class=\"line\">12876 NameNode</span><br><span class=\"line\">20844 Jps</span><br><span class=\"line\">12748 NodeManager</span><br><span class=\"line\">19885 Launcher</span><br><span class=\"line\">19886 B2BApplication</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"停止\"><a href=\"#停止\" class=\"headerlink\" title=\"停止\"></a>停止</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ stop-yarn.sh</span><br><span class=\"line\">$ stop-dfs.sh</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hadoop-常用-Shell-命令\"><a href=\"#Hadoop-常用-Shell-命令\" class=\"headerlink\" title=\"Hadoop 常用 Shell 命令\"></a>Hadoop 常用 Shell 命令</h2><p>调用 Hadoop Shell 命令在可使用 <code>$ hadoop fs &lt;args&gt;</code> 的形式（使用面最广，可以操作任何文件系统）或 <code>$ hdfs dfs &lt;args&gt;</code> 的形式（只能操作HDFS文件系统相关），区别可见 <a href=\"https://blog.csdn.net/jediael_lu/article/details/37649609\">何时使用hadoop fs、hadoop dfs与hdfs dfs命令</a>。常用 <code>&lt;args&gt;</code> 参数有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-ls #表示对hdfs下一级目录的查看 </span><br><span class=\"line\">-lsr #表示对hdfs目录的递归查看 </span><br><span class=\"line\">-mkdir #创建目录 </span><br><span class=\"line\">-put #从linux上传文件到hdfs </span><br><span class=\"line\">-get #从hdfs下载文件到linux </span><br><span class=\"line\">-text #查看文件内容 </span><br><span class=\"line\">-rm #表示删除文件 </span><br><span class=\"line\">-rmr #表示递归删除文件</span><br></pre></td></tr></table></figure>\n\n<p>详细的可参考 <a href=\"http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html\">Hadoop Shell 命令</a></p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>通过 HDFS 创建的目录和存储的文件以特殊的编码方式存放在机器上，不能在文件夹界面直接查看这些文件和目录，只能通过 Shell 命令来查看和操作这些文件</li>\n<li>HDFS的根目录是 <code>/</code>，这个是在 HDFS 系统上的目录，与系统目录无关。默认的工作目录是 <code>/user/$USER</code>，<code>USER</code> 是你的登录用户名。使用命令 <code>$ hdfs dfs -ls</code> 会直接显示工作目录 <code>/user/$USER</code> 下的内容</li>\n<li>使用 <code>-mkdir</code> 参数创建目录的时候，如果父目录不存在会报 <code>No such file or directory</code> 的错误。可以加上 <code>-p</code> 参数，如 <code>hdfs dfs -mkdir -p /user/Hadoop/twitter_data</code>，当路径中的某个目录不存在时会自动创建。</li>\n</ul>\n<h2 id=\"Hadoop-样例\"><a href=\"#Hadoop-样例\" class=\"headerlink\" title=\"Hadoop 样例\"></a>Hadoop 样例</h2><p>在这里使用 Hadoop 的 exmaple jar 包进行样例测试，该 jar 包的 wordCount 功能可用来统计一系列文本文件中每个单词出现的次数。该 jar 包的存放路径为 <code>/Users/mochuangbiao/hadoop-2.8.4/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.4.jar</code></p>\n<ol>\n<li>准备样本数据。在网上下载一些英文内容保存为 txt 格式，保存路径为 <code>/Users/mochuangbiao/test</code>。</li>\n<li>创建目录。执行命令 <code>$ hdfs dfs -mkdir input</code>，在默认工作目录下创建 <code>input</code> 目录，该目录路径为 <code>/user/mochuangbiao/input</code>。</li>\n<li>上传文件到 hdfs 系统。执行 <code>$ hdfs dfs -put /Users/mochuangbiao/test/*.txt input</code>，上传刚才的 txt 文件到 <code>input</code> 目录。</li>\n<li>运行样例。执行 <code>$ hdfs dfs /Users/mochuangbiao/hadoop-2.8.4/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.4.jar wordcount input output</code>。调用 example jar 包里面的 wordcount 统计 <code>input</code> 目录里面的文档，统计结果自动输出到 <code>output</code> 文件夹。</li>\n<li>查看结果。执行 <code>$ hdfs dfs -ls output</code>，一般里面会有一个类似于 <code>part-r-00000</code> 的文件，执行 <code>hdfs dfs -cat output/part-r-00000</code> 查看结果。</li>\n</ol>\n<p>详细可参考 <a href=\"https://www.cnblogs.com/CherishFX/p/4239959.html\">Hadoop例子——运行example中的wordCount例子</a></p>\n<h2 id=\"其他参考\"><a href=\"#其他参考\" class=\"headerlink\" title=\"其他参考\"></a>其他参考</h2><p><a href=\"https://www.jianshu.com/p/34ec406eb40d\">大数据学习 第一篇——基础知识</a><br><a href=\"https://www.csdn.net/article/a/2016-07-28/3775\">Hadoop大数据生态系统及常用组件简介\n</a><br><a href=\"https://blog.csdn.net/dashujuedu/article/details/53538609\">数据分析：Hive、Pig和Impala</a><br><a href=\"http://zhongyaonan.com/hadoop-tutorial/setting-up-hadoop-2-6-on-mac-osx-yosemite.html\">Setting up Hadoop 2.6 on Mac OS X Yosemite</a><br><a href=\"https://www.jianshu.com/p/de7eb61c983a\">Mac 系统安装Hadoop 2.7.3</a></p>\n","categories":["大数据","Hadoop"],"tags":["Hadoop"]},{"title":"小程序获取openid、session_key和access_token","url":"/2018/07/06/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%B0%83%E6%95%B4/","content":"<blockquote>\n<p>openid、session_key 和 access_token 是微信小程序常用到的信息，需要通过官方提供的 api 接口来获取。</p>\n<ul>\n<li>openid 是微信用户在公众号 appid 下的唯一用户标识（appid 不同，则获取到的 openid 就不同），可用于永久标记一个用户。</li>\n<li>session_key 用于校验用户信息（例如 wx.getUserInfo(OBJECT) 返回的 signature）和解密（例如 wx.getUserInfo(OBJECT) 返回的 encryptedData）。</li>\n<li>access_token 是全局唯一接口调用凭据，开发者调用各接口时都需使用。access_token 的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的 access_token 失效，所以需要妥善保存。</li>\n</ul>\n<p>转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"获取-openid-和-session-key\"><a href=\"#获取-openid-和-session-key\" class=\"headerlink\" title=\"获取 openid 和 session_key\"></a>获取 openid 和 session_key</h2><h3 id=\"获取用户信息接口调整\"><a href=\"#获取用户信息接口调整\" class=\"headerlink\" title=\"获取用户信息接口调整\"></a>获取用户信息接口调整</h3><p>根究官方公告 <a href=\"https://developers.weixin.qq.com/blogdetail?action=get_post_info&lang=zh_CN&token=384460955&docid=000aee01f98fc0cbd4b6ce43b56c01\">获取用户信息接口优化调整</a>，<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open.html#wxgetuserinfoobject\">wx.getUserInfo()</a> 进行调整，2018年05月10日以后小程序需要通过 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/component/button.html\">button</a> 按钮授权来引导用户主动进行授权操作才能获取用户信息。</p>\n<p>简单来说，在旧接口里面，开发人员可以随时调用 wx.getUserInfo()。在第一次调用的时候会弹出授权窗口，需要用户进行授权操作才能获取信息。</p>\n<p>在新接口里面，不能随时调用 wx.getUserInfo()，需要在 button 按钮里面添加属性 <code>open-type=“getUserInfo”</code>，通过点击 button 按钮来弹出授权窗口，用户授权之后两种方法获取用户信息：</p>\n<ol>\n<li>button 按钮绑定事件 <code>bindgetuserinfo=&quot;methodName&quot;</code>，通过 methodName 事件回调数据来获取用户信息。回调数据 e.detail 数据与 wx.getUserInfo() 返回的一致</li>\n</ol>\n<ul>\n<li>xml <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button open-type=“getUserInfo&quot; bindgetuserinfo=&quot;pageGetUserInfo&quot;&gt;下一步&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>\n<li>js <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pageGetUserInfo: function (e) &#123;</span><br><span class=\"line\">  console.log(e.detail) #detail数据与wx.getUserInfo()返回的一致</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>button 按钮绑定普通点击事件 <code>bindtap=&quot;methodName&quot;</code>，在 methodName 方法里面调用 wx.getUserInfo() 来获取用户信息。这时候 button 按钮只是起到弹出授权窗口的作用。</li>\n</ol>\n<ul>\n<li>xml <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button open-type=“getUserInfo&quot; bindtap=&quot;pageGetUserInfo&quot;&gt;下一步&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>\n<li>js <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pageGetUserInfo: function (e) &#123;</span><br><span class=\"line\">  var that = this</span><br><span class=\"line\">  app.getUserInfo(function (userInfo) &#123;</span><br><span class=\"line\">    that.setData(&#123;</span><br><span class=\"line\">      userInfo: userInfo</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n<li>app.js <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">getUserInfo: function (cb) &#123;</span><br><span class=\"line\">  var that = this</span><br><span class=\"line\">  if (this.globalData.userInfo) &#123;</span><br><span class=\"line\">    typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    wx.login(&#123;</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        var code = res.code; //获取code</span><br><span class=\"line\">        wx.getUserInfo(&#123;</span><br><span class=\"line\">          success: function (res) &#123; //用户授权登录</span><br><span class=\"line\">            that.globalData.userInfo = res.userInfo</span><br><span class=\"line\">            typeof cb == &quot;function&quot; &amp;&amp; cb(that.globalData.userInfo)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"获取-openid-和-session-key-1\"><a href=\"#获取-openid-和-session-key-1\" class=\"headerlink\" title=\"获取 openid 和 session_key\"></a>获取 openid 和 session_key</h3><p>根据官方提供的 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/api-login.html\">小程序登录</a> 流程，流程图如下：</p>\n<div style='width: 80%'>![liucheng](liucheng.jpg)</div>\n获取 openid 和 session_key 的步骤可以分为：\n\n<ol>\n<li><code>wx.login()</code> 获取登录临时凭证 code</li>\n<li>把 code 通过 <code>wx.request()</code> 发送到我们的开发服务器</li>\n<li>在开发服务器上把 code、appid 和 appsecret 发送到微信api <code>https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code</code>。appid 和 appsecret 从 <a href=\"https://mp.weixin.qq.com/\">微信公众平台</a> 上获取，然后在开发服务器上定义为配置变量来调用</li>\n<li>获取 openid 和 seesion_key 返回</li>\n</ol>\n<p>一般来说会在 app.js 里面定义获取用户信息的方法 <code>getUserInfo()</code> 方法，该方法里面再分别调用 <code>wx.login()</code> （返回的 code 用于获取 openid）和 <code>wx.getUserInfo()</code> （返回用户信息，其中 userInfo 可以保存在全局变量 app.globalData.userInfo 里面）。这样全局都可以通过调用 <code>getUserInfo()</code> 来进行获取 openid 和用户信息。</p>\n<blockquote>\n<p>wx.getUserInfo() 返回的数据 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open.html#wxgetuserinfoobject\">encryptedData</a> 包括 openid 等敏感数据的完整用户信息的加密数据，如果只需要 openid 而不需要 session_key 的话可以直接解密 encryptedData 来获取 openid，详见 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/signature.html#wxchecksessionobject\">加密数据解密算法</a></p>\n</blockquote>\n<p>下面贴出核心代码（并不是完整代码）</p>\n<h4 id=\"app-js\"><a href=\"#app-js\" class=\"headerlink\" title=\"app.js\"></a>app.js</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">getUserInfo: function (cb) &#123;</span><br><span class=\"line\">  var that = this</span><br><span class=\"line\">  if (this.globalData.userInfo) &#123;</span><br><span class=\"line\">    typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    wx.login(&#123;</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        var code = res.code;</span><br><span class=\"line\">        wx.getUserInfo(&#123;</span><br><span class=\"line\">          success: function (res) &#123; //用户授权登录</span><br><span class=\"line\">            that.globalData.userInfo = res.userInfo</span><br><span class=\"line\">            var encryptedData = encodeURIComponent(res.encryptedData);</span><br><span class=\"line\">            var iv = res.iv;</span><br><span class=\"line\">            that.wxLogin(code, encryptedData, iv); //调用后台接口登录</span><br><span class=\"line\">            typeof cb == &quot;function&quot; &amp;&amp; cb(that.globalData.userInfo)</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          fail: function (res) &#123; //用户没有授权登录</span><br><span class=\"line\">           //todo</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">wxLogin: function (code, encryptedData, iv) &#123;</span><br><span class=\"line\">  var that = this</span><br><span class=\"line\">  var data = &#123;</span><br><span class=\"line\">    code: code,</span><br><span class=\"line\">    encryptedData: encryptedData,</span><br><span class=\"line\">    iv: iv</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  that.api(&#x27;get&#x27;, &#x27;/index/decodeUserInfo&#x27;, data, function(res)&#123; //该方法是自定义对wx.request()进一步封装的request请求方法，添加了异常处理等</span><br><span class=\"line\">    that.globalData.openid = res.openid</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">globalData: &#123;</span><br><span class=\"line\">  userInfo: null,</span><br><span class=\"line\">  openid: null,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"UserController-java\"><a href=\"#UserController-java\" class=\"headerlink\" title=\"UserController.java\"></a>UserController.java</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class UserController &#123;</span><br><span class=\"line\">    @ResponseBody</span><br><span class=\"line\">    @RequestMapping(&quot;/index/decodeUserInfo&quot;)</span><br><span class=\"line\">    public Map decodeUserInfo(@RequestParam Map&lt;String, String&gt; params) &#123;</span><br><span class=\"line\">        String encryptedData = params.get(&quot;encryptedData&quot;);</span><br><span class=\"line\">        String iv = params.get(&quot;iv&quot;);</span><br><span class=\"line\">        String code = params.get(&quot;code&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            String rs = userService.getWxjscode2session(appIdVersion, code);</span><br><span class=\"line\">            JSONObject obj = JSONObject.parseObject(rs);</span><br><span class=\"line\">            String session_key = obj.get(&quot;session_key&quot;).toString();</span><br><span class=\"line\">            String openid = obj.get(&quot;openid&quot;).toString();</span><br><span class=\"line\">            </span><br><span class=\"line\">            Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">            map.put(&quot;openid&quot;, openid);</span><br><span class=\"line\">            map.put(&quot;session_key&quot;, session_key);</span><br><span class=\"line\"></span><br><span class=\"line\">            return ApiResponse.ok(map);</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            log.error(e.getMessage());</span><br><span class=\"line\">            return ApiResponse.response(ApiResponse.Code.ERROR, &quot;内部错误。&quot;, e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"UserService-java\"><a href=\"#UserService-java\" class=\"headerlink\" title=\"UserService.java\"></a>UserService.java</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class UserService &#123;</span><br><span class=\"line\">\tprivate final static String wxjscode2sessionURL= &quot;https://api.weixin.qq.com/sns/jscode2session&quot;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    private final static String appId = &quot;xxx&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final static String secret = &quot;xxx&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private final static String grantType = &quot;authorization_code&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public String getWxjscode2session (String appIdVersion, String code)&#123;</span><br><span class=\"line\">        String rs = &quot;&quot;;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            Map&lt;String, String&gt; parameters = new HashMap&lt;String, String&gt;();</span><br><span class=\"line\">            parameters.put(&quot;js_code&quot;, code);</span><br><span class=\"line\">            parameters.put(&quot;appid&quot;, appId);</span><br><span class=\"line\">            parameters.put(&quot;secret&quot;, secret);</span><br><span class=\"line\">            parameters.put(&quot;grant_type&quot;, grantType);</span><br><span class=\"line\">            rs = HttpClientUtils.doPost(UserService.wxjscode2sessionURL, parameters); //向微信api发送请求</span><br><span class=\"line\">        &#125;catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return rs;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HttpClientUtils-java\"><a href=\"#HttpClientUtils-java\" class=\"headerlink\" title=\"HttpClientUtils.java\"></a>HttpClientUtils.java</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class HttpClientUtils &#123;</span><br><span class=\"line\">    private static final String CHARSET = &quot;utf-8&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public static String doPost(String url, Map&lt;String, String&gt; map) &#123;</span><br><span class=\"line\">        CloseableHttpClient httpClient = null;</span><br><span class=\"line\">        HttpPost httpPost = null;</span><br><span class=\"line\">        String result = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            httpClient = HttpClients.createDefault();</span><br><span class=\"line\">            RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(30000).setConnectionRequestTimeout(10000).setSocketTimeout(30000).build();</span><br><span class=\"line\">            httpPost = new HttpPost(url);</span><br><span class=\"line\">            httpPost.setConfig(requestConfig);</span><br><span class=\"line\">            // 设置参数</span><br><span class=\"line\">            List&lt;NameValuePair&gt; list = null;</span><br><span class=\"line\">            if (null != map) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                list = new ArrayList&lt;NameValuePair&gt;();</span><br><span class=\"line\">                Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\">                while (iterator.hasNext()) &#123;</span><br><span class=\"line\">                    Entry&lt;String, String&gt; elem = iterator.next();</span><br><span class=\"line\">                    list.add(new BasicNameValuePair(elem.getKey(), elem.getValue()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (null != list &amp;&amp; list.size() &gt; 0) &#123;</span><br><span class=\"line\">                UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list, CHARSET);</span><br><span class=\"line\">                httpPost.setEntity(entity);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            CloseableHttpResponse response = httpClient.execute(httpPost);</span><br><span class=\"line\">            int statusCode = response.getStatusLine().getStatusCode();</span><br><span class=\"line\">            if (statusCode == 200) &#123;</span><br><span class=\"line\">                if (response != null) &#123;</span><br><span class=\"line\">                    HttpEntity resEntity = response.getEntity();</span><br><span class=\"line\">                    if (resEntity != null) &#123;</span><br><span class=\"line\">                        result = EntityUtils.toString(resEntity, CHARSET);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    EntityUtils.consume(resEntity);</span><br><span class=\"line\">                    response.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                System.err.println(&quot;HTTP POST ERROR: statusCode:&quot; + statusCode);</span><br><span class=\"line\">                if (response != null) &#123;</span><br><span class=\"line\">                    HttpEntity resEntity = response.getEntity();</span><br><span class=\"line\">                    if (resEntity != null) &#123;</span><br><span class=\"line\">                        String errMsg = EntityUtils.toString(resEntity, CHARSET);</span><br><span class=\"line\">                        System.err.println(errMsg);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    EntityUtils.consume(resEntity);</span><br><span class=\"line\">                    response.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Exception ex) &#123;</span><br><span class=\"line\">            System.err.println(&quot;HTTP POST 请求错误：&quot; + ex.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (StringUtils.isNotBlank(result)) &#123;</span><br><span class=\"line\">            if (result.indexOf(&quot;Token_b已失效&quot;) &gt; -1) &#123;</span><br><span class=\"line\">                throw new RuntimeException(&quot;Token已失效,请重新登录系统！&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"获取-access-token\"><a href=\"#获取-access-token\" class=\"headerlink\" title=\"获取 access_token\"></a>获取 access_token</h2><p>参考 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/token.html\">官方获取 access_token</a>，获取 access_token 的方法较为简单，通过 get 请求发送到 <code>https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET </code> 即可返回 access_token</p>\n<h4 id=\"UtilService-java\"><a href=\"#UtilService-java\" class=\"headerlink\" title=\"UtilService.java\"></a>UtilService.java</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class UtilService &#123;</span><br><span class=\"line\">    private final static String wxAccessTokenURL = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=%s&amp;secret=%s&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public void getAccessToken (String orderFid, int type, String reason) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            String url = String.format(TradeService.wxAccessTokenURL, UserService.getAppIdv2(), UserService.getSecretv2());</span><br><span class=\"line\">            String rs = HttpClientUtils.doGet(url1); //获取access_token</span><br><span class=\"line\">            JSONObject obj = JSONObject.parseObject(rs1);</span><br><span class=\"line\">            String access_token = obj1.get(&quot;access_token&quot;).toString();</span><br><span class=\"line\">        &#125;catch (NullPointerException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HttpClientUtils-java-1\"><a href=\"#HttpClientUtils-java-1\" class=\"headerlink\" title=\"HttpClientUtils.java\"></a>HttpClientUtils.java</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class HttpClientUtils &#123;</span><br><span class=\"line\">    private static final String CHARSET = &quot;utf-8&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static String doGet(String url) &#123;</span><br><span class=\"line\">        String result = null;</span><br><span class=\"line\">        CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class=\"line\">        RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(3000).setConnectionRequestTimeout(1000).setSocketTimeout(3000).build();</span><br><span class=\"line\">        HttpGet httpGet = new HttpGet(url);</span><br><span class=\"line\">        httpGet.setConfig(requestConfig);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            CloseableHttpResponse response = httpclient.execute(httpGet);</span><br><span class=\"line\">            int statusCode = response.getStatusLine().getStatusCode();</span><br><span class=\"line\">            if (statusCode == 200) &#123;</span><br><span class=\"line\">                HttpEntity entity1 = response.getEntity();</span><br><span class=\"line\">                if (entity1 != null) &#123;</span><br><span class=\"line\">                    result = EntityUtils.toString(entity1, CHARSET);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                EntityUtils.consume(entity1);</span><br><span class=\"line\">                response.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            System.err.println(&quot;HTTP GET 请求错误：&quot; + e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["平台开发","微信小程序"],"tags":["微信小程序"]},{"title":"Java异常处理详解","url":"/2018/07/10/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3/","content":"<blockquote>\n<p>之前在学习工作中虽然一直在用 Java 的异常处理，但一直都处于仅仅了解简单用法的表面基础上。最近趁有空进一步深入学习了 Java 的异常处理机制，发现一些写得很好的博客，转载过来学习。本文转载自: <a href=\"https://www.cnblogs.com/lulipro/p/7504267.html\">https://www.cnblogs.com/lulipro/p/7504267.html</a></p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"什么是异常\"><a href=\"#什么是异常\" class=\"headerlink\" title=\"什么是异常\"></a>什么是异常</h2><p><em><strong>异常就是程序运行时，发生的不被期望的事件，阻止了程序按照程序员的预期正常执行</strong></em>。Java 为异常提供了优秀的解决办法：异常处理机制。</p>\n<p>异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。</p>\n<p>Java 中的异常可以是函数中的语句执行时引发的，也可以是程序员通过 throw 语句手动抛出的，只要在 Java 程序中产生了异常，就会用一个对应类型的异常对象来封装异常，JRE就会试图寻找异常处理程序来处理异常。</p>\n<h2 id=\"Java异常的分类和类结构图\"><a href=\"#Java异常的分类和类结构图\" class=\"headerlink\" title=\"Java异常的分类和类结构图\"></a>Java异常的分类和类结构图</h2><p>Throwable 类是 Java 异常类型的顶层父类，一个对象只有是 Throwable 类的（直接或者间接）实例，他才是一个异常对象，才能被异常处理机制识别。JDK中内建了一些常用的异常类，我们也可以自定义异常。</p>\n<p>Throwable 又派生出 Error 类和 Exception 类。</p>\n<ul>\n<li><p><strong>Error</strong>：Error 类以及他的子类的实例，代表了 JVM 本身的错误。错误不能被程序员通过代码处理，Error 很少出现。因此，程序员应该关注 Exception 为父类的分支下的各种异常类。</p>\n</li>\n<li><p><strong>Exception</strong>：Exception 以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被 Java 异常处理机制使用，是异常处理的核心。</p>\n</li>\n</ul>\n<p><img src=\"/2018/07/10/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3/exception.png\" alt=\"exception\"></p>\n<p>根据编译器 Javac 对异常的处理要求（注意是分类是给 javac 识别的），将异常类分为2类。</p>\n<ul>\n<li><p><strong>非检查异常</strong>（unckecked exception）：<em><strong>Error 和 RuntimeException 以及他们的子类</strong></em>。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。<em><strong>对于这些异常，我们应该修正代码，而不是去通过异常处理器处理</strong></em>。这样的异常发生的原因多半是代码写的有问题。如除0错误 ArithmeticException，错误的强制类型转换错误 ClassCastException，数组索引越界 ArrayIndexOutOfBoundsException，使用了空对象 NullPointerException等等。</p>\n</li>\n<li><p><strong>检查异常</strong>（checked exception）：<em><strong>除了 Error 和 RuntimeException的其它异常</strong></em>。javac强制要求程序员为这样的异常做预备处理工作。<em><strong>在方法中要么用 try-catch 语句捕获它并处理，要么用 throws 子句声明抛出它，否则编译不会通过</strong></em>。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。</p>\n</li>\n</ul>\n<p>下面的代码会演示2个异常类型：ArithmeticException 和 InputMismatchException。前者由于整数除0引发，后者是输入的数据不能被转换为int类型引发。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package com.example;</span><br><span class=\"line\">import java. util .Scanner ;</span><br><span class=\"line\">public class AllDemo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">      public static void main (String [] args )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">            System . out. println( &quot;----欢迎使用命令行除法计算器----&quot; ) ;</span><br><span class=\"line\">            CMDCalculate ();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      public static void CMDCalculate ()</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">            Scanner scan = new Scanner ( System. in );</span><br><span class=\"line\">            int num1 = scan .nextInt () ;</span><br><span class=\"line\">            int num2 = scan .nextInt () ;</span><br><span class=\"line\">            int result = devide (num1 , num2 ) ;</span><br><span class=\"line\">            System . out. println( &quot;result:&quot; + result) ;</span><br><span class=\"line\">            scan .close () ;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      public static int devide (int num1, int num2 )&#123;</span><br><span class=\"line\">            return num1 / num2 ;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*****************************************</span><br><span class=\"line\"></span><br><span class=\"line\">----欢迎使用命令行除法计算器----</span><br><span class=\"line\">0</span><br><span class=\"line\">Exception in thread &quot;main&quot; java.lang.ArithmeticException : / by zero</span><br><span class=\"line\">     at com.example.AllDemo.devide( AllDemo.java:30 )</span><br><span class=\"line\">     at com.example.AllDemo.CMDCalculate( AllDemo.java:22 )</span><br><span class=\"line\">     at com.example.AllDemo.main( AllDemo.java:12 )</span><br><span class=\"line\"></span><br><span class=\"line\">----欢迎使用命令行除法计算器----</span><br><span class=\"line\">r</span><br><span class=\"line\">Exception in thread &quot;main&quot; java.util.InputMismatchException</span><br><span class=\"line\">     at java.util.Scanner.throwFor( Scanner.java:864 )</span><br><span class=\"line\">     at java.util.Scanner.next( Scanner.java:1485 )</span><br><span class=\"line\">     at java.util.Scanner.nextInt( Scanner.java:2117 )</span><br><span class=\"line\">     at java.util.Scanner.nextInt( Scanner.java:2076 )</span><br><span class=\"line\">     at com.example.AllDemo.CMDCalculate( AllDemo.java:20 )</span><br><span class=\"line\">     at com.example.AllDemo.main( AllDemo.java:12 )</span><br><span class=\"line\">*****************************************/</span><br></pre></td></tr></table></figure>\n\n<p>异常是在执行某个函数时引发的，而函数又是层级调用，形成调用栈的，因为，只要一个函数发生了异常，那么他的所有的caller都会被异常影响。当这些被影响的函数以异常信息输出时，就形成的了 <strong>异常追踪栈</strong>。</p>\n<p>异常最先发生的地方，叫做 <strong>异常抛出点</strong>。</p>\n<p><img src=\"/2018/07/10/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3/stack.png\" alt=\"stack\"></p>\n<p>从上面的例子可以看出，当devide函数发生除0异常时，devide函数将抛出ArithmeticException异常，因此调用他的CMDCalculate函数也无法正常完成，因此也发送异常，而CMDCalculate的caller——main 因为CMDCalculate抛出异常，也发生了异常，这样一直向调用栈的栈底回溯。这种行为叫做 <strong>异常的冒泡</strong>，异常的冒泡是为了在当前发生异常的函数或者这个函数的caller中找到最近的异常处理程序。由于这个例子中没有使用任何异常处理机制，因此异常最终由main函数抛给JRE，导致程序终止。</p>\n<p>上面的代码不使用异常处理机制，也可以顺利编译，因为2个异常都是非检查异常。但是下面的例子就必须使用异常处理机制，因为异常是检查异常。</p>\n<p>代码中我选择使用throws声明异常，让函数的调用者去处理可能发生的异常。但是为什么只throws了IOException呢？因为FileNotFoundException是IOException的子类，在处理范围内。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testException() throws IOException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //FileInputStream的构造函数会抛出FileNotFoundException</span><br><span class=\"line\">    FileInputStream fileIn = new FileInputStream(&quot;E:\\\\a.txt&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    int word;</span><br><span class=\"line\">    //read方法会抛出IOException</span><br><span class=\"line\">    while((word =  fileIn.read())!=-1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.print((char)word);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //close方法会抛出IOException</span><br><span class=\"line\">    fileIn.clos</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"怎么处理异常\"><a href=\"#怎么处理异常\" class=\"headerlink\" title=\"怎么处理异常\"></a>怎么处理异常</h2><p>在编写代码处理异常时，对于检查异常，有2种不同的处理方式：</p>\n<ol>\n<li>使用 <strong>try…catch…finally</strong> 语句块处理它。</li>\n<li>在函数签名中使用 <strong>throws 声明</strong> 交给函数调用者 caller 去解决。</li>\n</ol>\n<h3 id=\"try…catch…finally语句块\"><a href=\"#try…catch…finally语句块\" class=\"headerlink\" title=\"try…catch…finally语句块\"></a>try…catch…finally语句块</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try&#123;</span><br><span class=\"line\">     //try块中放可能发生异常的代码。</span><br><span class=\"line\">     //如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。</span><br><span class=\"line\">     //如果发生异常，则尝试去匹配catch块。</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;catch(SQLException SQLexception)&#123;</span><br><span class=\"line\">    //每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。</span><br><span class=\"line\">    //catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。</span><br><span class=\"line\">    //在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。</span><br><span class=\"line\">    //如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。</span><br><span class=\"line\">    //如果try中没有发生异常，则所有的catch块将被忽略。</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;catch(Exception exception)&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;finally&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //finally块通常是可选的。</span><br><span class=\"line\">   //无论异常是否发生，异常是否匹配被处理，finally都会执行。</span><br><span class=\"line\">   //一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。</span><br><span class=\"line\">  //finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的地方：</p>\n<ol>\n<li><p>try块中的局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，他们之间不可共享使用。</p>\n</li>\n<li><p>每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，<em><strong>如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面</strong></em>，这样保证每个catch块都有存在的意义。</p>\n</li>\n<li><p>java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。</p>\n</li>\n</ol>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args)&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            foo();</span><br><span class=\"line\">        &#125;catch(ArithmeticException ae) &#123;</span><br><span class=\"line\">            System.out.println(&quot;处理异常&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public static void foo()&#123;</span><br><span class=\"line\">        int a = 5/0;  //异常抛出点</span><br><span class=\"line\">        System.out.println(&quot;为什么还不给我涨工资!!!&quot;);  //这里后面不会执行</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：恢复式异常处理模式（resumption model of exception handling）<br> 而Java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：终结式异常处理模式（termination model of exception handling）</p>\n</blockquote>\n<h3 id=\"throws-函数声明\"><a href=\"#throws-函数声明\" class=\"headerlink\" title=\"throws 函数声明\"></a>throws 函数声明</h3><p>throws声明：如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。</p>\n<p>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。</p>\n<p>采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     //foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"异常的链化\"><a href=\"#异常的链化\" class=\"headerlink\" title=\"异常的链化\"></a>异常的链化</h2><p>在一些大型的，模块化的软件开发中，一旦一个地方发生异常，则如骨牌效应一样，将导致一连串的异常。假设B模块完成自己的逻辑需要调用A模块的方法，如果A模块发生异常，则B也将不能完成而发生异常，但是B在抛出异常时，会将A的异常信息掩盖掉，这将使得异常的根源信息丢失。异常的链化可以将多个模块的异常串联起来，使得异常信息不会丢失。</p>\n<p>异常链化: <em>以一个异常对象为参数构造新的异常对象。新的异对象将包含先前异常的信息</em>。这项技术主要是异常类的一个带Throwable参数的函数来实现的。这个当做参数的异常，我们叫他根源异常（cause）。</p>\n<p>查看Throwable类源码，可以发现里面有一个Throwable字段cause，就是它保存了构造时传递的根源异常参数。<em>这种设计和链表的结点类设计如出一辙</em>，因此形成链也是自然的了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Throwable implements Serializable &#123;</span><br><span class=\"line\">    private Throwable cause = this;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Throwable(String message, Throwable cause) &#123;</span><br><span class=\"line\">        fillInStackTrace();</span><br><span class=\"line\">        detailMessage = message;</span><br><span class=\"line\">        this.cause = cause;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     public Throwable(Throwable cause) &#123;</span><br><span class=\"line\">        fillInStackTrace();</span><br><span class=\"line\">        detailMessage = (cause==null ? null : cause.toString());</span><br><span class=\"line\">        this.cause = cause;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //........</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个例子，演示了异常的链化：从命令行输入2个int，将他们相加，输出。输入的数不是int，则导致getInputNumbers异常，从而导致add函数异常，则可以在add函数中抛出</p>\n<p>一个链化的异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;请输入2个加数&quot;);</span><br><span class=\"line\">    int result;</span><br><span class=\"line\">    try</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        result = add();</span><br><span class=\"line\">        System.out.println(&quot;结果:&quot;+result);</span><br><span class=\"line\">    &#125; catch (Exception e)&#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//获取输入的2个整数返回</span><br><span class=\"line\">private static List&lt;Integer&gt; getInputNumbers()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    Scanner scan = new Scanner(System.in);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        int num1 = scan.nextInt();</span><br><span class=\"line\">        int num2 = scan.nextInt();</span><br><span class=\"line\">        nums.add(new Integer(num1));</span><br><span class=\"line\">        nums.add(new Integer(num2));</span><br><span class=\"line\">    &#125;catch(InputMismatchException immExp)&#123;</span><br><span class=\"line\">        throw immExp;</span><br><span class=\"line\">    &#125;finally &#123;</span><br><span class=\"line\">        scan.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return nums;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//执行加法计算</span><br><span class=\"line\">private static int add() throws Exception</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int result;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; nums =getInputNumbers();</span><br><span class=\"line\">        result = nums.get(0)  + nums.get(1);</span><br><span class=\"line\">    &#125;catch(InputMismatchException immExp)&#123;</span><br><span class=\"line\">        throw new Exception(&quot;计算失败&quot;,immExp);  /////////////////////////////链化:以一个异常对象为参数构造新的异常对象。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return  result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">请输入2个加数</span><br><span class=\"line\">r 1</span><br><span class=\"line\">java.lang.Exception: 计算失败</span><br><span class=\"line\">    at practise.ExceptionTest.add(ExceptionTest.java:53)</span><br><span class=\"line\">    at practise.ExceptionTest.main(ExceptionTest.java:18)</span><br><span class=\"line\">Caused by: java.util.InputMismatchException</span><br><span class=\"line\">    at java.util.Scanner.throwFor(Scanner.java:864)</span><br><span class=\"line\">    at java.util.Scanner.next(Scanner.java:1485)</span><br><span class=\"line\">    at java.util.Scanner.nextInt(Scanner.java:2117)</span><br><span class=\"line\">    at java.util.Scanner.nextInt(Scanner.java:2076)</span><br><span class=\"line\">    at practise.ExceptionTest.getInputNumbers(ExceptionTest.java:30)</span><br><span class=\"line\">    at practise.ExceptionTest.add(ExceptionTest.java:48)</span><br><span class=\"line\">    ... 1 more</span><br><span class=\"line\"></span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018/07/10/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3/lianshi.png\" alt=\"lianshi\"></p>\n<h2 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h2><p>如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展自RuntimeException。</p>\n<p>按照国际惯例，自定义的异常应该总是包含如下的构造函数：</p>\n<ul>\n<li>一个无参构造函数</li>\n<li>一个带有String参数的构造函数，并传递给父类的构造函数。</li>\n<li>一个带有String参数和Throwable参数，并都传递给父类构造函数</li>\n<li>一个带有Throwable 参数的构造函数，并传递给父类的构造函数。</li>\n</ul>\n<p>下面是IOException类的完整源代码，可以借鉴。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class IOException extends Exception</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static final long serialVersionUID = 7818375828146090155L;</span><br><span class=\"line\"></span><br><span class=\"line\">    public IOException()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        super();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public IOException(String message)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        super(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public IOException(String message, Throwable cause)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        super(message, cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public IOException(Throwable cause)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        super(cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"异常的注意事项\"><a href=\"#异常的注意事项\" class=\"headerlink\" title=\"异常的注意事项\"></a>异常的注意事项</h2><h3 id=\"重写带-throws-声明的父类方法\"><a href=\"#重写带-throws-声明的父类方法\" class=\"headerlink\" title=\"重写带 throws 声明的父类方法\"></a>重写带 throws 声明的父类方法</h3><p>当子类重写父类的带有 throws 声明的函数时，其 throws 声明的异常必须在父类异常的可控范围内。意思是说</p>\n<ul>\n<li>子类 throws 的异常数量不能多于父类</li>\n<li>子类 throws 的类型必须是父类异常类型或其子类</li>\n</ul>\n<p>例如，父类方法 throws 2 个异常，子类就不能 throws 3 个及以上的异常。父类 throws IOException，子类就必须 throws IOException 或者 IOException 的子类。</p>\n<p>这是为了支持多态。看下面这个例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Father</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public void start() throws IOException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        throw new IOException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Son extends Father</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public void start() throws Exception</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        throw new SQLException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/**********************假设上面的代码是允许的（实质是错误的）***********************/</span><br><span class=\"line\">class Test</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public static void main(String[] args)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Father[] objs = new Father[2];</span><br><span class=\"line\">        objs[0] = new Father();</span><br><span class=\"line\">        objs[1] = new Son();</span><br><span class=\"line\"></span><br><span class=\"line\">        for(Father obj:objs)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        //因为Son类抛出的实质是SQLException，而IOException无法处理它。</span><br><span class=\"line\">        //那么这里的try。。catch就不能处理Son中的异常。</span><br><span class=\"line\">        //多态就不能实现了。</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                 obj.start();</span><br><span class=\"line\">            &#125;catch(IOException)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                 //处理IOException</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"异常是线程独立的\"><a href=\"#异常是线程独立的\" class=\"headerlink\" title=\"异常是线程独立的\"></a>异常是线程独立的</h3><p>Java 程序可以是多线程的。每一个线程都是一个独立的执行流，独立的函数调用栈。如果程序只有一个线程，那么没有被任何代码处理的异常会导致程序终止。如果是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。</p>\n<p>也就是说，Java中的异常是线程独立的，线程的问题应该由线程自己来解决，而不要委托到外部，也不会直接影响到其它线程的执行。</p>\n<h3 id=\"finally-执行不受-try-块中的-return-影响\"><a href=\"#finally-执行不受-try-块中的-return-影响\" class=\"headerlink\" title=\"finally 执行不受 try 块中的 return 影响\"></a>finally 执行不受 try 块中的 return 影响</h3><p>在 try 块中即便有 return，break，continue 等改变执行流的语句，finally 也会执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int re = bar();</span><br><span class=\"line\">    System.out.println(re);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private static int bar()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        return 5;</span><br><span class=\"line\">    &#125; finally&#123;</span><br><span class=\"line\">        System.out.println(&quot;finally&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*输出：</span><br><span class=\"line\">finally</span><br><span class=\"line\">5</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<p>很多人面对这个问题时，总是在归纳执行的顺序和规律，不过我觉得还是很难理解。我自己总结了一个方法。用如下GIF图说明。</p>\n<p><img src=\"/2018/07/10/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3/return.gif\" alt=\"return\"></p>\n<p>也就是说：try…catch…finally中的return 只要能执行，就都执行了，他们共同向同一个内存地址（假设地址是0x80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。那么，按照这个思想，下面的这个例子也就不难理解了。</p>\n<h3 id=\"finally-中的-return-会覆盖-try-或者-catch-中的返回值。\"><a href=\"#finally-中的-return-会覆盖-try-或者-catch-中的返回值。\" class=\"headerlink\" title=\"finally 中的 return 会覆盖 try 或者 catch 中的返回值。\"></a>finally 中的 return 会覆盖 try 或者 catch 中的返回值。</h3><p>不管 try 和 catch 里面 return 什么值，都会被 finally 的 return 值所覆盖。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    int result;</span><br><span class=\"line\"></span><br><span class=\"line\">    result = foo();</span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\"></span><br><span class=\"line\">    result = bar();</span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@SuppressWarnings(&quot;finally&quot;)</span><br><span class=\"line\">public static int foo() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        int a = 5 / 0;</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        return 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@SuppressWarnings(&quot;finally&quot;)</span><br><span class=\"line\">public static int bar() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        return 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">最终输入结果</span><br><span class=\"line\">2</span><br><span class=\"line\">2</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"finally-中的-return-会抑制（消灭）前面-try-或者-catch-块中的异常\"><a href=\"#finally-中的-return-会抑制（消灭）前面-try-或者-catch-块中的异常\" class=\"headerlink\" title=\"finally 中的 return 会抑制（消灭）前面 try 或者 catch 块中的异常\"></a>finally 中的 return 会抑制（消灭）前面 try 或者 catch 块中的异常</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int result;</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        result = foo();</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125; catch (Exception e)&#123;</span><br><span class=\"line\">        System.out.println(e.getMessage()); //没有捕捉到异常</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        result  = bar();</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125; catch (Exception e)&#123;</span><br><span class=\"line\">        System.out.println(e.getMessage()); //没有捕捉到异常</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//catch中的异常被抑制</span><br><span class=\"line\">@SuppressWarnings(&quot;finally&quot;)</span><br><span class=\"line\">public static int foo() throws Exception</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        int a = 5/0;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;catch(ArithmeticException amExp) &#123;</span><br><span class=\"line\">        throw new Exception(&quot;我将被忽略，因为下面的finally中使用了return&quot;);</span><br><span class=\"line\">    &#125;finally &#123;</span><br><span class=\"line\">        return 100;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//try中的异常被抑制</span><br><span class=\"line\">@SuppressWarnings(&quot;finally&quot;)</span><br><span class=\"line\">public static int bar() throws Exception</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        int a = 5/0;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;finally &#123;</span><br><span class=\"line\">        return 100;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">最终输出：</span><br><span class=\"line\">100</span><br><span class=\"line\">100</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"finally-中的异常会覆盖（消灭）前面-try-或者-catch-中的异常\"><a href=\"#finally-中的异常会覆盖（消灭）前面-try-或者-catch-中的异常\" class=\"headerlink\" title=\"finally 中的异常会覆盖（消灭）前面 try 或者 catch 中的异常\"></a>finally 中的异常会覆盖（消灭）前面 try 或者 catch 中的异常</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int result;</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        result = foo();</span><br><span class=\"line\">    &#125; catch (Exception e)&#123;</span><br><span class=\"line\">        System.out.println(e.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        result  = bar();</span><br><span class=\"line\">    &#125; catch (Exception e)&#123;</span><br><span class=\"line\">        System.out.println(e.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//catch中的异常被抑制</span><br><span class=\"line\">@SuppressWarnings(&quot;finally&quot;)</span><br><span class=\"line\">public static int foo() throws Exception</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        int a = 5/0;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;catch(ArithmeticException amExp) &#123;</span><br><span class=\"line\">        throw new Exception(&quot;我将被忽略，因为下面的finally中抛出了新的异常&quot;);</span><br><span class=\"line\">    &#125;finally &#123;</span><br><span class=\"line\">        throw new Exception(&quot;我是finaly中的Exception，覆盖了catch的异常&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//try中的异常被抑制</span><br><span class=\"line\">@SuppressWarnings(&quot;finally&quot;)</span><br><span class=\"line\">public static int bar() throws Exception</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        int a = 5/0; //这里产生的异常被下面finally抛出的异常覆盖</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;finally &#123;</span><br><span class=\"line\">        throw new Exception(&quot;我是finaly中的Exception，覆盖了try的异常&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">最终输出：</span><br><span class=\"line\">我是finaly中的Exception，覆盖了catch的异常</span><br><span class=\"line\">我是finaly中的Exception，覆盖了try的异常</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n\n<p>上面的3个例子都异于常人的编码思维，因此我建议：</p>\n<ul>\n<li>不要在fianlly中使用return。</li>\n<li>不要在finally中抛出异常。</li>\n<li>减轻finally的任务，不要在finally中做一些其它的事情，finally块仅仅用来释放资源是最合适的。</li>\n<li>将尽量将所有的return写在函数的最后面，而不是try … catch … finally中。</li>\n</ul>\n","categories":["Java","Java异常"],"tags":["Java","异常处理"]},{"title":"Java异常处理中throw和throws的区别和用法","url":"/2018/07/10/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%ADthrow%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/","content":"<blockquote>\n<p>前一篇文章已经详细介绍了 Java 的异常处理机制，在这里做一些补充，探讨异常处理关键字 throw 和 throws 的区别和用法。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"抛出异常的三种形式\"><a href=\"#抛出异常的三种形式\" class=\"headerlink\" title=\"抛出异常的三种形式\"></a>抛出异常的三种形式</h2><p>Java 抛出异常有三种形式：</p>\n<ul>\n<li>系统自动抛出异常</li>\n<li>方法名通过 throws 抛出异常</li>\n<li>方法体通过 throw 抛出异常</li>\n</ul>\n<h3 id=\"系统自动抛出异常\"><a href=\"#系统自动抛出异常\" class=\"headerlink\" title=\"系统自动抛出异常\"></a>系统自动抛出异常</h3><p>当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常。发生异常后线程停止运行，后面的语句执行不到，会在包含它的所有 try 块中（可能在上层调用函数中）从里向外寻找含有与其匹配的 catch 子句的 try 块。如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tint a = 5, b =0;</span><br><span class=\"line\">\tSystem.out.println(5/b);</span><br><span class=\"line\">\t//function();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>系统会自动抛出ArithmeticException异常：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class=\"line\"></span><br><span class=\"line\">at test.ExceptionTest.main(ExceptionTest.java:62)</span><br></pre></td></tr></table></figure>\n\n<p>再如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tString s = &quot;abc&quot;;</span><br><span class=\"line\">\tSystem.out.println(Double.parseDouble(s));</span><br><span class=\"line\">\t//function();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>系统会自动抛出NumberFormatException异常：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1224)</span><br><span class=\"line\"></span><br><span class=\"line\">at java.lang.Double.parseDouble(Double.java:510)</span><br><span class=\"line\"></span><br><span class=\"line\">at test.ExceptionTest.main(ExceptionTest.java:62)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"throw-抛出异常\"><a href=\"#throw-抛出异常\" class=\"headerlink\" title=\"throw 抛出异常\"></a>throw 抛出异常</h3><p>throw 出现在方法体中，用于程序员主动抛出某种特定类型的异常。通过 throw 抛出的异常和系统自动抛出的异常有相同的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tString s = &quot;abc&quot;;</span><br><span class=\"line\">\tif(s.equals(&quot;abc&quot;)) &#123;</span><br><span class=\"line\">\t\tthrow new NumberFormatException();</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tSystem.out.println(s);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t//function();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>会抛出异常：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.NumberFormatException</span><br><span class=\"line\"></span><br><span class=\"line\">at test.ExceptionTest.main(ExceptionTest.java:67)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"throws-抛出异常\"><a href=\"#throws-抛出异常\" class=\"headerlink\" title=\"throws 抛出异常\"></a>throws 抛出异常</h3><p>throws 出现方法头中，用来声明该方法可能抛出的异常类型，然后把异常交给调用它的上级程序来处理。</p>\n<p>对于 Error 和 RuntimeException 类型的及其子类的异常，不需要在方法头通过 throws 明确声明，因为这是不期待出现的异常。对于其他类型的异常 Java 编译器强制要求在方法头 通过 throws 明确声明，否则编译不通过。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void function() throws NumberFormatException&#123;</span><br><span class=\"line\">\tString s = &quot;abc&quot;;</span><br><span class=\"line\">\tSystem.out.println(Double.parseDouble(s));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tfunction();</span><br><span class=\"line\">\t&#125; catch (NumberFormatException e) &#123;</span><br><span class=\"line\">\t\tSystem.err.println(&quot;非数据类型不能转换。&quot;);</span><br><span class=\"line\">\t\t//e.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">非数据类型不能转换。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"throw-和-throws-的区别和用法\"><a href=\"#throw-和-throws-的区别和用法\" class=\"headerlink\" title=\"throw 和 throws 的区别和用法\"></a>throw 和 throws 的区别和用法</h2><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ul>\n<li>throws 用于方法头，throw 用于方法内部</li>\n<li>throws 后跟异常类型，表示可能会出现这些类型的异常，但是不一定抛出；throw 后跟异常对象，如果执行到 throw 就一定会抛出这种类型的异常。</li>\n<li>throw 后只能跟一个异常对象，throws 后可以一次声明多种异常类型。</li>\n</ul>\n<h3 id=\"使用场合\"><a href=\"#使用场合\" class=\"headerlink\" title=\"使用场合\"></a>使用场合</h3><p>Java 将派生于 Error 类和 RuntimeException 类的异常称为 <strong>非检查异常</strong> (unchecked exception)，将其他异常称为 <strong>检查异常</strong> (checked exception)。</p>\n<p>一般来说，系统在编译阶段检查的是检查异常和 throws 声明的异常，在运行阶段自动抛出的是非检查异常。</p>\n<p>对于检查异常，如果通过 throw 主动抛出，或者调用了可能会产生异常的方法但是又没有进行处理，必须在方法头上用 throws 显式声明该异常类型，否则编译器会报错。如下面 IOException 为检查异常</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//通过throw主动抛出</span><br><span class=\"line\">public void throwEx1() throws IOException &#123; //正常编译</span><br><span class=\"line\">    throw new IOException(&quot;.&quot;); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void throwEx2() &#123; //编译报错 unhandled exception java.io.ioexeption</span><br><span class=\"line\">    throw new IOException(&quot;.&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//调用可能会产生异常的方法但是没有进行处理</span><br><span class=\"line\">public void throwEx3() throws IOException&#123; //正常编译</span><br><span class=\"line\">    FileInputStream input = new FileInputStream(&quot;xxx&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void throwEx4() &#123; //编译报错 unhandled exception java.io.ioexeption</span><br><span class=\"line\">    FileInputStream input = new FileInputStream(&quot;xxx&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于非检查异常，如果通过 throw 主动抛出，可自行选择是否在方法头用 throws 显式声明，不声明编译也不会报错。如下面 SQLException 为非检查异常</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void throwEx5() throws SQLException&#123; //正常编译</span><br><span class=\"line\">    throw new IllegalStateException(&quot;.&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void throwEx6() &#123; //正常编译</span><br><span class=\"line\">    throw new IllegalStateException(&quot;.&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果调用方法名包含 throws 异常类型的方法，必须<em>在方法内通过 <code>try...catch</code> 捕获，或者继续在方法名上用 throws 声明继续往上抛</em>。例如调用上面的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void throwEx7() &#123;</span><br><span class=\"line\">    throwEx1(); //编译报错 unhandled exception java.io.ioexeption</span><br><span class=\"line\">    throwEx5(); //编译报错 unhandled exception java.sql.sqlexeption</span><br><span class=\"line\">    throwEx6(); //正常编译</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void throwEx8() throws IOException, SQLException&#123;</span><br><span class=\"line\">    throwEx1(); //正常编译</span><br><span class=\"line\">    throwEx5(); //正常编译</span><br><span class=\"line\">    throwEx6(); //正常编译</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编程总结\"><a href=\"#编程总结\" class=\"headerlink\" title=\"编程总结\"></a>编程总结</h3><ol>\n<li>在写程序时，对可能会出现异常的部分通常要用 <code>try&#123;...&#125;catch&#123;...&#125;</code> 去捕捉它并对它进行处理</li>\n<li>用 <code>try&#123;...&#125;catch&#123;...&#125;</code> 捕捉了异常之后一定要对在 <code>catch&#123;...&#125;</code> 中对其进行处理，那怕是最简单的一句输出语句，或栈输入 <code>e.printStackTrace()</code></li>\n<li>如果是捕捉 IO 输入输出流中的异常，一定要在 <code>try&#123;...&#125;catch&#123;...&#125;</code> 后加 <code>finally&#123;...&#125;</code> 把输入输出流关闭；</li>\n<li>如果在函数体内用 throw 抛出了某种异常，最好要在函数名中加 throws 抛异常声明，然后交给调用它的上层函数进行处理。</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/luoweifu/article/details/10721543\">再探java基础——throw与throws</a><br><a href=\"https://zhidao.baidu.com/question/519014936.html?si=2&qbpn=1_2&tx=&wtp=wk&word=Java%EF%BC%9Athrow%E5%92%8Cthrows%E6%9C%89%E5%BF%85%E8%A6%81%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F&fr=solved&from=qb&ssid=&uid=bd_1492636518_230&pu=sz@224_240,os@&step=2&bd_page_type=1&init=middle\">百度问答</a></p>\n","categories":["Java","Java异常"],"tags":["Java","异常处理"]},{"title":"js时间操作","url":"/2018/07/23/js%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/","content":"<blockquote>\n<p>总结了 js 中常用的时间操作和格式化的方法，在这里记录一下以供日后查阅。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"js-时间初始化和常用方法\"><a href=\"#js-时间初始化和常用方法\" class=\"headerlink\" title=\"js 时间初始化和常用方法\"></a>js 时间初始化和常用方法</h2><h3 id=\"初始化时间\"><a href=\"#初始化时间\" class=\"headerlink\" title=\"初始化时间\"></a>初始化时间</h3><h4 id=\"1、获取系统当前时间\"><a href=\"#1、获取系统当前时间\" class=\"headerlink\" title=\"1、获取系统当前时间\"></a>1、获取系统当前时间</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var date = new Date() //获取当前系统时间</span><br></pre></td></tr></table></figure>\n\n<p>返回一个表示系统当前时间的 Date 对象。</p>\n<h4 id=\"2、根据整数参数初始化\"><a href=\"#2、根据整数参数初始化\" class=\"headerlink\" title=\"2、根据整数参数初始化\"></a>2、根据整数参数初始化</h4><p>格式： <code>new Date(year, month, date, hour, minute, second) </code><br>说明： 按给定的参数创建 Date 对象，参数范围如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>year</td>\n<td>四位整数表示年份，如果提供两位整数默认补全 19 开头</td>\n</tr>\n<tr>\n<td>month</td>\n<td>0-11 表示 1到12月份</td>\n</tr>\n<tr>\n<td>date</td>\n<td>1-31 表示 1到31日</td>\n</tr>\n<tr>\n<td>hour</td>\n<td>0-23 表示 1到24小时</td>\n</tr>\n<tr>\n<td>minute</td>\n<td>0-59 表示 1到60分钟</td>\n</tr>\n<tr>\n<td>second</td>\n<td>0-59 表示 1到60秒</td>\n</tr>\n</tbody></table>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var date = new Date(2018, 01, 01) //Thu Feb 01 2018 00:00:00 GMT+0800 (中国标准时间)</span><br><span class=\"line\"></span><br><span class=\"line\">var date = new Date(2018, 01, 01, 01) //Thu Feb 01 2018 01:00:00 GMT+0800 (中国标准时间)</span><br><span class=\"line\"></span><br><span class=\"line\">var date = new Date(2018, 01, 01, 01, 01, 01, 01) //Thu Feb 01 2018 01:01:01 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、根据字符串参数初始化\"><a href=\"#3、根据字符串参数初始化\" class=\"headerlink\" title=\"3、根据字符串参数初始化\"></a>3、根据字符串参数初始化</h4><p>格式： <code>new Date(&#39;year-month-day hour:minute:second&#39;)</code><br>说明： 通过字符串内容来创建 Date 对象，日期部分可以写成 <code>&#39;year-month-day&#39;</code>，<code>&#39;year month day&#39;</code>，<code>&#39;year/month/day&#39;</code> 和 <code>&#39;year.month.day&#39;</code>等格式，时间部分写成 <code>&#39;hour:minute:second&#39;</code>，两部分以空格隔开，最常用的写法是 <code>&#39;year-month-day hour:minute:second&#39;</code><br>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var date = new Date(&#x27;2018-02-02&#x27;) //Fri Feb 02 2018 08:00:00 GMT+0800 (中国标准时间)</span><br><span class=\"line\"></span><br><span class=\"line\">var date = new Date(&#x27;2018/02/02&#x27;) //Fri Feb 02 2018 08:00:00 GMT+0800 (中国标准时间)</span><br><span class=\"line\"></span><br><span class=\"line\">var date = new Date(&#x27;2018-02-02 02:02:02&#x27;) //Fri Feb 02 2018 02:02:02 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4、根据时间戳参数初始化\"><a href=\"#4、根据时间戳参数初始化\" class=\"headerlink\" title=\"4、根据时间戳参数初始化\"></a>4、根据时间戳参数初始化</h4><blockquote>\n<p>时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。时间戳唯一地标识某一刻的时间。</p>\n</blockquote>\n<p>格式： <code>new Date(timestamp)</code><br>说明： 通过时间戳来创建 Date 对象，时间戳可以为负数，表示 1970 年以前的时间<br>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var date = new Date(1520017383000) //Sat Mar 03 2018 03:03:03 GMT+0800 (中国标准时间)</span><br><span class=\"line\"></span><br><span class=\"line\">var date = new Date(-1520017383000) //Tue Nov 01 1921 12:56:57 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><h4 id=\"1、set-方法\"><a href=\"#1、set-方法\" class=\"headerlink\" title=\"1、set 方法\"></a>1、set 方法</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">date.setTime()  -------以毫秒设置时间</span><br><span class=\"line\">date.setDate()  -------设置月中某一天(1-31)</span><br><span class=\"line\">date.setMonth() -------设置年中某一月(0-11)</span><br><span class=\"line\">date.setFullYear() ----设置年份(4位数,2位数不支持了)</span><br><span class=\"line\">date.setHours() -------设置某一天中小时(0-23)</span><br><span class=\"line\">date.setMinutes()   ---设置某一小时中分钟(0-59)</span><br><span class=\"line\">date.setSeconds()   ---设置某一小时中秒数(0-59)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、get-方法\"><a href=\"#2、get-方法\" class=\"headerlink\" title=\"2、get 方法\"></a>2、get 方法</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">date.getDate()  -------获取月中某一天(1-31)</span><br><span class=\"line\">date.getMonth() -------获取年中某一月(0-11)</span><br><span class=\"line\">date.getDay()   -------获取星期中某一天的编号(0-6),星期天为0</span><br><span class=\"line\">date.getFullYear()  ---获取四位数年份(2位数被代替了)</span><br><span class=\"line\">date.getHours() -------获取天中的小时(0-23)</span><br><span class=\"line\">date.getMinutes()   ---获取小时中分钟(0-59)</span><br><span class=\"line\">date.getSeconds()   ---获取分钟中秒(0-59)</span><br><span class=\"line\">date.getMillSeconds() -获取毫秒值(0-999)</span><br><span class=\"line\">date.getTime()  -------获取时间戳</span><br><span class=\"line\">Date.parse(&#x27;str&#x27;)   ---解析 str 字符串返回时间戳</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、toString-类方法\"><a href=\"#3、toString-类方法\" class=\"headerlink\" title=\"3、toString 类方法\"></a>3、toString 类方法</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">date.toString()  ----------返回日期时间，如 Mon Jul 24 2017 14:47:31 GMT+0800 (中国标准时间)</span><br><span class=\"line\">date.toTimeString() -------返回时间，如 14:49:06 GMT+0800 (中国标准时间)</span><br><span class=\"line\">date.toDateString() -------返回日期，如 Mon Jul 24 2017</span><br><span class=\"line\">date.toLocaleString() -----返回本地化的日期时间，如 2017/7/24 下午2:51:34</span><br><span class=\"line\">date.toLocaleDateString() -返回本地化的日期，如 2017/7/24</span><br><span class=\"line\">date.toLocaleTimeString() -返回本地化的时间，如 下午2:52:32</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日期时间格式化\"><a href=\"#日期时间格式化\" class=\"headerlink\" title=\"日期时间格式化\"></a>日期时间格式化</h2><p>原生 js 并没有格式化日期时间的方法，需要发开人员自己写方法来格式化日期。</p>\n<h3 id=\"最简单的写法\"><a href=\"#最简单的写法\" class=\"headerlink\" title=\"最简单的写法\"></a>最简单的写法</h3><p>思路是获取需要格式化日期的 Date 对象，调用该对象的 get 类方法获取单独部分，最后再把单独部分拼装成完整的日期时间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//昨天的时间</span><br><span class=\"line\">var day1 = new Date();</span><br><span class=\"line\">day1.setTime(day1.getTime()-24*60*60*1000); //1、时间戳</span><br><span class=\"line\">day1.setDate(day1.getDate() - 1); //2、通过 get、set 方法</span><br><span class=\"line\">var s1 = day1.getFullYear()+&quot;-&quot; + (day1.getMonth()+1) + &quot;-&quot; + day1.getDate();</span><br><span class=\"line\"></span><br><span class=\"line\">//今天的时间</span><br><span class=\"line\">var day2 = new Date();</span><br><span class=\"line\">var s2 = day2.getFullYear()+&quot;-&quot; + (day2.getMonth()+1) + &quot;-&quot; + day2.getDate();</span><br><span class=\"line\"></span><br><span class=\"line\">//明天的时间</span><br><span class=\"line\">var day3 = new Date();</span><br><span class=\"line\">day3.setTime(day3.getTime()+24*60*60*1000); //1、时间戳</span><br><span class=\"line\">day3.setDate(day3.getDate() + 1); //2、通过 get、set 方法</span><br><span class=\"line\">var s3 = day3.getFullYear()+&quot;-&quot; + (day3.getMonth()+1) + &quot;-&quot; + day3.getDate();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"封装格式化方法\"><a href=\"#封装格式化方法\" class=\"headerlink\" title=\"封装格式化方法\"></a>封装格式化方法</h3><p>封装格式化方法，传入格式化字符串参数如 <code>yyyy-MM-dd HH:mm:ss</code> 可返回格式化后的日期。在网上找到两个方法，记录一下。</p>\n<h4 id=\"1、第一个方法\"><a href=\"#1、第一个方法\" class=\"headerlink\" title=\"1、第一个方法\"></a>1、第一个方法</h4><p>为 Date 原型添加方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Date.prototype.format = function(fmt) &#123; </span><br><span class=\"line\">     var o = &#123; </span><br><span class=\"line\">        &quot;M+&quot; : this.getMonth()+1,                 //月份 </span><br><span class=\"line\">        &quot;d+&quot; : this.getDate(),                    //日 </span><br><span class=\"line\">        &quot;h+&quot; : this.getHours(),                   //小时 </span><br><span class=\"line\">        &quot;m+&quot; : this.getMinutes(),                 //分 </span><br><span class=\"line\">        &quot;s+&quot; : this.getSeconds(),                 //秒 </span><br><span class=\"line\">        &quot;q+&quot; : Math.floor((this.getMonth()+3)/3), //季度 </span><br><span class=\"line\">        &quot;S&quot;  : this.getMilliseconds()             //毫秒 </span><br><span class=\"line\">    &#125;; </span><br><span class=\"line\">    if(/(y+)/.test(fmt)) &#123;</span><br><span class=\"line\">            fmt=fmt.replace(RegExp.$1, (this.getFullYear()+&quot;&quot;).substr(4 - RegExp.$1.length)); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     for(var k in o) &#123;</span><br><span class=\"line\">        if(new RegExp(&quot;(&quot;+ k +&quot;)&quot;).test(fmt))&#123;</span><br><span class=\"line\">             fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((&quot;00&quot;+ o[k]).substr((&quot;&quot;+ o[k]).length)));</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    return fmt; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var time1 = new Date().format(&quot;yyyy-MM-dd hh:mm:ss&quot;); //2018-07-23 12:13:14</span><br><span class=\"line\"></span><br><span class=\"line\">var time2 = new Date().format(&quot;yyyy-MM-dd&quot;); ////2018-07-23</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、第二个方法\"><a href=\"#2、第二个方法\" class=\"headerlink\" title=\"2、第二个方法\"></a>2、第二个方法</h4><p>传入需要被格式化的日期 date 和格式化字符串 datestr，其中 datestr 必须为以下格式</p>\n<ul>\n<li>yyyy-MM-dd </li>\n<li>yyyy&#x2F;MM&#x2F;dd </li>\n<li>yyyy-MM-dd hh:mm:ss </li>\n<li>yyyy&#x2F;MM&#x2F;dd hh:mm:ss </li>\n<li>hh:mm:ss</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function formateDate (date, dateStr) &#123;</span><br><span class=\"line\">    if(typeof date === &quot;number&quot;)&#123;</span><br><span class=\"line\">        var d=new Date();</span><br><span class=\"line\">        d.setTime(date);</span><br><span class=\"line\">        date=d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var arr=dateStr.split(/\\/|-|:| /);  //分割字符串,- / : 空格</span><br><span class=\"line\">    var timeArr=[];</span><br><span class=\"line\">    for (var i = 0; i &lt; arr.length; i++) &#123; //按照需要将日期放入数组timeArr</span><br><span class=\"line\">        switch (arr[i]) &#123;</span><br><span class=\"line\">            case &quot;yyyy&quot;:</span><br><span class=\"line\">                timeArr.push(date.getFullYear());           </span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &quot;MM&quot;:</span><br><span class=\"line\">                timeArr.push(date.getMonth()+1);            </span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &quot;dd&quot;:</span><br><span class=\"line\">                timeArr.push(date.getDate());           </span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &quot;hh&quot;:</span><br><span class=\"line\">                timeArr.push(date.getHours());          </span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &quot;mm&quot;:</span><br><span class=\"line\">                timeArr.push(date.getMinutes());        </span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &quot;ss&quot;:</span><br><span class=\"line\">                timeArr.push(date.getSeconds());</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (var i = 0; i &lt;arr.length; i++) &#123;</span><br><span class=\"line\">        dateStr = dateStr.replace(arr[i],timeArr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return dateStr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/sxxjyj/p/6093326.html\">js获取当前时间(昨天、今天、明天)</a><br><a href=\"https://www.cnblogs.com/tugenhua0707/p/3776808.html\">JS日期格式化转换方法</a><br><a href=\"https://blog.csdn.net/guxiansheng1991/article/details/76020091\">JavaScript 时间操作</a><br><a href=\"https://blog.csdn.net/LavanSum/article/details/72875454\">js 初始化日期对象 new Date() 常用方式</a></p>\n","categories":["前端","javascript"],"tags":["javascript"]},{"title":"Java集合框架总结","url":"/2018/07/12/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/","content":"<blockquote>\n<p>之前对 Java 集合框架的了解仅仅停留在知道怎么使用一些常见集合，对集合框架的使用也没有做深一步的研究，经常被种类繁多的集合框架弄得云里雾里。现在对 Java 集合框架的设计思想和原理进行进一步学习，希望更加熟练灵活地掌握集合框架进而提高我们的开发效率。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在 Java 2 之前，Java 是没有完整的集合框架的。它只有一些简单的可以自扩展的容器类，比如 Vector，Stack，Hashtable 等。这些容器类在使用的过程中由于效率问题饱受诟病，因此在 Java 2 中，Java 设计者们进行了大刀阔斧的整改，重新设计，于是就有了现在的集合框架。需要注意的是，之前的那些容器类库并没有被弃用而是进行了保留，主要是为了向下兼容的目的，但我们在平时使用中还是应该尽量少用。</p>\n<p><img src=\"/2018/07/12/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/jihe.gif\" alt=\"jihe\"></p>\n<p>从上面我们可以看到 Java 集合框架主要有 <strong>Collection</strong> 和 <strong>Map</strong> 两种类型的容器接口，再下面是一些子接口或者抽象类，最后是具体实现类。：</p>\n<ul>\n<li>Collection 集合接口：存储单个元素数据，下面有 3 个经典的子接口类型 <strong>List</strong>、<strong>Set</strong> 和 <strong>Queue</strong>。</li>\n<li>List 代表有序、可重复的集合，常用的实现类有 ArrayList、LinkedList。</li>\n<li>Set 代表无序、不可重复的集合，常用的实现类有 HashSet、TreeSet。</li>\n<li>Queue 代表先进先出的队列集合，常用的实现类有 ArrayDeque、LinkedList。  </li>\n<li>Map 映射接口：存储 key-value 对元素数据，其中 key 是不可重复的。常用的实现类有 HashMap、TreeMap 等。</li>\n</ul>\n<h2 id=\"Collection-接口\"><a href=\"#Collection-接口\" class=\"headerlink\" title=\"Collection 接口\"></a>Collection 接口</h2><p>Collection 接口是集合的根接口，定义对集合元素进行操作的通用方法。Collection 的框架图如下所示：</p>\n<p><img src=\"/2018/07/12/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/collection.png\" alt=\"collection\"></p>\n<p>Collection 接口定义的所有方法如下所示：</p>\n<div style='width: 60%'>![colfunc](colfunc.jpeg)</div>\n常用的方法有 `add()` 添加一个元素到集合中，`addAll()` 将指定集合中的所有元素添加到另外一个集合中，`contains()` 方法检测集合中是否包含指定的元素，`toArray()` 方法返回一个表示集合的数组，`iterator()` 获取集合的迭代器来遍历集合。\n\n<h3 id=\"遍历-Collection\"><a href=\"#遍历-Collection\" class=\"headerlink\" title=\"遍历 Collection\"></a>遍历 Collection</h3><p>由上图可见 Collection 接口包含 Iterator 变量，且继承了 Iterable 接口，根据官方文档</p>\n<blockquote>\n<p>Implementing this interface allows an object to be the target of the “for-each loop” statement.</p>\n</blockquote>\n<p>所以 Collection 接口下的所有集合都可以通过 <strong>for-each 循环</strong> 或者 <strong>Iterator 迭代器</strong> 两种方法进行遍历。对于 List 类集合还可以通过 <strong>索引值</strong> 来遍历或者获取指定位置的元素。</p>\n<ul>\n<li>for-each 循环遍历</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">//往list里面添加元素</span><br><span class=\"line\">for(String item : list)&#123; //每一次循环把元素放到item变量里面</span><br><span class=\"line\">    //对取出的元素进行操作</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Iterator 迭代器遍历</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">//往list里面添加元素</span><br><span class=\"line\">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class=\"line\">while(iterator.hasNext())&#123; //判断是否有下一个元素</span><br><span class=\"line\">    String item = iterator.next(); //取出该元素放到item变量里面</span><br><span class=\"line\">    //对取出的元素进行操作</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>索引值获取元素</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">//往list里面添加元素</span><br><span class=\"line\">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">   String item = list.get(i); //取出该元素放到item变量里面   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Collection-元素比较\"><a href=\"#Collection-元素比较\" class=\"headerlink\" title=\"Collection 元素比较\"></a>Collection 元素比较</h3><p>Collection 集合的元素比较大小可以通过实现 Comparable 接口 ，然后 覆盖 compareTo(Object obj) 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public int compare(Integer o1, Integer o2) &#123;</span><br><span class=\"line\">    return o1 - o2; //从小到大排序</span><br><span class=\"line\">    //return o2 - o1; //从大到小排序</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>部分 Collection 集合例如 TreeSet、PriorityQueue 等类已经实现了 Comparable 接口，默认从小到大的自然排序。</p>\n<p>如果我们不想用自然排序，像用其他方式进行排序，我们可以新建一个 Comparator 比较器，在创建集合的时候提供 Comparator。</p>\n<p>例如下面对 PriorityQueue 中的元素进行比较，并且也可以覆盖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void defaultCompareQueue() &#123;</span><br><span class=\"line\">    //实现 Comparable 接口的 PriorityQueue 类，默认从小到大的自然排序</span><br><span class=\"line\">    PriorityQueue&lt;Integer&gt; q1 = new PriorityQueue&lt;&gt;();</span><br><span class=\"line\">    q1.add(2);</span><br><span class=\"line\">    q1.add(4);</span><br><span class=\"line\">    q1.add(9);</span><br><span class=\"line\">    q1.add(1);</span><br><span class=\"line\">    while (!q1.isEmpty()) &#123;</span><br><span class=\"line\">        System.out.print(q1.poll() + &quot;,&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void defineCompareQueue1() &#123;</span><br><span class=\"line\">    //自定义一个 Comparator，采用从大到小的降序排序</span><br><span class=\"line\">    Comparator&lt;Integer&gt; cmp = new Comparator&lt;Integer&gt;() &#123;</span><br><span class=\"line\">        public int compare(Integer e1, Integer e2) &#123;</span><br><span class=\"line\">            return e2 - e1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    //在新建集合时候提供上面的 Comparator</span><br><span class=\"line\">    PriorityQueue&lt;Integer&gt; q2 = new PriorityQueue&lt;&gt;(5, cmp);</span><br><span class=\"line\">    q2.add(2);</span><br><span class=\"line\">    q2.add(4);</span><br><span class=\"line\">    q2.add(9);</span><br><span class=\"line\">    q2.add(1);</span><br><span class=\"line\">    while (!q2.isEmpty()) &#123;</span><br><span class=\"line\">        System.out.print(q2.poll() + &quot;,&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void defineCompareQueue2() &#123;</span><br><span class=\"line\">    //初始化集合时直接提供自定义的 Comparator，采用从小到大的降序排序</span><br><span class=\"line\">    PriorityQueue&lt;Integer&gt; q3 = new PriorityQueue&lt;&gt;(</span><br><span class=\"line\">            new Comparator&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public int compare(Integer o1, Integer o2) &#123;</span><br><span class=\"line\">                    return o2 - o1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    q3.add(2);</span><br><span class=\"line\">    q3.add(4);</span><br><span class=\"line\">    q3.add(9);</span><br><span class=\"line\">    q3.add(1);</span><br><span class=\"line\">    while (!q3.isEmpty()) &#123;</span><br><span class=\"line\">        System.out.print(q3.poll() + &quot;,&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"一、List\"><a href=\"#一、List\" class=\"headerlink\" title=\"一、List\"></a>一、List</h3><p>List 是一个可重复的有序集合。元素会增加到容器中的特定位置。除了常规的 Iterator 迭代器，还增加了能够双向遍历线性表的列表迭代器 ListIterator。List 可以通过 <strong>for-each 循环</strong>、<strong>Iterator 迭代器</strong> 和 <strong>索引值</strong> 三种方法进行访问。</p>\n<p>下面介绍 List 接口的两个重要的具体实现类，也是我们可能最常用的类，<strong>ArrayList</strong> 和 <strong>LinkedList</strong>。</p>\n<h4 id=\"1、ArrayList\"><a href=\"#1、ArrayList\" class=\"headerlink\" title=\"1、ArrayList\"></a>1、ArrayList</h4><p><em><strong>ArrayList 是一个动态扩展的数组</strong></em>。它用数组存储元素，这个数组可以动态创建，如果元素个数超过了数组的容量，那么就创建一个更大的新数组，并将当前数组中的所有元素都复制到新数组中。因为基于数组的结构，所以 ArrayList 通过索引值来获取指定元素的效率很高。</p>\n<p>下面是 ArrayList 初始化的源码部分，从中我们可以看到 ArrayList 创建动态数组的过程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">private static final int DEFAULT_CAPACITY = 10; //默认容量</span><br><span class=\"line\"></span><br><span class=\"line\">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //空数组</span><br><span class=\"line\"></span><br><span class=\"line\">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; //默认容量空数组</span><br><span class=\"line\"></span><br><span class=\"line\">transient Object[] elementData; //用非序列化的数组临时存储元素</span><br><span class=\"line\"></span><br><span class=\"line\">private int size; //数组长度</span><br><span class=\"line\"></span><br><span class=\"line\">public ArrayList(int initialCapacity) &#123; //传入容量参数创建 ArrayList，如果容量为0就用默认容量</span><br><span class=\"line\">    if (initialCapacity &gt; 0) &#123;</span><br><span class=\"line\">        this.elementData = new Object[initialCapacity];</span><br><span class=\"line\">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class=\"line\">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public ArrayList() &#123; //没有传入容量就创建默认容量数组</span><br><span class=\"line\">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public boolean add(E e) &#123; //向集合中添加指定元素。</span><br><span class=\"line\">    ensureCapacityInternal(size + 1);</span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void ensureCapacityInternal(int minCapacity) &#123; //比较所需要的最小容量和目前数组的长度length(不管数组上是否有元素)，如果前者比后者大就新建更大容量的数组</span><br><span class=\"line\">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    if (minCapacity - elementData.length &gt; 0)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void grow(int minCapacity) &#123; //创建更大容量的数组，然后将旧数组的元素复制到新数组中。</span><br><span class=\"line\">    // overflow-conscious code</span><br><span class=\"line\">    int oldCapacity = elementData.length;</span><br><span class=\"line\">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class=\"line\">    if (newCapacity - minCapacity &lt; 0)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    // minCapacity is usually close to size, so this is a win:</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ArrayList-和-Vector-比较\"><a href=\"#ArrayList-和-Vector-比较\" class=\"headerlink\" title=\"ArrayList 和 Vector 比较\"></a>ArrayList 和 Vector 比较</h4><p>ArrayList 和 Vector 的功能非常类似，区别是 ArrayList 是线程不安全的，Vector 是线程安全的，且 Vector 比 Arraylist 的性能要差，尽量少用 Vector类。如果对线程安全没有要求就用 Arraylist，如果有要求可以参考 java.util.concurrent 并发编程包里面的类。</p>\n<p>Stack 是 Vector 的子类，用户模拟 “栈” 这种数据结构，“栈” 通常是指 “后进先出” (LIFO) 的容器。最后 “push” 进栈的元素，将被最先 “pop” 出栈。Stack 与 Vector 一样，是线程安全的，但是性能较差，尽量少用 Stack 类。如果要实现栈这种数据结构，可以考虑使用 LinkedList。</p>\n<h4 id=\"2、LinkedList\"><a href=\"#2、LinkedList\" class=\"headerlink\" title=\"2、LinkedList\"></a>2、LinkedList</h4><p><em><strong>LinkedList 是以链表的形式来保存元素</strong></em>。除此之外，LinkedList 还实现了 Deque 接口，可以被当作成双端队列来使用，因此既可以被当成栈来使用（实现 Stack 类），也可以当成队列来使用（实现 Queue 类）。</p>\n<p>虽然 LinkedList 也是 List 集合，可以根据索引来随机访问集合中的元素。但是通过索引来访问链表的第 n 个元素，必须从头开始遍历完前面的 n-1 个元素才能访问到目标元素，没有捷径可走，所以 LinkedList 随机访问的性能非常差。</p>\n<p>下面是 LinkedList 初始化的源码部分，我们可以看到 LinkedList 的数据结构和创建过程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">transient int size = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">transient Node&lt;E&gt; first; //链表保存开始节点和最后节点，用于双向修改链表</span><br><span class=\"line\"></span><br><span class=\"line\">transient Node&lt;E&gt; last;</span><br><span class=\"line\"></span><br><span class=\"line\">private static class Node&lt;E&gt; &#123; //每个节点包含元素内容，前驱节点和后驱节点</span><br><span class=\"line\">    E item;</span><br><span class=\"line\">    Node&lt;E&gt; next;</span><br><span class=\"line\">    Node&lt;E&gt; prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        this.item = element;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">        this.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public boolean add(E e) &#123; //添加元素</span><br><span class=\"line\">    linkLast(e);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void linkLast(E e) &#123; //默认在链表最后添加元素</span><br><span class=\"line\">    final Node&lt;E&gt; l = last;</span><br><span class=\"line\">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class=\"line\">    last = newNode;</span><br><span class=\"line\">    if (l == null)</span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        l.next = newNode;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ArrayList-和-LinkedList-比较\"><a href=\"#ArrayList-和-LinkedList-比较\" class=\"headerlink\" title=\"ArrayList 和 LinkedList 比较\"></a>ArrayList 和 LinkedList 比较</h4><ul>\n<li>ArrayList 随机访问效率高，随机插入、随机删除效率低；LinkedList则反之，随机访问效率低，随机插入、随机删除效率高。</li>\n<li>ArrayList 使用随机访问来遍历效率高，LinkedList 使用逐个遍历效率高。</li>\n<li>如果需要经常随机插入、删除元素，应使用 LinkedList；如果需要随机快速访问元素，应使用 ArrayList。</li>\n</ul>\n<h3 id=\"二、Set\"><a href=\"#二、Set\" class=\"headerlink\" title=\"二、Set\"></a>二、Set</h3><p>Set 是无序的不允许重复的集合。如果试图把两个相同的元素加入同一个 Set 集合中，则添加操作失败，add() 方法返回 false，且新元素不会被加入。</p>\n<h4 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h4><p>在介绍 Set 集合之前我们先来认识一下哈希表。</p>\n<h5 id=\"什么是散列表\"><a href=\"#什么是散列表\" class=\"headerlink\" title=\"什么是散列表\"></a>什么是散列表</h5><p>当我们用数组来存储元素，然后通过把元素的关键字通过某个函数映射到数组中的某个位置，然后把元素存储在该位置上。这样我们通过关键字就可以迅速查找到元素的数组位置，然后访问该位置上的元素。这种方式实现的数组就叫做 <strong>哈希表</strong> (hash table)，把关键字映射成存储位置的函数就叫做 <strong>哈希函数</strong> (hash function)，映射后得到一个整数值叫做 <strong>哈希码</strong> (hash code)。如下图所示</p>\n<p><img src=\"/2018/07/12/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/hash.png\" alt=\"hash\"></p>\n<h5 id=\"哈希冲突\"><a href=\"#哈希冲突\" class=\"headerlink\" title=\"哈希冲突\"></a>哈希冲突</h5><p>当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的 <strong>哈希冲突</strong>。解决哈希冲突的方法有</p>\n<ul>\n<li>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）</li>\n<li>再哈希法</li>\n<li>拉链法</li>\n<li>建立一个公共溢出区</li>\n</ul>\n<p>例如最常用的 <strong>拉链法</strong> 也被称为 <strong>链表的数组</strong>。散列表的主干是数组，每一个数组元素都叫做 <strong>桶</strong> (bucket)，每个桶存储一个链表，整体看起来就像链表组成的数组。同一个链表上的元素的哈希码相同，不同链表之间的元素的哈希码都不相同。</p>\n<p>要插入一个元素，先计算该元素的散列码，然后与桶的总数取余，得到余数 n 就是该元素应插入到第 n 个桶，然后把元素插入到该桶所在位置。如果该位置没有元素就直接插入，如果该位置已经有元素了，遍历该元素所在的链表，通过 equals 方法进行对比，存在即覆盖，不存在就插入到链表末尾。</p>\n<p>hashCode 方法和 equals 方法的单方面兼容：</p>\n<ul>\n<li>如果 a.equals(b) 为 true，a 和 b 必须有相同的散列码。</li>\n<li>如果 a 和 b 有相同的散列码，a.equals(b) 不一定为 true。</li>\n</ul>\n<p><img src=\"/2018/07/12/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/hashmap.png\" alt=\"hashmap\"></p>\n<p>Set 有三个常见实现类 <strong>TreeSet</strong>、<strong>HashSet</strong>(下面有子类 <strong>LinkedHashSet</strong>)和 <strong>EnumSet</strong>。</p>\n<h4 id=\"1、HashSet\"><a href=\"#1、HashSet\" class=\"headerlink\" title=\"1、HashSet\"></a>1、HashSet</h4><p><em><strong>HashSet 是基于散列表实现的无序 Set 集合</strong></em>。HashSet 中的元素的排序顺序随机分配，所以访问顺序也是随机。</p>\n<p>HashSet 的底层是基于 HashMap 实现的，使用 HashMap 来保存所有元素。因此 HashSet  的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成的。参考 <a href=\"http://zhangshixi.iteye.com/blog/673143\">深入Java集合学习系列：HashSet的实现原理</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public HashSet() &#123;</span><br><span class=\"line\">    map = new HashMap&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、TreeSet\"><a href=\"#2、TreeSet\" class=\"headerlink\" title=\"2、TreeSet\"></a>2、TreeSet</h4><p><em><strong>TreeSet 和 HashSet 类似，但是它是一个不允许重复的有序 Set 集合</strong></em>。可以将任意顺序将元素插入到集合中，在遍历的时候每个值将自动按照排序后的顺序显示。</p>\n<p>TreeSet 使用红黑树的结构来实现排序，每次添加新元素的时候都会从根节点开始跟其他元素进行比较，最终将其放在正确的排序位置上。实际上 TreeSet 的底层是根据 TreeMap 来实现的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public TreeSet() &#123;</span><br><span class=\"line\">    this(new TreeMap&lt;E,Object&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HashSet-和-TreeSet-比较\"><a href=\"#HashSet-和-TreeSet-比较\" class=\"headerlink\" title=\"HashSet 和 TreeSet 比较\"></a>HashSet 和 TreeSet 比较</h4><p>将元素添加到树中比添加到散列表中的速度要慢，所以如果对排序有要求就可以选择 TreeSet，如果无要求就可以选择 HashSet。</p>\n<h3 id=\"三、Queue\"><a href=\"#三、Queue\" class=\"headerlink\" title=\"三、Queue\"></a>三、Queue</h3><p>Queue 用于模拟队列这种数据结构，队列通常是指 <strong>先进先出</strong>（FIFO）的容器。新元素插入到队列的尾部，访问元素操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。</p>\n<p>Queue 常用的实现类有 <strong>PriorityQueue</strong>、<strong>Deque</strong> 接口下的 <strong>ArrayDeque</strong> 和 <strong>LinkedList</strong>。</p>\n<h4 id=\"1、PriorityQueue\"><a href=\"#1、PriorityQueue\" class=\"headerlink\" title=\"1、PriorityQueue\"></a>1、PriorityQueue</h4><p><em><strong>PriorityQueue 是使用 堆(heap) 结构的实现的队列</strong></em>。堆是一种可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花时间对元素进行排序。</p>\n<p>PriorityQueue 中的元素可以按照任意的顺序插入，但是会按队列元素的大小进行重新排序。因此当取出队列中头部的元素时，并不是取出最先进入队列的元素，而是取出队列中的最小的元素。</p>\n<p>PriorityQueue 本质也是一个动态数组，在这一方面与ArrayList是一致的。PriorityQueue 调用默认的构造方法时，使用默认的初始容量（DEFAULT_INITIAL_CAPACITY&#x3D;11）创建一个 PriorityQueue，并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的 Comparable ）。</p>\n<p>另外注意：</p>\n<ul>\n<li>PriorityQueue 不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue 实例，这时请使用线程安全的 PriorityBlockingQueue 类。</li>\n<li>不允许插入 null 元素。</li>\n<li>方法 iterator() 中提供的迭代器并不保证以有序的方式遍历优 PriorityQueue 中的元素。</li>\n</ul>\n<h4 id=\"2、ArrayDeque\"><a href=\"#2、ArrayDeque\" class=\"headerlink\" title=\"2、ArrayDeque\"></a>2、ArrayDeque</h4><p>Deque 接口是 Queue 接口的子接口，它代表一个双端队列。LinkedList 是以链表实现的双端队列，ArrayDeque 是用数组实现的双端队列。两者都维护表示头尾的两个节点。</p>\n<p>ArrayDeque 为了满足可以同时在数组两端插入或删除元素的需求，其内部的动态数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。</p>\n<p>ArrayDeque 不是线程安全的。当作为栈使用时，性能比 Stack 好；当作为队列使用时，性能比 LinkedList 好。</p>\n<h2 id=\"Map-接口\"><a href=\"#Map-接口\" class=\"headerlink\" title=\"Map 接口\"></a>Map 接口</h2><p><em><strong>Map 是用于保存具有映射关系的数据集合</strong></em>。Map 集合里保存着 key 和 value 两组值，key 和 value 都可以是任何引用类型的数据。Map 的 key 不允许重复，同一个 Map 对象的任何两个 key 通过 equals 方法比较总是返回 false。key 和 value 之间存在单向一对一关系，即通过指定的 key，总能找到唯一的、确定的 value。</p>\n<p><img src=\"/2018/07/12/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/map.png\" alt=\"map\"></p>\n<p>Map 接口定义的所有方法如下所示：</p>\n<div style='width: 60%'>![mapfunc](mapfunc.jpeg)</div>\n从上面我们可以看到 key、value 和 key-value 对应的成员变量如下所示：\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set&lt;K&gt; keySet();</span><br><span class=\"line\"></span><br><span class=\"line\">Collection&lt;V&gt; values();</span><br><span class=\"line\"></span><br><span class=\"line\">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>values</code> 是一个 Collection 集合，<code>keySet</code> 和 <code>entrySet</code> 是一个 Set 集合。但是注意这个 Set 集合也不是 HashSet 或者 TreeSet。这里的 Collection 和 Set 集合被称为 <strong>视图</strong> (views)，是其他实现了 Collection 接口和 Set 接口 的类返回的对象。这个视图并没有创建一个新集合，而是返回一个类对象来对原来的映射进行操作。</p>\n<p>另外我们还可以看到 Map 接口 比 Collection 接口多提供了一个 Entry 子接口，一般用 <code>Map.Entry&lt;&gt;</code> 来表示 Map 集合 key-value 对元素类型。</p>\n<h3 id=\"遍历-Map\"><a href=\"#遍历-Map\" class=\"headerlink\" title=\"遍历 Map\"></a>遍历 Map</h3><p>遍历 Map 有三种常用方式</p>\n<ul>\n<li>遍历 keySet()</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">//1.for-each 循环遍历 keySet()</span><br><span class=\"line\">for (String item : map.keySet()) &#123;</span><br><span class=\"line\">    //对取出来的每个key进行下一步操作</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//2.iterator 迭代器遍历 keySet()</span><br><span class=\"line\">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class=\"line\">while (iterator.hasNext()) &#123;</span><br><span class=\"line\">    String item = iterator.next();</span><br><span class=\"line\">    //对取出来的每个key进行下一步操作</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>遍历 values()</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">//1.for-each 循环遍历 values()</span><br><span class=\"line\">for (Integer item : map.values()) &#123;</span><br><span class=\"line\">    //对取出来的每个value进行下一步操作</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//2.iterator 迭代器遍历 values()</span><br><span class=\"line\">Iterator&lt;Integer&gt; iterator = map.values().iterator();</span><br><span class=\"line\">while (iterator.hasNext()) &#123;</span><br><span class=\"line\">    Integer item = iterator.next();</span><br><span class=\"line\">    //对取出来的每个value进行下一步操作</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>遍历 entrySet()</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">//1.for-each 循环遍历 entrySet()</span><br><span class=\"line\">for (Map.Entry&lt;String, Integer&gt; item : map.entrySet()) &#123;</span><br><span class=\"line\">    //对取出来的每个entry进行下一步操作</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//2.iterator 迭代器遍历 entrySet()</span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator2 = map.entrySet().iterator();</span><br><span class=\"line\">while (iterator2.hasNext()) &#123;</span><br><span class=\"line\">    Map.Entry&lt;String, Integer&gt; item = iterator2.next();</span><br><span class=\"line\">    //对取出来的每个entry进行下一步操作</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：</p>\n<ul>\n<li>如果同时需要 key 和 value 的值就用直接遍历 entrySet()，这是最常用的遍历方法。</li>\n<li>如果只需要 key 或者 value 的值，就遍历 keySet() 或者 values()，性能上比遍历 entrySet() 要快 10%～20%。</li>\n<li>通过遍历 keySet()，根据 key 值来获取对应的 value 值的方式性能最低，应尽量避免使用。</li>\n</ul>\n<p>Map 接口下最常用的实现类是 <strong>HashMap</strong> 和 <strong>TreeMap</strong>。</p>\n<h3 id=\"1、HashMap\"><a href=\"#1、HashMap\" class=\"headerlink\" title=\"1、HashMap\"></a>1、HashMap</h3><p><em><strong>HashMap 是基于散列表实现的无序的 Map 集合</strong></em>。实际上 HashMap 是通过 <strong>拉链法</strong> 也就是数组+链表实现的。数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">transient Node&lt;K,V&gt;[] table; //HashMap 的主干是一个 Node 类型的数组</span><br><span class=\"line\"></span><br><span class=\"line\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; //Node节点包含下一个 Node 节点的索引，实际上构成一个链表</span><br><span class=\"line\">    final int hash;</span><br><span class=\"line\">    final K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在访问 HashMap 的时候</p>\n<ul>\n<li>如果定位到的数组位置不含链表（当前 entry 的 next 指向 null ）,那么对于查找，添加等操作很快，仅需一次寻址即可</li>\n<li>如果定位到的数组包含链表，对于添加操作，其时间复杂度为 O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过 key 对象的 equals 方法逐一比对查找。</li>\n</ul>\n<p>所以，性能考虑，HashMap中的链表出现越少，性能才会越好。具体可以参考 <a href=\"https://www.cnblogs.com/chengxiao/p/6059914.html\">HashMap实现原理及源码分析</a></p>\n<h3 id=\"HashMap-与-Hashtable-的区别\"><a href=\"#HashMap-与-Hashtable-的区别\" class=\"headerlink\" title=\"HashMap 与 Hashtable 的区别\"></a>HashMap 与 Hashtable 的区别</h3><p>HashMap 和 Hashtable 的功能和实现机制非常类似，Hashtable 是更早期实现的，现在已经很少用了。两者的区别如下，具体可参考 <a href=\"https://www.cnblogs.com/xinzhao/p/5644175.html\">HashMap和HashTable到底哪不同？</a></p>\n<ul>\n<li>Hashtable 是线程安全的，HashMap 是线程不安全的，因此 HashMap 比 Hashtable 的性能更好一些。</li>\n<li>HashMap 允许 key 或者 value 的值为 null，而 HashTable 的 key 或者 value 不允许为 null，否则会抛出 NullPointerException 异常。</li>\n<li>根据官方注释，HashTable已经被淘汰了，不要在新的代码中再使用它。如果你不需要线程安全，那么使用 HashMap，如果需要线程安全，那么使用 ConcurrentHashMap。</li>\n</ul>\n<h3 id=\"2、TreeMap\"><a href=\"#2、TreeMap\" class=\"headerlink\" title=\"2、TreeMap\"></a>2、TreeMap</h3><p>TreeMap 是基于散列表实现的有序的 Map 集合。TreeMap 会对插入的 key-value 对的 key<br>值进行排序。实际上TreeMap 是基于 <strong>红黑树</strong> (Red-Black Tree) 结构实现的，其排序是通过调整树结构来实现的，红黑树的具体知识参考 <a href=\"http://www.cnblogs.com/skywang12345/p/3245399.html#!comments\">红黑树(一)之 原理和算法详细介绍</a>。</p>\n<p>因为在插入删除元素的时候设计树结构的调整，所以红黑树的插入删除元素性能比较差。</p>\n<h3 id=\"HashMap-和-TreeMap-比较\"><a href=\"#HashMap-和-TreeMap-比较\" class=\"headerlink\" title=\"HashMap 和 TreeMap 比较\"></a>HashMap 和 TreeMap 比较</h3><p>一般的应用场景，尽可能多考虑使用HashMap，因为其为快速查询设计的。如果需要特定的排序时，考虑使用TreeMap。</p>\n<h2 id=\"其他参考\"><a href=\"#其他参考\" class=\"headerlink\" title=\"其他参考\"></a>其他参考</h2><p><a href=\"https://www.jianshu.com/p/63e76826e852\">Java - 集合框架完全解析</a><br><a href=\"https://www.jianshu.com/p/589d58033841\">由浅入深理解java集合(一)——集合框架 Collection、Map</a><br><a href=\"https://www.jianshu.com/p/9081017a2d67\">由浅入深理解java集合(二)——集合 Set</a><br><a href=\"https://www.jianshu.com/p/d436b4cf6b94\">由浅入深理解java集合(三)——集合 List</a><br><a href=\"https://www.jianshu.com/p/35760d7bac0d\">由浅入深理解java集合(四)——集合 Queue</a><br><a href=\"https://www.jianshu.com/p/0580eb808eea\">由浅入深理解java集合(五)——集合 Map</a>  </p>\n","categories":["Java","Java集合"],"tags":["Java","集合"]},{"title":"Java泛型理解","url":"/2018/07/25/Java%E6%B3%9B%E5%BD%A2%E7%90%86%E8%A7%A3/","content":"<blockquote>\n<p>泛型在 Java 中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。在这里简单介绍个人学习 Java 泛型设计过程中的心得总结，如有错误希望大佬们指出。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"1、什么是泛型\"><a href=\"#1、什么是泛型\" class=\"headerlink\" title=\"1、什么是泛型\"></a>1、什么是泛型</h3><p>泛型的本质是 <strong>类型参数</strong>（type parameter），即把类型当一个参数来定义和传递使用。</p>\n<p>我们平时最熟悉的参数是变量参数，即是在方法头声明里面定义变量形参，在使用的时候再传递实参。</p>\n<p>类似于变量参数，<em><strong>类型参数化即把类型由具体的类型参数化（类型形参），在使用的时候再传入具体的类型（类型实参）</strong></em>。这样我们通过传入不同的类型参数就可以创建功能相同，仅仅类型不同的各种类或者方法。这种参数类型可以用在类、接口和方法中，分别被称为 <strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>\n<h3 id=\"2、为什么要用泛型\"><a href=\"#2、为什么要用泛型\" class=\"headerlink\" title=\"2、为什么要用泛型\"></a>2、为什么要用泛型</h3><p>假如我们想要实现一个 String 数组，并且要求它可以动态改变大小，这时我们都会想到用 ArrayList 来聚合 String 对象。然而，过了一阵，我们想要实现一个大小可以改变的 Date 对象数组，这时我们当然希望能够重用之前写过的那个针对 String 对象的 ArrayList 实现。</p>\n<p>在Java 5之前，ArrayList的实现大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class ArrayList &#123;</span><br><span class=\"line\">    public Object get(int i) &#123; ... &#125;</span><br><span class=\"line\">    public void add(Object o) &#123; ... &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    private Object[] elementData;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从以上代码我们可以看到，用于向 ArrayList 中添加元素的 add 函数接收一个 Object 型的参数，从 ArrayList 获取指定元素的 get 方法也返回一个 Object 类型的对象，Object 对象数组 elementData 存放这 ArrayList 中的对象， 也就是说，无论你向 ArrayList 中放入什么类型的类型，到了它的内部，都是一个 Object 对象。</p>\n<p>基于继承的泛型实现会带来两个问题：第一个问题是有关 get 方法的，我们每次调用 get 方法都会返回一个 Object 对象，每一次都要强制类型转换为我们需要的类型，这样会显得很麻烦；第二个问题是有关 add 方法的，假如我们往聚合了 String 对象的 ArrayList 中加入一个 File 对象，编译器不会产生任何错误提示，而这不是我们想要的。</p>\n<p>所以，从 Java 5 开始，ArrayList 在使用时可以加上一个类型参数（type parameter），这个类型参数用来指明 ArrayList 中的元素类型。类型参数的引入解决了以上提到的两个问题，如以下代码所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; s = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">s.add(&quot;abc&quot;);</span><br><span class=\"line\">String s = s.get(0); //无需进行强制转换</span><br><span class=\"line\">s.add(123);  //编译错误，只能向其中添加String对象</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码中，编译器“获知” ArrayList 的类型参数 String 后，便会替我们完成强制类型转换以及类型检查的工作。</p>\n<h2 id=\"泛型的分类\"><a href=\"#泛型的分类\" class=\"headerlink\" title=\"泛型的分类\"></a>泛型的分类</h2><h3 id=\"1、泛型类\"><a href=\"#1、泛型类\" class=\"headerlink\" title=\"1、泛型类\"></a>1、泛型类</h3><h4 id=\"1）定义\"><a href=\"#1）定义\" class=\"headerlink\" title=\"1）定义\"></a>1）定义</h4><p>泛型类（generic class）是具有一个或多个类型变量的类。<em><strong>类型变量用尖括号 <code>&lt;&gt;</code> 括起来，并放在类名后面</strong></em>。泛型类可以有多个类型变量，多个类型变量之前用逗号 <code>,</code> 隔开。</p>\n<p>泛型类中可以用定义的泛型变量指定 <strong>方法的返回类型</strong> 或者 <strong>类变量和局部变量</strong> 的类型等。</p>\n<blockquote>\n<p>类型变量命名常用 E 表示集合的元素类型，K 和 V 表示关键字和值类型，T（或者 U、S ）表示任意类型。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class=\"line\">//在实例化泛型类时，必须指定T的具体类型</span><br><span class=\"line\">public class Pair&lt;T, U&gt; &#123;</span><br><span class=\"line\">    private T first;</span><br><span class=\"line\">    private U second;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Pair(T first, U second) &#123;</span><br><span class=\"line\">        this.first = first;</span><br><span class=\"line\">        this.second = second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public T getFirst() &#123;</span><br><span class=\"line\">        return first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public U getSecond() &#123;</span><br><span class=\"line\">        return second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setFirst(T newValue) &#123;</span><br><span class=\"line\">        first = newValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setSecond(U newValue) &#123;</span><br><span class=\"line\">        second = newValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码中我们可以看到，泛型类 Pair 的类型参数为 T、U，放在类名后的尖括号中。类中可以使用 T 和 U 表示类变量类型或者方法返回类型等如 <code>private T first</code>。</p>\n<h4 id=\"2）使用\"><a href=\"#2）使用\" class=\"headerlink\" title=\"2）使用\"></a>2）使用</h4><p>在实例化泛型类时，我们需要把具体类型当作实参传递进来。<em><strong>注意泛型的参数类型只能是类类型，不能是简单类型</strong></em>。如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Pair&lt;String, Integer&gt; pair = new Pair&lt;String, Integer&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>在 Java 7 版本以后，编译器可以根据变量声明里面的具体类型自动推断出构造函数的具体类型，也就是说构造函数可以省略具体类型，我们可以这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Pair&lt;String, Integer&gt; pair = new Pair&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<h4 id=\"3）继承\"><a href=\"#3）继承\" class=\"headerlink\" title=\"3）继承\"></a>3）继承</h4><p>泛型类也可以被继承，但是使用效果不是很好。一般用 <strong>泛型通配符</strong> 代替使用，后面详细介绍。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class PairChild&lt;T, U, S&gt; extends Pair&lt;T, U&gt; &#123; //可以继承父类的泛型类型并添加新的泛型类型，但是不经常用</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、泛型接口\"><a href=\"#2、泛型接口\" class=\"headerlink\" title=\"2、泛型接口\"></a>2、泛型接口</h3><h4 id=\"1）定义-1\"><a href=\"#1）定义-1\" class=\"headerlink\" title=\"1）定义\"></a>1）定义</h4><p><strong>泛型接口</strong> (generic interface)和泛型类的使用基本类似，<em><strong>在接口名后加 <code>&lt;&gt;</code> 括起来的类型变量</strong></em>，例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public interface Generator&lt;T&gt; &#123;</span><br><span class=\"line\">    public T next();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2）实现\"><a href=\"#2）实现\" class=\"headerlink\" title=\"2）实现\"></a>2）实现</h4><p>未传入泛型实参</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span><br><span class=\"line\"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class=\"line\"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public T next() &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>传入泛型实参</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 传入泛型实参时：</span><br><span class=\"line\"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span><br><span class=\"line\"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span><br><span class=\"line\"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span><br><span class=\"line\"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class FruitGenerator implements Generator&lt;String&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String next() &#123;</span><br><span class=\"line\">        Random rand = new Random();</span><br><span class=\"line\">        return fruits[rand.nextInt(3)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、泛型方法\"><a href=\"#3、泛型方法\" class=\"headerlink\" title=\"3、泛型方法\"></a>3、泛型方法</h3><h4 id=\"1）定义-2\"><a href=\"#1）定义-2\" class=\"headerlink\" title=\"1）定义\"></a>1）定义</h4><p><strong>泛型方法</strong> 是指 <em><strong><code>&lt;&gt;</code> 括起来的类型变量放在修饰符（如 public static）后面，返回类型前面的方法</strong></em>。泛型方法可以定义在普通类中，也可以定义在泛型类中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class ArrayAlg &#123;</span><br><span class=\"line\">    public static &lt;T&gt; T getMiddle(T... a) &#123; //传入个数未知的 T 类型变量，T 类型必须为前面 &lt;&gt; 内定义的类型</span><br><span class=\"line\">        return a[a.length / 2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面 <code>getMiddle </code> 就是一个在普通类 ArrayAlg 里面声明的泛型方法。在方法内可以使用定义的类型变量 T 来作为返回类型或者变量类型。</p>\n<p>注意，方法头在返回值前面没有<code>&lt;&gt;</code> 括起来的类型变量都不是泛型方法。例如下面这个方法不是泛型方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void getMiddle(Pair&lt;String, Integer&gt; param) &#123; //该方法只是使用了泛型类型的参数的普通方法，不是泛型方法</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2）使用-1\"><a href=\"#2）使用-1\" class=\"headerlink\" title=\"2）使用\"></a>2）使用</h4><p>我们可以在方法名前传入具体类型来调用，如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ArrayAlg.&lt;String&gt;getMiddle(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;); // 编译器提示 Explicit type arguments can be inferred</span><br></pre></td></tr></table></figure>\n\n<p>上面警告实际上是由于 Java 7 以后编译器可以通过传入的变量实参推断出所需要的具体类型，所以我们可以简化成这样的写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ArrayAlg.getMiddle(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>但是这种写法有一种弊端就是如果传入了不符合要求的类型，编译器也不会报错，在运行阶段才会抛出异常。解决办法是采用第一种调用方法，即在方法名前加具体类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ArrayAlg.getMiddle(&quot;aa&quot;, &quot;bb&quot;, 111); //编译器通过，但是如果我们希望传入的都是 String 类型的参数，最后一个整形参数可能会产生异常</span><br><span class=\"line\"></span><br><span class=\"line\">ArrayAlg.&lt;String&gt;getMiddle(&quot;aa&quot;, &quot;bb&quot;, 111); //编译器提示错误，可以在编译阶段就发现错误</span><br></pre></td></tr></table></figure>\n\n<p>可以看下这个具体一点的例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class GenericFruit &#123;</span><br><span class=\"line\">    class Fruit&#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;fruit&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Apple extends Fruit&#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;apple&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Person&#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;Person&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class GenerateTest&lt;T&gt;&#123;</span><br><span class=\"line\">        public void show_1(T t)&#123;</span><br><span class=\"line\">            System.out.println(t.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span><br><span class=\"line\">        //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span><br><span class=\"line\">        public &lt;E&gt; void show_3(E t)&#123;</span><br><span class=\"line\">            System.out.println(t.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span><br><span class=\"line\">        public &lt;T&gt; void show_2(T t)&#123;</span><br><span class=\"line\">            System.out.println(t.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Apple apple = new Apple();</span><br><span class=\"line\">        Person person = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">        GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;();</span><br><span class=\"line\">        //apple是Fruit的子类，所以这里可以</span><br><span class=\"line\">        generateTest.show_1(apple);</span><br><span class=\"line\">        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span><br><span class=\"line\">        //generateTest.show_1(person);</span><br><span class=\"line\"></span><br><span class=\"line\">        //使用这两个方法都可以成功</span><br><span class=\"line\">        generateTest.show_2(apple);</span><br><span class=\"line\">        generateTest.show_2(person);</span><br><span class=\"line\"></span><br><span class=\"line\">        //使用这两个方法也都可以成功</span><br><span class=\"line\">        generateTest.show_3(apple);</span><br><span class=\"line\">        generateTest.show_3(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、泛型限定-extends\"><a href=\"#4、泛型限定-extends\" class=\"headerlink\" title=\"4、泛型限定 extends\"></a>4、泛型限定 extends</h3><p>在有些情况下，泛型类或者泛型方法想要对自己的类型参数进一步加一些限制。比如，我们想要限定类型参数只能为某个类的子类或者只能为实现了某个接口的类。我们可以用到 <strong>边界限定符 extends</strong>。我们可以这样写</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;T extends BoundingType&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其中 BoundingType 是一个类或者接口，可以为一个或多个，多个之间用 <code>&amp;</code> 连接。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;T extends BoundingType1 &amp; BoundingType2 &amp; BoundingType3&gt;</span><br></pre></td></tr></table></figure>\n\n<p>类添加限定符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Generic&lt;T extends Number&gt;&#123;</span><br><span class=\"line\">    private T key;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Generic(T key) &#123;</span><br><span class=\"line\">        this.key = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接口添加限定符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public interface Comparable&lt;T&gt; &#123;</span><br><span class=\"line\">    public int compareTo(T o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法添加限定符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span><br><span class=\"line\">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;</span><br><span class=\"line\">public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123;</span><br><span class=\"line\">    System.out.println(&quot;container key :&quot; + container.getKey());</span><br><span class=\"line\">    T test = container.getKey();</span><br><span class=\"line\">    return test;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、泛型通配符\"><a href=\"#5、泛型通配符\" class=\"headerlink\" title=\"5、泛型通配符\"></a>5、泛型通配符</h3><h4 id=\"1）什么是通配符\"><a href=\"#1）什么是通配符\" class=\"headerlink\" title=\"1）什么是通配符\"></a>1）什么是通配符</h4><p>假设有两个类 Manager 和 Employee，其中 Manager 是 Employee 的一个子类。那么 List&lt; Manager &gt; 是 List&lt; Employee &gt; 的一个子类吗？事实上 <strong>List&lt; Manager &gt; 和 List&lt; Employee &gt; 之间没有任何关系</strong>。这样会导致可以使用 List&lt; Employee &gt; 的地方不一定能使用 List&lt; Manager &gt;，尽管逻辑上应该是两者都可以使用的。例如下面：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Employee &#123;...&#125; //员工类</span><br><span class=\"line\"></span><br><span class=\"line\">class Manager extends Employee&#123;...&#125; //管理层类，继承员工类</span><br><span class=\"line\"></span><br><span class=\"line\">class Company &#123;</span><br><span class=\"line\">    public void traverse(List&lt;Employee&gt; list) &#123; //遍历员工，理论上应该也可以用该方法来遍历管理层</span><br><span class=\"line\">        for(Employee item : list) &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void test () &#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employeeList = new ArrayList&lt;&gt;(); //员工集合</span><br><span class=\"line\">        //添加员工</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Manager&gt; managerList = new ArrayList&lt;&gt;(); //管理层集合</span><br><span class=\"line\">        //添加管理层</span><br><span class=\"line\"></span><br><span class=\"line\">        traverse(employeeList); //编译通过</span><br><span class=\"line\">        traverse(managerList); //编译不通过</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个例子中，可以用来遍历 List&lt; Employee &gt; 的方法却不能用来遍历 List&lt; Manager &gt;。难道我们要为 List&lt; Manager &gt; 再写一个功能相同，只是类型不同的遍历方法吗？Java 的开发人员想出通过 <strong>通配符</strong> 来解决这个问题。</p>\n<p><strong>通配符是指用 ? 来代替具体的类型</strong>。这里的 ？相当于一个类型实参，也就是说不需要事先在方法头的返回值前面通过 <code>&lt;&gt;</code> 来说明，可以直接使用。**&lt;? extends Class&gt;** 表示 Class 类本身和其所有子类型，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;? extends Employee&gt;</span><br></pre></td></tr></table></figure>\n\n<p>表示类型参数是 Employee 本身及其子类的所有 List 类型，包括 List&lt; Manager &gt;。<em>通过通配符 List&lt; Employee &gt; 和 List&lt; Manager &gt; 形成了类似于父子关系</em>，这样可以使用 List&lt; Employee &gt; 的地方也可以使用 List&lt; Manager &gt; 了。在上面的例子中我们只需要把遍历方法改一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void traverse(List&lt;? extends Employee&gt; list) &#123; //可同时遍历员工和管理层</span><br><span class=\"line\">    for(Employee item : list) &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时候我们调用 <code>traverse(employeeList)</code> 和 <code>traverse(managerList)</code> 都会编译通过。</p>\n<p>&lt; T extends Class &gt; 和 &lt; ? extends Class &gt; 这两个有什么区别呢？最主要的区别是 <em><strong>T 是类型形参，? 是类型实参</strong></em>。使用 T 的话需要在方法头的返回值前面通过 <code>&lt;T&gt;</code> 声明才能在后面使用，使用 ? 的话可以跟 Integer 等实参一样不需要声明随时使用，下面两个方法可以实现相同的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void traverse1(List&lt;? extends Employee&gt; list) &#123; //使用通配符 ?</span><br><span class=\"line\">    for(Employee item : list) &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public &lt;T extends Employee&gt; void traverse2(List&lt;T&gt; list) &#123;  使用泛型 T</span><br><span class=\"line\">    for(Employee item : list) &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2）超类型限定-super\"><a href=\"#2）超类型限定-super\" class=\"headerlink\" title=\"2）超类型限定 super\"></a>2）超类型限定 super</h4><p>通配符比类型变量还多了一个功能：通过关键字 <strong>super</strong> 可以指定超类型限定(supertype bound)。这个功能跟 extends 恰好相反。**&lt;? super Class&gt;** 表示 Class 类本身和其所有超类型。<em><strong>注意没有 &lt; T super Class &gt; 这样的写法</strong></em>。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;? super Manager&gt;</span><br></pre></td></tr></table></figure>\n\n<p>表示所有 Manager 本身及其所有父类类型。</p>\n<h4 id=\"3）PECS-原则\"><a href=\"#3）PECS-原则\" class=\"headerlink\" title=\"3）PECS 原则\"></a>3）PECS 原则</h4><h5 id=\"通配符上界-extends\"><a href=\"#通配符上界-extends\" class=\"headerlink\" title=\"通配符上界 extends\"></a>通配符上界 extends</h5><p>假如有一个 list 的类型为 <em><strong>List&lt;? extends Class&gt;，Class 相当于类型上界</strong></em>。</p>\n<ul>\n<li>当我们从 list 获取元素时，因为 Class 是父类型，我们可以用父类型来转换所有的子类型对象，这是符合 Java 继承规则的。</li>\n<li>当我们往 list 添加元素时，因为 list 里面每个对象的类型是未知的，有的可能是顶级父类类型 Class，有的可能是其他的子孙类型 ClassChild。ClassChild 一般会在 Class 的基础上扩展增加了很多其他方法。假设我们可以添加成功，那么当我们再取出 list 元素的时候，我们只能知道该元素的顶级父类类型是 Class，但是我们没办法知道该元素在添加前是什么类型以及有哪些方法可以调用。<em><strong>所以禁止向 &lt;? extends Class&gt; 类型添加对象</strong></em> ，除了 null。</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void modify1 (List&lt;? extends Employee&gt; list) &#123;</span><br><span class=\"line\">    list.add(new Employee()); //编译失败</span><br><span class=\"line\">    Employee employee = list.get(0); //编译通过</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"通配符下界-super\"><a href=\"#通配符下界-super\" class=\"headerlink\" title=\"通配符下界 super\"></a>通配符下界 super</h5><p>假如有一个 list 的类型为 <em><strong>List&lt;? super Class&gt;，Class 相当于类型下界</strong></em>。</p>\n<ul>\n<li>当我们从 list 获取元素时，因为 Class 是最底层的子孙类型，list 里面的元素可能会存在父类类型的元素。在 Java 继承规则里面，子类类型变量不能表示父类类型对象，因此我们不能用 Class 类型来表示任意 list 元素。<em><strong>所以禁止从 &lt;? super Class&gt;类型获取对象</strong></em>，除了 null。</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void modify2 (List&lt;? super Manager&gt; list) &#123;</span><br><span class=\"line\">    list.add(new Manager()); //编译通过</span><br><span class=\"line\">    Manager manager = list.get(0); //编译失败</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当我们向 list 添加元素时，因为 Class 是最底层的子类类型，其包括了本身和父类的所有变量和方法。假设可以添加成功，我们可以获取任意元素转换成子类 Class 类型，然后任意调用其本身和父类的变量和方法，这是符合 Java 继承规则的。所以允许向 list 添加元素。</li>\n</ul>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>根据上面的例子，extends 定义了类型的上界，super 定义了类型的下界，我们可以总结出一条规律，”Producer Extends, Consumer Super”，也就是常说的 <strong>PECS 原则</strong>：</p>\n<ul>\n<li>“Producer Extends”：如果你需要一个只读 List，用它来 produce T，那么使用 &lt; ? extends T &gt;。</li>\n<li>“Consumer Super”：如果你需要一个只写 List，用它来 consume T，那么使用 &lt; ? super T &gt;。</li>\n<li>如果需要同时读取以及写入，那么我们就不能使用通配符了。</li>\n</ul>\n<p>阅读过一些Java集合类的源码，可以发现通常我们会将两者结合起来一起用，比如像下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Collections &#123;</span><br><span class=\"line\">    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;</span><br><span class=\"line\">        for (int i=0; i&lt;src.size(); i++)</span><br><span class=\"line\">            dest.set(i, src.get(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4）无限定通配符\"><a href=\"#4）无限定通配符\" class=\"headerlink\" title=\"4）无限定通配符\"></a>4）无限定通配符</h4><p>无限定通配符就是没有上下界限定，只有单独的 **<?>**。如 List<?>，? 可以表示任何类型。无界通配符通常会用在下面两种情况：</p>\n<ol>\n<li>当方法是使用原始的Object类型作为参数时，如下：</li>\n</ol>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void printList(List&lt;Object&gt; list) &#123;</span><br><span class=\"line\">   for (Object elem : list)</span><br><span class=\"line\">       System.out.println(elem + &quot;&quot;);</span><br><span class=\"line\">   System.out.println();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//上面方法可以选择改为如下所示，这样就可以兼容更多的输出，而不单纯是 List&lt;Object&gt;</span><br><span class=\"line\">public static void printList(List&lt;?&gt; list) &#123;</span><br><span class=\"line\">   for (Object elem: list)</span><br><span class=\"line\">       System.out.print(elem + &quot;&quot;);</span><br><span class=\"line\">   System.out.println();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在定义的方法体的业务逻辑与泛型类型无关，如 List.size()，List.clear() 等这些方法。实际上，最常用的就是 Class&lt;?&gt;。</li>\n</ol>\n<p>最后提醒一下的就是，List<Object> 与 List<?> 并不等同，List<Object> 是 List<?> 的子类。不能往 List&lt;?&gt; 里面获取和添加任何元素，除了 null。</p>\n<h2 id=\"深入理解泛型\"><a href=\"#深入理解泛型\" class=\"headerlink\" title=\"深入理解泛型\"></a>深入理解泛型</h2><h3 id=\"1、类型擦除\"><a href=\"#1、类型擦除\" class=\"headerlink\" title=\"1、类型擦除\"></a>1、类型擦除</h3><p><strong>类型擦除</strong> 就是说 Java 泛型只能用于在编译期间的静态类型检查，然后编译器生成的代码会擦除相应的类型信息，把所有类型参数替换为 BoundingType（若未加限定就替换为 Object ）。</p>\n<p>这样到了运行期间实际上 JVM 根本不知道泛型所代表的具体类型。这样做的目的是因为 Java 泛型是 1.5 之后才被引入的，为了保持向下的兼容性，所以只能做类型擦除来兼容以前的非泛型代码。</p>\n<p>例如下面这段代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Node&lt;T&gt; &#123;</span><br><span class=\"line\">    private T data;</span><br><span class=\"line\">    private Node&lt;T&gt; next;</span><br><span class=\"line\">    public Node(T data, Node&lt;T&gt; next) &#123;</span><br><span class=\"line\">        this.data = data;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public T getData() &#123; return data; &#125;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译器做完相应的类型检查之后会把类型进行擦除，因为没有限定类型，所以替换为 Object 类型。实际上到了运行期间上面这段代码会变成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Node &#123;</span><br><span class=\"line\">    private Object data;</span><br><span class=\"line\">    private Node next;</span><br><span class=\"line\">    public Node(Object data, Node next) &#123;</span><br><span class=\"line\">        this.data = data;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public T getData() &#123; return data; &#125;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们设置了限定类型，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Node&lt;T extends Comparable&lt;T&gt;&gt; &#123;</span><br><span class=\"line\">    private T data;</span><br><span class=\"line\">    private Node&lt;T&gt; next;</span><br><span class=\"line\">    public Node(T data, Node&lt;T&gt; next) &#123;</span><br><span class=\"line\">        this.data = data;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public T getData() &#123; return data; &#125;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样编译器就会将 T 出现的地方替换成 Comparable 而不再是默认的 Object 了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Node &#123;</span><br><span class=\"line\">    private Comparable data;</span><br><span class=\"line\">    private Node next;</span><br><span class=\"line\">    public Node(Comparable data, Node next) &#123;</span><br><span class=\"line\">        this.data = data;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public Comparable getData() &#123; return data; &#125;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不管原来声明的是 List&lt; String &gt; 还是 List&lt; Integer &gt;，类型擦除之后都会变成 List&lt; Object &gt;，所以两者在编译完成后的 Class 类型是相同的，看下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">Class classStringArrayList = stringArrayList.getClass();</span><br><span class=\"line\">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(classStringArrayList.equals(classIntegerArrayList)) //输出 true，证明类型擦除后两者的 class 类型相同。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、桥方法\"><a href=\"#2、桥方法\" class=\"headerlink\" title=\"2、桥方法\"></a>2、桥方法</h3><p><strong>桥方法</strong>（Bridge Method）是用来解决继承泛型类型中的多态问题的。我们先来看下面这个例子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Pair&lt;T&gt; &#123;</span><br><span class=\"line\">\tprivate T first;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setFirst(T first)&#123;  </span><br><span class=\"line\">\t\tthis.first = first;  </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Object getFirst()&#123;  </span><br><span class=\"line\">\t\treturn this.first;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class SonPair extends Pair&lt;String&gt;&#123;</span><br><span class=\"line\">\tpublic void setFirst(String first)&#123;...&#125;</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>在这里程序猿传入类型 String 来继承 Pair 类并想覆盖父类中的 <code>setFirst()</code> 方法，但事实上子类没有办法覆盖这个方法。因为父类 Pair 在编译阶段已经被类型擦除，变成了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Pair &#123;</span><br><span class=\"line\">\tprivate Object first;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setFirst(Object first)&#123;  </span><br><span class=\"line\">\t\tthis.first = first;  </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>子类中的 <code>setFirst(String first)</code> 方法不能覆盖父类的 <code>setFirst(Object first)</code> 方法。为了解决这个问题，就需要用到桥方法。桥方法简单来说就是 <em><strong>生成一个跟父类方法头相同的方法，该方法把参数转换类型后再调用子类的方法</strong></em>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//实际上子类生成了两个方法</span><br><span class=\"line\">class SonPair extends Pair&lt;String&gt;&#123;</span><br><span class=\"line\">\tpublic void setFirst(Object first)&#123;</span><br><span class=\"line\">\t\tsetFirst((String) first)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setFirst(String first)&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样可以解决泛型继承的多态问题。对于 <code>getFirst()</code> 方法，子类也生成了两个方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class SonPair extends Pair&lt;String&gt;&#123;</span><br><span class=\"line\">\tpublic Object getFirst()&#123;  </span><br><span class=\"line\">\t\treturn this.first;  </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getFirst()&#123;  </span><br><span class=\"line\">\t\treturn this.first;  </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根据 Java 的多态继承规则，在同一个类里面不能定义两个方法名和参数完全相同的方法，所以我们在写代码的时候写两个这样的方法，编译器肯定是不能通过的。但是注意：JVM 会用参数类型和返回类型来确定一个方法。 一旦编译器通过某种方式自己编译出方法签名一样的两个方法(只能编译器自己来创造这种奇迹，我们程序员却不能人为的编写这种代码)。JVM 还是能够分清楚这些方法的，前提是需要返回类型不一样。</p>\n<h3 id=\"3、注意事项\"><a href=\"#3、注意事项\" class=\"headerlink\" title=\"3、注意事项\"></a>3、注意事项</h3><h4 id=\"1）不允许创建泛型数组\"><a href=\"#1）不允许创建泛型数组\" class=\"headerlink\" title=\"1）不允许创建泛型数组\"></a>1）不允许创建泛型数组</h4><p>Java 不支持创建泛型数组。假设如果允许创建泛型数组，会出现下面这种情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object[] stringLists = new List&lt;String&gt;[];  // compiler error, but pretend it&#x27;s allowed</span><br><span class=\"line\"></span><br><span class=\"line\">stringLists[0] = new ArrayList&lt;String&gt;();  // OK</span><br><span class=\"line\"></span><br><span class=\"line\">stringLists[1] = new ArrayList&lt;Integer&gt;(); // An ArrayStoreException should be thrown, but the runtime can&#x27;t detect it.</span><br><span class=\"line\"></span><br><span class=\"line\">String s = stringLists[1].get(0); // Run-time error: ClassCastException.</span><br></pre></td></tr></table></figure>\n\n<p>假设我们支持泛型数组的创建，由于运行时期类型信息已经被擦除，JVM实际上根本就不知道 new ArrayList&lt; String &gt;() 和 new ArrayList&lt; Integer &gt;() 的区别，他们可以被添加到同一个数组里面 List<String>[] 里面。只有当运行时取出元素的时候进行类型转换时才会报 <code>ClassCastException</code> 的异常。为了避免这种情况我们不允许创建泛型数组，让编译器去帮助我们检查就可以避免这种情况。</p>\n<h4 id=\"2）不能利用类型参数创建实例\"><a href=\"#2）不能利用类型参数创建实例\" class=\"headerlink\" title=\"2）不能利用类型参数创建实例\"></a>2）不能利用类型参数创建实例</h4><p>Java 不允许类型类型参数创建实例，例如下面这种情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static &lt;E&gt; void append(List&lt;E&gt; list) &#123;</span><br><span class=\"line\">    E elem = new E();  // compile-time error</span><br><span class=\"line\">    list.add(elem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要还是由于类型擦除的问题，在运行阶段实际上我们会创建一个 Object 对象，违背了我们只想创建特定类型的对象的初衷。但是如果某些场景我们想要需要利用类型参数创建实例，我们应该怎么做呢？可以利用反射解决这个问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123;</span><br><span class=\"line\">    E elem = cls.newInstance();   // OK</span><br><span class=\"line\">    list.add(elem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3）不能用基本类型实例化类型参数\"><a href=\"#3）不能用基本类型实例化类型参数\" class=\"headerlink\" title=\"3）不能用基本类型实例化类型参数\"></a>3）不能用基本类型实例化类型参数</h4><p>对于数据类型，类型参数只支持 Integer 等包装类型，不支持 int 等基本类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); //OK</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;int&gt; list2 = new ArrayList&lt;&gt;(); //compile error, Type argument cannot be of primitive type</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4）不能抛出也不能捕获泛型类实例\"><a href=\"#4）不能抛出也不能捕获泛型类实例\" class=\"headerlink\" title=\"4）不能抛出也不能捕获泛型类实例\"></a>4）不能抛出也不能捕获泛型类实例</h4><p>泛型类扩展 Throwable 即为不合法，因此无法抛出或捕获泛型类实例。但在异常声明中使用类型参数是合法的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static &lt;T extends Throwable&gt; void doWork(T t) throws T &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125; catch (T e) &#123; //compile error, cannot catch type parameters</span><br><span class=\"line\">        Logger.global.info(e.getMessage());</span><br><span class=\"line\">    &#125; catch (Throwable realCause) &#123; //OK</span><br><span class=\"line\">        t.initCause(realCause);</span><br><span class=\"line\">        throw t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5）泛型类的静态上下文中不能使用类型变量\"><a href=\"#5）泛型类的静态上下文中不能使用类型变量\" class=\"headerlink\" title=\"5）泛型类的静态上下文中不能使用类型变量\"></a>5）泛型类的静态上下文中不能使用类型变量</h4><p>泛型类里面的静态变量和方法不能直接使用类上定义的类型变量，如果静态方法要使用泛型，必须将静态方法也定义成泛型方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class StaticGenerator&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static T name; //compilr error</span><br><span class=\"line\"></span><br><span class=\"line\">    public static T getName()&#123; return null;&#125;; //compilr error</span><br><span class=\"line\"></span><br><span class=\"line\">    public static &lt;T&gt; T getNamebyGeneric() &#123;return null;&#125; //OK</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6）不能对泛型使用-instanceof\"><a href=\"#6）不能对泛型使用-instanceof\" class=\"headerlink\" title=\"6）不能对泛型使用 instanceof\"></a>6）不能对泛型使用 instanceof</h4><p>不能对泛型代码直接使用 instanceof 关键字，因为编译器在生成代码的时候会擦除所有相关泛型的类型信息，正如我们上面验证过的 JVM 在运行时期无法识别出 ArrayList&lt; Integer &gt; 和 ArrayList&lt; String &gt;的之间的区别：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123;</span><br><span class=\"line\">    if (list instanceof ArrayList&lt;Integer&gt;) &#123;  // compile error</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>泛型的本质是类型参数，即把类型当作一个参数来使用。在实例化泛型时再把具体类型当作实参传递进来。泛型的用途有泛型类、泛型接口和泛型方法等。</li>\n<li>泛型的用途是在编译阶段限制对象类型，这样可以避免在运行阶段出现类型转换异常。</li>\n<li>泛型类是具有一个或多个类型变量的类。类型变量用尖括号 <code>&lt;&gt;</code> 括起来，并放在类名后面。泛型类可以有多个类型变量，多个类型变量之前用逗号 <code>,</code> 隔开。</li>\n<li>泛型接口和泛型类的使用基本类似，在接口名后加 <code>&lt;&gt;</code> 括起来的类型变量。</li>\n<li>泛型方法是指 <code>&lt;&gt;</code> 括起来的类型变量放在修饰符（如 public static）后面，返回类型前面的方法。泛型方法可以定义在普通类中，也可以定义在泛型类中。</li>\n<li>子类型限定符 <code>extends</code> 用于限制类型上界。</li>\n<li>通配符 <code>?</code> 用于实现两个泛型集合之间的父子关系。通配符有 PECS 原则。</li>\n<li>超类型限定符 super 是通配符特有的，用于限制类型下界。</li>\n<li>类型擦除是指编译器生成的代码会擦除相应的类型信息，把所有类型参数替换为 BoundingType（若未加限定就替换为 Object ）。</li>\n<li>桥方法是用来解决继承泛型类型中的多态问题的。</li>\n<li>不允许创建泛型数组。</li>\n<li>不能利用类型参数创建实例。</li>\n<li>不能用基本类型实例化类型参数。</li>\n<li>不能抛出也不能捕获泛型类实例。</li>\n<li>泛型类的静态上下文中不能使用类型变量。</li>\n<li>不能对泛型使用 instanceof。</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/s10461/article/details/53941091\">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a><br><a href=\"http://www.importnew.com/24029.html\">Java泛型详解</a><br><a href=\"https://www.cnblogs.com/ggjucheng/p/3352519.html\">JVM如何理解Java泛型类(转)</a><br><a href=\"http://www.cnblogs.com/absfree/p/5270883.html\">Java核心技术点之泛型</a><br><a href=\"https://www.linuxidc.com/Linux/2013-10/90928.htm\">Java 通配符解惑</a></p>\n","categories":["Java","Java基础"],"tags":["Java"]},{"title":"Java封装、继承和多态","url":"/2018/08/12/Java%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/","content":"<blockquote>\n<p>封装、继承和多态是 java 面向对象的三大特性，其中封装是面向对象编程的基础，继承在封装的基础上简化类编程和提高类的可复用性，并为多态的实现提供了前提，三大特性体现了面向对象编程的思想。在这里简单介绍一些基础知识，转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><h3 id=\"封装是什么\"><a href=\"#封装是什么\" class=\"headerlink\" title=\"封装是什么\"></a>封装是什么</h3><p><em><strong>封装把方法和数据包围起来，控制方法和数据的访问级别，隐藏了类的内部实现机制，只向外界暴露特定的访问接口</strong></em>。外界只能通过这些公开的接口来访问数据。</p>\n<p>封装的作用：对于类内部，保护私有数据不被轻易破坏，提高了类调用的安全性；对于类外部，调用者不需要了解类内部的具体实现细节，只需要根据接口的规则进行调用，简化编程过程，提高了模块的可复用性和可维护性。</p>\n<h3 id=\"深入封装\"><a href=\"#深入封装\" class=\"headerlink\" title=\"深入封装\"></a>深入封装</h3><h4 id=\"1、访问权限\"><a href=\"#1、访问权限\" class=\"headerlink\" title=\"1、访问权限\"></a>1、访问权限</h4><p>java 通过访问权限修饰符来控制类、属性和方法的可见范围，访问权限修饰符一共有四种，可见范围从大到小排列如下：</p>\n<ul>\n<li>public: 所有类都可访问</li>\n<li>无修饰符(default): 同一个包的类可访问（包括子类和非子类）</li>\n<li>protected: 子类可访问（包括直接子类和间接子类）</li>\n<li>private: 只有本身内部可访问</li>\n</ul>\n<p>在这里需要注意的是，<em><strong>子类继承父类时会继承父类的所有域和方法（包括 private 域和 private 方法），但是子类不能访问这些私有域和方法，看起来相当于没有继承一样</strong></em>。</p>\n<p>属性和方法可以使用以上四种修饰符，类只能使用 public 和 default 两种修饰符。</p>\n<h4 id=\"2、构造器\"><a href=\"#2、构造器\" class=\"headerlink\" title=\"2、构造器\"></a>2、构造器</h4><p>当创建一个对象时，系统会为这个对象的实例进行默认的初始化，例如把基本类型数值类型的属性设为 0，把布尔类型的属性设为 false，把引用属性设为 null 等等。通过构造器我们可以改变这种默认的初始化，把指定属性初始化为指定值。</p>\n<p>构造器有以下特点：</p>\n<ul>\n<li>构造器必须和类同名。</li>\n<li>构造器不是方法，不能被继承。</li>\n<li>构造器没有返回值，也不允许出现返回值。如果出现返回值编译器不会报错，但是就不是构造器了，只是一个跟类同名的普通方法。</li>\n<li>构造器只能用 public、default、protected 或 private 四种访问限制修饰符，不能用其他的修饰符。例如 static（构造器总是关联具体对象使用，没必要使用 static）、final（构造器不会被继承，没必要使用 final 限制继承）、abstract（抽象类不能直接实例化）。</li>\n<li>可以在一个构造器里面通过 this 关键字来调用另一个构造器，<em><strong>该调用必须写在第一行</strong></em>，不能在普通方法里面调用构造器。</li>\n</ul>\n<p>参考 <a href=\"http://www.cnblogs.com/aademeng/articles/6188323.html\">java中构造器（Constructor）</a></p>\n<h4 id=\"3、this\"><a href=\"#3、this\" class=\"headerlink\" title=\"3、this\"></a>3、this</h4><p><em><strong>this 关键字用来表示当前对象本身</strong></em>。this 关键字的用法如下：</p>\n<ul>\n<li>在构造方法中通过 this 关键字来调用其他构造方法，该调用必须放在第一行。</li>\n<li>通过 this 关键字来访问类中的所有成员变量和方法，<em><strong>不受访问权限的控制</strong></em>，包括 private 成员和 static 成员。不过由于 static 成员可以通过类名直接访问，如果通过 this 来访问会有 “The static field ××× should be accessed in a static way” 的警告信息。<em><strong>不能在类的 static 成员或 static 块中使用 this</strong></em>。</li>\n<li>表示当前类对象的引用，可作为参数传递。</li>\n</ul>\n<p>参考 <a href=\"https://blog.csdn.net/ccpat/article/details/44515335\">Java this 关键字用法</a></p>\n<h4 id=\"4、static\"><a href=\"#4、static\" class=\"headerlink\" title=\"4、static\"></a>4、static</h4><p><em><strong>被 static 关键字修饰的属性和方法不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问</strong></em>。static 的作用是在没有创建对象的情况下来进行调用属性或方法。static 可以用来修饰类的成员方法、类的成员变量，另外可以编写 static 代码块来优化程序性能。</p>\n<h5 id=\"1）static-方法\"><a href=\"#1）static-方法\" class=\"headerlink\" title=\"1）static 方法\"></a>1）static 方法</h5><p>static 方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有 this 的，因为它不依附于任何对象，既然都没有对象，就谈不上 this 了。并且由于这个特性，<em><strong>在静态方法中不能访问类的非静态成员变量和非静态成员方法</strong></em>，因为非静态成员方法&#x2F;变量都是必须依赖具体的对象才能够被调用。</p>\n<p>但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法&#x2F;变量的。</p>\n<p>如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为 static。我们最常见的 static 方法就是 main 方法，至于为什么 main 方法必须是 static 的，现在就很清楚了。因为程序在执行 main 方法的时候没有创建任何对象，因此只有通过类名来访问。</p>\n<h5 id=\"2）static-变量\"><a href=\"#2）static-变量\" class=\"headerlink\" title=\"2）static 变量\"></a>2）static 变量</h5><p>static 变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p>\n<p>static 成员变量的初始化顺序按照定义的顺序进行初始化，也就是说静态代码块和静态变量的级别是相同的，按照出现的顺序初始化。</p>\n<h5 id=\"3）static-代码块\"><a href=\"#3）static-代码块\" class=\"headerlink\" title=\"3）static 代码块\"></a>3）static 代码块</h5><p>static 代码块（包括静态方法）可以置于类中的任何地方，类中可以有多个 static 块。在类初次被加载的时候，会按照 static 块的顺序来执行每个 static 块，并且只会执行一次。因为这个特性可以将一些只需要进行一次的初始化操作都放在 static 代码块中进行，可以优化程序性能。</p>\n<p>参考 <a href=\"https://www.cnblogs.com/dolphin0520/p/3799052.html\">Java中的static关键字解析</a></p>\n<h4 id=\"5、类初始化和类实例化\"><a href=\"#5、类初始化和类实例化\" class=\"headerlink\" title=\"5、类初始化和类实例化\"></a>5、类初始化和类实例化</h4><p><strong>类初始化</strong>：类第一次加载到内存，虚拟机将类变量（static 修饰的变量）分配内存并设置零值的过程。在类初始化阶段，执行类构造器 <code>&lt;cinit&gt;()</code> 方法。<code>&lt;cinit&gt;()</code> 类初始化方法有如下特点：</p>\n<ol>\n<li>编译器会在将 .java 文件编译成 .class 文件时，收集所有类初始化代码和 static {} 域的代码，收集在一起成为 <code>&lt;cinit&gt;()</code> 方法；</li>\n<li>子类初始化时会首先调用父类的 <code>&lt;cinit&gt;()</code> 方法；</li>\n<li>JVM 会保证 <code>&lt;cinit&gt;()</code> 方法的线程安全，保证同一时间只有一个线程执行；</li>\n</ol>\n<p><strong>类实例化</strong>：类完全加载到内存之后创建对象的过程。在类实例化阶段会调用 <code>&lt;init&gt;()</code> 方法，过程如下：</p>\n<ol>\n<li>JVM 收集实例初始化变量和 {} 域组合成实例初始化方法 <code>&lt;init&gt;()</code>；</li>\n<li>实例初始化时首先执行 <code>&lt;init&gt;()</code> 方法，然后执行构造函数；</li>\n<li>子类通过构造函数构造实例时会首先调用父类的 <code>&lt;init&gt;()</code> 方法和父类的构造函数，如果没有显示调用父类的构造函数，那么 JVM 会自动调用父类的无参构造函数，保证父类构造函数一定被调用，然后再是子类自己的 <code>&lt;init&gt;()</code> 方法和构造函数；</li>\n<li>至此，实例就构造完毕了；</li>\n</ol>\n<p>所以类初始化和类实例化的过程是：</p>\n<ol>\n<li>父类类初始化 <code>&lt;cinit&gt;()</code>；</li>\n<li>子类类初始化 <code>&lt;cinit&gt;()</code>；</li>\n<li>父类 <code>&lt;init&gt;()</code> + 父类构造器；</li>\n<li>子类 <code>&lt;init&gt;()</code> + 子类构造器；</li>\n</ol>\n<p>最后，具体执行顺序可以总结为 <em><strong>“先静态后非静态，先父类后子类”</strong></em>：</p>\n<ol>\n<li>父类静态变量和静态代码块（先声明的先执行）；</li>\n<li>子类静态变量和静态代码块（先声明的先执行）；</li>\n<li>父类的变量和代码块（先声明的先执行）；</li>\n<li>父类的构造函数；</li>\n<li>子类的变量和代码块（先声明的先执行）；</li>\n<li>子类的构造函数。</li>\n</ol>\n<p>这个执行顺序在面试题里面经常会看到，可以记一下。</p>\n<p>参考 <a href=\"https://blog.csdn.net/w1196726224/article/details/56529615\">Java 类初始化（详解）</a><br><a href=\"https://www.cnblogs.com/jj-chenjunjie/p/5331107.html\">Java（静态）变量和（静态）代码块的执行顺序</a></p>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><h3 id=\"继承是什么\"><a href=\"#继承是什么\" class=\"headerlink\" title=\"继承是什么\"></a>继承是什么</h3><p>继承是当两个类存在 IS-A 关系的时候，例如人类和男人&#x2F;女人，学生和小学生&#x2F;中学生&#x2F;大学生，后者属于前者的一个特殊分类的时候，就可以在父类的基础上定义一个子类来继承它，子类会自动继承父类的所有属性和方法（会继承但是不一定有权限访问，例如父类的私有域和私有方法）。如下图所示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Human &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Man extends Human &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Woman extends Human &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>子类 Man 和 Woman 分别通过关键字 <code>extends</code> 继承父类 Human，这样子类就可以访问父类的有权限访问的属性和方法了。</p>\n<p>继承的作用：提高了代码的可复用性，大大减少代码量，并且使类之间产生强依赖关系，为多态的实现提供前提。</p>\n<h3 id=\"深入继承\"><a href=\"#深入继承\" class=\"headerlink\" title=\"深入继承\"></a>深入继承</h3><h4 id=\"1、子类构造器\"><a href=\"#1、子类构造器\" class=\"headerlink\" title=\"1、子类构造器\"></a>1、子类构造器</h4><p>在调用子类构造器之前会自动调用父类的构造器。在这里有两种情况：</p>\n<ul>\n<li>子类构造器里显示调用父类构造器。通过 <code>super()</code> 调用父类无参构造器或者 super(arg1…) 调用父类有参构造器。<em><strong>使用 super 调用父类构造器必须写在子类构造器的第一行</strong></em>，否则编译器会报错。因为上面说过通过 this 调用本类的其他构造器也必须写在第一行，<em><strong>所以不能在同一个构造器里面同时通过 super 和 this 调用构造器</strong></em>。</li>\n<li>子类构造器没有显示调用父类构造器。这时编译器会自动调用父类的无参构造器，即会自动在第一行调用 <code>super()</code>。如果父类没有无参构造器，编译报错。</li>\n</ul>\n<p>所以为了防止子类编译报错，我们在写父类的时候最好都加上无参构造器，就算是空方法体也行。</p>\n<h4 id=\"2、super\"><a href=\"#2、super\" class=\"headerlink\" title=\"2、super\"></a>2、super</h4><p><em><strong>super 是用来访问父类的成员</strong></em>，作用和 this 类似：</p>\n<ul>\n<li>在构造器里面通过 super 来调用父类的构造方法，该调用必须写在子类构造器的第一行。</li>\n<li>访问有可见权限的父类的成员变量和方法，不能访问父类的 private 成员。例如当子类中出现和父类同名的成员变量或方法时，父类的成员会被隐藏，这时候可以通过 super 来访问父类中隐藏的成员。如果子类中没有重写父类的成员变量和成员方法，则子类会继承父类的所有非 private 的成员变量和成员方法。这时在子类中无论通过 this 来访问成员和通过 super 来访问成员，结果都是一样的。</li>\n</ul>\n<p>请注意 super 和 this 的区别：<br>this 是当前对象的一个引用，所以可以直接把 this 赋值给另外一个对象引用，例如 <code>Object o = this</code>，但是 <em><strong>super 只是一个指示编译器访问父类成员的特殊关键字，不是一个对象引用</strong></em>，<code>Object o = super</code> 这样的写法是错误的。</p>\n<h4 id=\"3、final\"><a href=\"#3、final\" class=\"headerlink\" title=\"3、final\"></a>3、final</h4><p>在 Java 中，final 关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。</p>\n<ol>\n<li>修饰类，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用 final 进行修饰。final 类中的成员变量可以根据需要设为 final，但是要注意 final 类中的所有成员方法都会被隐式地指定为 final 方法。</li>\n<li>修饰方法，表明方法不能被覆盖。类的 private方 法会隐式地被指定为 final 方法。</li>\n<li>修饰变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li>\n</ol>\n<p>参考 <a href=\"http://www.cnblogs.com/dolphin0520/p/3736238.html\">浅析Java中的final关键字</a></p>\n<h4 id=\"4、抽象类\"><a href=\"#4、抽象类\" class=\"headerlink\" title=\"4、抽象类\"></a>4、抽象类</h4><p><em><strong>抽象类是指 abstract 关键字修饰的类</strong></em>，子类通过 extends 关键字继承抽象类。</p>\n<p>抽象类是对普通类的抽象，我们可以把只有概念但是没有具体实现的信息添加到抽象类里面，然后再让继承类来具体实现这些信息。注意抽象类有以下特点：</p>\n<ul>\n<li>不能用抽象类来实例化对象。但是可以用抽象类来声明变量，然后用该抽象类的实现子类来实例化对象。</li>\n<li>抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。</li>\n<li>抽象类里面可以不包含任何 abstract 方法。（这样的抽象类其实没有什么意义，暂且当作概念来记住），但是只要包含一个以上 abstract 方法，该类就必须定义为抽象类。</li>\n<li>抽象方法必须为 public 或者 protected（因为如果为 private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为 public。</li>\n<li>抽象类可以包含普通的成员变量和方法，即变量可以定义为任何类型，方法可以有具体实现。</li>\n<li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为 abstract 类。</li>\n</ul>\n<p>例如下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">abstract class AbstractClass &#123; //父类抽象类</span><br><span class=\"line\">    private String name; //可以包含普通成员变量</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CommonMethod() &#123; //可以包含有具体实现的普通方法</span><br><span class=\"line\">        //some method</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    abstract public void AbstractMethod1(); //没有实现的抽象方法（注意后面没有中括号）</span><br><span class=\"line\"></span><br><span class=\"line\">    abstract public void AbstractMethod2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">abstract class NonImplementClass extends AbstractClass &#123; //没有完全实现父类抽象方法的类也必须定义为抽象类</span><br><span class=\"line\">    public void AbstractMethod1() &#123;</span><br><span class=\"line\">        System.out.println(&quot;实现了父类的第一个抽象方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ImplementClass extends AbstractClass &#123; //实现了父类所有抽象方法的类不用定义为抽象类</span><br><span class=\"line\">    public void AbstractMethod1() &#123;</span><br><span class=\"line\">        System.out.println(&quot;实现了父类的第一个抽象方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void AbstractMethod2() &#123;</span><br><span class=\"line\">        System.out.println(&quot;实现了父类的第二个抽象方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5、接口\"><a href=\"#5、接口\" class=\"headerlink\" title=\"5、接口\"></a>5、接口</h4><p>接口是对抽象类的进一步抽象，但是接口不是类。接口用 interface 来修饰，实现类通过 implements 来实现接口，子接口通过 extends 来继承父接口。</p>\n<p>接口有以下特点：</p>\n<ul>\n<li><p>接口可以定义成员变量，但是所有的成员变量都会隐式指定为 public static final 变量（并且只能是 public static final 变量，用 private 修饰会报编译错误），所以我们一般不在接口定义成员变量。</p>\n</li>\n<li><p>接口的方法都会隐式指定为 public abstract 方法且只能是 public abstract 方法（用其他关键字，比如 private、protected、static、 final 等修饰会报编译错误），并且接口中所有的方法不能有具体的实现。</p>\n</li>\n<li><p>实现接口的非抽象类必须要实现该接口的所有方法，如果没有完全实现接口的所有方法就要被定义为抽象类。</p>\n</li>\n</ul>\n<p>例如下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Interface &#123; //父接口</span><br><span class=\"line\">    String name = &quot;这是一个常量&quot;; //变量隐式用public static final修饰，所以必须赋初值</span><br><span class=\"line\"></span><br><span class=\"line\">    void method(); //方法隐式用public abstract修饰</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface ChildInterface extends Interface &#123; //子接口通过extends继承父接口</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">abstract class ImplementClass1 implements Interface &#123; //没有实现接口所有方法的类必须定义为抽象类</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ImplementClass2 implements Interface &#123; //实现接口所有方法的类不用定义为抽象类</span><br><span class=\"line\">    public void method() &#123; //因为接口方法隐式用public abstract修饰，所以这里必须加上public修饰符</span><br><span class=\"line\">        System.out.println(&quot;实现接口的方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6、抽象类和接口的区别\"><a href=\"#6、抽象类和接口的区别\" class=\"headerlink\" title=\"6、抽象类和接口的区别\"></a>6、抽象类和接口的区别</h4><h5 id=\"1）语法层面上的区别\"><a href=\"#1）语法层面上的区别\" class=\"headerlink\" title=\"1）语法层面上的区别\"></a>1）语法层面上的区别</h5><ol>\n<li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li>\n<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li>\n<li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li>\n<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>\n</ol>\n<h5 id=\"2）设计层面上的区别\"><a href=\"#2）设计层面上的区别\" class=\"headerlink\" title=\"2）设计层面上的区别\"></a>2）设计层面上的区别</h5><ol>\n<li><p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口 Fly，包含方法 fly( )，然后 Airplane和 Bird 分别根据自己的需要实现 Fly 这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承 Airplane 即可，对于鸟也是类似的，不同种类的鸟直接继承 Bird 类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>\n</li>\n<li><p>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过 ppt 里面的模板，如果用模板A设计了 ppt B和ppt C，ppt B和ppt C公共的部分就是模板 A 了，如果它们的公共部分需要改动，则只需要改动模板 A 就可以了，不需要重新对 ppt B 和 ppt C 进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>\n</li>\n</ol>\n<p>下面看一个网上流传最广泛的例子：门和警报的例子：门都有 open( ) 和 close( ) 两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">abstract class Door &#123;</span><br><span class=\"line\">    public abstract void open();</span><br><span class=\"line\">    public abstract void close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Door &#123;</span><br><span class=\"line\">    public abstract void open();</span><br><span class=\"line\">    public abstract void close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>\n<ol>\n<li>将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</li>\n<li>将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</li>\n</ol>\n<p>从这里可以看出， Door 的 open() 、close() 和 alarm() 根本就属于两个不同范畴内的行为，open() 和 close() 属于门本身固有的行为特性，而 alarm() 属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含 alarm() 行为,Door 设计为单独的一个抽象类，包含 open 和 close 两种行为。再设计一个报警门继承 Door 类和实现 Alarm 接口。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Alram &#123;</span><br><span class=\"line\">    void alarm();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">abstract class Door &#123;</span><br><span class=\"line\">    void open();</span><br><span class=\"line\">    void close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class AlarmDoor extends Door implements Alarm &#123;</span><br><span class=\"line\">    void oepn() &#123;</span><br><span class=\"line\">      //....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void close() &#123;</span><br><span class=\"line\">      //....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void alarm() &#123;</span><br><span class=\"line\">      //....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上参考 <a href=\"https://www.cnblogs.com/dolphin0520/p/3811437.html\">深入理解Java的接口和抽象类</a><br><a href=\"https://blog.csdn.net/chenssy/article/details/12858267\">java提高篇（四）—–抽象类与接口</a></p>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><h3 id=\"多态是什么\"><a href=\"#多态是什么\" class=\"headerlink\" title=\"多态是什么\"></a>多态是什么</h3><p><em><strong>多态是指当当一个变量用父类类型声明，但用子类类型实例化，该变量在编译阶段会表现为父类类型，在运行阶段会表现为子类类型，会使用子类类型的方法</strong></em>。例如下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Human &#123;</span><br><span class=\"line\">  public void eat() &#123; //父类的 eat 方法</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Woman extends Human &#123;</span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public void eat() &#123; //Human 类重写 eat() 方法</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Man extends Human &#123;</span><br><span class=\"line\">  public void eat() &#123; //Man 类重写 eat() 方法</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class HumanTest &#123;</span><br><span class=\"line\">  public static void main(String[] args) &#123;</span><br><span class=\"line\">    Human human = new Woman();</span><br><span class=\"line\">    human.eat(); //会调用 Woman 类的 eat() 方法</span><br><span class=\"line\"></span><br><span class=\"line\">    human = new Man();</span><br><span class=\"line\">    human.eat(); //会调用 Man 类的 eat() 方法</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面例子我们可以看到，一个用父类类型 Human 声明的变量 human 调用 eat() 方法，当该变量用子类 Woman 实例化时会调用 Woman 的 eat() 方法，用子类 Man 实例化时会调用 Man 的 eat() 方法，同一个类型声明的变量可以调用不同子类型的方法，具体调用哪个类的方法要等运行阶段实例化对象的时候才能确定，这就是多态性。</p>\n<h3 id=\"深入多态\"><a href=\"#深入多态\" class=\"headerlink\" title=\"深入多态\"></a>深入多态</h3><h4 id=\"1、动态绑定和静态绑定\"><a href=\"#1、动态绑定和静态绑定\" class=\"headerlink\" title=\"1、动态绑定和静态绑定\"></a>1、动态绑定和静态绑定</h4><p>绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来。对 java 来说，绑定分为 <strong>静态绑定</strong> 和 <strong>动态绑定</strong>；或者叫做前期绑定和后期绑定。</p>\n<p><strong>静态绑定</strong>：</p>\n<p>在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。例如：C。<br>针对 Java 简单的可以理解为程序编译期的绑定。<em><strong>java 当中的方法只有 final，static，private 和构造方法是前期绑定</strong></em>。</p>\n<p><strong>动态绑定</strong>：</p>\n<p>在运行时根据具体对象的类型进行绑定。<br>若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。</p>\n<p><strong>java 方法的调用过程：</strong></p>\n<ol>\n<li>编译器查看对象的声明类型和方法名（对象变量的声明类型），通过声明类型找到方法列表。</li>\n<li>编译器查看调用方法时提供的参数类型。如果方法是 private、static、final或者构造器，编译器就可以确定调用那个方法。这是静态绑定。</li>\n<li>如果不是上述情况，就要使用运行时（动态）绑定。在程序运行时，采用动态绑定意味着：<em><strong>虚拟机将调用对象实际类型所限定的方法</strong></em>。具体过程如下：</li>\n</ol>\n<p><strong>动态绑定的过程：</strong></p>\n<ol>\n<li>虚拟机提取对象的实际类型的方法表；</li>\n<li>虚拟机搜索方法签名；</li>\n<li>调用方法。</li>\n</ol>\n<p><strong>总结：</strong></p>\n<p>在 java 中，几乎所有的 方法（不是字段属性）都是后期绑定（动态绑定），除了 private、static、final 修饰的方法。</p>\n<ul>\n<li>对于 static 方法和 final 方法由于不能被继承，因此在编译时就可以确定他们的值，他们是属于前期绑定（静态绑定）的。</li>\n<li>对于 private 声明的方法和成员变量不能被子类继承，所有的 private 方法都被隐式的指定为 final。由此我们也可以知道：将方法声明为 final 类型的一是为了防止方法被覆盖，二是为了有效的关闭 java 中的动态绑定。</li>\n</ul>\n<p>参考 <a href=\"https://my.oschina.net/u/566345/blog/81235\">java的动态绑定与静态绑定(彻底理解多态与重载)</a></p>\n<h4 id=\"2、向上转型和向下转型\"><a href=\"#2、向上转型和向下转型\" class=\"headerlink\" title=\"2、向上转型和向下转型\"></a>2、向上转型和向下转型</h4><p><strong>向上转型</strong>：父类引用指向子类对象</p>\n<p>好处：父类声明的变量（包括实参和形参）引用子类对象，可以直接调用子类对象中的方法，这样用一种类型声明的变量就可以调用其所有子类的方法，代码比较简介灵活。否则要调用子类的方法，有多少个子类就要声明多少种类型的变量。</p>\n<p>坏处：父类声明的对象只能调用子类重写父类的方法，子类内其他自定义的方法会丢失。</p>\n<p><strong>向下转型</strong>：父类引用指向子类对象后，再把父类引用类型转换类型后赋值给子类引用</p>\n<p>好处：可以调用子类中所有的方法</p>\n<p>坏处：可能会存在类型转换失败，在编译时能通过，但是运行会出错，为了安全的类型转换，最好先用 if(A instanceof  B) 判断一下。</p>\n<h4 id=\"3、重载和重写\"><a href=\"#3、重载和重写\" class=\"headerlink\" title=\"3、重载和重写\"></a>3、重载和重写</h4><p><strong>重载（OverLoad）</strong> ：一个类中定义了多个方法名相同，参数的类型或者数量不同的方法</p>\n<ul>\n<li>参数列表必须改变(参数个数或类型不一样)；</li>\n<li>返回类型可以改变；</li>\n<li>访问修饰符可以改变；</li>\n<li>可以声明新的或更广的检查异常；</li>\n<li>返回值类型不能作为重载函数的区分标准。</li>\n<li>方法能够在同一个类中或者在一个子类中被重载。</li>\n</ul>\n<p><strong>重写（Override）</strong> ：子类定义了和父类方法名相同、参数个数类型相同、返回值相同的方法。</p>\n<ul>\n<li>参数列表必须完全与被重写方法的相同；</li>\n<li>返回类型必须完全与被重写方法的返回类型相同；</li>\n<li>访问修饰符可以改变，但是不能做更严格的限制（可以降低限制）</li>\n<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>\n<li>父类的成员方法只能被它的子类重写。</li>\n<li>声明为 final 的方法不能被重写。</li>\n<li>声明为 static 的方法不能被重写，但是能够被再次声明。</li>\n<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li>\n<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li>\n<li>构造方法不能被重写。</li>\n<li>如果不能继承一个方法，则不能重写这个方法。</li>\n</ul>\n<p>总结：方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</p>\n<p> | 方法名 | 参数列表 | 返回类型 | 访问修饰符 | 异常</p>\n<ul>\n<li>| - | - | - | - | -<br>重写 | 必须相同 | 必须相同 | 必须相同 | 可以不同（不能做更严格的限制） | 可以减少或删除，一定不能抛出新的或者更广的异常<br>重载 | 必须相同 | 必须不同（类型或个数不同）| 可以不同 | 可以不同 | 可以不同</li>\n</ul>\n<p>简单来说，重写靠方法名、参数列表和返回值三个相同的判断，重载只靠方法名相同来判断，访问修饰符和异常均不能作为判断依据。</p>\n<h4 id=\"3、多态的三个必要条件\"><a href=\"#3、多态的三个必要条件\" class=\"headerlink\" title=\"3、多态的三个必要条件\"></a>3、多态的三个必要条件</h4><ol>\n<li><strong>存在继承关系</strong></li>\n<li><strong>子类要重写父类的方法</strong></li>\n<li><strong>父类类型的引用指向子类对象（向上转型）</strong></li>\n</ol>\n<p>看下面这个例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">    int num = 10;</span><br><span class=\"line\">    static int age = 20;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;动物吃饭&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void sleep() &#123;</span><br><span class=\"line\">        System.out.println(&quot;动物在睡觉&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(&quot;动物在奔跑&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Cat extends Animal &#123;</span><br><span class=\"line\">    int num = 80;</span><br><span class=\"line\">    static int age = 90;</span><br><span class=\"line\">    String name = &quot;tomCat&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;猫吃饭&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void sleep() &#123;</span><br><span class=\"line\">        System.out.println(&quot;猫在睡觉&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void catchMouse() &#123;</span><br><span class=\"line\">        System.out.println(&quot;猫在抓老鼠&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class AnimalTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Animal am = new Cat();</span><br><span class=\"line\">        am.eat();</span><br><span class=\"line\">        am.sleep();</span><br><span class=\"line\">        am.run();</span><br><span class=\"line\">        //am.catchMouse(); //这里需要注释掉，因为am不能调用子类特有的方法catchMouse()</span><br><span class=\"line\">        //System.out.println(am.name); //这里需要注释掉，因为am不能调用子类特有的属性name</span><br><span class=\"line\">        System.out.println(am.num);</span><br><span class=\"line\">        System.out.println(am.age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上的三段代码充分体现了多态的三个前提，即：</p>\n<ol>\n<li>存在继承关系<br>Cat 类继承了 Animal 类</li>\n<li>子类要重写父类的方法<br>子类重写(override)了父类的两个成员方法 eat()，sleep()。其中 eat() 是非静态的，sleep() 是静态的<br>（static）。</li>\n<li>父类数据类型的引用指向子类对象。（向上转型）<br>测试类 Demo_Test1 中 Animal am &#x3D; new Cat();语句在堆内存中开辟了子类 (Cat) 的对象，并把栈内存中的<br>父类 (Animal) 的引用指向了这个 Cat 对象。<br>到此，满足了 Java 多态的的必要三个前提。</li>\n</ol>\n<p>输出结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">猫吃饭</span><br><span class=\"line\">动物在睡觉</span><br><span class=\"line\">动物在奔跑</span><br><span class=\"line\">10</span><br><span class=\"line\">20</span><br></pre></td></tr></table></figure>\n\n<p>可以看出来<br>子类 Cat 重写了父类 Animal 的非静态成员方法 am.eat() 的输出结果为：猫吃饭。<br>子类重写了父类 (Animal) 的静态成员方法 am.sleep() 的输出结果为：动物在睡觉<br>未被子类（Cat）重写的父类（Animal）方法 am.run() 输出结果为：动物在奔跑</p>\n<p>总结：<br>成员变量（包括静态和非静态）和静态方法，编译看父类，运行看父类<br>只有非静态的成员方法，编译看父类，运行看子类</p>\n<p>但是多态有一个弊端：<em><strong>多态后不能使用子类特有的成员属性和成员方法</strong></em>。例如上面的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">am.catchMouse();</span><br><span class=\"line\">System.out.println(am.name);</span><br></pre></td></tr></table></figure>\n\n<p>在编译器期间会报错，因为 am 对象不能去获取子类特有的方法 catchMouse() 和属性 am.name。如果一定要调用子类特有的方法和方法，需要把父类引用转成子类类型，也就是向下转型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">((Cat)am).catchMouse(); //强转成 Cat 类型再调用编译就不会报错了</span><br><span class=\"line\">System.out.println(((Cat)am).name); //强转成 Cat 类型再调用编译就不会报错了</span><br></pre></td></tr></table></figure>\n\n<p>参考 <a href=\"https://www.zhihu.com/question/30082151\">JAVA的多态用几句话能直观的解释一下吗？</a></p>\n","categories":["Java","Java基础"],"tags":["Java"]},{"title":"js正则表达式","url":"/2018/09/05/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"<blockquote>\n<p>正则表达式具有复杂字符串搜寻，替换，验证等强大功能，最近接触了 js 的正则表达式顺便学习了一下基础，在这里记录一下学习相关资料。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>下面有两篇文章较为详细地介绍了 js 正则表达式的基础内容和一些实践例子，先直接贴链接，以后有时间再详细介绍内容：</p>\n<p><a href=\"https://www.jianshu.com/p/67e3bcafdd46\">JavaScript 正则表达式（实例）</a></p>\n<p><a href=\"http://imweb.io/topic/56e804ef1a5f05dc50643106\">玩转JavaScript正则表达式</a></p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"RexExp-对象\"><a href=\"#RexExp-对象\" class=\"headerlink\" title=\"RexExp 对象\"></a>RexExp 对象</h3><h4 id=\"RexExp-对象是什么\"><a href=\"#RexExp-对象是什么\" class=\"headerlink\" title=\"RexExp 对象是什么\"></a>RexExp 对象是什么</h4><p>RexExp 对象是一个全局对象，用于存储模式匹配期间找到的对象。</p>\n<ul>\n<li>RexExp 对象的写法是 <strong>RexExp.$n</strong>，RexExp.$1，RexExp.$2……RexExp.$99，一共可以存储 99 个对象。</li>\n<li>每次在调用 <strong>非全局的</strong>（没有 g 修饰）文本匹配方法，例如<code>RegExp.prototype.exec(str)</code>、 <code>String.prototype.match(reg)</code> 或者 <code>String.prototype.replace(reg)</code> 时，当找到匹配项时，<em><strong>RexExp.$1 对应匹配项中第一个括号中的内容，RexExp.$2 对应匹配项中第二个括号中的内容，以此类推</strong></em>。也就是说 RexExp 对象只储存括号里面的内容。</li>\n<li>每次找到匹配项都会 <em><strong>更新所有 RexExp 对象</strong></em>，也就是说 RexExp.$1，RexExp.$2……这些对象全都会被更新。</li>\n</ul>\n<p>这么说可能有点抽象，看下下面的例子就明白了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var reg1 = /\\d(\\w)/;</span><br><span class=\"line\">var reg2 = /\\d(\\w)/g;</span><br><span class=\"line\">var str = &#x27;$1a2b3c4d5e&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">//非全局匹配</span><br><span class=\"line\">var rs1 = str.match(reg1)</span><br><span class=\"line\">console.log(rs1) //[&quot;1a&quot;, &quot;a&quot;, index: 1, input: &quot;$1a2b3c4d5e&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">//全局匹配</span><br><span class=\"line\">var rs2 = str.match(reg2)</span><br><span class=\"line\">console.log(rs2) //[&quot;1a&quot;, &quot;2b&quot;, &quot;3c&quot;, &quot;4d&quot;, &quot;5e&quot;]</span><br></pre></td></tr></table></figure>\n\n<p>在上面非全局匹配中返回的数组信息有</p>\n<ul>\n<li>第一个元素 1a 是找到的第一个匹配项。</li>\n<li>第二个元素对应 RegExp.$1 存储的内容。因为正则表达式<code>\\d(\\w)</code> 有一个括号 <code>(\\w)</code>，对应匹配项 1a 里面的 a，所以 a 会被存储在 RegExp.$1 中。</li>\n<li>index: 1 表示找到匹配项首字符的位置。</li>\n<li>input: “1a2b3c4d5e” 表示输入的查找字符串。</li>\n</ul>\n<p>但是在全局匹配返回的数组里面，就只有所有的匹配项信息，RegExp对象、index 和 input 这些信息都没有保存。</p>\n<h4 id=\"RexExp-对象怎么用\"><a href=\"#RexExp-对象怎么用\" class=\"headerlink\" title=\"RexExp 对象怎么用\"></a>RexExp 对象怎么用</h4><p>那么这些 RexExp 对象有什么作用呢？其中最重要的一个作用是用子匹配项 RexExp.$n 来替换原来的文本内容。比如我们想把 ‘2016-11-25’ 变成 ‘11&#x2F;25&#x2F;2016’，这时候用 RexExp 对象就会非常方便</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x27;2016-11-25&#x27;.replace(/(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/g,&#x27;$2/$3/$1&#x27;) //&#x27;11/25/2016&#x27;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>下面收集了在工作中常用到的一些正则表达式的例子，在这里记录一下以供日后查阅</p>\n<h3 id=\"控制输入框金额的正确性\"><a href=\"#控制输入框金额的正确性\" class=\"headerlink\" title=\"控制输入框金额的正确性\"></a>控制输入框金额的正确性</h3><p>思路是通过动态修改输入框的内容来控制输入金额的合法性，这里的合法性包括</p>\n<ul>\n<li>输入的必须数字或者小数点.</li>\n<li>整数部分不能是0开头的两位以上数字</li>\n<li>小数部分不能超过两位数字</li>\n<li>不能包含两个以上小数点</li>\n</ul>\n<p>做法是输入框绑定动态输入事件，每次输入内容时候都把内容传进来检查一遍，如果存在不合法的地方进行替换修改，最后把检查完的内容返回输入框显示。这里假设传进来的内容是 <code>value</code>，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var regStrs = [</span><br><span class=\"line\">  [&#x27;^0(\\\\d+)$&#x27;, &#x27;$1&#x27;], //禁止录入整数部分两位以上，但首位为0</span><br><span class=\"line\">  [&#x27;[^\\\\d\\\\.]+$&#x27;, &#x27;&#x27;], //禁止录入任何非数字和点</span><br><span class=\"line\">  [&#x27;\\\\.(\\\\d?)\\\\.+&#x27;, &#x27;.$1&#x27;], //禁止录入两个以上的点</span><br><span class=\"line\">  [&#x27;^(\\\\d+\\\\.\\\\d&#123;2&#125;).+&#x27;, &#x27;$1&#x27;] //禁止录入小数点后两位以上</span><br><span class=\"line\">]</span><br><span class=\"line\">for (var i = 0; i &lt; regStrs.length; i++) &#123;</span><br><span class=\"line\">  var reg = new RegExp(regStrs[i][0]);</span><br><span class=\"line\">  value = value.replace(reg, regStrs[i][1]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["前端","javascript"],"tags":["javascript"]},{"title":"log4j详解","url":"/2019/08/02/log4j%E8%AF%A6%E8%A7%A3/","content":"<blockquote>\n<p> Log4j是Apache的一个开源的日志框架，通过使用Log4j，可以控制将应用日志信息输送到指定的地方。下面学习log4j的简单入门和相关的配置文件。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"log4j是什么\"><a href=\"#log4j是什么\" class=\"headerlink\" title=\"log4j是什么\"></a>log4j是什么</h1><p>Log4j是Apache的一个开源的日志框架，通过使用Log4j，可以控制将应用日志信息输送到：</p>\n<p>控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程、数据库等；</p>\n<p>可以控制每一条日志的输出格式；</p>\n<p>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</p>\n<p>最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p>\n<h1 id=\"配置使用log4j\"><a href=\"#配置使用log4j\" class=\"headerlink\" title=\"配置使用log4j\"></a>配置使用log4j</h1><h2 id=\"1、引入依赖\"><a href=\"#1、引入依赖\" class=\"headerlink\" title=\"1、引入依赖\"></a>1、引入依赖</h2><ul>\n<li>非springboot项目</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>maven路径：<a href=\"https://mvnrepository.com/artifact/log4j/log4j\">https://mvnrepository.com/artifact/log4j/log4j</a></p>\n<ul>\n<li>springboot项目</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.3.8.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>可以不加版本号，使用 spring-boot-starter-parent 的版本好，maven仓库地址：<a href=\"https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-log4j\">https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-log4j</a></p>\n<h2 id=\"2、添加配置文件\"><a href=\"#2、添加配置文件\" class=\"headerlink\" title=\"2、添加配置文件\"></a>2、添加配置文件</h2><p>log4j支持properties和xml格式的配置文件，一般情况下用<code>log4j.properties</code>比较多。添加<code>log4j.properties</code>配置文件到类路径下面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger = debug,stdout,D,E</span><br><span class=\"line\"></span><br><span class=\"line\">### 输出信息到控制抬</span><br><span class=\"line\">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.stdout.Target = System.out</span><br><span class=\"line\">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><br><span class=\"line\"></span><br><span class=\"line\">### 输出DEBUG 级别以上的日志到=/home/duqi/logs/debug.log</span><br><span class=\"line\">log4j.appender.D = org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">log4j.appender.D.File = /home/duqi/logs/debug.log</span><br><span class=\"line\">log4j.appender.D.Append = true</span><br><span class=\"line\">log4j.appender.D.Threshold = DEBUG </span><br><span class=\"line\">log4j.appender.D.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br><span class=\"line\"></span><br><span class=\"line\">### 输出ERROR 级别以上的日志到=/home/admin/logs/error.log</span><br><span class=\"line\">log4j.appender.E = org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">log4j.appender.E.File =/home/admin/logs/error.log </span><br><span class=\"line\">log4j.appender.E.Append = true</span><br><span class=\"line\">log4j.appender.E.Threshold = ERROR </span><br><span class=\"line\">log4j.appender.E.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3、使用log4j打印\"><a href=\"#3、使用log4j打印\" class=\"headerlink\" title=\"3、使用log4j打印\"></a>3、使用log4j打印</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package com.javadu.log;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.slf4j.Logger;</span><br><span class=\"line\">import org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class Log4JTest &#123;</span><br><span class=\"line\">    private static final Logger logger = LoggerFactory.getLogger(Log4JTest.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        // 记录debug级别的信息</span><br><span class=\"line\">        logger.debug(&quot;This is debug message.&quot;);</span><br><span class=\"line\">        // 记录info级别的信息</span><br><span class=\"line\">        logger.info(&quot;This is info message.&quot;);</span><br><span class=\"line\">        // 记录error级别的信息</span><br><span class=\"line\">        logger.error(&quot;This is error message.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"log4j配置文件\"><a href=\"#log4j配置文件\" class=\"headerlink\" title=\"log4j配置文件\"></a>log4j配置文件</h1><p>Log4j支持两种配置文件格式，一种是XML（标准通用标记语言下的一个应用）格式的文件，一种是Java特性文件log4j.properties（键&#x3D;值）。下面主要介绍log4j.properties配置文件。</p>\n<p>Log4j有三个主要的组件：</p>\n<ul>\n<li>Logger(记录器):收集指定级别或指定包的日志 </li>\n<li>Appender (输出源):日志要输出的地方</li>\n<li>Layout(布局):日志以何种形式输出</li>\n</ul>\n<p>其中Logger和Appender的关系是：</p>\n<ol>\n<li>Logger类似于收集器，可以指定多个收集器，每个收集器收集指定级别或者指定包下面的日志。Appender负责把Logger收集到的日志输出到指定位置。</li>\n<li>一个Logger输出到多个Appender</li>\n</ol>\n<h2 id=\"1、Logger\"><a href=\"#1、Logger\" class=\"headerlink\" title=\"1、Logger\"></a>1、Logger</h2><p>Logger定义了所收集的日志的级别或者包位置。</p>\n<p>Logger的日志级别分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别。</p>\n<p>Log4j建议只使用四个级别，优先级从高到低分别是<strong>ERROR、WARN、INFO、DEBUG</strong>。通过在这里定义的级别，可以控制<strong>只有等于或高于该级别的日志才会被打印</strong>。比如在这里定义了INFO级别，只有等于及高于这个级别的才进行打印，则应用程序中所有DEBUG级别的日志信息将不被打印出来。</p>\n<p>Logger分为根Logger和非根Logger。</p>\n<h3 id=\"根Logger\"><a href=\"#根Logger\" class=\"headerlink\" title=\"根Logger\"></a>根Logger</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger = [ level ] , appenderName, appenderName, ...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"非根Logger\"><a href=\"#非根Logger\" class=\"headerlink\" title=\"非根Logger\"></a>非根Logger</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.logger.loggerName1 = [ level ], appendName1,…appendNameN</span><br></pre></td></tr></table></figure>\n\n<p><code>loggerName1</code>可以自己随便定义，在代码里面通过 <code>public static final Logger log = LoggerFactory.getLogger(&quot;loggerName1&quot;);</code> 的方式调用该Logger。</p>\n<p>所有的非根Logger打印的日志默认都会追加到根Logger，也就是日志信息会在两个日志文件各打印一份。如果想禁止追加到根Logger，可以在非根Logger输出的Appender配置属性<code>Append=false</code></p>\n<p>非根Logger有多种用法</p>\n<ol>\n<li><p>例如我们想定义一个Logger专门用来收集sql语句，在properties定义</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.logger.sql=DEBUG,sql_log</span><br></pre></td></tr></table></figure>\n\n<p>然后我们在代码里面使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static final Logger log = LoggerFactory.getLogger(&quot;sql&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>日志信息全部打印到<code>sql_log</code>指定的appender里面。</p>\n</li>\n<li><p>例如某个依赖包打印的INFO以下的日志信息太多，我们只想收集ERROR以上的日志，可以定义</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger=INFO,api_stdout</span><br><span class=\"line\">log4j.logger.com.mchange.v2.resourcepool.BasicResourcePool=ERROR,api_stdout</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用根Logger打印，其他包都打印INFO及以上的日志，这个包只会打印ERROR及以上的信息。</p>\n</li>\n<li><p>同一个类输出多个日志文件。首先在properties定义</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.logger.myTest1= DEBUG, test1</span><br><span class=\"line\">log4j.logger.myTest2= DEBUG, test2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后在代码里面使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">private static Log logger1 = LogFactory.getLog(&quot;myTest1&quot;); </span><br><span class=\"line\">private static Log logger2 = LogFactory.getLog(&quot;myTest2&quot;); </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2、Appender\"><a href=\"#2、Appender\" class=\"headerlink\" title=\"2、Appender\"></a>2、Appender</h2><p>Appender把日志输出到不同的地方，如控制台（Console）、文件（Files）等，可以根据天数或者文件大小产生新的文件，可以以流的形式发送到其它地方等等。</p>\n<p>配置语法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.appender.appenderName = Appender完整类名</span><br><span class=\"line\">log4j.appender.appenderName.layout = Layout完整类名</span><br><span class=\"line\">log4j.appender.appenderName.Option1 = value1</span><br><span class=\"line\">…</span><br><span class=\"line\">log4j.appender.appenderName.OptionN = valueN</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Layout\"><a href=\"#Layout\" class=\"headerlink\" title=\"Layout\"></a>Layout</h3><p>Layouts提供四种日志输出样式，如根据<strong>HTML样式</strong>、<strong>自由指定样式</strong>、<strong>包含日志级别与信息的样式</strong>和<strong>包含日志时间、线程、类别等信息的样式</strong>。</p>\n<ul>\n<li>org.apache.log4j.HTMLLayout（以HTML表格形式布局）</li>\n<li>org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</li>\n<li>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</li>\n<li>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）</li>\n</ul>\n<p>HTMLLayout和PatternLayout有一些配置选项，其他的都是默认格式。</p>\n<h4 id=\"1-HTMLLayout\"><a href=\"#1-HTMLLayout\" class=\"headerlink\" title=\"1. HTMLLayout\"></a>1. HTMLLayout</h4><ul>\n<li>LocationInfo&#x3D;true：输出java文件名称和行号，默认值是false。</li>\n<li>Title&#x3D;My Logging： 默认值是Log4J Log Messages。</li>\n</ul>\n<h4 id=\"2-PatternLayout\"><a href=\"#2-PatternLayout\" class=\"headerlink\" title=\"2. PatternLayout\"></a>2. PatternLayout</h4><ul>\n<li>ConversionPattern&#x3D;%m%n：设定以怎样的格式显示消息。参数解释如下：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n<th><strong>例子</strong></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%c</td>\n<td>列出logger名字空间的全称，如果加上{&lt;层数&gt;}表示列出从最内层算起的指定层数的名字空间</td>\n<td>log4j配置文件参数举例</td>\n<td>输出显示媒介</td>\n</tr>\n<tr>\n<td>假设当前logger名字空间是”a.b.c”</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%c</td>\n<td>a.b.c</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%c{2}</td>\n<td>b.c</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%20c</td>\n<td>（若名字空间长度小于20，则左边用空格填充）</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%-20c</td>\n<td>（若名字空间长度小于20，则右边用空格填充）</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%.30c</td>\n<td>（若名字空间长度超过30，截去多余字符）</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%20.30c</td>\n<td>（若名字空间长度小于20，则左边用空格填充；若名字空间长度超过30，截去多余字符）</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%-20.30c</td>\n<td>（若名字空间长度小于20，则右边用空格填充；若名字空间长度超过30，截去多余字符）</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%C</td>\n<td>列出调用logger的类的全名（包含包路径）</td>\n<td>假设当前类是”org.apache.xyz.SomeClass”</td>\n<td></td>\n</tr>\n<tr>\n<td>%C</td>\n<td>org.apache.xyz.SomeClass</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%C{1}</td>\n<td>SomeClass</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%d</td>\n<td>显示日志记录时间，{&lt;日期格式&gt;}使用ISO8601定义的日期格式</td>\n<td>%d{yyyy&#x2F;MM&#x2F;dd HH:mm:ss,SSS}</td>\n<td>2005&#x2F;10&#x2F;12 22:23:30,117</td>\n</tr>\n<tr>\n<td>%d{ABSOLUTE}</td>\n<td>22:23:30,117</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%d{DATE}</td>\n<td>12 Oct 2005 22:23:30,117</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%d{ISO8601}</td>\n<td>2005-10-12 22:23:30,117</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%F</td>\n<td>显示调用logger的源文件名</td>\n<td>%F</td>\n<td>MyClass.java</td>\n</tr>\n<tr>\n<td>%l</td>\n<td>输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数</td>\n<td>%l</td>\n<td>MyClass.main(MyClass.java:129)</td>\n</tr>\n<tr>\n<td>%L</td>\n<td>显示调用logger的代码行</td>\n<td>%L</td>\n<td>129</td>\n</tr>\n<tr>\n<td>%m</td>\n<td>显示输出消息</td>\n<td>%m</td>\n<td>This is a message for debug.</td>\n</tr>\n<tr>\n<td>%M</td>\n<td>显示调用logger的方法名</td>\n<td>%M</td>\n<td>main</td>\n</tr>\n<tr>\n<td>%n</td>\n<td>当前平台下的换行符</td>\n<td>%n</td>\n<td>Windows平台下表示rnUNIX平台下表示n</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>显示该条日志的优先级</td>\n<td>%p</td>\n<td>INFO</td>\n</tr>\n<tr>\n<td>%r</td>\n<td>显示从程序启动时到记录该条日志时已经经过的毫秒数</td>\n<td>%r</td>\n<td>1215</td>\n</tr>\n<tr>\n<td>%t</td>\n<td>输出产生该日志事件的线程名</td>\n<td>%t</td>\n<td>MyClass</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>按NDC（Nested Diagnostic Context，线程堆栈）顺序输出日志</td>\n<td>假设某程序调用顺序是MyApp调用com.foo.Bar</td>\n<td></td>\n</tr>\n<tr>\n<td>%c %x - %m%n</td>\n<td>MyApp - Call com.foo.Bar.com.foo.Bar - Log in BarMyApp - Return to MyApp.</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%X</td>\n<td>按MDC（Mapped Diagnostic Context，线程映射表）输出日志。通常用于多个客户端连接同一台服务器，方便服务器区分是那个客户端访问留下来的日志。</td>\n<td>%X{5}</td>\n<td>（记录代号为5的客户端的日志）</td>\n</tr>\n<tr>\n<td>%%</td>\n<td>显示一个百分号</td>\n<td>%%</td>\n<td>%</td>\n</tr>\n</tbody></table>\n<p>实例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%p] (%F:%L) %t %m%n</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>打印结果为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">2019-08-02 17:50:08 101 [INFO] (Slf4JLogger.java:101) nioEventLoopGroup-2-1 [id: 0x9fc7d7b5] REGISTERED</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Appender\"><a href=\"#Appender\" class=\"headerlink\" title=\"Appender\"></a>Appender</h3><p>常用的Appender如下：</p>\n<ul>\n<li>org.apache.log4j.ConsoleAppender（控制台）</li>\n<li>org.apache.log4j.FileAppender（文件）</li>\n<li>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</li>\n<li>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</li>\n<li>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</li>\n</ul>\n<p>每个Appender都有一些配置选项。</p>\n<h4 id=\"1-ConsoleAppender\"><a href=\"#1-ConsoleAppender\" class=\"headerlink\" title=\"1. ConsoleAppender\"></a>1. ConsoleAppender</h4><p>ConsoleAppender会把消息全部输出到控制台</p>\n<p>配置选项</p>\n<ul>\n<li>Threshold&#x3D;WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>\n<li>ImmediateFlush&#x3D;true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</li>\n<li>Target&#x3D;System.err：默认值是System.out。</li>\n</ul>\n<p>实例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger=info,console_log</span><br><span class=\"line\"></span><br><span class=\"line\">log4j.appender.console_log= org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.console_log.layout=org.apache.log4j.PatternLayout </span><br><span class=\"line\">log4j.appender.console_log.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%p] (%F:%L) %t %m%n</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-FileAppender\"><a href=\"#2-FileAppender\" class=\"headerlink\" title=\"2. FileAppender\"></a>2. FileAppender</h4><p>FileAppender会一直把日志输出到一个文件，容易发生文件过大导致读写缓慢的问题，不推荐使用。</p>\n<p>配置选项</p>\n<ul>\n<li>Threshold&#x3D;WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>\n<li>ImmediateFlush&#x3D;true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</li>\n<li>Append&#x3D;false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</li>\n<li>File&#x3D;D:&#x2F;logs&#x2F;logging.log4j：指定消息输出到logging.log4j文件中。</li>\n</ul>\n<p>实例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger=info,file_log</span><br><span class=\"line\"></span><br><span class=\"line\">log4j.appender.file_log=org.apache.log4j.RollingFileAppender </span><br><span class=\"line\">log4j.appender.file_log.File= $&#123;api.logs.dir&#125;/file.log </span><br><span class=\"line\">log4j.appender.file_log.Append = true </span><br><span class=\"line\">log4j.appender.file_log.MaxFileSize=100MB</span><br><span class=\"line\">log4j.appender.file_log.MaxBackupIndex=15</span><br><span class=\"line\">log4j.appender.file_log.layout=org.apache.log4j.PatternLayout </span><br><span class=\"line\">log4j.appender.file_log.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%p] (%F:%L) %t %m%n</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-RollingFileAppender\"><a href=\"#3-RollingFileAppender\" class=\"headerlink\" title=\"3. RollingFileAppender\"></a>3. RollingFileAppender</h4><p>达到指定文件大小的时候，会把当前的日志文件重命名，作为备份文件保存，并生成新的日志文件用来接收日志。</p>\n<p>配置选项</p>\n<ul>\n<li>Threshold&#x3D;WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>\n<li>ImmediateFlush&#x3D;true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</li>\n<li>Append&#x3D;false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</li>\n<li>File&#x3D;D:&#x2F;logs&#x2F;logging.log4j：指定消息输出到logging.log4j文件中。</li>\n<li>MaxFileSize&#x3D;100KB：后缀可以是KB, MB 或者GB。当日志文件到达该大小时，文件被重命名为logging.log4j.1，作为备份文件保存起来，并生成一个新的logging.log4j用来接收日志。</li>\n<li>MaxBackupIndex&#x3D;2：指定可以备份文件的最大数。</li>\n</ul>\n<p>实例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger=DEBUG,sql_log</span><br><span class=\"line\"></span><br><span class=\"line\">log4j.appender.sql_log=org.apache.log4j.RollingFileAppender </span><br><span class=\"line\">log4j.appender.sql_log.File= $&#123;api.logs.dir&#125;/sql.log </span><br><span class=\"line\">log4j.appender.sql_log.Append = true </span><br><span class=\"line\">log4j.appender.sql_log.MaxFileSize=100MB</span><br><span class=\"line\">log4j.appender.sql_log.MaxBackupIndex=15</span><br><span class=\"line\">log4j.appender.sql_log.layout=org.apache.log4j.PatternLayout </span><br><span class=\"line\">log4j.appender.sql_log.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%p] (%F:%L) %t %m%n</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-DailyRollingFileAppender\"><a href=\"#4-DailyRollingFileAppender\" class=\"headerlink\" title=\"4. DailyRollingFileAppender\"></a>4. DailyRollingFileAppender</h4><p>每隔一段时间生成一个日志文件，时间间隔和备份文件命名由<code>DatePattern</code>配置。但是不能指定备份文件的大小的个数，也就是说RollingFileAppender的<code>MaxFileSize</code>和<code>MaxBackupIndex</code>在这里不起作用，如果想控制备份文件的大小可以参考[<a href=\"https://www.cnblogs.com/rembau/p/5201001.html\">Log4j的扩展-支持设置最大日志数量的DailyRollingFileAppender</a>]</p>\n<p>配置选项</p>\n<ul>\n<li><p>Threshold&#x3D;WARN：指定日志信息的最低输出级别，默认为DEBUG。</p>\n</li>\n<li><p>ImmediateFlush&#x3D;true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</p>\n</li>\n<li><p>Append&#x3D;false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</p>\n</li>\n<li><p>File&#x3D;D:&#x2F;logs&#x2F;logging.log4j：指定当前消息输出到logging.log4j文件中。</p>\n</li>\n<li><p>DatePattern&#x3D;’.’yyyy-MM：每月滚动一次日志文件，即每月产生一个新的日志文件。当前月的日志文件名为logging.log4j，前一个月的日志文件名为logging.log4j.yyyy-MM。</p>\n<p>另外，也可以指定按周、天、时、分等来滚动日志文件，对应的格式如下：</p>\n<ol>\n<li>‘.’yyyy-MM：每月</li>\n<li>‘.’yyyy-ww：每周</li>\n<li>‘.’yyyy-MM-dd：每天</li>\n<li>‘.’yyyy-MM-dd-a：每天两次</li>\n<li>‘.’yyyy-MM-dd-HH：每小时</li>\n<li>‘.’yyyy-MM-dd-HH-mm：每分钟</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger=info,api_stdout</span><br><span class=\"line\"></span><br><span class=\"line\">log4j.appender.api_stdout=org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">log4j.appender.api_stdout.File= $&#123;api.logs.dir&#125;/api_stdout.log</span><br><span class=\"line\">log4j.appender.api_stdout.Append = true</span><br><span class=\"line\">log4j.appender.api_stdout.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.api_stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%p] (%F:%L) %c %t %m%n</span><br><span class=\"line\">log4j.appender.api_stdout.DatePattern = &#x27;.&#x27;yyyy-MM-dd_HH</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"完整实例\"><a href=\"#完整实例\" class=\"headerlink\" title=\"完整实例\"></a>完整实例</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger=DEBUG,console,dailyFile,im</span><br><span class=\"line\">log4j.additivity.org.apache=true</span><br><span class=\"line\"># 控制台(console)</span><br><span class=\"line\">log4j.appender.console=org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.console.Threshold=DEBUG</span><br><span class=\"line\">log4j.appender.console.ImmediateFlush=true</span><br><span class=\"line\">log4j.appender.console.Target=System.err</span><br><span class=\"line\">log4j.appender.console.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.console.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"># 日志文件(logFile)</span><br><span class=\"line\">log4j.appender.logFile=org.apache.log4j.FileAppender</span><br><span class=\"line\">log4j.appender.logFile.Threshold=DEBUG</span><br><span class=\"line\">log4j.appender.logFile.ImmediateFlush=true</span><br><span class=\"line\">log4j.appender.logFile.Append=true</span><br><span class=\"line\">log4j.appender.logFile.File=D:/logs/log.log4j</span><br><span class=\"line\">log4j.appender.logFile.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.logFile.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"># 回滚文件(rollingFile)</span><br><span class=\"line\">log4j.appender.rollingFile=org.apache.log4j.RollingFileAppender</span><br><span class=\"line\">log4j.appender.rollingFile.Threshold=DEBUG</span><br><span class=\"line\">log4j.appender.rollingFile.ImmediateFlush=true</span><br><span class=\"line\">log4j.appender.rollingFile.Append=true</span><br><span class=\"line\">log4j.appender.rollingFile.File=D:/logs/log.log4j</span><br><span class=\"line\">log4j.appender.rollingFile.MaxFileSize=200KB</span><br><span class=\"line\">log4j.appender.rollingFile.MaxBackupIndex=50</span><br><span class=\"line\">log4j.appender.rollingFile.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.rollingFile.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"># 定期回滚日志文件(dailyFile)</span><br><span class=\"line\">log4j.appender.dailyFile=org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">log4j.appender.dailyFile.Threshold=DEBUG</span><br><span class=\"line\">log4j.appender.dailyFile.ImmediateFlush=true</span><br><span class=\"line\">log4j.appender.dailyFile.Append=true</span><br><span class=\"line\">log4j.appender.dailyFile.File=D:/logs/log.log4j</span><br><span class=\"line\">log4j.appender.dailyFile.DatePattern=&#x27;.&#x27;yyyy-MM-dd</span><br><span class=\"line\">log4j.appender.dailyFile.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.dailyFile.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"># 应用于socket</span><br><span class=\"line\">log4j.appender.socket=org.apache.log4j.RollingFileAppender</span><br><span class=\"line\">log4j.appender.socket.RemoteHost=localhost</span><br><span class=\"line\">log4j.appender.socket.Port=5001</span><br><span class=\"line\">log4j.appender.socket.LocationInfo=true</span><br><span class=\"line\"># Set up for Log Factor 5</span><br><span class=\"line\">log4j.appender.socket.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.socket.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"># Log Factor 5 Appender</span><br><span class=\"line\">log4j.appender.LF5_APPENDER=org.apache.log4j.lf5.LF5Appender</span><br><span class=\"line\">log4j.appender.LF5_APPENDER.MaxNumberOfRecords=2000</span><br><span class=\"line\"># 发送日志到指定邮件</span><br><span class=\"line\">log4j.appender.mail=org.apache.log4j.net.SMTPAppender</span><br><span class=\"line\">log4j.appender.mail.Threshold=FATAL</span><br><span class=\"line\">log4j.appender.mail.BufferSize=10</span><br><span class=\"line\">log4j.appender.mail.From = xxx@mail.com</span><br><span class=\"line\">log4j.appender.mail.SMTPHost=mail.com</span><br><span class=\"line\">log4j.appender.mail.Subject=Log4J Message</span><br><span class=\"line\">log4j.appender.mail.To= xxx@mail.com</span><br><span class=\"line\">log4j.appender.mail.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.mail.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"># 应用于数据库</span><br><span class=\"line\">log4j.appender.database=org.apache.log4j.jdbc.JDBCAppender</span><br><span class=\"line\">log4j.appender.database.URL=jdbc:mysql://localhost:3306/test</span><br><span class=\"line\">log4j.appender.database.driver=com.mysql.jdbc.Driver</span><br><span class=\"line\">log4j.appender.database.user=root</span><br><span class=\"line\">log4j.appender.database.password=</span><br><span class=\"line\">log4j.appender.database.sql=INSERT INTO LOG4J (Message) VALUES(&#x27;=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n&#x27;)</span><br><span class=\"line\">log4j.appender.database.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.database.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"></span><br><span class=\"line\"># 自定义Appender</span><br><span class=\"line\">log4j.appender.im = net.cybercorlin.util.logger.appender.IMAppender</span><br><span class=\"line\">log4j.appender.im.host = mail.cybercorlin.net</span><br><span class=\"line\">log4j.appender.im.username = username</span><br><span class=\"line\">log4j.appender.im.password = password</span><br><span class=\"line\">log4j.appender.im.recipient = corlin@cybercorlin.net</span><br><span class=\"line\">log4j.appender.im.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.im.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>参考</p>\n<p><a href=\"https://github.com/digoal/blog/blob/master/201701/20170126_01.md\">https://github.com/digoal/blog/blob/master/201701/20170126_01.md</a></p>\n<p><a href=\"https://www.jianshu.com/p/c6c543e4975e\">https://www.jianshu.com/p/c6c543e4975e</a></p>\n<p><a href=\"https://www.jianshu.com/p/ccafda45bcea\">https://www.jianshu.com/p/ccafda45bcea</a></p>\n","categories":["javax","log4j"],"tags":["日志"]},{"title":"Hexo部署到个人服务器","url":"/2020/01/14/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"<blockquote>\n<p>之前一直把 Hexo 博客托管在 github page 上，但是最近发现 github page 的打开速度越来越慢，有时候不翻墙甚至打不开，严重影响我写博客的心情，所以考虑把 Hexo 博客部署到个人服务器上，可以提高访问速度。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h2><ul>\n<li>本地已经安装好 Hexo 环境</li>\n<li>一台云服务器</li>\n<li>一个注册域名（可跳过）</li>\n</ul>\n<p>基本思路：</p>\n<ol>\n<li><p>在服务器上安装 nginx 和 git ，用 nginx 来托管 Hexo 静态文件，用 git 搭建个人仓库用于存储本地提交，git 仓库和 nginx 托管目录使用钩子关联，保证每次本地 git 提交后都能更新 nginx 托管目录。</p>\n</li>\n<li><p>本地设置 Hexo 的部署目录为服务器的个人仓库地址，保证每次部署的时候都能自动 git 提交</p>\n</li>\n<li><p>设置域名解析指向服务器</p>\n</li>\n</ol>\n<p>最终达到的效果：本地编辑文章完成后，使用一个部署命令即可更新服务器资源，使用域名访问可以实时看到更新后的资源。</p>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><h3 id=\"安装配置nginx\"><a href=\"#安装配置nginx\" class=\"headerlink\" title=\"安装配置nginx\"></a>安装配置nginx</h3><h4 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y nginx</span><br></pre></td></tr></table></figure>\n\n<p>yum 安装的 nginx 默认安装目录为 <code>/etc/nginx</code>，nginx 全局配置文件路径为 <code>/etc/nginx/nginx.conf</code></p>\n<p>如果安装失败可以尝试加上 <code>sudo</code> 命令</p>\n<h4 id=\"2、检查nginx是否安装成功\"><a href=\"#2、检查nginx是否安装成功\" class=\"headerlink\" title=\"2、检查nginx是否安装成功\"></a>2、检查nginx是否安装成功</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx -v</span><br></pre></td></tr></table></figure>\n\n<p>显示nginx版本号例如 <code>nginx version: nginx/1.16.1</code> 表示安装成功</p>\n<h4 id=\"3、修改nginx配置\"><a href=\"#3、修改nginx配置\" class=\"headerlink\" title=\"3、修改nginx配置\"></a>3、修改nginx配置</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen <span class=\"number\">80</span>;</span><br><span class=\"line\">    listen [::]:<span class=\"number\">80</span>;</span><br><span class=\"line\">    root /data/hexo; <span class=\"comment\"># 设置为hexo静态文件存放的目录，也是git钩子指向的目录</span></span><br><span class=\"line\">    server_name laoyuyu.me www.laoyuyu.me; <span class=\"comment\"># 如果需要改域名访问，修改server_name 为域名便可</span></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>保存后我们可以使用下面命令检查配置有没问题</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br></pre></td></tr></table></figure>\n\n<p>输出以下内容表示配置没问题，如果有错误会打印详细信息</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4、启动\"><a href=\"#4、启动\" class=\"headerlink\" title=\"4、启动\"></a>4、启动</h4><p>启动nginx</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl start nginx.service</span><br></pre></td></tr></table></figure>\n\n<p>下面为nginx相关命令，如果你的系统版本是 centos 7 以上，可以使用 <code>Systemd</code> 相关命令进行操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 设置开机启动</span><br><span class=\"line\">systemctl enable nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止开机启动</span><br><span class=\"line\">systemctl disable nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 启动</span><br><span class=\"line\">systemctl start nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止</span><br><span class=\"line\">systemctl stop nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 重启</span><br><span class=\"line\">systemctl restart nginx</span><br></pre></td></tr></table></figure>\n\n<p>如果系统是旧版本，可以使用 <code>SysVinit</code> 相关命令进行操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 设置开机启动</span><br><span class=\"line\">chkconfig nginx on</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止开机启动</span><br><span class=\"line\">chkconfig nginx off</span><br><span class=\"line\"></span><br><span class=\"line\"># 启动</span><br><span class=\"line\">service nginx start</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止</span><br><span class=\"line\">service nginx stop</span><br><span class=\"line\"></span><br><span class=\"line\"># 重启</span><br><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装配置git\"><a href=\"#安装配置git\" class=\"headerlink\" title=\"安装配置git\"></a>安装配置git</h3><h4 id=\"1、安装-1\"><a href=\"#1、安装-1\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install git -y</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、查看是否安装成功\"><a href=\"#2、查看是否安装成功\" class=\"headerlink\" title=\"2、查看是否安装成功\"></a>2、查看是否安装成功</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git —version</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、创建git用户，用来运行git服务\"><a href=\"#3、创建git用户，用来运行git服务\" class=\"headerlink\" title=\"3、创建git用户，用来运行git服务\"></a>3、创建git用户，用来运行git服务</h4><p>创建系统用户git</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adduser git</span><br></pre></td></tr></table></figure>\n\n<p>设置密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">passwd git</span><br></pre></td></tr></table></figure>\n\n<p>切换到 git 用户，这步很重要</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">su git</span><br></pre></td></tr></table></figure>\n\n<p>创建 hexo 静态文件存放目录，对应上面 nginx 的 root 目录</p>\n<p>注意这一步如果显示没有权限创建目录，可以以 root 用户执行 <code>chmod 777 /data</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir /data/hexo</span><br></pre></td></tr></table></figure>\n\n<p>创建 git 私人仓库目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir /data/repo</span><br></pre></td></tr></table></figure>\n\n<p>在私人仓库下创建一个裸露仓库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd /data/repo</span><br><span class=\"line\"></span><br><span class=\"line\">git init --bare blog.git</span><br></pre></td></tr></table></figure>\n\n<p>创建 git 钩子，把裸露仓库和 hexo 静态文件存放目录关联起来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>\n\n<p>添加以下内容，其中 <code>/data/hexo</code> 为 hexo 静态文件存放目录，<code>/data/repo/blog.git</code> 为裸露仓库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git --work-tree=/data/hexo --git-dir=/data/repo/blog.git checkout -f</span><br></pre></td></tr></table></figure>\n\n<p>保存后添加权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod +x post-receive</span><br><span class=\"line\"></span><br><span class=\"line\">exit // 退出到 root 登录</span><br><span class=\"line\"></span><br><span class=\"line\">chown -R git:git /data/repo/blog.git // 添加权限</span><br></pre></td></tr></table></figure>\n\n<p>测试 git 仓库是否可用，在本地执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone git@server_ip:/data/repo/blog.git</span><br></pre></td></tr></table></figure>\n\n<p>如果能把空仓库拉下来说明 git 仓库搭建成功了，<strong>注意这时候执行这个命令需要输入密码的</strong>。</p>\n<h4 id=\"4、设置-git-仓库安全控制\"><a href=\"#4、设置-git-仓库安全控制\" class=\"headerlink\" title=\"4、设置 git 仓库安全控制\"></a>4、设置 git 仓库安全控制</h4><p>找到本地创建的 <code>id_rsa.pub</code> 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">open ~/.ssh</span><br></pre></td></tr></table></figure>\n\n<p>本地电脑和 git 仓库建立 ssh 联系</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-copy-id -i C:/Users/yourname/.ssh/id_rsa.pub git@server_ip</span><br></pre></td></tr></table></figure>\n\n<p>测试能否登陆，<strong>注意这个时候登陆是不需要密码的，再执行 <code>git clone</code> 命令也不需要密码</strong>，否则就有问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh git@server_ip</span><br></pre></td></tr></table></figure>\n\n<p>为了安全起见禁用 git 用户的 shell 登录权限，从而只能用 git clone，git push 等登录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查看 git-shell 是否在登录方式里面</span><br><span class=\"line\">cat /etc/shells</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看 git-shell 目录</span><br><span class=\"line\">which git-shell</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加第2步显示的路径</span><br><span class=\"line\">vim /etc/shells</span><br></pre></td></tr></table></figure>\n\n<p>修改 <code>/etc/passwd</code> 中的权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 将原来的</span><br><span class=\"line\">git:x:1000:1000::/home/git:/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">// 修改为</span><br><span class=\"line\">git:x:1000:1000:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"本地配置\"><a href=\"#本地配置\" class=\"headerlink\" title=\"本地配置\"></a>本地配置</h2><h3 id=\"配置-config-yml文件\"><a href=\"#配置-config-yml文件\" class=\"headerlink\" title=\"配置_config.yml文件\"></a>配置_config.yml文件</h3><p>进入 hexo 安装目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim _config.yml</span><br></pre></td></tr></table></figure>\n\n<p>设置 deploy 属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@server_ip:/data/repo/blog.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置package-json文件\"><a href=\"#配置package-json文件\" class=\"headerlink\" title=\"配置package.json文件\"></a>配置package.json文件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;start&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;,</span><br><span class=\"line\">  &quot;debug&quot;: &quot;hexo clean &amp;&amp; hexo g&quot;,</span><br><span class=\"line\">  &quot;deploy&quot;: &quot;hexo clean &amp;&amp; hexo g -d&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们可以快速本地启动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm run start</span><br></pre></td></tr></table></figure>\n\n<p>本地调试</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm run debug</span><br></pre></td></tr></table></figure>\n\n<p>部署到远程服务器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm run deploy</span><br></pre></td></tr></table></figure>\n\n<p>至此我们的本地环境和服务器环境已经搭建完毕。</p>\n<h2 id=\"域名配置\"><a href=\"#域名配置\" class=\"headerlink\" title=\"域名配置\"></a>域名配置</h2><p>如果你有个人域名，可以设置个人域名指向你的服务器ip</p>\n<p>以阿里云域名为例，登陆域名控制台，域名列表——操作——解析——添加记录</p>\n<p><img src=\"/2020/01/14/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/domain1.png\" alt=\"domain1\"></p>\n<p>可以添加 <code>www</code> 和 <code>@</code> 两条主机记录，这样可以同时支持 <a href=\"http://www.domain.cn/\">www.domain.cn</a> 和 domain.cn 两种访问方式。</p>\n<p><img src=\"/2020/01/14/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/domain2.png\" alt=\"domain2\"></p>\n<p>保存 10 分钟后即生效。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://juejin.im/post/5b70d68ae51d45665d383281\">带你跳过各种坑，一次性把 Hexo 博客部署到自己的服务器</a></p>\n<p><a href=\"https://www.jianshu.com/p/70bf58c48010\">HEXO 部署到云服务器详细指南</a></p>\n<p><a href=\"https://blog.csdn.net/u012486840/article/details/52610320\">CentOS 7 yum 安装 Nginx</a></p>\n","categories":["工具","Hexo"],"tags":["Hexo"]},{"title":"Netty系列（二）：Netty是什么","url":"/2020/01/18/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ANetty%E6%98%AF%E4%BB%80%E4%B9%88/","content":"<blockquote>\n<p>上一篇文章介绍了 netty 的同步&#x2F;异步&#x2F;阻塞&#x2F;非阻塞的概念和四种常用 IO 模型。本文介绍网络编程的发展，从 bio 发展到 nio 最后到 netty，我们可以感受到 netty 给网络编程带来的极大便利性。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>网络编程，简单来说就是实现一个客户端与服务端进行网络通信的程序。我们从最传统的 BIO 开始介绍，本章只做简单介绍，不涉及深入原理。</p>\n<h2 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h2><p>BIO 全称是 Blocking IO，是 JDK1.4 之前的传统 IO 模型，本身是同步阻塞模式。 </p>\n<p>BIO分为 ServerSocket 和 Socket 两种类，分别对应服务端和客户端。</p>\n<h3 id=\"ServerSocket\"><a href=\"#ServerSocket\" class=\"headerlink\" title=\"ServerSocket\"></a>ServerSocket</h3><p>ServerSocket 对象在服务端运行，负责接收客户端连接。</p>\n<ol>\n<li><p>服务端调用 <code>ServerSocket serverSocket = new ServerSocket(600);</code> 绑定一个本地端口用于接收客户端请求。</p>\n</li>\n<li><p>然后调用 <code>serverSocket.accept()</code> ，这个方法的执行将使 Server 端一直阻塞，直到捕捉到一个来自 Client 端的请求，并返回一个用于与该 Client 通信的 Socket 对象 Link-Socket。此后 Server 程序只要向这个 Socket 对象读写数据，就可以实现向远端的 Client 读写数据。</p>\n</li>\n<li><p><code>serverSocket</code> 可以接收多次客户端请求，当需要结束服务端程序时调用 <code>serverSocket.close()</code>。</p>\n</li>\n</ol>\n<p>ServerSocket 一般仅用于设置端口号和监听，真正进行通信的是服务器端的 Socket 与客户端的 Socket，在ServerSocket 进行 accept 之后，就将主动权转让了。</p>\n<h3 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h3><p>客户端通过创建 Socket 对象，向服务端发起连接。</p>\n<ol>\n<li>客户端调用 <code>Socket socket = new Socket(“127.0.0.1”，600);</code>，创建到服务端的连接。第一个参数是 Server 的主机地址，第二个参数是 Server 绑定的端口号。</li>\n<li>在服务端和客户端之间创建连接后，调用 <code>OutputStream outputStream = socket.getOutputStream()</code> 和 <code>InputStream inputStream = socket.getInputStream()</code> 获取输出&#x2F;输出流，然后可以调用 <code>outputStream.write()</code> 和 <code>inputStream.read()</code> 向服务器端写&#x2F;读数据。</li>\n<li>客户端活动完成调用 <code>socket.close()</code> 结束客户端程序。</li>\n</ol>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p><strong>服务端代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class BIOServer &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException &#123;</span><br><span class=\"line\">        // 服务端绑定本地端口并启动</span><br><span class=\"line\">        ServerSocket serverSocket = new ServerSocket(7000);</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            // accept() 会阻塞服务端，直到获取到一个客户端的请求</span><br><span class=\"line\">            Socket socket = serverSocket.accept();</span><br><span class=\"line\">            // 接收到客户端请求后，开始读取数据</span><br><span class=\"line\">            byte[] data = new byte[1024];</span><br><span class=\"line\">            InputStream inputStream = socket.getInputStream();</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                int len;</span><br><span class=\"line\">                // 按字节流方式读取数据</span><br><span class=\"line\">                while ((len = inputStream.read(data)) != -1) &#123;</span><br><span class=\"line\">                    System.out.println(new String(data, 0, len) + &quot; receive&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是最简单的服务端代码，服务端代码创建一个 <code>ServerSocket</code> 用于监听本地 7000 端口，然后在死循环里面调用 serverSocket.accept() 阻塞服务端直到获取到一个客户端连接，最后以字节流方式读取客户端数据并打印。</p>\n<p><strong>客户端代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class BIOClient &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class=\"line\">        Socket socket = new Socket(&quot;127.0.0.1&quot;, 7000);</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            String str = new Date() + &quot;: hello world&quot;;</span><br><span class=\"line\">            socket.getOutputStream().write(str.getBytes());</span><br><span class=\"line\">            socket.getOutputStream().flush();</span><br><span class=\"line\">            System.out.println(str + &quot; send&quot;);</span><br><span class=\"line\">            Thread.sleep(2000);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>服务端代码连接本地 7000 端口，每隔两秒向服务端发送 “hello world” 的数据。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>BIO 编程模型在客户端较少的情况下运行良好，但是对于客户端比较多的业务来说，单机服务端可能需要支撑成千上万的连接，BIO 模型可能就不太合适了。</p>\n<p>从服务端代码中我们可以看到，在传统的 BIO 模型中，每个连接创建成功之后都需要一个线程来维护，每个线程包含一个 while 死循环，那么 1w 个连接对应 1w 个线程，继而 1w 个 while 死循环，这就带来如下几个问题：</p>\n<ol>\n<li>线程资源受限：线程是操作系统中非常宝贵的资源，同一时刻有大量的线程处于阻塞状态是非常严重的资源浪费，操作系统耗不起</li>\n<li>线程切换效率低下：单机 cpu 核数固定，线程爆炸之后操作系统频繁进行线程切换，应用性能急剧下降。</li>\n<li>数据读写是以字节流为单位，效率不高。</li>\n</ol>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><p>为了解决 BIO 存在的问题，在 Java 1.4 中引入了 NIO 框架。 NIO 可以理解为 Non-blocking。</p>\n<p>在传统的 BIO 模型中一个连接对应一个 while 死循环，死循环的目的就是不断监测这条连接上是否有数据可以读，大多数情况下，1w个连接里面同一时刻只有少量的连接有数据可读，因此，很多个while死循环都白白浪费掉了，因为读不出啥数据。</p>\n<div style=\"width: 80%; margin: auto\">![bio](bio.png)</div>\n而在NIO模型中，他把这么多 while 死循环变成一个死循环，这个死循环由一个线程控制。这个线程就是 NIO 模型中的 selector。一条连接来了直接把这条连接注册到 selector 上，通过检查这个selector，就可以批量监测出有数据可读的连接，进而读取数据。这样导致线程数量大大减少。\n\n<div style=\"width: 80%; margin: auto\">![nio](nio.png)</div>\nNIO 提供了 Channel、Buffer 和 Selector 三个核心组件。BIO 基于字节流和字符流进行操作，而 NIO 基于Channel 和 Buffer 进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector 用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。整体流程大致如下：\n\n<div style=\"width: 80%; margin: auto\">![component](component.png)</div>\n### Channel\n\n<p>Channel 类似于 BIO 中的 Stream。只不过 Stream 是单向的，譬如：InputStream, OutputStream.而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。</p>\n<p>NIO 中的 Channel 的主要实现有：</p>\n<ul>\n<li>FileChannel</li>\n<li>DatagramChannel</li>\n<li>SocketChannel</li>\n<li>ServerSocketChannel</li>\n</ul>\n<p>分别可以对应文件 IO、UDP 和 TCP（Client 和 Server）</p>\n<h3 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h3><p>BIO 模型中，每次都是从操作系统底层一个字节一个字节地读取数据，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。</p>\n<p>而 NIO 维护一个缓冲区 Buffer，在读取数据时，它是直接读到缓冲区中的；在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p>\n<p>与Java基本类型相对应，NIO 提供了多种 Buffer 类型，如 ByteBuffer、CharBuffer、IntBuffer等，区别就是读写缓冲区时的单位长度不一样（以对应类型的变量为单位进行读写）。</p>\n<p>Buffer 中有三个很重要的变量：</p>\n<ul>\n<li>capacity：缓冲区数组的总长度</li>\n<li>position：下一个要操作的数据元素的位置</li>\n<li>limit：读&#x2F;写边界位置，limit&lt;&#x3D;capacity</li>\n</ul>\n<p>我们读写 buffer 的流程一般如下：</p>\n<ol>\n<li>通过 <code>ByteBuffer.allocate(11)</code> 方法创建了一个 11 个 byte 的数组的缓冲区，初始状态如上图，position 的位置为 0，capacity 和 limit 默认都是数组长度。这个时候 ByteBuffer 处于写模式，等待 Channel 数据写入。</li>\n</ol>\n<div style=\"width: 50%; margin: auto\">![buffer1](buffer1.png)</div>\n2. 写入 5 个字节，postion 移动了 5 个位置，limit 和 capacity 保持不变。\n\n<div style=\"width: 50%; margin: auto\">![buffer2](buffer2.png)</div>\n3. 调用 `ByteBuffer.flip()` 方法，将写模式改成读模式，position 设回 0，并将 limit 设成之前的 position 的值。这时 position 到 limit 这个区间内的就是可读数据。\n\n<div style=\"width: 50%; margin: auto\">![buffer3](buffer3.png)</div>\n4. 在下一次写数据之前我们调用 `ByteBuffer.clear()` 方法，将读模式改成写模式。缓冲区的索引位置又回到了初始位置。注意这个时候 Buffer 中的数据并未被清除，只是这些标记告诉我们可以从哪里开始往 Buffer 里写数据。\n5. 如果 Buffer 中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用 `ByteBuffer.compact()` 方法。将所有未读的数据拷贝到 Buffer 起始处，然后将 position 设到最后一个未读元素正后面。limit 属性依然像 clear() 方法一样，设置成 capacity。现在 Buffer 准备好写数据了，但是不会覆盖未读的数据。\n6. 如果你有一部分数据需要重复读写，调用 `ByteBuffer.mark()` 方法，可以标记 Buffer 中的一个特定的 position，之后可以通过调用 `ByteBuffer.reset()` 方法恢复到这个position。\n7. 如果你需要将同一个 Buffer 的数据写入多个通道时，在第一次读取完 Buffer 后，调用 `ByteBuffer.rewind()` 方法，将 position 设回 0，limit 保持不变，这样就可以重读 Buffer 中的所有数据。\n\n<h3 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h3><p>Selector 可以理解为一个单线程管理器，管理多个 Channel。我们将 Channel 注册到 Selector 上，然后设置关注的事件，然后调用 Selector.select() 方法，等待事件发生。</p>\n<p>Selector 可以监听以下四种事件，并对应 SelectionKey 的四个常量：</p>\n<ul>\n<li><p>Connect：连接就绪事件，客户端 channel 成功连接到服务器上，对应 SelectionKey.OP_CONNECT</p>\n</li>\n<li><p>Accept：接收就绪事件，服务端 socket channel 准备好接收客户端的连接，对应 SelectionKey.OP_ACCEPT</p>\n</li>\n<li><p>Read：读就绪事件，channel 有数据可读，对应 SelectionKey.OP_READ</p>\n</li>\n<li><p>Write：写就绪事件，准备写数据到 channel，对应 SelectionKey.OP_WRITE</p>\n</li>\n</ul>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p><strong>服务端代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class NIOServer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void initServer() throws IOException &#123;</span><br><span class=\"line\">        // 创建 serverSelector</span><br><span class=\"line\">        Selector serverSelector = Selector.open();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 serverSocketChannel，设置为非阻塞，并绑定本地端口</span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        serverSocketChannel.configureBlocking(false);</span><br><span class=\"line\">        serverSocketChannel.socket().bind(new InetSocketAddress(7000));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 把 serverSocketChannel 注册到 selector 上并设置关心事件为 ON_ACCEPT 事件，ACCEPT 事件表明这是一个服务器 channel</span><br><span class=\"line\">        SelectionKey selectionKey = serverSocketChannel.register(serverSelector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">        //轮询</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            // select() 会一直阻塞，直到有事件发生</span><br><span class=\"line\">            serverSelector.select();</span><br><span class=\"line\">            // 运行到这一步说明已经有事件发生，获取并遍历的所有事件key集合</span><br><span class=\"line\">            Set keys = serverSelector.selectedKeys();</span><br><span class=\"line\">            Iterator iterator = keys.iterator();</span><br><span class=\"line\">            while (iterator.hasNext()) &#123;</span><br><span class=\"line\">                // 获取 key 示例</span><br><span class=\"line\">                SelectionKey key = (SelectionKey) iterator.next();</span><br><span class=\"line\">                // 删除 key 实例，因为 selector 不会删除 key 实例，需要手动删除</span><br><span class=\"line\">                iterator.remove();</span><br><span class=\"line\">                if (key.isAcceptable()) &#123;</span><br><span class=\"line\">                    // 服务端待连接就绪事件</span><br><span class=\"line\">                    doAccept(key);</span><br><span class=\"line\">                &#125; else if (key.isReadable()) &#123;</span><br><span class=\"line\">                    // 读就绪事件</span><br><span class=\"line\">                    doRead(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void doAccept(SelectionKey key) throws IOException &#123;</span><br><span class=\"line\">        // 当 accept 事件发生的时候，创建 clientChannel 注册到 serverSelector 上并注册关心事件为 OP_READ 和 OP_WRITE，等待读/写事件发生</span><br><span class=\"line\">        System.out.println(&quot;服务端等待客户端连接就绪&quot;);</span><br><span class=\"line\">        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();</span><br><span class=\"line\">        SocketChannel clientChannel = serverChannel.accept();</span><br><span class=\"line\">        clientChannel.configureBlocking(false);</span><br><span class=\"line\">        clientChannel.register(key.selector(), SelectionKey.OP_READ);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void doRead(SelectionKey key) throws IOException &#123;</span><br><span class=\"line\">        System.out.println(&quot;服务端开始读取数据&quot;);</span><br><span class=\"line\">        SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class=\"line\">        // 初始化，设置postition=0，limit=capacity</span><br><span class=\"line\">        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);</span><br><span class=\"line\">        // 写模式，设置position=可读字节数，limit=capacity</span><br><span class=\"line\">        long bytesRead = clientChannel.read(byteBuffer);</span><br><span class=\"line\">        while (bytesRead &gt; 0) &#123;</span><br><span class=\"line\">            // 写模式转成读模式，设置postition=0，limit=可读字节数</span><br><span class=\"line\">            byteBuffer.flip();</span><br><span class=\"line\">            byte[] data = byteBuffer.array();</span><br><span class=\"line\">            String info = new String(data).trim();</span><br><span class=\"line\">            System.out.println(&quot;服务端接收的消息是： &quot; + info);</span><br><span class=\"line\">            // 读模式转成写模式，设置position=0，limit=capacity</span><br><span class=\"line\">            byteBuffer.clear();</span><br><span class=\"line\">            // 继续开始下一次读入</span><br><span class=\"line\">            bytesRead = clientChannel.read(byteBuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        clientChannel.close(); //关闭channel</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws IOException &#123;</span><br><span class=\"line\">        NIOServer nioServer = new NIOServer();</span><br><span class=\"line\">        nioServer.initServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>服务端代码简单解析</p>\n<ol>\n<li>服务端创建 serverSelector。</li>\n<li>服务端创建 serverSocketChannel，绑定一个本地端口，然后注册到 serverSelector，并设置关心事件为  OP_ACCEPT。调用 <code>serverSelector.select()</code> 方法等待事件发生。</li>\n<li>事件发生，获取并遍历 selectedKeys，对事件类型为 Accept 和 Read 的事件进行相应操作。</li>\n</ol>\n<p><strong>客户端代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class NIOClient &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void initClient() throws IOException &#123;</span><br><span class=\"line\">        Selector clientSelector = Selector.open();</span><br><span class=\"line\"></span><br><span class=\"line\">        SocketChannel clientChannel = SocketChannel.open();</span><br><span class=\"line\">        clientChannel.configureBlocking(false);</span><br><span class=\"line\">        clientChannel.connect(new InetSocketAddress(7000));</span><br><span class=\"line\">        clientChannel.register(clientSelector, SelectionKey.OP_CONNECT);</span><br><span class=\"line\"></span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            clientSelector.select();</span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; iterator = clientSelector.selectedKeys().iterator();</span><br><span class=\"line\">            while (iterator.hasNext()) &#123;</span><br><span class=\"line\">                SelectionKey key = iterator.next();</span><br><span class=\"line\">                iterator.remove();</span><br><span class=\"line\">                if (key.isConnectable()) &#123;</span><br><span class=\"line\">                    doConnect(key);</span><br><span class=\"line\">                &#125; else if (key.isWritable() &amp;&amp; key.isValid()) &#123;</span><br><span class=\"line\">                    doWrite(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void doConnect(SelectionKey key) throws IOException &#123;</span><br><span class=\"line\">        System.out.println(&quot;客户端连接成功&quot;);</span><br><span class=\"line\">        SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class=\"line\">        if (clientChannel.isConnectionPending()) &#123;</span><br><span class=\"line\">            clientChannel.finishConnect();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        clientChannel.configureBlocking(false);</span><br><span class=\"line\">        clientChannel.register(key.selector(), SelectionKey.OP_WRITE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void doWrite(SelectionKey key) throws IOException &#123;</span><br><span class=\"line\">        System.out.println(&quot;客户端开始向服务端写数据&quot;);</span><br><span class=\"line\">        SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class=\"line\">        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);</span><br><span class=\"line\">        String info = &quot;hello world&quot;;</span><br><span class=\"line\">        byteBuffer.clear();</span><br><span class=\"line\">        byteBuffer.put(info.getBytes());</span><br><span class=\"line\">        byteBuffer.flip();</span><br><span class=\"line\">        while (byteBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">            clientChannel.write(byteBuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;客户端发送的消息是： &quot; + info);</span><br><span class=\"line\">        clientChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws IOException &#123;</span><br><span class=\"line\">        NIOClient nioClient = new NIOClient();</span><br><span class=\"line\">        nioClient.initClient();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端代码类似于服务端代码，区别是对事件类型为 Connect 和 Write 的事件做了相应处理。在这里不再做详细介绍。</p>\n<h3 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>由此我们可以看出来虽然 NIO 虽然解决了 BIO 的一些痛点，但是 NIO 的原生编程也带来了新的问题：</p>\n<ol>\n<li>JDK的NIO编程需要了解很多的概念，编程复杂，对 NIO 入门非常不友好，编程模型不友好，ByteBuffer 的 api 简直反人类</li>\n<li>对 NIO 编程来说，一个比较合适的线程模型能充分发挥它的优势，而 JDK 没有给你实现，你需要自己实现，就连简单的自定义协议拆包都要你自己实现</li>\n<li>JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮训 bug 会导致 cpu 飙升100%</li>\n<li>项目庞大之后，自行实现的 NIO 很容易出现各类bug，维护成本较高</li>\n</ol>\n<p>下面我们就看下 Netty 是怎么解决 NIO 带来的各种问题的。</p>\n<h2 id=\"Netty\"><a href=\"#Netty\" class=\"headerlink\" title=\"Netty\"></a>Netty</h2><p>Netty 是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端。简单来说就是 Netty 封装了 JDK 的 NIO，可以简化开发流程。</p>\n<p>相比起 NIO，Netty 的优势有：</p>\n<ol>\n<li>使用JDK自带的NIO需要了解太多的概念，编程复杂，一不小心bug横飞</li>\n<li>Netty底层IO模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从NIO模型变身为IO模型</li>\n<li>Netty自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑</li>\n<li>Netty解决了JDK的很多包括空轮询在内的bug</li>\n<li>Netty底层对线程，selector做了很多细小的优化，精心设计的reactor线程模型做到非常高效的并发处理</li>\n<li>自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手</li>\n<li>Netty社区活跃，遇到问题随时邮件列表或者issue</li>\n<li>Netty已经历各大rpc框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大</li>\n</ol>\n<p>Netty 的具体内容我们后面再详细介绍，这里简单介绍一下 Netty 的使用，感受一下 Netty 给开发带来的便利性。</p>\n<p><strong>引入 Maven 依赖</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;<span class=\"number\">4.1</span><span class=\"number\">.6</span>.Final&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>服务端代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class NettyServer &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class=\"line\">        NioEventLoopGroup boos = new NioEventLoopGroup();</span><br><span class=\"line\">        NioEventLoopGroup worker = new NioEventLoopGroup();</span><br><span class=\"line\">        serverBootstrap</span><br><span class=\"line\">                .group(boos, worker)</span><br><span class=\"line\">                .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">                    protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class=\"line\">                        ch.pipeline().addLast(new StringDecoder());</span><br><span class=\"line\">                        ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;</span><br><span class=\"line\">                            @Override</span><br><span class=\"line\">                            protected void channelRead0(ChannelHandlerContext ctx, String msg) &#123;</span><br><span class=\"line\">                                System.out.println(msg);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .bind(8000);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>客户端代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class NettyClient &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        Bootstrap bootstrap = new Bootstrap();</span><br><span class=\"line\">        NioEventLoopGroup group = new NioEventLoopGroup();</span><br><span class=\"line\">        bootstrap.group(group)</span><br><span class=\"line\">                .channel(NioSocketChannel.class)</span><br><span class=\"line\">                .handler(new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    protected void initChannel(Channel ch) &#123;</span><br><span class=\"line\">                        ch.pipeline().addLast(new StringEncoder());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        Channel channel = bootstrap.connect(&quot;127.0.0.1&quot;, 8000).channel();</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            channel.writeAndFlush(new Date() + &quot;: hello world!&quot;);</span><br><span class=\"line\">            Thread.sleep(2000);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码的具体内容在这里先不做分析，但是我们可以看到，这两段简单的代码，就可以完成 NIO 原生编程那一大段代码的功能，代码非常清晰易于维护。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文简单介绍了 BIO、NIO 的一些基本原理，认识到 NIO 相对于 BIO 在性能和资源管理方面带来的巨大提升，但 NIO 的原生编程过于复杂，难以维护。Netty 通过对 NIO 进行封装，大大降低了开发的复杂性。如果涉及到网络编程，Netty 将是你是不二选择。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"\">Netty实战</a></p>\n<p><a href=\"https://www.jianshu.com/p/a4e03835921a\">《跟闪电侠学Netty》开篇：Netty是什么？</a></p>\n<p><a href=\"https://blog.csdn.net/forezp/article/details/88414741\">Java NIO？看这一篇就够了！</a></p>\n","categories":["Netty"],"tags":["Netty"]},{"title":"Netty系列（一）：IO模型","url":"/2020/01/17/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AIO%E6%A8%A1%E5%9E%8B/","content":"<blockquote>\n<p>Netty 是目前比较火的网络编程框架，是 java 进阶的必备知识点，特此记录 Netty 学习过程中的一些知识点用于日后翻阅。本章介绍 Netty 的一些入门准备知识，包括同步和异步、阻塞和非阻塞的区别，还有常见的 IO 模型。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"同步、异步、阻塞和非阻塞\"><a href=\"#同步、异步、阻塞和非阻塞\" class=\"headerlink\" title=\"同步、异步、阻塞和非阻塞\"></a>同步、异步、阻塞和非阻塞</h1><p>这四个概念都是针对一次调用发生的，我们可以这么理解，在一次调用里面存在<code>调用者</code>、<code>被调用者</code>和<code>调用结果</code>这三个概念。</p>\n<h2 id=\"一、同步和异步\"><a href=\"#一、同步和异步\" class=\"headerlink\" title=\"一、同步和异步\"></a>一、同步和异步</h2><p>同步和异步是从<code>调用结果通知机制</code>这个角度来区分的。</p>\n<ul>\n<li><p>同步：调用发生后，<code>调用者</code> 主动去获取 <code>调用结果</code>，这就是同步调用。</p>\n</li>\n<li><p>异步：调用发生后，<code>调用者</code>被动等待 <code>被调用者</code> 通知 <code>调用结果</code>，这就是异步调用。通常过程是，调用发生后，<code>调用者</code>收到一个来自 <code>被调用者</code> 的回执，这个回执内容通常是是 <code>被调用者</code> 告诉 <code>调用者</code> 我已经收到这个任务了，但是这个任务具体什么时候执行，什么时候能得到执行结果，<code>调用者</code> 不需要管。等到执行完成后，<code>被调用者</code> 主动把 <code>调用结果</code> 通知给 <code>调用者</code>，整个调用过程才算完成。</p>\n</li>\n</ul>\n<h2 id=\"二、阻塞和非阻塞\"><a href=\"#二、阻塞和非阻塞\" class=\"headerlink\" title=\"二、阻塞和非阻塞\"></a>二、阻塞和非阻塞</h2><p>阻塞和非阻塞是从 <code>调用者在获取到调用结果前的行为</code> 这个角度进行区分的。</p>\n<ul>\n<li>阻塞：<code>调用者 </code>在获取到 <code>调用结果</code> 前什么都不干，线程整个挂起一直等待 <code>调用结果</code>，这就是阻塞调用。</li>\n<li>非阻塞：<code>调用者</code> 在获取 <code>调用结果 </code>前可以做自己的事情，这就是非阻塞调用。</li>\n</ul>\n<h2 id=\"三、四种概念组合\"><a href=\"#三、四种概念组合\" class=\"headerlink\" title=\"三、四种概念组合\"></a>三、四种概念组合</h2><p>综上所述，同步和异步、阻塞和非阻塞是两套完全不同而且并不矛盾的概念，所以产生以下四种概念组合：</p>\n<ul>\n<li>同步阻塞：<code>调用者</code> 一直挂起什么都不做，主动去获取 <code>调用结果</code>。</li>\n<li>同步非阻塞：<code>调用者 </code>拿到回执后继续做自己的事情，然后通过轮询机制，每隔一段时间去询问<code>调用结果</code>，直到最终获取 <code>调用结果</code>，调用才算完成。</li>\n<li>异步阻塞：<code>调用者</code> 一直挂起什么都不做，直到 <code>被调用者</code> 通知 <code>调用结果</code>。</li>\n<li>异步非阻塞：调用者拿到回执后继续做自己的事情，等到 <code>被调用者</code> 通知<code>调用结果</code>后，调用才算完成。</li>\n</ul>\n<p>这四种概念，是下面常见IO模型的基础。</p>\n<h1 id=\"IO模型\"><a href=\"#IO模型\" class=\"headerlink\" title=\"IO模型\"></a>IO模型</h1><h2 id=\"一、基础概念\"><a href=\"#一、基础概念\" class=\"headerlink\" title=\"一、基础概念\"></a>一、基础概念</h2><p>在进行解释之前，首先要说明几个概念：</p>\n<ul>\n<li>用户空间和内核空间</li>\n<li>进程切换</li>\n<li>进程的阻塞</li>\n<li>文件描述符</li>\n<li>缓存 IO</li>\n</ul>\n<h3 id=\"用户空间与内核空间\"><a href=\"#用户空间与内核空间\" class=\"headerlink\" title=\"用户空间与内核空间\"></a>用户空间与内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间&#96;。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>\n<h3 id=\"进程切换\"><a href=\"#进程切换\" class=\"headerlink\" title=\"进程切换\"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>\n<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>\n<ol>\n<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>\n<li>更新PCB信息。</li>\n<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>\n<li>选择另一个进程执行，并更新其PCB。</li>\n<li>更新内存管理的数据结构。</li>\n<li>恢复处理机上下文。</li>\n</ol>\n<h3 id=\"进程的阻塞\"><a href=\"#进程的阻塞\" class=\"headerlink\" title=\"进程的阻塞\"></a>进程的阻塞</h3><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</p>\n<h3 id=\"文件描述符fd\"><a href=\"#文件描述符fd\" class=\"headerlink\" title=\"文件描述符fd\"></a>文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>\n<p>文件描述符在形式上是一个非负整数。实际上，<code>它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表</code>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>\n<h3 id=\"缓存-IO\"><a href=\"#缓存-IO\" class=\"headerlink\" title=\"缓存 IO\"></a>缓存 IO</h3><p>缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，<code>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</code>。这个概念非常重要！</p>\n<h3 id=\"linux-IO-的过程\"><a href=\"#linux-IO-的过程\" class=\"headerlink\" title=\"linux IO 的过程\"></a>linux IO 的过程</h3><p>结合以上的基础概念，linux IO 的整体流程是 <code>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</code></p>\n<p>对于本地 read IO，分为以下两个阶段：</p>\n<ul>\n<li><p>第一阶段：等待数据准备 (Waiting for the data to be ready)。</p>\n</li>\n<li><p>第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。</p>\n</li>\n</ul>\n<p>对于网络 IO，<code>网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作</code>。对于socket流而言，</p>\n<ul>\n<li>第一阶段：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li>\n<li>第二阶段：把数据从内核缓冲区复制到应用进程缓冲区。</li>\n</ul>\n<h2 id=\"二、五种常见IO模型\"><a href=\"#二、五种常见IO模型\" class=\"headerlink\" title=\"二、五种常见IO模型\"></a>二、五种常见IO模型</h2><p>根据以上基础知识，我们可以得到这样网络 IO 关系：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">网络数据 —&gt; 内核空间 —&gt; 拷贝到用户空间 —&gt; 应用程序收到结果</span><br></pre></td></tr></table></figure>\n\n<p><code>阻塞/非阻塞</code> 概念可以发生在 <code>网络数据—&gt;内核空间</code> 和 <code>内核空间—&gt;拷贝到用户空间</code> 这两个阶段。如果应用程序什么事都不做直到本阶段完成就称作 <code>阻塞</code>，如果应用程序在阶段完成前可以做自己的事情就称作 <code>非阻塞</code>。</p>\n<p><code>同步/异步</code> 概念发生在 <code>应用程序怎么收到结果</code> 这个阶段。如果应用程序主动去获取结果就称作 <code>同步</code>，如果应用程序被动等待内核通知结果就称作 <code>异步</code>。</p>\n<p>这些概念是下面 IO 模型的基础。</p>\n<h3 id=\"1、同步阻塞-IO（blocking-IO）\"><a href=\"#1、同步阻塞-IO（blocking-IO）\" class=\"headerlink\" title=\"1、同步阻塞 IO（blocking IO）\"></a>1、同步阻塞 IO（blocking IO）</h3><h4 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h4><p>同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型。在这个 IO 模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据。</p>\n<p>在等待数据到处理数据的两个阶段，整个进程都被阻塞。不能处理别的网络 IO。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。流程图如下：</p>\n<p><img src=\"/2020/01/17/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AIO%E6%A8%A1%E5%9E%8B/blockingIO.png\" alt=\"blockingIO\"></p>\n<h4 id=\"流程描述\"><a href=\"#流程描述\" class=\"headerlink\" title=\"流程描述\"></a>流程描述</h4><ul>\n<li>第一个阶段：准备数据。当用户进程调用了 <code>recv()/recvfrom()</code> 这个系统调用之后，用户进程就开始阻塞等待数据。对于网络 IO 来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候 kernel 就要等待足够的数据到来。这个过程也需要等待。也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。</li>\n<li>第二个阶段：当kernel 一直等到数据准备好了，它就会将数据从 kernel 中拷贝到用户内存。然后 kernel 返回结果，用户进程才解除 block 的状态，重新运行起来。</li>\n</ul>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p><strong>特点</strong></p>\n<p>在 IO 执行的两个阶段都被阻塞。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>能够及时返回数据，无延迟。</li>\n<li>对内核开发者来说这是省事了。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<p>性能差，不能支持高并发的应用场景。</p>\n<h3 id=\"2、同步非阻塞-IO（nonblocking-IO）\"><a href=\"#2、同步非阻塞-IO（nonblocking-IO）\" class=\"headerlink\" title=\"2、同步非阻塞 IO（nonblocking IO）\"></a>2、同步非阻塞 IO（nonblocking IO）</h3><h4 id=\"网络模型-1\"><a href=\"#网络模型-1\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h4><p>同步非阻塞就是「每隔一会儿瞄一眼进度条」的轮询方式。在这种模型中，非阻塞也会调用 <code>recvform</code> 系统调用，不管数据是否准备好，内核都会马上返回给进程。如果数据还没准备好，就会返回一个错误代码（EAGAIN 或 EWOULDBLOCK），说明这个命令不能立即满足。进程在返回之后，可以干点别的事情，过一段时间再发起<code>recvform</code> 系统调用，重复上面的过程。这个过程通常被称之为轮询。直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。流程如图所示：</p>\n<p><img src=\"/2020/01/17/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AIO%E6%A8%A1%E5%9E%8B/nonblockingIO.png\" alt=\"nonblockingIO\"></p>\n<h4 id=\"流程描述-1\"><a href=\"#流程描述-1\" class=\"headerlink\" title=\"流程描述\"></a>流程描述</h4><ul>\n<li>用户进程发出 read 操作时，马上就得到了一个结果。<ul>\n<li>kernel中的数据还没有准备好，返回一个 error 信号。</li>\n<li>用户进程接收到一个 error 信号时，就知道数据还没有准备好，这时候用户进程可以去做自己的事情。</li>\n<li>过一段时间再进行 read 操作。一直等到 kernel 中的数据准备好，返回一个数据已经准备好的信号。</li>\n</ul>\n</li>\n<li>用户进程收到数据准备好的信号后，开始阻塞自己，将 kernel 的数据拷到用户进程空间。</li>\n</ul>\n<h4 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p><strong>特点</strong></p>\n<p>nonblocking IO 的特点是用户进程需要不断的主动询问 kernel 数据好了没有。</p>\n<p>同步非阻塞方式相比同步阻塞方式：</p>\n<p><strong>优点</strong></p>\n<p>能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。</p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>任务完成的响应延迟增大了，因为每过一段时间才去轮询一次 read 操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</li>\n<li>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间</li>\n</ul>\n<h3 id=\"3、IO-多路复用（-IO-multiplexing）\"><a href=\"#3、IO-多路复用（-IO-multiplexing）\" class=\"headerlink\" title=\"3、IO 多路复用（ IO multiplexing）\"></a>3、IO 多路复用（ IO multiplexing）</h3><h4 id=\"网络模型-2\"><a href=\"#网络模型-2\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h4><p>IO 多路复用就是用一个单独的非用户态的进程去完成同步非阻塞的轮询工作。和同步非阻塞 IO 的区别是，同步非阻塞 IO使用用户态的进程去完成这个轮询工作，而 IO多路复用使用 UNIX&#x2F;Linux 下的内核函数 <code>select、poll、epoll</code> 都可以完成这个轮询工作（epoll 比 poll、select 效率高，做的事情是一样的）。我们可以把这类函数的工作称为 select 轮询。</p>\n<p>select 轮询是内核级别的，可以监听多个 socket，能实现同时对多个IO端口进行监听，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用 I&#x2F;O 操作函数。然后进程再进行 recvform 系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。流程图如下：</p>\n<p><img src=\"/2020/01/17/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AIO%E6%A8%A1%E5%9E%8B/IOmultiplexing.png\" alt=\"IOmultiplexing\"></p>\n<h4 id=\"流程描述-2\"><a href=\"#流程描述-2\" class=\"headerlink\" title=\"流程描述\"></a>流程描述</h4><ul>\n<li>当用户进程调用了 select，整个进程会被 block，而同时，kernel 会监视所有 select 负责的 socket</li>\n<li>当任何一个 socket 中的数据准备好了，select 就会返回。</li>\n<li>用户进程开始阻塞，将数据从 kernel 拷贝到用户进程。</li>\n</ul>\n<p>上面的图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。<code>因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)</code>。但是，<code>用select的优势在于它可以同时处理多个connection</code>。</p>\n<h4 id=\"分析-2\"><a href=\"#分析-2\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>如果处理的连接数不是很高的话，使用 select&#x2F;epoll 不一定比使用 multi-threading + blocking IO 性能更好，可能延迟还更大。<strong>select&#x2F;epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</strong>I&#x2F;O 多路复用技术通过把多个 I&#x2F;O 的阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求，大大降低系统开销小，节省了系统资源。</p>\n<p>I&#x2F;O多路复用的主要应用场景如下：</p>\n<ul>\n<li><p>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。</p>\n</li>\n<li><p>服务器需要同时处理多种网络协议的套接字。</p>\n</li>\n</ul>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>前面三种IO模式，在用户进程进行系统调用的两个阶段：</p>\n<ul>\n<li>第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。</li>\n<li>第二个阶段可以阻塞又可以不阻塞。</li>\n</ul>\n<p><strong>从整个IO过程来看，他们都是同步模型，因为都属于应用程序主动等待且向内核检查状态。</strong></p>\n<h3 id=\"4、异步非阻塞-IO（asynchronous-IO）\"><a href=\"#4、异步非阻塞-IO（asynchronous-IO）\" class=\"headerlink\" title=\"4、异步非阻塞 IO（asynchronous IO）\"></a>4、异步非阻塞 IO（asynchronous IO）</h3><h4 id=\"网络模型-3\"><a href=\"#网络模型-3\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h4><p>相对于同步IO，异步IO不是顺序执行。用户进程进行 aio_read 系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。</p>\n<p>Linux 提供了 AIO 库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如 libevent、libev、libuv。异步过程如下图所示：</p>\n<p><img src=\"/2020/01/17/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AIO%E6%A8%A1%E5%9E%8B/asynchronousIO.png\" alt=\"asynchronousIO\"></p>\n<h4 id=\"流程描述-3\"><a href=\"#流程描述-3\" class=\"headerlink\" title=\"流程描述\"></a>流程描述</h4><ul>\n<li>用户进程发起 aio_read 操作之后，立刻就可以开始去做其它的事。从 kernel 的角度，当它受到一个asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。</li>\n<li>kernel 会等待数据准备完成，然后将数据拷贝到用户内存。</li>\n<li>kernel 会给用户进程发送一个 signal 或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它 read 操作完成了。如果这个进程正在处理别的事情，就看情况进行处理。<ul>\n<li>如果用户态忙着做别的事（例如在计算两个矩阵的乘积），那就强行打断之，调用事先注册的信号处理函数，这个函数可以决定何时以及如何处理这个异步任务。由于信号处理函数是突然闯进来的，因此跟中断处理程序一样，有很多事情是不能做的，因此保险起见，一般是把事件 “登记” 一下放进队列，然后返回该进程原来在做的事。</li>\n<li>如果这个进程正在内核态忙着做别的事，例如以同步阻塞方式读写磁盘，那就只好把这个通知挂起来了，等到内核态的事情忙完了，快要回到用户态的时候，再触发信号通知。</li>\n<li>如果这个进程现在被挂起了，例如无事可做 sleep 了，那就把这个进程唤醒，下次有 CPU 空闲的时候，就会调度到这个进程，触发信号通知。</li>\n</ul>\n</li>\n</ul>\n<p>Linux 的异步 IO（AIO）支持是 2.6.22 才引入的，还有很多系统调用不支持异步 IO。Linux 的异步 IO 最初是为数据库设计的，因此通过异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制。</p>\n<h4 id=\"分析-3\"><a href=\"#分析-3\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>IO 多路复用和 AIO 都适合高并发的应用场景，两者的区别是：</p>\n<ul>\n<li><p>IO多路复用：IO 多路复用是同步非阻塞模式。select 函数所提供的功能（异步阻塞 IO）与 AIO 类似。不过，它是对通知事件进行阻塞，而不是对 IO 调用进行阻塞。当内核数据在准备过程中，select 函数一直被阻塞，等到数据准备完成后会通知应用程序数据准备好了，然后 select 函数的任务就完成了，至于后面把数据从内核空间复制到用户空间（通过阻塞&#x2F;非阻塞形式都可以）这部分工作由应用程序本身完成。</p>\n</li>\n<li><p>AIO：AIO 是异步模式。内核准备数据和把数据从内核空间复制到用户空间这两部分工作都由系统完成，也就是 IO 过程全部由系统控制，当应用程序收到通知的时候用户空间已经准备好数据了。</p>\n</li>\n</ul>\n<h3 id=\"5、信号驱动式IO（signal-driven-IO）\"><a href=\"#5、信号驱动式IO（signal-driven-IO）\" class=\"headerlink\" title=\"5、信号驱动式IO（signal-driven IO）\"></a>5、信号驱动式IO（signal-driven IO）</h3><p>信号驱动式I&#x2F;O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I&#x2F;O操作函数处理数据。过程如下图所示：</p>\n<p><img src=\"/2020/01/17/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AIO%E6%A8%A1%E5%9E%8B/signal-drivenIO.png\" alt=\"signal-drivenIO\"></p>\n<p>信号驱动IO实际使用得不多，所以在这里不做深入介绍。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本章介绍了同步&#x2F;异步、阻塞&#x2F;非阻塞的概念、linux IO的基础概念和五种常见的 IO 模型：</p>\n<ol>\n<li><p>同步和异步是从<code>调用结果通知机制</code>这个角度来区分的。同步调用是指调用发生后，<code>调用者</code>主动去获取<code>调用结果</code>；异步调用是指调用发生后，<code>调用者</code>被动等待<code>被调用者</code>通知<code>调用结果</code>。</p>\n</li>\n<li><p>阻塞和非阻塞是从<code>调用者在获取到调用结果前的行为</code>这个角度进行区分的。阻塞调用是指调用者<code>在获取到</code>调用结果前什么都不干，线程整个挂起一直等待<code>调用结果</code>；非阻塞调用是指<code>调用者</code>在获取<code>调用结果</code>前可以做自己的事情。</p>\n</li>\n<li><p>系统空间分为用户空间和内核空间，内核空间供系统内核使用，用户空间供各个进程使用。</p>\n</li>\n<li><p>进程被挂起，新的进程或者以前被挂起的某个进程恢复执行，这种过程被称作进程切换。进程从运行态转换成阻塞态，这种过程被称作进程阻塞，进程阻塞后不占用cpu资源。</p>\n</li>\n<li><p>文件描述符fd是指向文件的引用的抽象化概念。</p>\n</li>\n<li><p>linux IO的过程：数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>\n</li>\n<li><p>五种常见的 IO 模型：</p>\n<ul>\n<li>同步阻塞 IO（blocking IO）</li>\n<li>同步非阻塞 IO（nonblocking IO）</li>\n<li>IO 多路复用（ IO multiplexing）</li>\n<li>异步非阻塞 IO（asynchronous IO）</li>\n<li>信号驱动式IO（signal-driven IO）</li>\n</ul>\n<p>其中 IO 多路复用模型是 netty IO 模型的基础，必须要掌握，五种 IO 模型流程简单总结如下：</p>\n<p><img src=\"/2020/01/17/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AIO%E6%A8%A1%E5%9E%8B/fiveIO.png\" alt=\"fiveIO\"></p>\n</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.jianshu.com/p/486b0965c296\">聊聊Linux 五种IO模型</a></p>\n<p><a href=\"https://www.jianshu.com/p/aed6067eeac9\">聊聊同步、异步、阻塞与非阻塞</a></p>\n","categories":["Netty"],"tags":["Netty"]},{"title":"Netty系列（三）：Netty原理和组件简介","url":"/2020/01/20/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ANetty%E5%8E%9F%E7%90%86%E5%92%8C%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B/","content":"<blockquote>\n<p>在上一篇文章我们了解到网络编程的相关知识以及 Netty 给网络编程开发带来的便利性，本文我们介绍 Netty 的基础线程模型 Reactor 模型、Netty 组件和基于这两者的 Netty 线程模型，有助于理解 Netty 整体原理结构。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>本文首先介绍 Reactor 模型的发展历史，该线程模型是 Netty 组件设计和线程模型的基础。然后介绍 Netty 基于 Reactor 模型设计的各种组件，最后介绍 Netty 组件组成的 Netty 线程模型。</p>\n<h1 id=\"Reactor-模型\"><a href=\"#Reactor-模型\" class=\"headerlink\" title=\"Reactor 模型\"></a>Reactor 模型</h1><p>Reactor 模型是一个 IO 设计模式，Java 中的 NIO 就对  Reactor 模式提供了很好的支持，比较著名的就是 [Doung Lea](<a href=\"https://baike.baidu.com/item/Doug\">https://baike.baidu.com/item/Doug</a> Lea&#x2F;6319404) 大神在 <a href=\"http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf\">《Scalable IO in Java》</a>演示如何使用 NIO 实现Reactor模式。</p>\n<p>在维基百科上对  Reactor 模式定义如下：</p>\n<blockquote>\n<p>The reactor design pattern is an <strong>event handling pattern</strong> for handling service requests <strong>delivered concurrently to a service handler</strong> by one or more inputs. The service handler then <strong>demultiplexes</strong> the incoming requests and dispatches them synchronously to the associated request handlers</p>\n</blockquote>\n<p>从这段定义我们可以得到三个关键点：</p>\n<ul>\n<li>事件驱动（event handling）</li>\n<li>可以处理一个或多个输入源（one or more inputs）</li>\n<li>通过 Service Handler 同步的将输入事件（Event）采用多路复用分发给相应的 Request Handler（多个）处理</li>\n</ul>\n<p>基本流程图如下：</p>\n<div style=\"width: 80%; margin: auto\">![base](base.png)</div>\n对流程图进行进一步抽象，得到 Reactor 模型的 OMT 类图如下：\n\n<div style=\"width: 80%; margin: auto\">![omt](omt.png)</div>\n五种类解释如下：\n\n<ul>\n<li><p>Handle(描述符)：表示触发事件，是触发所有操作的发源地。在 Linux 中 Handle 就是文件描述符 fd。</p>\n</li>\n<li><p>Synchronous Event Demultiplexer(同步事件分离器)：事件发生后通知 Initiation Dispatcher，对于 Linux 来说，同步事件分离器指的就是常用的 I&#x2F;O 多路复用机制，比如说 select、poll、epoll 等。在 Java NIO 领域中，同步事件分离器对应的组件就是 Selector，对应的阻塞方法就是 select 方法。</p>\n</li>\n<li><p>Initiation Dispatcher(初始分发器)：相当于 Reactor 的角色，Initiation Dispatcher 会通过 Synchronous Event Demultiplexer 来等待事件的发生。一旦事件发生，Initiation Dispatcher 会调用 Event Handler 来处理事件。</p>\n</li>\n<li><p>Event Handler(事件处理器)：事件产生时实现相应的回调方法进行业务逻辑，类似于接口。</p>\n</li>\n<li><p>Concrete Event Handler(具体事件处理器)： Event Handler的实现。</p>\n</li>\n</ul>\n<p>对 OMT 类图进行简化后，Reactor 模型定义了三种角色：</p>\n<ul>\n<li><strong>Reactor</strong>: 负责监听和响应事件，将事件分发绑定了该事件的 Handler 处理</li>\n<li><strong>Handler</strong>: 事件处理器，绑定了某类事件，负责对事件进行处理</li>\n<li><strong>Acceptor</strong>：Handler 的一种，绑定了 connect 事件，当客户端发起 connect 请求时，Reactor 会将 accept 事件分发给 Acceptor 处理</li>\n</ul>\n<p>这三种角色也是我们下面介绍的三种模型的基础。</p>\n<h2 id=\"Reactor-单线程模型\"><a href=\"#Reactor-单线程模型\" class=\"headerlink\" title=\"Reactor 单线程模型\"></a>Reactor 单线程模型</h2><div style=\"width: 80%; margin: auto\">![reactor1](reactor1.png)</div>\n**处理流程**\n\n<ol>\n<li>Reactor 对象通过 select 监控连接事件，收到事件后通过 dispatch 进行分发</li>\n<li>如果是连接建立的事件，则交由 Acceptor 通过 accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理</li>\n<li>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应</li>\n<li>Handler 会完成 read -&gt; 业务处理 -&gt; send 的完整业务流程</li>\n</ol>\n<p><strong>特点分析</strong></p>\n<ul>\n<li>优点：模型简单，没有多线程，进程通信，竞争的问题，全部都在一个线程中完成。Redis 就是使用 Reactor 单进程的模型。</li>\n<li>缺点：所有的 IO 操作（read、send）和非 IO 操作（decode、compute、encode）都在一个线程里面完成，当非 IO 操作处理速度较慢时，会导致 IO 响应速度严重下降。</li>\n</ul>\n<h2 id=\"Reactor-多线程模型\"><a href=\"#Reactor-多线程模型\" class=\"headerlink\" title=\"Reactor 多线程模型\"></a>Reactor 多线程模型</h2><div style=\"width: 80%; margin: auto\">![reactor2](reactor2.png)</div>\n**处理流程**\n\n<ol>\n<li>主线程中，Reactor 对象通过 select  监听连接事件，收到事件后通过 dispatch 进行分发。</li>\n<li>如果是连接建立的事件，则由 Acceptor 处理，Acceptor 通过 accept 接受连接，并创建一个 Handler 来处理连接后续的各种事件。</li>\n<li>如果不是连接建立事件，则 Reactor 会调用连接对应的 Handler 来进行相应。</li>\n<li>Handler 只负责请求响应事件，不进行业务处理。Handler 通过 read 读取到数据后，会发给业务线程池 Thread Pool 进行业务处理。</li>\n<li>Thread Pool 会在独立的子线程中完成真正的业务处理，然后将响应结果返回给 Handler。</li>\n<li>Handler 收到响应后通过 send 将响应结果返回给 client。</li>\n</ol>\n<p><strong>特点分析</strong></p>\n<ul>\n<li>优点：和单线程模型相比，多线程模型最大的特点就是把非 IO 操作（decode、compute、encode）抽取出来放到专门的业务线程池去进行处理，Handler 只需要负责 IO 操作（read、send），这样会大大提升系统的 IO 响应速度。</li>\n<li>缺点：这个模型仍然把管理连接的 acceptor 和负责 IO 的 Handler 放在同一个 Reactor 中。在瞬间高并发的场景中，系统可能会因为忙于处理新的连接，导致 IO 响应速度瞬间下降。</li>\n</ul>\n<h2 id=\"主从-Reactor-多线程模型\"><a href=\"#主从-Reactor-多线程模型\" class=\"headerlink\" title=\"主从 Reactor 多线程模型\"></a>主从 Reactor 多线程模型</h2><div style=\"width: 80%; margin: auto\">![reactor3](reactor3.png)</div>\n**处理流程**\n\n<ol>\n<li>主进程中 mainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 接收，将新的连接分配给子进程 subReactor（可以有多个）。</li>\n<li>子进程中的 subReactor 将 mainReactor 分配的连接加入队列进行监听，并把该连接从 mainReactor 的管理队列中移除，然后创建一个 Handler 用于处理连接的各种事件</li>\n<li>当有新的事件发生时，subReactor 会调用里连接对应的 Handler 来进行处理。</li>\n<li>Handler 通过 Read 读取数据后，会分发给后面的 Thread Pool 线程池进行业务处理。</li>\n<li>Thread Pool 线程池会分配独立的线程完成真正的业务处理，然后将响应结果返回给 Handler。</li>\n<li>Handler 收到响应结果后通过 send 将响应结果返回给 client。</li>\n</ol>\n<p><strong>特点分析</strong></p>\n<p>和多线程模型相比，该模型将 Reactor 分成两部分，mainReactor 只负责管理连接（accept），subReactor 负责管理除了连接外的其他操作（read、decode、compute、encode、send）。mainReactor 和 subReactor 相互独立，之间的交互非常简单，mainReactor 只需要把连接传给 subReactor 就完成任务了。Reactor 具有以下特点：</p>\n<ul>\n<li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的</li>\n<li>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销</li>\n<li>可扩展性，可以方便地通过增加 Reactor 实例个数来充分利用 CPU 资源；</li>\n<li>可复用性，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性。</li>\n</ul>\n<p>主从 Reactor 多线程模型是 Netty 线程模型的基础，Netty 的主要组件都是围绕该模型进行设计的。</p>\n<h1 id=\"Netty-组件\"><a href=\"#Netty-组件\" class=\"headerlink\" title=\"Netty 组件\"></a>Netty 组件</h1><h2 id=\"Bootstrap\"><a href=\"#Bootstrap\" class=\"headerlink\" title=\"Bootstrap\"></a>Bootstrap</h2><p>Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件。Bootstrap 分为 Bootstrap 和，ServerBootstrapNetty， Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p>\n<h2 id=\"EventLoop、EventLoopGroup\"><a href=\"#EventLoop、EventLoopGroup\" class=\"headerlink\" title=\"EventLoop、EventLoopGroup\"></a>EventLoop、EventLoopGroup</h2><p>一个 EventLoop 对应一个线程，可以绑定多个 Channel，内部会维护一个 selector 和 taskQueue。</p>\n<ul>\n<li>selector：处理 IO 任务，即 selectionKey 中 ready 的事件，如 accept、connect、read、write 等。</li>\n<li>taskQueue：处理非 IO 任务，如 register0、bind0 等任务。</li>\n</ul>\n<p>两种任务的执行时间比由变量 ioRatio 控制，默认为 50，则表示允许非 IO 任务执行的时间与 IO 任务的执行时间相等。</p>\n<p>一个 EventLoopGroup 可以理解为一个线程池，包含一到多个 EventLoop。</p>\n<h2 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><p>Channel 是 Netty 网络操作的基础组件，可以把他理解为 BIO 的 Socket 类和 NIO 的 Channel 的升级版，把相关 api 进行进一步封装，提供了基本的 I&#x2F;O 操作如 bind、connect、read、write 等，并且将 Netty 的相关功能类（例如 EventLoop）聚合在 Channel 中，由 Channel 统一负责和调度（例如可以通过 channel.eventLoop() 获取 channel 所在的 EventLoop 实例），可以功能实现更加灵活。</p>\n<p>一个 Channel 会注册到一个 EventLoop 上，然后在它的整个生命周期过程中，都会用这个 EventLoop。</p>\n<p>用 Netty 编写网络程序的时候，我们一般不会直接操纵 Channel，而是直接操作 Channel 的组件例如最常用的 ChannelHandler。</p>\n<p>Channel 涉及的组件有 ChannelHandler、ChannelHandlerContext、ChannelPipline 和 ChannelFuture。这些组件的关系如下：</p>\n<div style=\"width: 80%; margin: auto\">![channel](channel.png)</div>\n### ChannelHandler\n\n<p>ChannelHandler 是 Netty 的核心组件，用来处理各种事件，例如连接、接收、数据转换、异常处理以及我们的业务逻辑逻辑。ChannelHandler 包括两个核心子类：</p>\n<ul>\n<li>ChannelInboundHandler：用于接收、处理入站数据和事件</li>\n<li>ChannelOutboundHandler：用于接收、处理出站数据和事件</li>\n</ul>\n<p>一个 Channel 可以包含多个 ChannelHandler，这些 ChannelHandler 呈流水线式处理事件。一个 ChannelHandler 也可以被多个 Channel 复用。</p>\n<h3 id=\"ChannelHandlerContext\"><a href=\"#ChannelHandlerContext\" class=\"headerlink\" title=\"ChannelHandlerContext\"></a>ChannelHandlerContext</h3><p>Channel 的上下文，一个 ChannelHandlerContext 对应一个 ChannelHandler，并且与前后的 ChannelHandler 的 ChannelHandlerContext 产生关联。可以把一些数据放到 ChannelHandlerContext 中进行上下文传递。</p>\n<h3 id=\"ChannelPipline\"><a href=\"#ChannelPipline\" class=\"headerlink\" title=\"ChannelPipline\"></a>ChannelPipline</h3><p>ChannelPipline 是 ChannelHandler 的链表，负责把多个 ChannelHandler 串行起来，提供了一种截取过滤模式（类似 serverlet 中的 filter 功能），拦截处理 Channel 的输入输出 event。</p>\n<p>当一个数据流进入 ChannlePipeline 时，它会从 ChannelPipeline 头部开始传给第一个 ChannelInboundHandler ，当第一个处理完后再传给下一个，一直传递到管道的尾部。与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的 “最后” 一个ChannelOutboundHandler，当它处理完成后会传递给前一个 ChannelOutboundHandler 。</p>\n<p>一个 Channel 包含一个 ChannelPipline。当 ChannelHandler 被添加到 ChannelPipeline 时，它将会被分配一个 ChannelHandlerContext，它代表了 ChannelHandler 和 ChannelPipeline 之间的绑定。ChannelPipeline 通过 ChannelHandlerContext 来间接管理 ChannelHandler。</p>\n<h3 id=\"ChannelFuture、ChannelPromise\"><a href=\"#ChannelFuture、ChannelPromise\" class=\"headerlink\" title=\"ChannelFuture、ChannelPromise\"></a>ChannelFuture、ChannelPromise</h3><p>在 Netty 中所有的 IO 操作都是异步的，不能立刻得知消息的处理处理。这时候我们通过 ChannelFuture 或 ChannelPromise，对结果注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。ChannelPromise 是 ChannelFuture 的扩展，可以设置结果。</p>\n<h2 id=\"ByteBuf\"><a href=\"#ByteBuf\" class=\"headerlink\" title=\"ByteBuf\"></a>ByteBuf</h2><p>ByteBuf 是 Netty 的数据容器，本质是一个由不同索引分别控制读访问和写访问的字节数组。Netty 的 ByteBuf 对 NIO 的 ByteBuffer 进行封装，提供更友好的 api 和更强大的功能。</p>\n<h2 id=\"组件关系\"><a href=\"#组件关系\" class=\"headerlink\" title=\"组件关系\"></a>组件关系</h2><p>以上我们介绍的组件有以下关系：</p>\n<ul>\n<li>一个 EventLoopGroup 包含一个或多个 EventLoop。</li>\n<li>一个 EventLoop 在它的生命周期内只能与一个 Thread 绑定。</li>\n<li>所有有 EnventLoop 处理的 I&#x2F;O 事件都将在它专有的 Thread 上被处理。</li>\n<li>一个 Channel 在它的生命周期内只能注册与一个 EventLoop。</li>\n<li>一个 EventLoop 可被分配至一个或多个 Channel 。</li>\n<li>一个 Channel 对应一个 ChannelPipline，一个 ChannelPipline 包含多个 ChannelHandler，每个 ChannelHandler 对应一个 ChannelHandlerContext，与前后 ChannelHandler 的 ChannelHandlerContext 产生关联。</li>\n</ul>\n<h1 id=\"Netty-线程模型\"><a href=\"#Netty-线程模型\" class=\"headerlink\" title=\"Netty 线程模型\"></a>Netty 线程模型</h1><p>根据 Reactor 模型和 Netty 的基本组件，我们可以得到 Netty Server 端的线程模型如下：</p>\n<div style=\"width: 80%; margin: auto\">![netty](netty.png)</div>\n**线程模型分析**\n\n<ul>\n<li>Server 端包含 1 个 Boss NioEventLoopGroup 和 1 个 Worker NioEventLoopGroup。</li>\n<li>每个 Boss NioEventLoopGroup 通常包含 1 个 NioEventLoop，1 个 NioEventLoop 包含 1 个 Selector 和 1 个事件循环线程。Boss NioEventLoopGroup 的工作过程如下：<ul>\n<li>轮询 Accept 事件。</li>\n<li>处理 Accept I&#x2F;O 事件，与 Client 建立连接，生成 NioSocketChannel，并将 NioSocketChannel 注册到某个 Worker NioEventLoop 的 Selector 上。</li>\n<li>处理任务队列中的任务，runAllTasks。任务队列中的任务包括用户调用 eventloop.execute 或 schedule 执行的任务，或者其他线程提交到该 eventloop 的任务。</li>\n</ul>\n</li>\n<li>每个 Worker NioEventLoopGroup 通常包含多个 NioEventLoop。Worker NioEventLoopGroup 的工作过程如下：<ul>\n<li>轮询 Read、Write 事件。</li>\n<li>处理 I&#x2F;O 事件，即 Read、Write 事件，在 NioSocketChannel 可读、可写事件发生时进行处理。</li>\n<li>处理任务队列中的任务，runAllTasks。</li>\n</ul>\n</li>\n</ul>\n<p>该线程模型是 netty 框架的基础，能清晰地认识该模型，对理解 netty 的整体结构设计非常重要。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Reactor 模型是一个 IO 设计模式，发展衍生出三种模型：</p>\n<ul>\n<li>Reactor 单线程模型</li>\n<li>Reactor 多线程模型</li>\n<li>主从 Reactor 多线程模型</li>\n</ul>\n<p>Netty 根据主从 Reactor 多线程模型设计出多种基础组件：</p>\n<ul>\n<li>Bootstrap</li>\n<li>EventLoop、EventLoopGroup</li>\n<li>Channel<ul>\n<li>ChannelHandler</li>\n<li>ChannelHandlerContext</li>\n<li>ChannelPipline</li>\n<li>ChannelFuture、ChannelPromise</li>\n</ul>\n</li>\n<li>ByteBuf</li>\n</ul>\n<p>Netty 的线程模型就是基于主从 Reactor 多线程模型和 Netty 基础组件进行设计的，该线程模型是 Netty 整体结构的基础。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"\">《Netty In Action》</a></p>\n<p><a href=\"http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf\">Scalable IO in Java</a></p>\n<p><a href=\"https://juejin.im/post/5ba3845e6fb9a05cdd2d03c0\">Java NIO 系列文章之 浅析Reactor模式</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1488120\">彻底搞懂Reactor模型和Proactor模型</a></p>\n","categories":["Netty"],"tags":["Netty"]},{"title":"Netty系列（四）：Bootstrap","url":"/2020/05/27/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ABootstrap/","content":"<blockquote>\n<p>上篇文章我们简单介绍了 Netty 的线程模型和基本组件，后面我们开始详细介绍 Netty 每个基本组件。本文先介绍 Netty 的启动器 Bootstrap，包括 Bootstrap 的简介、类分析和实战。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"Bootstrap是什么\"><a href=\"#Bootstrap是什么\" class=\"headerlink\" title=\"Bootstrap是什么\"></a>Bootstrap是什么</h1><p>Bootstrap 是 Netty 的启动器，负责把 Netty 的组件例如 EventLoopGroup 等组装起来，并配置系统属性，然后启动 Netty 服务。例如下面是 Bootstrap 的常用用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 新建Bootstrap</span><br><span class=\"line\">Bootstrap b = new Bootstrap();</span><br><span class=\"line\"></span><br><span class=\"line\">try &#123;   </span><br><span class=\"line\">    //1 设置reactor 线程</span><br><span class=\"line\">    b.group(bossLoopGroup, workerLoopGroup);</span><br><span class=\"line\">    //2 设置nio类型的channel</span><br><span class=\"line\">    b.channel(NioServerSocketChannel.class);</span><br><span class=\"line\">    //3 设置监听端口</span><br><span class=\"line\">    b.localAddress(new InetSocketAddress(port));</span><br><span class=\"line\">    //4 设置通道选项</span><br><span class=\"line\">    b.option(ChannelOption.SO_KEEPALIVE, true);</span><br><span class=\"line\">    b.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);</span><br><span class=\"line\"></span><br><span class=\"line\">    //5 装配流水线</span><br><span class=\"line\">    b.childHandler(new ChannelInitializer&lt;SocketChannel&gt;()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //有连接到达时会创建一个channel</span><br><span class=\"line\">        protected void initChannel(SocketChannel ch) throws Exception</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(new ProtobufDecoder());</span><br><span class=\"line\">            ch.pipeline().addLast(new ProtobufEncoder());</span><br><span class=\"line\">            // pipeline管理channel中的Handler</span><br><span class=\"line\">            // 在channel队列中添加一个handler来处理业务</span><br><span class=\"line\">            ch.pipeline().addLast(&quot;serverHandler&quot;, serverHandler);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // 6 开始绑定server</span><br><span class=\"line\">    // 通过调用sync同步方法阻塞直到绑定成功</span><br><span class=\"line\"></span><br><span class=\"line\">    ChannelFuture channelFuture = b.bind().sync();</span><br><span class=\"line\">    LOGGER.info(ChatServer.class.getName() +</span><br><span class=\"line\">            &quot; started and listen on &quot; +</span><br><span class=\"line\">            channelFuture.channel().localAddress());</span><br><span class=\"line\"></span><br><span class=\"line\">    // 7 监听通道关闭事件</span><br><span class=\"line\">    // 应用程序会一直等待，直到channel关闭</span><br><span class=\"line\">    ChannelFuture closeFuture=  channelFuture.channel().closeFuture();</span><br><span class=\"line\">    closeFuture.sync();</span><br><span class=\"line\">&#125; catch (Exception e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">    // 8 优雅关闭EventLoopGroup，</span><br><span class=\"line\">    // 释放掉所有资源包括创建的线程</span><br><span class=\"line\">    workerLoopGroup.shutdownGracefully();</span><br><span class=\"line\">    bossLoopGroup.shutdownGracefully();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了更清楚地了解 Bootstrap 的用法，我们先介绍  Bootstrap 的类继承关系。</p>\n<h1 id=\"Bootstrap-类分析\"><a href=\"#Bootstrap-类分析\" class=\"headerlink\" title=\"Bootstrap 类分析\"></a>Bootstrap 类分析</h1><h2 id=\"类分析\"><a href=\"#类分析\" class=\"headerlink\" title=\"类分析\"></a>类分析</h2><p><img src=\"/2020/05/27/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ABootstrap/inherit.png\" alt=\"inherit\"></p>\n<p>AbstractBootstrap 中定义了一系列属性供子类使用，每个属性都有 setter 和 getter 方法，另外还有用于验证、启动等其他方法。</p>\n<p>ServerBootstrap 和 Bootstrap 都继承自抽象类 AbstractBootstrap，都能使用父类中的属性。其中 ServerBootstrap 是服务器端的启动类，Bootstrap 是客户端的系统类。两者在类方法上的区别有：</p>\n<ul>\n<li>ServerBootstrap 的 group 的 setter 方法可以设置两个 eventLoopGroup：一个 bossLoopGroup 和一个 workerLoopGroup（也可以只设置一个 eventLoopGroup 同时完成 bossLoopGroup 和 workerLoopGroup 两个线程组的工作）。Bootstrap 的 group 的 setter 方法只需要设置一个 eventLoopGroup，用于与服务端的所有交互。<ul>\n<li>bossLoopGroup 用于监听连接，专门 accept 新的客户端连接。</li>\n<li>workerLoopGroup 用于处理与客户端除了 accept 之外的其他交互。</li>\n</ul>\n</li>\n<li>ServerBootstrap 有 child 前缀的一些属性，用于配置 ServerSocketChannel 的相关属性，而 Bootstrap 没有 child 前缀的属性。</li>\n<li>Bootstrap 的 remoteAddress 属性可以设置远程主机的地址和端口，ServerBootstrap 没有该属性。</li>\n<li>ServerBootstrap 使用父类的 <code>bind</code> 方法进行启动，Bootstrap 使用自定义的 <code>connect</code> 方法进行启动。</li>\n</ul>\n<p>ServerBootstrap 和 Bootstrap 都使用 Builder 链式模式设置属性，例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">bootstrap.group(group)</span><br><span class=\"line\">\t.channel(NioSocketChannel.class)</span><br><span class=\"line\">\t.option(ChannelOption.TCP_NODELAY, true);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"属性介绍\"><a href=\"#属性介绍\" class=\"headerlink\" title=\"属性介绍\"></a>属性介绍</h2><h3 id=\"group-属性\"><a href=\"#group-属性\" class=\"headerlink\" title=\"group 属性\"></a>group 属性</h3><p>设置 EventLoopGroup。服务端使用 ServerBootstrap 的 group 的 setter 方法可以设置两个 eventLoopGroup：一个 bossLoopGroup 和一个 workerLoopGroup。</p>\n<ul>\n<li><strong>bossLoopGroup</strong>：用于监听连接，专门 accept 新的客户端连接。</li>\n<li><strong>workerLoopGroup</strong>：用于处理与客户端除了 accept 之外的其他交互。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">EventLoopGroup bossGroup = new NioEventLoopGroup();</span><br><span class=\"line\">EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class=\"line\">serverBootstrap.group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure>\n\n<p>上面这种模型对应上篇介绍的主从 Reactor 多线程模型，也可以只设置一个 eventLoopGroup 同时完成 bossLoopGroup 和 workerLoopGroup 两个线程组的工作，对应单 Reactor 多线程模型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">EventLoopGroup eventGroup = new NioEventLoopGroup();</span><br><span class=\"line\">serverBootstrap.group(eventGroup);</span><br></pre></td></tr></table></figure>\n\n<p>客户端一般只需要设置一个 eventLoopGroup 就可以完成和服务端的所有交互。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">EventLoopGroup eventGroup = new NioEventLoopGroup();</span><br><span class=\"line\">bootstrap.group(eventGroup);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"channelFactory-属性\"><a href=\"#channelFactory-属性\" class=\"headerlink\" title=\"channelFactory 属性\"></a>channelFactory 属性</h3><p>设置 Channel 属性，ServerBootstrap 和 Bootstrap 通用，例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">serverBootstrap.channel(NioServerSocketChannel.class);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们使用 NioServerSocketChannel.class，看似是直接创建了 ServerSocketChannel 实例，但实际上是调用工厂类 BootstrapChannelFactory 来创建实例，这就是属性名称 channelFactory 的由来。从源码可以看到：</p>\n<pre><code>public B channel(Class&lt;? extends C&gt; channelClass) &#123;\n    if (channelClass == null) &#123;\n        throw new NullPointerException(&quot;channelClass&quot;);\n    &#125;\n    // 调用 BootstrapChannelFactory 获取 Channel 实例\n    return channelFactory(new BootstrapChannelFactory&lt;C&gt;(channelClass));\n&#125;\n\nprivate static final class BootstrapChannelFactory&lt;T extends Channel&gt; implements ChannelFactory&lt;T&gt; &#123;\n    private final Class&lt;? extends T&gt; clazz;\n\n    BootstrapChannelFactory(Class&lt;? extends T&gt; clazz) &#123;\n        this.clazz = clazz;\n    &#125;\n    \n    // 通过 newInstance 创建实例\n    @Override\n    public T newChannel() &#123;\n        try &#123;\n            return clazz.newInstance();\n        &#125; catch (Throwable t) &#123;\n            throw new ChannelException(&quot;Unable to create Channel from class &quot; + clazz, t);\n        &#125;\n    &#125;\n&#125; \n</code></pre>\n<p>serverBootstrap.channel() 方法可配置的常用类有：</p>\n<ul>\n<li><strong>NioDatagramChannel</strong>：基于 NIO，服务端和客户端通用</li>\n<li><strong>NioServerSocketChannel</strong>：基于 NIO，服务端 channel() 方法使用</li>\n<li><strong>NioSocketChannel</strong>：基于 NIO，服务端 childChannel() 和客户端 channel() 方法使用</li>\n<li><strong>OioDatagramChannel</strong>：基于 BIO，同 NioDatagramChannel</li>\n<li><strong>OioServerSocketChannel</strong>：基于 BIO，同 NioServerSocketChannel</li>\n<li><strong>OioSocketChannel</strong>：基于 BIO，同 NioSocketChannel</li>\n</ul>\n<p>我们看到除了可以使用 NIO 的相关 Channel 外，还可以使用 OIO（BIO）的相关 Channel，只需要修改一下类名称即可在 NIO 和 OIO 之间进行切换，对开发非常友好。一般情况下我们只使用 NIO 的相关 Channel。</p>\n<h3 id=\"localAddress、remoteAddress-属性\"><a href=\"#localAddress、remoteAddress-属性\" class=\"headerlink\" title=\"localAddress、remoteAddress 属性\"></a>localAddress、remoteAddress 属性</h3><p>localAddress 用于设置本地端口，一般用于服务端。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 直接使用端口</span><br><span class=\"line\">serverBootstrap.localAddress(8000);</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者使用 InetSocketAddress 对象</span><br><span class=\"line\">serverBootstrap.localAddress(new InetSocketAddress(8000));</span><br></pre></td></tr></table></figure>\n\n<p>也可以不通过 localAddress 来设置端口，在服务端调用 <code>bind</code> 方法的时候再设置端口，两者效果一致。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">serverBootstrap.bind(8000).sync();</span><br><span class=\"line\">// 或</span><br><span class=\"line\">serverBootstrap.bind(new InetSocketAddress(8000)).sync();</span><br></pre></td></tr></table></figure>\n\n<p>remoteAddress 用于设置远程主机地址和端口，一般用于客户端。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 直接使用地址端口</span><br><span class=\"line\">bootstrap.remoteAddress(&quot;192.168.10.1&quot;, 8000);</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者使用 InetSocketAddress 对象</span><br><span class=\"line\">bootstrap.remoteAddress(new InetSocketAddress(&quot;192.168.10.1&quot;, 8000));</span><br></pre></td></tr></table></figure>\n\n<p>也可以不通过 remoteAddress 来设置远程主机地址和端口，在客户点调用 <code>connect</code> 方法的时候再设置，两者效果一致。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">bootstrap.connect(&quot;192.168.10.1&quot;, 8000).sync();</span><br><span class=\"line\">// 或</span><br><span class=\"line\">bootstrap.connect(new InetSocketAddress(&quot;192.168.10.1&quot;, 8000)).sync();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"options-属性\"><a href=\"#options-属性\" class=\"headerlink\" title=\"options 属性\"></a>options 属性</h3><p>设置 Channel 的 options 属性，ServerBootstrap 和 Bootstrap 通用，options 对服务端而言是设置 ServerSocketChannel 的属性，对客户端而言是设置 SocketChannel 的属性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">serverBootstrap.option(ChannelOption.TCP_NODELAY, true);</span><br></pre></td></tr></table></figure>\n\n<p>options 可设置的属性有：</p>\n<p><strong>通用参数</strong></p>\n<ul>\n<li><strong>CONNECT_TIMEOUT_MILLIS</strong>：Netty 参数，连接超时毫秒数，默认值30000毫秒即30。</li>\n<li><strong>MAX_MESSAGES_PER_READ</strong>：Netty 参数，一次 Loop 读取的最大消息数，对于 ServerChannel或者NioByteChannel，默认值为16，其他 Channel 默认值为1。默认值这样设置，是因为：ServerChannel 需要接受足够多的连接，保证大吞吐量，NioByteChannel 可以减少不必要的系统调用 select。</li>\n<li><strong>WRITE_SPIN_COUNT</strong>：Netty 参数，一个 Loop 写操作执行的最大次数，默认值为16。也就是说，对于大数据量的写操作至多进行16次，如果16次仍没有全部写完数据，此时会提交一个新的写任务给 EventLoop，任务将在下次调度继续执行。这样，其他的写请求才能被响应不会因为单个大数据量写请求而耽误。</li>\n<li><strong>ALLOCATOR</strong>：Netty 参数，ByteBuf 的分配器，默认值为 ByteBufAllocator.DEFAULT，4.0版本为 UnpooledByteBufAllocator，4.1版本为 PooledByteBufAllocator。该值也可以使用系统参数io.netty.allocator.type 配置，使用字符串值：”unpooled”，”pooled”。</li>\n<li><strong>RCVBUF_ALLOCATOR</strong>：Netty 参数，用于 Channel 分配接受 Buffer 的分配器，默认值为 AdaptiveRecvByteBufAllocator.DEFAULT，是一个自适应的接受缓冲区分配器，能根据接受到的数据自动调节大小。可选值为 FixedRecvByteBufAllocator，固定大小的接受缓冲区分配器。</li>\n<li><strong>AUTO_READ</strong>：Netty 参数，自动读取，默认值为 True。Netty 只在必要的时候才设置关心相应的I&#x2F;O事件。对于读操作，需要调用 channel.read() 设置关心的 I&#x2F;O 事件为 OP_READ，这样若有数据到达才能读取以供用户处理。该值为 True 时，每次读操作完毕后会自动调用 channel.read()，从而有数据到达便能读取；否则，需要用户手动调用 channel.read()。需要注意的是：当调用 config.setAutoRead(boolean) 方法时，如果状态由 false 变为 true，将会调用 channel.read() 方法读取数据；由 true 变为 false，将调用 config.autoReadCleared()方法终止数据读取。</li>\n<li><strong>WRITE_BUFFER_HIGH_WATER_MARK</strong>：Netty 参数，写高水位标记，默认值 64KB。如果Netty的写缓冲区中的字节超过该值，Channel的isWritable() 返回False。</li>\n<li><strong>WRITE_BUFFER_LOW_WATER_MARK</strong>：Netty 参数，写低水位标记，默认值 32KB。当 Netty 的写缓冲区中的字节超过高水位之后若下降到低水位，则 Channel 的isWritable()返回True。写高低水位标记使用户可以控制写入数据速度，从而实现流量控制。推荐做法是：每次调用 channl.write(msg) 方法首先调用 channel.isWritable() 判断是否可写。</li>\n<li><strong>MESSAGE_SIZE_ESTIMATOR</strong>：Netty 参数，消息大小估算器，默认为 DefaultMessageSizeEstimator.DEFAULT。估算 ByteBuf、ByteBufHolder 和 FileRegion 的大小，其中 ByteBuf和ByteBufHolder 为实际大小，FileRegion 估算值为0。该值估算的字节数在计算水位时使用，FileRegion 为 0 可知 FileRegion 不影响高低水位。</li>\n<li><strong>SINGLE_EVENTEXECUTOR_PER_GROUP</strong>：Netty 参数，单线程执行 ChannelPipeline 中的事件，默认值为 True。该值控制执行 ChannelPipeline 中执行 ChannelHandler 的线程。如果为 Trye，整个 pipeline 由一个线程执行，这样不需要进行线程切换以及线程同步，是 Netty4 的推荐做法；如果为 False，ChannelHandler 中的处理过程会由 Group 中的不同线程执行。</li>\n</ul>\n<p><strong>SocketChannel 参数</strong></p>\n<ul>\n<li><strong>SO_RCVBUF</strong>：Socket 参数，TCP 数据接收缓冲区大小。该缓冲区即 TCP 接收滑动窗口，linux 操作系统可使用命令：cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_rmem 查询其大小。一般情况下，该值可由用户在任意时刻设置，但当设置值超过 64KB 时，需要在连接到远端之前设置。</li>\n<li><strong>SO_SNDBUF</strong>：Socket 参数，TCP 数据发送缓冲区大小。该缓冲区即 TCP 发送滑动窗口，linux 操作系统可使用命令：cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_smem 查询其大小。</li>\n<li><strong>TCP_NODELAY</strong>：TCP 参数，立即发送数据，默认值为 Ture（Netty 默认为 True 而操作系统默认为 False）。该值设置 Nagle 算法的启用，改算法将小的碎片数据连接成更大的报文来最小化所发送的报文的数量，如果需要发送一些较小的报文，则需要禁用该算法。Netty 默认禁用该算法，从而最小化报文传输延时。注意这个参数与是否开启 Nagle 算法是反着来的，true 表示关闭，false 表示开启。通俗地说，如果要求高实时性，有数据发送时就马上发送，就设置为 true；如果需要减少发送次数减少网络交互，就设置为 false。</li>\n<li><strong>SO_KEEPALIVE</strong>：Socket 参数，连接保活，默认值为 False。启用该功能时，TCP 会主动探测空闲连接的有效性。可以将此功能视为 TCP 的心跳机制，需要注意的是：默认的心跳间隔是 7200s 即 2 小时。Netty 默认关闭该功能。</li>\n<li><strong>SO_REUSEADDR</strong>：Socket 参数，地址复用，默认值 False。有四种情况可以使用<ul>\n<li>当有一个有相同本地地址和端口的 socket1 处于 TIME_WAIT 状态时，而你希望启动的程序的 socket2 要占用该地址和端口，比如重启服务且保持先前端口。</li>\n<li>有多块网卡或用 IP Alias 技术的机器在同一端口启动多个进程，但每个进程绑定的本地IP地址不能相同。</li>\n<li>单个进程绑定相同的端口到多个 socket 上，但每个 socket 绑定的 ip 地址不同。</li>\n<li>完全相同的地址和端口的重复绑定。但这只用于 UDP 的多播，不用于 TCP。</li>\n</ul>\n</li>\n<li><strong>SO_LINGER</strong>：Socket 参数，关闭 Socket 的延迟时间，默认值为 -1，表示禁用该功能。-1 表示 socket.close() 方法立即返回，但 OS 底层会将发送缓冲区全部发送到对端。0 表示 socket.close() 方法立即返回，OS 放弃发送缓冲区的数据直接向对端发送 RST 包，对端收到复位错误。非 0 整数值表示调用 socket.close() 方法的线程被阻塞直到延迟时间到或发送缓冲区中的数据发送完毕，若超时，则对端会收到复位错误。</li>\n<li><strong>IP_TOS</strong>：IP 参数，设置 IP 头部的 Type-of-Service 字段，用于描述 IP 包的优先级和 QoS 选项。</li>\n<li><strong>ALLOW_HALF_CLOSURE</strong>：Netty 参数，一个连接的远端关闭时本地端是否关闭，默认值为 False。值为 False 时，连接自动关闭；为 True 时，触发 ChannelInboundHandler 的 userEventTriggered() 方法，事件为 ChannelInputShutdownEvent。</li>\n</ul>\n<p><strong>ServerSocketChannel 参数</strong></p>\n<ul>\n<li><strong>SO_RCVBUF</strong>：已说明，需要注意的是：当设置值超过 64KB 时，需要在绑定到本地端口前设置。该值设置的是由 ServerSocketChannel 使用 accept 接受的 SocketChannel 的接收缓冲区。</li>\n<li><strong>SO_REUSEADDR</strong>：已说明</li>\n<li><strong>SO_BACKLOG</strong>：Socket 参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值， Windows 为 200，其他为 128。</li>\n</ul>\n<p><strong>DatagramChannel参数</strong></p>\n<ul>\n<li><strong>SO_BROADCAST</strong>：Socket 参数，设置广播模式。</li>\n<li><strong>SO_RCVBUF</strong>：已说明</li>\n<li><strong>SO_SNDBUF</strong>：已说明</li>\n<li><strong>SO_REUSEADDR</strong>：已说明</li>\n<li><strong>IP_MULTICAST_LOOP_DISABLED</strong>：对应 IP 参数 IP_MULTICAST_LOOP，设置本地回环接口的多播功能。由于 IP_MULTICAST_LOOP 返回 True 表示关闭，所以 Netty 加上后缀 _DISABLED 防止歧义。</li>\n<li><strong>IP_MULTICAST_ADDR</strong>：对应 IP 参数 IP_MULTICAST_IF，设置对应地址的网卡为多播模式。</li>\n<li><strong>IP_MULTICAST_IF</strong>：对应 IP 参数 IP_MULTICAST_IF2，同上但支持 IPV6。</li>\n<li><strong>IP_MULTICAST_TTL</strong>：IP 参数，多播数据报的 time-to-live 即存活跳数。</li>\n<li><strong>IP_TOS</strong>：已说明</li>\n<li><strong>DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION</strong>：Netty 参数，DatagramChannel 注册的 EventLoop 即表示已激活。</li>\n</ul>\n<h3 id=\"attrs-属性\"><a href=\"#attrs-属性\" class=\"headerlink\" title=\"attrs 属性\"></a>attrs 属性</h3><p>设置 Channel 的 attrs 属性，attrs 是用户自定义的 key-value 对，ServerBootstrap 和 Bootstrap 通用，对服务端而言会把 key-value 添加到 ServerSocketChannel，对客户端而言会把 key-value 添加到 SocketChannel。</p>\n<blockquote>\n<p>Bootstrap 在启动过程中会调用 initAndRegister() 方法创建 Channel，然后把 options 和 attrs 属性设置到 Channel 上。</p>\n</blockquote>\n<p>使用 Bootstrap 的 attrs 属性添加的自定义 key-value 作为全局变量，被和该 Bootstrap 关联的所有 Channel 共用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">serverBootstrap.attr(AttributeKey.valueOf(&quot;key&quot;), &quot;value&quot;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"handler-属性\"><a href=\"#handler-属性\" class=\"headerlink\" title=\"handler 属性\"></a>handler 属性</h3><p>把 handler 添加到 Channel 上，ServerBootstrap 和 Bootstrap 通用，对服务端而言会把 handler 添加到 ServerSocketChannel，对客户端而言会把 handler 添加到 SocketChannel。</p>\n<p>如果只有单个 handler，可以直接添加</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">serverBootstrap.handler(new PacketDecoder());</span><br></pre></td></tr></table></figure>\n\n<p>如果有多个 handler，可以借助 NettyClientInitializer 类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">serverBootstrap.handler(new ChannelInitializer&lt;ServerSocketChannel&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void initChannel(ServerSocketChannel ch) throws Exception &#123;</span><br><span class=\"line\">        // 解密</span><br><span class=\"line\">        ch.pipeline().addLast(&quot;packetDecoder&quot;, new PacketDecoder());</span><br><span class=\"line\">        // 子命令解码器</span><br><span class=\"line\">        ch.pipeline().addLast(&quot;subPacketDecoder&quot;, new SubPacketDecoder());</span><br><span class=\"line\">        // 返回封包</span><br><span class=\"line\">        ch.pipeline().addLast(&quot;packetEncoder&quot;, new PacketEncoder());</span><br><span class=\"line\">        // 子命令封包</span><br><span class=\"line\">        ch.pipeline().addLast(&quot;subPacketEncoder&quot;, new SubPacketEncoder());</span><br><span class=\"line\">        // 登陆</span><br><span class=\"line\">        ch.pipeline().addLast(&quot;loginSendHandler&quot;, new LoginSenderhandler());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>ChannelInitializer 是一种特殊的 ChannelHandler，负责把多个 Handler 和自己添加到 Channel 对应的 pipeline 中，最后把自己移除，这部分看源码可以看出来</p>\n<pre><code>private boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;\n    if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) &#123; // Guard against re-entrance.\n        try &#123;\n            // 这个是抽象方法，我们在实例化 ChannelInitializer 类时必须实现的就是这个方法\n            initChannel((C) ctx.channel());\n        &#125; catch (Throwable cause) &#123;\n            exceptionCaught(ctx, cause);\n        &#125; finally &#123;\n            // 移除多余的 ChannelHandler，具体见下\n            remove(ctx);\n        &#125;\n        return true;\n    &#125;\n    return false;\n&#125;\n\nprivate void remove(ChannelHandlerContext ctx) &#123;\n    try &#123;\n        ChannelPipeline pipeline = ctx.pipeline();\n        if (pipeline.context(this) != null) &#123;\n            // 把本实例也就是 ChannelInitializer 实例从 pipeline 中移除\n            pipeline.remove(this);\n        &#125;\n    &#125; finally &#123;\n        initMap.remove(ctx);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"childOptions、childAttrs、childHandler-属性\"><a href=\"#childOptions、childAttrs、childHandler-属性\" class=\"headerlink\" title=\"childOptions、childAttrs、childHandler 属性\"></a>childOptions、childAttrs、childHandler 属性</h3><p>这四个属性是用来设置服务端的 workerLoopGroup 的属性，具体设置方法和没有带 child 前缀的属性基本相同，两者的区别是：不带 child 前缀的属性在程序初始化时就会执行，带 child 前缀的属性在客户端 connect 成功后才会执行。</p>\n<h1 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h1><p>下面我们开始使用上面介绍的属性创建一个 Bootstrap 对象，示例化方式分为服务端 ServerBootstrap 和客户端 Bootstrap。</p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">NioEventLoopGroup bossGroup = new NioEventLoopGroup();</span><br><span class=\"line\">NioEventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class=\"line\">// 服务端启动类使用ServerBootstrap</span><br><span class=\"line\">ServerBootstrap bootstrap = new ServerBootstrap();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">   // 设置eventLoopGroup，服务端一般情况下会使用bossGroup和workerGroup两组NioEventLoopGroup</span><br><span class=\"line\">   bootstrap.group(bossGroup, workerGroup)</span><br><span class=\"line\">         // 设置channelFactory，服务端设置NioServerSocketChannel，表示这是NIO模式的TCP连接</span><br><span class=\"line\">         .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">         // 设置localAddress，也可以不在这里设置，在下面的bind方法里面设置</span><br><span class=\"line\">         .localAddress(8000)</span><br><span class=\"line\">         // 设置option，SO_BACKLOG表示服务端接受连接的队列长度为100，如果队列已满，客户端连接将被拒绝。</span><br><span class=\"line\">         .option(ChannelOption.SO_BACKLOG, 100)</span><br><span class=\"line\">         // 设置attr</span><br><span class=\"line\">         .attr(AttributeKey.valueOf(&quot;key&quot;), &quot;value&quot;)</span><br><span class=\"line\">         // 设置handler，使用Netty自带的LoggingHandler作为acceptor</span><br><span class=\"line\">         .handler(new LoggingHandler())</span><br><span class=\"line\">         // 设置childOption，TCP_NODELAY表示不管数据大小有数据就发送，SO_KEEPALIVE表示开启心跳探测</span><br><span class=\"line\">         .childOption(ChannelOption.TCP_NODELAY, true)</span><br><span class=\"line\">         .childOption(ChannelOption.SO_KEEPALIVE, true)</span><br><span class=\"line\">         // 设置childAttr</span><br><span class=\"line\">         .childAttr(AttributeKey.valueOf(&quot;childKey&quot;), &quot;childValue&quot;)</span><br><span class=\"line\">         // 设置childHandler，因为有多个ChannelHandler，所以使用ChannelInitializer</span><br><span class=\"line\">         .childHandler(new ChannelInitializer&lt;ServerSocketChannel&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            protected void initChannel(ServerSocketChannel ch) throws Exception &#123;</span><br><span class=\"line\">               // 解密</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;packetDecoder&quot;, new PacketDecoder());</span><br><span class=\"line\">               // 子命令解码器</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;subPacketDecoder&quot;, new SubPacketDecoder());</span><br><span class=\"line\">               // 返回封包</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;packetEncoder&quot;, new PacketEncoder());</span><br><span class=\"line\">               // 子命令封包</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;subPacketEncoder&quot;, new SubPacketEncoder());</span><br><span class=\"line\">               // 登陆</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;loginSendHandler&quot;, new LoginSenderhandler());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 调用bind()启动服务器，并对启动结果增加回调监听</span><br><span class=\"line\">   ChannelFuture future = bootstrap.bind().sync().addListener(f -&gt; &#123;</span><br><span class=\"line\">      if(f.isSuccess()) &#123;</span><br><span class=\"line\">         log.info(&quot;服务端启动成功&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 对服务端关闭增加回调监听</span><br><span class=\"line\">   future.channel().closeFuture().sync().addListener(f -&gt; &#123;</span><br><span class=\"line\">      if(f.isSuccess()) &#123;</span><br><span class=\"line\">         log.info(&quot;服务端关闭服务&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">   // 销毁资源</span><br><span class=\"line\">   bossGroup.shutdownGracefully();</span><br><span class=\"line\">   workerGroup.shutdownGracefully();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>服务端启动流程代码解析</strong></p>\n<ol>\n<li>创建两组 NioEventLoopGroup 实例：bossGroup 和 workerGroup。</li>\n<li>创建 ServerBootstrap 实例。</li>\n<li>把 bossGroup 和 workerGroup 注册到 ServerBootstrap 实例。下面 4 ～ 8 为设置 bossGroup 实例属性，9 ～ 11 为设置 workerGroup 实例属性。</li>\n<li>设置 channelFactory，服务端一般配置为 NioServerSocketChannel.class。</li>\n<li>设置 localAddress，绑定本地端口 8000。</li>\n<li>设置 option，SO_BACKLOG 是服务端属性，表示服务端接受连接的队列长度为100，如果队列已满，客户端连接将被拒绝。</li>\n<li>设置 attr。</li>\n<li>设置 handler，直接使用 Netty 自带的 LoggingHandler 作为 acceptor。</li>\n<li>设置 childOption，TCP_NODELAY 表示不管数据大小有数据就发送，SO_KEEPALIVE 表示开启心跳探测。</li>\n<li>设置 childAttr。</li>\n<li>设置 childHandler，因为有多个 ChannelHandler，所以使用 ChannelInitializer。</li>\n<li>ServerBootstrap 实例调用 <code>bind()</code> 启动服务器，并对启动结果增加回调监听。</li>\n<li>对服务端关闭增加回调监听</li>\n<li>服务端关闭后销毁资源</li>\n</ol>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">NioEventLoopGroup group = new NioEventLoopGroup();</span><br><span class=\"line\">// 客户端启动类使用Bootstrap</span><br><span class=\"line\">Bootstrap bootstrap = new Bootstrap();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">   // 设置eventLoopGroup，客户端只需要设置一组</span><br><span class=\"line\">   bootstrap.group(group)</span><br><span class=\"line\">         // 设置channelFactory，客户端设置NioSocketChannel，表示这是NIO模式的TCP连接</span><br><span class=\"line\">         .channel(NioSocketChannel.class)</span><br><span class=\"line\">         // 设置remoteAddress，也可以不在这里设置，在下面的connect方法里面设置</span><br><span class=\"line\">         .remoteAddress(&quot;192.168.10.1&quot;, 8000)</span><br><span class=\"line\">         // 设置option，TCP_NODELAY 表示不管数据大小有数据就发送，SO_KEEPALIVE表示开启心跳探测</span><br><span class=\"line\">         .option(ChannelOption.TCP_NODELAY, true)</span><br><span class=\"line\">         .option(ChannelOption.SO_KEEPALIVE, true)</span><br><span class=\"line\">         // 设置attr</span><br><span class=\"line\">         .attr(AttributeKey.valueOf(&quot;key&quot;), &quot;value&quot;)</span><br><span class=\"line\">         // 设置handler，因为有多个ChannelHandler，所以使用ChannelInitializer</span><br><span class=\"line\">         .handler(new ChannelInitializer&lt;ServerSocketChannel&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            protected void initChannel(ServerSocketChannel ch) throws Exception &#123;</span><br><span class=\"line\">               // 解密</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;packetDecoder&quot;, new PacketDecoder());</span><br><span class=\"line\">               // 子命令解码器</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;subPacketDecoder&quot;, new SubPacketDecoder());</span><br><span class=\"line\">               // 返回封包</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;packetEncoder&quot;, new PacketEncoder());</span><br><span class=\"line\">               // 子命令封包</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;subPacketEncoder&quot;, new SubPacketEncoder());</span><br><span class=\"line\">               // 登陆</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;loginSendHandler&quot;, new LoginSenderhandler());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 客户端调用connect()开始连接服务器，并增加回调监听</span><br><span class=\"line\">   ChannelFuture future = bootstrap.connect().sync().addListener(f -&gt; &#123;</span><br><span class=\"line\">      if(f.isSuccess()) &#123;</span><br><span class=\"line\">         log.info(&quot;客户端连接成功&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 断开服务器增加回调监听</span><br><span class=\"line\">   future.channel().closeFuture().sync().addListener(f -&gt; &#123;</span><br><span class=\"line\">      if(f.isSuccess()) &#123;</span><br><span class=\"line\">         log.info(&quot;客户端连接断开&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">   // 销毁资源</span><br><span class=\"line\">   group.shutdownGracefully();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>客户端启动流程代码解析</strong></p>\n<p>客户端的启动代码相对于服务端就简单很多</p>\n<ol>\n<li>创建一个 NioEventLoopGroup 实例：group</li>\n<li>创建 Bootstrap 实例。</li>\n<li>把 group 注册到 Bootstrap 实例，下面 4 ～ 8 为设置 group 实例属性。</li>\n<li>设置 channelFactory，客户端一般设置 NioSocketChannel.class。</li>\n<li>设置 remoteAddress，设置远程主机地址和端口。</li>\n<li>设置 option，TCP_NODELAY 表示不管数据大小有数据就发送，SO_KEEPALIVE 表示开启心跳探测。</li>\n<li>设置 attr。</li>\n<li>设置 handler，因为有多个 ChannelHandler，所以使用 ChannelInitializer。</li>\n<li>Bootstrap 实例使用 <code>connect()</code> 连接远程服务器，并对连接结果增加回调监听。</li>\n<li>对客户端连接关闭增加回调监听。</li>\n<li>客户端关闭后销毁资源。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文介绍了 Netty 的启动类 Bootstrap。Bootstrap 按用途分为 ServerBootstrap 和 Bootstrap，分别对应服务端和客户端。Bootstrap 的常用属性有：</p>\n<ul>\n<li>group</li>\n<li>channelFactory</li>\n<li>localAddress、remoteAddress</li>\n<li>options</li>\n<li>attrs</li>\n<li>handler</li>\n<li>childOptions、childAttrs、childHandler</li>\n</ul>\n<p>其中 localAddress、childOptions、childAttrs 和 childHandler是服务端属性，remoteAddress 是客户端属性，其他两者通用。最后通过实战例子分别分析 ServerBootstrap 和 Bootstrap 的具体启动过程。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"\">《Netty In Action》</a></p>\n<p><a href=\"http://www.kancloud.cn:8080/ssj234/netty-source/433213\"> Netty服务器启动过程</a></p>\n","categories":["Netty"],"tags":["Netty"]},{"title":"Netty系列（六）：Channel","url":"/2020/06/09/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AChannel/","content":"<blockquote>\n<p>上一篇介绍了 Netty 的线程模型 EventLoop 和 EventLoopGroup，本文开始介绍 Netty 的传输流组件 Channel 以及相关组件 ChannelHandler、ChannelHandlerContext、ChannelPipline 和 ChannelFuture 等。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><h3 id=\"Channel是什么\"><a href=\"#Channel是什么\" class=\"headerlink\" title=\"Channel是什么\"></a>Channel是什么</h3><p>Channel 是一个管道，用于连接字节缓冲区 Buf 和另一端的实体，这个实例可以是 Socket，也可以是 File，在 NIO 网络编程模型中，服务端和客户端进行 IO 数据交互(得到彼此推送的信息)的媒介就是 Channel。</p>\n<p>Netty 对 NIO 的原生的 Channel 进行了封装和增强封装成 NioXXXChannel，相对于原生的 Channel，Netty 的 Channel 增加了如下的组件：</p>\n<ul>\n<li>id 标识唯一身份信息</li>\n<li>可能存在的 parent Channel</li>\n<li>管道 pepiline</li>\n<li>用于数据读写的 unsafe 内部类</li>\n<li>关联上相伴终生的 NioEventLoop</li>\n</ul>\n<h3 id=\"Channel的工作流程\"><a href=\"#Channel的工作流程\" class=\"headerlink\" title=\"Channel的工作流程\"></a>Channel的工作流程</h3><p>Channel 本身做的事情不多，主要通过其包含的成员完成大量工作，包含的主要成员如下：</p>\n<ul>\n<li>EventLoop：每个 Channel 整个生命周期都绑定到一个特定的 EventLoop。</li>\n<li>Unsafe：承担 Channel 网络相关的功能，例如真正的网络读写操作。</li>\n<li>DefaultChannelPipeLine：每个 Channel 绑定到一个 ChannelPipeLine，Channel 在生命周期的大部分动作都通过调用 ChannelPipeLine 的方法来完成。</li>\n</ul>\n<p>Channel 通过调用成员，可以完成以下工作流程： </p>\n<ul>\n<li>一旦用户端连接成功，将新建一个 Channel 同该用户端进行绑定。</li>\n<li>Channel 从 EventLoopGroup 获得一个 EventLoop，并注册到该 EventLoop，Channel 生命周期内都和该 EventLoop 在一起（注册时获得 selectionKey）。</li>\n<li>Channel 同用户端进行网络连接、关闭和读写，生成相对应的 event（改变 selectinKey 信息），触发eventloop调度线程进行执行。</li>\n</ul>\n<h3 id=\"Channel的分类\"><a href=\"#Channel的分类\" class=\"headerlink\" title=\"Channel的分类\"></a>Channel的分类</h3><p>Netty 中的 Channel 有很多种类型。</p>\n<p>从 IO 类型来说，分为同步（Oio）和异步（Nio）两种类型。一般情况下我们都会使用异步的 Channel，特殊情况下需要切换成同步通讯时，我们只需要修改 Channel 的类型即可，所以在 Netty 通讯中同步和异步的切换非常灵活。</p>\n<p>从数据传输类型来说，分为按事件消息传递（Message）以及按字节传递（Byte）两种类型。</p>\n<p>从使用角色类型来说，分为服务器（ServerSocket）以及客户端（Socket）两种。</p>\n<p>从使用协议类型来说，分为 TCP、UDT 和 SCTP 协议等。</p>\n<p>Channel 的具体实现类如下：</p>\n<ul>\n<li>NioSocketChannel：异步的客户端 TCP Socket 连接</li>\n<li>NioServerSocketChannel：异步的服务器端 TCP Socket 连接</li>\n<li>NioDatagramChannel：异步的 UDP 连接</li>\n<li>NioSctpChannel：异步的客户端 Sctp 连接</li>\n<li>NioSctpServerChannel：异步的 Sctp 服务器端连接</li>\n<li>OioSocketChannel：同步的客户端 TCP Socket 连接</li>\n<li>OioServerSocketChannel：同步的服务器端 TCP Socket 连接</li>\n<li>OioDatagramChannel：同步的 UDP 连接</li>\n<li>OioSctpChannel：同步的 Sctp 服务器端连接</li>\n<li>OioSctpServerChannel：同步的客户端 TCP Socket 连接</li>\n</ul>\n<h3 id=\"Channel-整体结构图\"><a href=\"#Channel-整体结构图\" class=\"headerlink\" title=\"Channel 整体结构图\"></a>Channel 整体结构图</h3><p><img src=\"/2020/06/09/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AChannel/channel1.png\" alt=\"channel1\"></p>\n<p>一个 Channel 里面包含 ChannelPipeLine、ChannelHandler 和 ChannelHandlerContext 等组件，组件间的关系如下：</p>\n<ul>\n<li>一个 Channel 绑定到一个 ChannelPipeLine 上，Channel 的大部分功能都通过调用 ChannelPipeLine 的方法来完成。</li>\n<li>一个 ChannelPipeLine 通过 filter 的模式把一到多个 ChannelHandler 组织到一起，ChannelHandler 之间不会产生直接关联。</li>\n<li>把一个 ChannelHandler 添加到 ChannelPipeLine 的时候，会生成一个 ChannelHandlerContext 和该 ChannelHandler 对应。ChannelHandlerContext 是一个双向链表，使前后的 ChannelHandler 产生关联。</li>\n</ul>\n<p>因为 ChannelHandler 都是通过 ChannelHandlerContext 产生关联 ，所以事件在 Channel 中进行传播的过程，实际上是通过 ChannelHandlerContext 来完成的。</p>\n<p><img src=\"/2020/06/09/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AChannel/channel2.png\" alt=\"channel2\"></p>\n<p>下面我们简单介绍一下 Channel 的主要组件。</p>\n<h2 id=\"ChannelPipline\"><a href=\"#ChannelPipline\" class=\"headerlink\" title=\"ChannelPipline\"></a>ChannelPipline</h2><p>ChannelPipline 可以理解为拦截流经 Channel 的入站和出站事件的 <strong>ChannelHandler实例链</strong> ，ChannelPipline 的官方结构图如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                                    I/O Request  via Channel or  ChannelHandlerContext</span><br><span class=\"line\">                                                  |</span><br><span class=\"line\">+---------------------------------------------------+---------------+</span><br><span class=\"line\">|                           ChannelPipeline         |               |</span><br><span class=\"line\">|                                                  \\|/              |</span><br><span class=\"line\">|    +---------------------+            +-----------+----------+    |</span><br><span class=\"line\">|    | Inbound Handler  N  |            | Outbound Handler  1  |    |</span><br><span class=\"line\">|    +----------+----------+            +-----------+----------+    |</span><br><span class=\"line\">|              /|\\                                  |               |</span><br><span class=\"line\">|               |                                  \\|/              |</span><br><span class=\"line\">|    +----------+----------+            +-----------+----------+    |</span><br><span class=\"line\">|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |</span><br><span class=\"line\">|    +----------+----------+            +-----------+----------+    |</span><br><span class=\"line\">|              /|\\                                  .               |</span><br><span class=\"line\">|               .                                   .               |</span><br><span class=\"line\">| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class=\"line\">|        [ method call]                       [method call]         |</span><br><span class=\"line\">|               .                                   .               |</span><br><span class=\"line\">|               .                                  \\|/              |</span><br><span class=\"line\">|    +----------+----------+            +-----------+----------+    |</span><br><span class=\"line\">|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |</span><br><span class=\"line\">|    +----------+----------+            +-----------+----------+    |</span><br><span class=\"line\">|              /|\\                                  |               |</span><br><span class=\"line\">|               |                                  \\|/              |</span><br><span class=\"line\">|    +----------+----------+            +-----------+----------+    |</span><br><span class=\"line\">|    | Inbound Handler  1  |            | Outbound Handler  M  |    |</span><br><span class=\"line\">|    +----------+----------+            +-----------+----------+    |</span><br><span class=\"line\">|              /|\\                                  |               |</span><br><span class=\"line\">+---------------+-----------------------------------+---------------+</span><br><span class=\"line\">              |                                  \\|/</span><br><span class=\"line\">+---------------+-----------------------------------+---------------+</span><br><span class=\"line\">|               |                                   |               |</span><br><span class=\"line\">|       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class=\"line\">|                                                                   |</span><br><span class=\"line\">|  Netty Internal I/O Threads (Transport Implementation)            |</span><br><span class=\"line\">+-------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，流经 ChannelPipline 的事件分为 Inbound 和 Outbound 两种类型，Inbound 事件的流向是从下至上，而 Outbound 刚好相反。Inbound 的传递方式是通过调用相应的 <strong>ChannelHandlerContext.fireIN_EVT()</strong> 方法，而 Outbound 方法的的传递方式是通过调用 <strong>ChannelHandlerContext.OUT_EVT()</strong> 方法。例如 <strong>ChannelHandlerContext.fireChannelRegistered()</strong> 调用会发送一个 <strong>ChannelRegistered</strong> 的 Inbound 事件给下一个ChannelHandlerContext，而 <strong>ChannelHandlerContext.bind</strong> 调用会发送一个 <strong>bind</strong> 的 Outbound 事件给 下一个 ChannelHandlerContext。</p>\n<p>在 ChannelPipeline 传播事件时，它会测试 ChannelPipeline 中的下一个 ChannelHandler 的类型是否和事件的运动方向相匹配。如果不匹配，ChannelPipeline 将跳过该 ChannelHandler 并前进到下一个，直到它找到和该事件所期望的方向相匹配的为止。</p>\n<p>DefaultChannelPipeline 是 ChannelPipeline 的默认实现类，新建 Channel 时默认，部分源码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">final class DefaultChannelPipeline implements ChannelPipeline &#123;</span><br><span class=\"line\">    private static final WeakHashMap&lt;Class&lt;?&gt;, String&gt;[] nameCaches = new WeakHashMap[Runtime.getRuntime().availableProcessors()];</span><br><span class=\"line\"></span><br><span class=\"line\">    final AbstractChannel channel;</span><br><span class=\"line\"></span><br><span class=\"line\">    final DefaultChannelHandlerContext head;</span><br><span class=\"line\">    final DefaultChannelHandlerContext tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final Map&lt;String, DefaultChannelHandlerContext&gt; name2ctx = new HashMap&lt;String, DefaultChannelHandlerContext&gt;(4);</span><br><span class=\"line\"></span><br><span class=\"line\">    final Map&lt;EventExecutorGroup, ChannelHandlerInvoker&gt; childInvokers = new IdentityHashMap&lt;EventExecutorGroup, ChannelHandlerInvoker&gt;();</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 DefaultChannelPipeline 构造器中，首先将与之关联的 Channel 保存到字段 channel 中，然后实例化两个 ChannelHandlerContext，一个是 HeadContext 实例 head，另一个是 TailContext 实例 tail。接着将 head 和 tail 互相指向，构成一个双向链表。<strong>这个链表是 Netty 实现 Pipeline 机制的关键</strong>。</p>\n<h2 id=\"ChannelHandler\"><a href=\"#ChannelHandler\" class=\"headerlink\" title=\"ChannelHandler\"></a>ChannelHandler</h2><p>ChannelHandler 是 Channel 的核心，<strong>数据编解码和所有的业务逻辑都需要通过自定义 ChannelHandler 来实现</strong>。</p>\n<p>ChannelHandler 分为 ChannelInboundHandler 和 ChannelOutboundHandler：</p>\n<ul>\n<li>ChannelInboundHandler：处理入站事件，如链路建立、链路关闭或者读完成等事件。</li>\n<li>ChannelOutboundHandler：处理出站事件，如由用户线程或者代码发起的 IO 操作事件。</li>\n</ul>\n<p>其中 ChannelOutboundHandler 用的比较少（Netty 5 后面已经有废弃的趋势），下面介绍下 ChannelInboundHandler 的生命周期：</p>\n<p><img src=\"/2020/06/09/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AChannel/channel3.png\" alt=\"channel3\"></p>\n<ol>\n<li>handlerAdded：新建立的连接会按照初始化策略，把 handler 添加到该 channel 的 pipeline 里面，也就是 channel.pipeline.addLast(new LifeCycleInBoundHandler) 执行完成后的回调；</li>\n<li>channelRegistered：当该连接分配到具体的 worker 线程后，该回调会被调用。</li>\n<li>channelActive：channel 的准备工作已经完成，所有的 pipeline 添加完成，并分配到具体的线上上，说明该 channel 准备就绪，可以使用了。</li>\n<li>channelRead：客户端向服务端发来数据，每次都会回调此方法，表示有数据可读；</li>\n<li>channelReadComplete：服务端每次读完一次完整的数据之后，回调该方法，表示数据读取完毕；</li>\n<li>channelInactive：当连接断开时，该回调会被调用，说明这时候底层的TCP连接已经被断开了。</li>\n<li>channelUnREgistered：对应 channelRegistered，当连接关闭后，释放绑定的workder线程；</li>\n<li>handlerRemoved：对应 handlerAdded，将 handler 从该 channel 的 pipeline 移除后的回调方法。</li>\n</ol>\n<p>ChannelInboundHandler 的生命周期里面除了正常的读写流程外， 还提供了定时处理和异常处理的方法：</p>\n<ol>\n<li>userEventTriggered：处理心跳超时事件，在 IdleStateHandler 设置超时时间，达到了超时时间就会直接调用该方法。</li>\n<li>exceptionCaught：处理连接出现的异常情况。</li>\n</ol>\n<h2 id=\"ChannelHandlerContext\"><a href=\"#ChannelHandlerContext\" class=\"headerlink\" title=\"ChannelHandlerContext\"></a>ChannelHandlerContext</h2><p>ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandlerContext。<strong>ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互</strong>。</p>\n<p>我们可以通过 ChannelHandlerContext 来获取整个 Channel 的上下文属性。例如通过 ChannelHandlerContext 来访问 Channel：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//获取到与 ChannelHandlerContext相关联的 Channel 的引用</span><br><span class=\"line\">ChannelHandlerContext ctx = ..;</span><br><span class=\"line\">Channel channel = ctx.channel();</span><br><span class=\"line\">//通过 Channel 写入缓冲区</span><br><span class=\"line\">channel.write(Unpooled.copiedBuffer(&quot;Netty in Action&quot;, CharsetUtil.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p>通过 ChannelHandlerContext 访问 ChannelPipeline：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//获取到与 ChannelHandlerContext相关联的 ChannelPipeline 的引用</span><br><span class=\"line\">ChannelHandlerContext ctx = ..;</span><br><span class=\"line\">ChannelPipeline pipeline = ctx.pipeline();</span><br><span class=\"line\">//通过 ChannelPipeline写入缓冲区</span><br><span class=\"line\">pipeline.write(Unpooled.copiedBuffer(&quot;Netty in Action&quot;, CharsetUtil.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p>最开始的时候 ChannelPipeline 中含有 head 和 tail 两个 ChannelHandlerContext(同时也是 ChannelHandler)，但是这个 Pipeline并不能实现什么特殊的功能，因为我们还没有给它添加自定义的 ChannelHandler。通常来说，我们在初始化 Bootstrap，会添加我们自定义的 ChannelHandler。</p>\n<p>如果你在 Channel 或者 ChannelPipeline 实例上调用这些方法，它们的调用会穿过整个 pipeline。而在 ChannelHandlerContext 上调用的同样的方法，仅仅从当前 ChannelHandler 开始，走到 pipeline 中下一个可以处理这个 event 的 ChannelHandler。例如调用 <code>ctx.writeAndFlush</code>，是从当前 handler 直接发出这个消息，而调用 <code>channel.writeAndFlush</code> 是从整个 pipline 最后一个 outhandler 发出消息。</p>\n<h2 id=\"ChannelFuture、ChannelPromise\"><a href=\"#ChannelFuture、ChannelPromise\" class=\"headerlink\" title=\"ChannelFuture、ChannelPromise\"></a>ChannelFuture、ChannelPromise</h2><p>ChannelFuture 的作用是用来保存 Channel 异步操作的结果。</p>\n<p>在 Netty 中所有的 I&#x2F;O 操作都是异步的。这意味着任何的 I&#x2F;O 调用都将立即返回，而不保证这些被请求的 I&#x2F;O 操作在调用结束的时候已经完成。取而代之地，你会得到一个返回的 ChannelFuture 实例，这个实例将给你一些关于 I&#x2F;O 操作结果或者状态的信息。下面是官方关于 ChannelFuture 的状态迁移图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                                     +---------------------------+</span><br><span class=\"line\">                                     | Completed successfully    |</span><br><span class=\"line\">                                     +---------------------------+</span><br><span class=\"line\">                                +----&gt;      isDone() = true      |</span><br><span class=\"line\">+--------------------------+    |    |   isSuccess() = true      |</span><br><span class=\"line\">|        Uncompleted       |    |    +===========================+</span><br><span class=\"line\">+--------------------------+    |    | Completed with failure    |</span><br><span class=\"line\">|      isDone() = false    |    |    +---------------------------+</span><br><span class=\"line\">|   isSuccess() = false    |----+----&gt;      isDone() = true      |</span><br><span class=\"line\">| isCancelled() = false    |    |    |       cause() = non-null  |</span><br><span class=\"line\">|       cause() = null     |    |    +===========================+</span><br><span class=\"line\">+--------------------------+    |    | Completed by cancellation |</span><br><span class=\"line\">                                |    +---------------------------+</span><br><span class=\"line\">                                +----&gt;      isDone() = true      |</span><br><span class=\"line\">                                     | isCancelled() = true      |</span><br><span class=\"line\">                                     +---------------------------+</span><br></pre></td></tr></table></figure>\n\n<p>ChannelFuture 有 <code>Completed</code> 和 <code>Uncompleted</code> 两种父状态，父状态下分为 <code>isDone</code>、<code>isSuccess</code>、<code>isCancelled</code> 和 <code>cause</code> 四种子状态</p>\n<ul>\n<li>ChannelFuture 新创建的时候是 <code>Uncompleted</code> 状态，这个时候子状态 为<code>isDone</code>、<code>isSuccess</code> 和 <code>isCancelled</code>  都是 false，<code>cause</code> 是一个 null 值。</li>\n<li>当 ChannelFuture 变成 <code>completed</code> 状态并且结果成功，<code>isDone</code> 和 <code>isSuccess</code>  变成 true。</li>\n<li>当 ChannelFuture 变成 <code>completed</code> 状态并且结果失败，<code>isDone</code> 变成 true，<code>cause</code> 为非 null 值。</li>\n<li>当 ChannelFuture 变成 <code>completed</code> 状态并且结果取消，<code>isDone</code> 和 <code>isCancelled</code>  变成 true。</li>\n</ul>\n<p>我们创建 ChannelFuture 一般会使用 <code>addListener(GenericFutureListener)</code> 为 ChannelFuture 添加监听器，监听 ChannelFuture 的结果状态变化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ChannelFuture future = bootstrap.connect(serverIp, serverPort).sync();</span><br><span class=\"line\">future.addListener(new ChannelFutureListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class=\"line\">        log.info(&quot;连接服务器成功&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>ChannelPromise 是 ChannelFuture 的子类，ChannelFuture 是只读的，而 ChannelPromise 是可写的，提供了 <code>setSuccess</code> 和 <code>setFailure</code> 等方法对结果进行修改。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>Channel 是 Netty 的通讯载体，是对 NIO 原生 Channel 的二次封装，提供更完善的功能。</li>\n<li>Channel 有很多类型，比较常用的有 NioSocketChannel 和 NioServerSocketChannel。</li>\n<li>一个 Channel 在创建之后整个生命周期都绑定到一个特定的 EventLoop。</li>\n<li>一个 Channel 对应一个 ChannelPipeLine。</li>\n<li>一个 ChannelPipeLine 通过 filter 的模式把一到多个 ChannelHandler 组织到一起，ChannelHandler 之间不会产生直接关联。</li>\n<li>每个 ChannelHandler 对应一个 ChannelHandlerContext，通过 ChannelHandlerContext 使前后的 ChannelHandler 产生关联。</li>\n<li>ChannelFuture 的作用是用来保存 Channel 异步操作的结果，ChannelPromise 提供了可写的方法。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"\">《Netty in Action》</a></p>\n<p><a href=\"https://jianyuan.fun/post/netty-channel-lifecycle/\">Netty Channel的生命周期</a></p>\n<p><a href=\"https://www.cnblogs.com/lighten/p/8950347.html\">Netty核心概念(5)之Channel</a></p>\n<p><a href=\"https://www.cnblogs.com/duanxz/p/3724247.html\">netty中的Channel、ChannelPipeline</a></p>\n","categories":["Netty"],"tags":["Netty"]},{"title":"Netty系列（五）：EventLoop和EventLoopGroup","url":"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/","content":"<blockquote>\n<p>上一篇文章介绍了 Netty 的启动器 Bootstrap，这篇开始介绍 Netty 的线程机制 EventLoop 和 EventLoopGroup，包括 EventLoop 和 EventLoopGroup 的简介、类继承结构和实例化过程。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"EventLoop-和-EventLoopGroup-是什么\"><a href=\"#EventLoop-和-EventLoopGroup-是什么\" class=\"headerlink\" title=\"EventLoop 和 EventLoopGroup 是什么\"></a>EventLoop 和 EventLoopGroup 是什么</h1><p>Netty 的非阻塞线程模型的实现基于 NIO Reactor 模型，其中 EventLoop 和 EventLoopGroup 是该线程模型的核心组件。当然 Netty 也提供了阻塞线程模型的实现，在这里对阻塞模型不做介绍。</p>\n<p>一个 EventLoop 只包含一个死循环的线程，用于处理绑定到该 EventLoop 的所有 Channel 的 IO 操作和业务操作。一个 EventLoop 包含一到多个 Channel。</p>\n<p>一个 EventLoopGroup 包含一到多个 EventLoop，EventLoopGroup 负责将 EventLoop 分配给每个新创建的 Channel。</p>\n<p>EventLoop、EventLoopGroup 和 Channel 的整体关系图如下：</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/relation.png\" alt=\"relation\"></p>\n<h1 id=\"EventLoop\"><a href=\"#EventLoop\" class=\"headerlink\" title=\"EventLoop\"></a>EventLoop</h1><p>EventLoop 是用来执行任务的单线程，任务包括周期性的 IO 任务（accept、read、write等）和用户自定义任务（decode、compute、encode）等。为了清晰了解 EventLoop 的内部结构，下面我们从 EventLoop 接口的继承结构开始介绍。</p>\n<h2 id=\"EventLoop-继承结构\"><a href=\"#EventLoop-继承结构\" class=\"headerlink\" title=\"EventLoop 继承结构\"></a>EventLoop 继承结构</h2><p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/Eventloop.png\" alt=\"Eventloop\"></p>\n<p>在这个类图里面，EventExecutorGroup 上层是  JDK 提供的并发包接口，下层是 Netty 提供的抽象类和实现。EventLoop 的继承结构这么复杂，有一部分原因是为了使用父接口或父类里面的部分特性或者方法而已，和父接口或父类的用途定位并没有太多的关联。下面我们按接口用途分组介绍：</p>\n<ul>\n<li>Executor、ExecutorService、ScheduledExecutorService</li>\n<li>Iterable</li>\n<li>EventExecutorGroup</li>\n<li>EventExecutor、OrderedEventExecutor</li>\n<li>EventLoopGroup、EventLoop</li>\n</ul>\n<h3 id=\"Executor、ExecutorService、ScheduledExecutorService\"><a href=\"#Executor、ExecutorService、ScheduledExecutorService\" class=\"headerlink\" title=\"Executor、ExecutorService、ScheduledExecutorService\"></a>Executor、ExecutorService、ScheduledExecutorService</h3><p>这三个都是 java.util.concurrent 里面提供的接口，是 Java5 之后引进的，基本定义了 Java 的线程池机制，用来控制线程的启动、执行和关闭。</p>\n<p>Executor 是最基础的父接口，只定义了一个方法 <code>execute(Runnable command)</code>，用来执行一个 Runable 实例。</p>\n<p>ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法。例如 <code>submit(Runnable task)</code> 用于提交任务并返回异步执行结果 Future，<code>shutdown()</code> 用于平滑地关闭线程池（先拒绝接收新的任务，然后等待已接收的任务全部执行完毕，再关闭线程池）。</p>\n<p>ScheduledExecutorService 接口继承自 ExecutorService 接口，是一种用于延时和定期执行任务的特殊线程池。EventLoop 继承这个接口是为了继承这里面的延时或周期执行的方法，在 Netty 中，有可能用户线程和 I&#x2F;O 线程同时操作网络资源，而为了减少并发锁竞争，Netty 将用户线程的任务包装成 task，然后像 Netty 的 I&#x2F;O 任务一样延期执行，另外有些时候需要周期性执行任务例如心跳检测。</p>\n<h3 id=\"Iterable\"><a href=\"#Iterable\" class=\"headerlink\" title=\"Iterable\"></a>Iterable</h3><p>上面我们谈到 EventLoopGroup 包含一到多个 EventLoop，实现 Iterable 接口可以对所有 EventLoop 进行遍历。</p>\n<h3 id=\"EventExecutorGroup\"><a href=\"#EventExecutorGroup\" class=\"headerlink\" title=\"EventExecutorGroup\"></a>EventExecutorGroup</h3><p>EventExecutorGroup 是 Netty 自定义线程模型的基础接口，下面是接口方法定义</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/EventExecutorGroup.png\" alt=\"EventExecutorGroup\"></p>\n<p>我们可以看到 EventExecutorGroup 是对继承的接口的大部分方法进行 Override，并自定义了部分方法。EventExecutorGroup 提供的功能有：</p>\n<ul>\n<li>提供线程池的基础功能，例如 <code>submit</code> 提交任务功能，并废弃了原始的关闭线程池接口 <code>shutdown()</code>，自定义了关闭线程池接口 <code>shutdownGracefully()</code>。</li>\n<li>提供延时和周期执行的功能。</li>\n<li>提供迭代功能。</li>\n</ul>\n<h3 id=\"EventExecutor、OrderedEventExecutor\"><a href=\"#EventExecutor、OrderedEventExecutor\" class=\"headerlink\" title=\"EventExecutor、OrderedEventExecutor\"></a>EventExecutor、OrderedEventExecutor</h3><p>EventExecutor 相当于 EventExecutorGroup 的扩展，提供了 <code>next()</code>、<code>parent()</code> 等判断集合关系的方法。</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/EventExecutor.png\" alt=\"EventExecutor\"></p>\n<p>OrderedEventExecutor 是一个空接口，作用是为了说明继承这个接口就可以使用顺序执行任务等功能。</p>\n<h3 id=\"EventLoopGroup、EventLoop\"><a href=\"#EventLoopGroup、EventLoop\" class=\"headerlink\" title=\"EventLoopGroup、EventLoop\"></a>EventLoopGroup、EventLoop</h3><p>EventLoopGroup 提供了把 Channel 注册到具体 EventLoop 的方法。</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/EventLoopGroup.png\" alt=\"EventLoopGroup\"></p>\n<p>EventLoop 只提供一个 <code>parent()</code> 方法，用于判断 EventLoop 所属的 EventLoopGroup。</p>\n<p>NioEventLoop 是 EventLoop 接口最常用的实现类。下面我们简单分析下 NioEventLoop 类。</p>\n<h2 id=\"NioEventLoop-继承结构\"><a href=\"#NioEventLoop-继承结构\" class=\"headerlink\" title=\"NioEventLoop 继承结构\"></a>NioEventLoop 继承结构</h2><p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/NioEventLoop.png\" alt=\"NioEventLoop\"></p>\n<p>我们可以看到 NioEventLoop 的继承结构更复杂，右侧是上面介绍 EventLoop 的接口的继承结构，左侧是抽象类的继承关系。下面我们简单介绍几个抽象类：</p>\n<ul>\n<li>AbstractExecutorService</li>\n<li>AbstractEventExecutor</li>\n<li>SingleThreadEventExecutor</li>\n<li>SingleThreadEventLoop</li>\n</ul>\n<h3 id=\"AbstractExecutorService\"><a href=\"#AbstractExecutorService\" class=\"headerlink\" title=\"AbstractExecutorService\"></a>AbstractExecutorService</h3><p>AbstractExecutorService 也是 java.util.concurrent 包里面的抽象类，实现了 ExecutorService 接口的部分方法。</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/AbstractExecutorService.png\" alt=\"AbstractExecutorService\"></p>\n<p>AbstractExecutorService 主要实现了执行任务的相关方法，例如 <code>submit</code>、<code>invokeAny</code> 等，把返回结果封装为 FutureTask 实例。</p>\n<h3 id=\"AbstractEventExecutor\"><a href=\"#AbstractEventExecutor\" class=\"headerlink\" title=\"AbstractEventExecutor\"></a>AbstractEventExecutor</h3><p>AbstractEventExecutor 以下是 Netty 定义的类，继承了 AbstractExecutorService 类，增加了 group 的概念。</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/AbstractEventExecutor.png\" alt=\"AbstractEventExecutor\"></p>\n<h3 id=\"AbstractScheduledEventExecutor\"><a href=\"#AbstractScheduledEventExecutor\" class=\"headerlink\" title=\"AbstractScheduledEventExecutor\"></a>AbstractScheduledEventExecutor</h3><p>AbstractScheduledEventExecutor 继承了 AbstractEventExecutor，增加了可以延时或周期执行的任务队列 scheduledTaskQueue，并实现了 <code>schedule</code> 延时执行以及 <code>scheduleAtFixedRate</code> 周期执行等方法。</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/AbstractScheduledEventExecutor.png\" alt=\"AbstractScheduledEventExecutor\"></p>\n<h3 id=\"SingleThreadEventExecutor\"><a href=\"#SingleThreadEventExecutor\" class=\"headerlink\" title=\"SingleThreadEventExecutor\"></a>SingleThreadEventExecutor</h3><p>SingleThreadEventExecutor 继承了 AbstractScheduledEventExecutor，实现了 EventLoop 的大部分功能，基本上算是最终 EventLoop 的一个雏型了。这个类的功能非常丰富，我们看下最关键的几个属性和方法。</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/SingleThreadEventExecutor.png\" alt=\"SingleThreadEventExecutor\"></p>\n<p><strong>关键属性</strong></p>\n<ul>\n<li>thread：每个 EventLoop 和一个死循环的线程进行绑定，这个线程就是在这里定义的。</li>\n<li>taskQueue：除了 IO 操作之外的其他任务，都放在这个队列里面依次执行。</li>\n<li>executor：在这里可以把这个理解为只有一个线程的线程池，可通过 executor 执行任务或获取执行线程的状态等。</li>\n</ul>\n<p>这个类里面实现 EventLoop 在生命周期中的大部分工作：启动、添加任务、执行任务和关闭等。</p>\n<p><strong>启动</strong></p>\n<pre><code>private void doStartThread() &#123;\n    assert thread == null;\n    executor.execute(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            // 新建一个线程，并把线程和当前实例的thread对象绑定，这个thread就是NioEventLoop绑定的线程\n            thread = Thread.currentThread();\n            if (interrupted) &#123;\n                thread.interrupt();\n            &#125;\n\n            boolean success = false;\n            updateLastExecutionTime();\n            try &#123;\n                // 启动NioEventLoop的run方法\n                SingleThreadEventExecutor.this.run();\n                success = true;\n            &#125; catch (Throwable t) &#123;\n                logger.warn(&quot;Unexpected exception from an event executor: &quot;, t);\n            &#125; finally &#123;\n                // 循环判断线程状态，如果是关闭中状态就进行下一步操作\n                for (;;) &#123;\n                    int oldState = state;\n                    if (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(\n                            SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) &#123;\n                        break;\n                    &#125;\n                &#125;\n\n                ......\n            &#125;\n        &#125;\n    &#125;);\n&#125;\n</code></pre>\n<p>启动代码里面新建一个线程，并把线程和当前实例的 thread 对象绑定，这个 thread 就是 NioEventLoop 实例绑定的线程，然后再启动 NioEventLoop 实例。</p>\n<p><strong>添加任务</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">protected void addTask(Runnable task) &#123;</span><br><span class=\"line\">    if (task == null) &#123;</span><br><span class=\"line\">        throw new NullPointerException(&quot;task&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!offerTask(task)) &#123;</span><br><span class=\"line\">        reject(task);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">final boolean offerTask(Runnable task) &#123;</span><br><span class=\"line\">    if (isShutdown()) &#123;</span><br><span class=\"line\">        reject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return taskQueue.offer(task);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>添加任务过程很简单，就是把新的 task 添加到 taskQueue。</p>\n<p><strong>执行任务</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">protected final boolean runAllTasksFrom(Queue&lt;Runnable&gt; taskQueue) &#123;</span><br><span class=\"line\">    Runnable task = pollTaskFrom(taskQueue);</span><br><span class=\"line\">    if (task == null) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        //安全执行任务</span><br><span class=\"line\">        safeExecute(task);</span><br><span class=\"line\">        //继续执行剩余任务</span><br><span class=\"line\">        task = pollTaskFrom(taskQueue);</span><br><span class=\"line\">        if (task == null) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">protected final Runnable pollTaskFrom(Queue&lt;Runnable&gt; taskQueue) &#123;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        Runnable task = taskQueue.poll();</span><br><span class=\"line\">        //忽略WAKEUP_TASK类型任务</span><br><span class=\"line\">        if (task == WAKEUP_TASK) &#123;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return task;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">protected boolean runAllTasks(long timeoutNanos) &#123;</span><br><span class=\"line\">    //先执行周期任务</span><br><span class=\"line\">    fetchFromScheduledTaskQueue();</span><br><span class=\"line\">    //从taskQueue提一个任务，如果为空执行所有tailTasks</span><br><span class=\"line\">    Runnable task = pollTask();</span><br><span class=\"line\">    //如果taskQueue没有任务，立即执行子类的tailTasks</span><br><span class=\"line\">    if (task == null) &#123;</span><br><span class=\"line\">         afterRunningAllTasks();</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //计算出超时时间 = 当前 nanoTime + timeoutNanos</span><br><span class=\"line\">    final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</span><br><span class=\"line\">    long runTasks = 0;</span><br><span class=\"line\">    long lastExecutionTime;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        safeExecute(task);</span><br><span class=\"line\"></span><br><span class=\"line\">        runTasks ++;</span><br><span class=\"line\">        //当执行任务次数大于64判断是否超时，防止长时间独占CPU</span><br><span class=\"line\">        if ((runTasks &amp; 0x3F) == 0) &#123;</span><br><span class=\"line\">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class=\"line\">            if (lastExecutionTime &gt;= deadline) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        task = pollTask();</span><br><span class=\"line\">        if (task == null) &#123;</span><br><span class=\"line\">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    afterRunningAllTasks();</span><br><span class=\"line\">    this.lastExecutionTime = lastExecutionTime;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里包含安全执行执行单个任务、取出任务和执行所有任务。所有任务包括 taskQueue 和 下面提到到的 tailTasks。</p>\n<h3 id=\"SingleThreadEventLoop\"><a href=\"#SingleThreadEventLoop\" class=\"headerlink\" title=\"SingleThreadEventLoop\"></a>SingleThreadEventLoop</h3><p>SingleThreadEventLoop 继承了 SingleThreadEventExecutor 类，主要增加了 tailTasks 属性。</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/SingleThreadEventLoop.png\" alt=\"SingleThreadEventLoop\"></p>\n<p>tailTasks 中是用户自定义的一些列在本次事件循环遍历结束后会执行的任务，我们可以通过类似如下的方式来添加 tailTask。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">((NioEventLoop)ctx.channel().eventLoop()).executeAfterEventLoopIteration(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// add some task to execute after eventLoop iteration</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NioEventLoop\"><a href=\"#NioEventLoop\" class=\"headerlink\" title=\"NioEventLoop\"></a>NioEventLoop</h3><p>NioEventLoop 是最终实现类，这里定义了较多的方法和属性，其中最重要的有三个属性：</p>\n<ul>\n<li>SELECTOR_AUTO_REBUILD_THRESHOLD：用于解决 NIO 空轮询导致 cpu 飙升到 100% 的 bug。</li>\n<li>selector：选择器。</li>\n<li>selectorProvider：选择器的生产类。</li>\n<li>ioRatio：在事件循环中期待用于处理 I&#x2F;O 操作时间的百分比。</li>\n</ul>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/NioEventLoop1.png\" alt=\"NioEventLoop1\"></p>\n<p><strong>selector</strong></p>\n<p>netty 的 selector 对 NIO 的 selector 进行进一步封装，解决了空轮询导致 cpu 100% 的问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">private void select(boolean oldWakenUp) throws IOException &#123;</span><br><span class=\"line\">    Selector selector = this.selector;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // select操作计数</span><br><span class=\"line\">        int selectCnt = 0;</span><br><span class=\"line\">        // 记录当前系统时间</span><br><span class=\"line\">        long currentTimeNanos = System.nanoTime();</span><br><span class=\"line\">        // delayNanos方法用于计算定时任务队列，最近一个任务的截止时间</span><br><span class=\"line\">        // selectDeadLineNanos 表示当前select操作所不能超过的最大截止时间</span><br><span class=\"line\">        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (;;) &#123;</span><br><span class=\"line\">            // 计算超时时间，判断是否超时</span><br><span class=\"line\">            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;</span><br><span class=\"line\">            // 如果 timeoutMillis &lt;= 0， 表示超时，进行一个非阻塞的 select 操作。设置 selectCnt 为 1. 并终止本次循环。</span><br><span class=\"line\">            if (timeoutMillis &lt;= 0) &#123;</span><br><span class=\"line\">                if (selectCnt == 0) &#123;</span><br><span class=\"line\">                    selector.selectNow();</span><br><span class=\"line\">                    selectCnt = 1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            // 如果当前任务队列为空，并且超时时间未到，则进行一个阻塞式的selector操作。timeoutMillis 为最大的select时间</span><br><span class=\"line\">            int selectedKeys = selector.select(timeoutMillis);</span><br><span class=\"line\">            // 操作计数 +1</span><br><span class=\"line\">            selectCnt ++;</span><br><span class=\"line\">            </span><br><span class=\"line\">            // 记录当前时间</span><br><span class=\"line\">            long time = System.nanoTime();</span><br><span class=\"line\">            // 如果time &gt; currentTimeNanos + timeoutMillis(超时时间)，则表明已经执行过一次select操作</span><br><span class=\"line\">            if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class=\"line\">                // timeoutMillis elapsed without anything selected.</span><br><span class=\"line\">                selectCnt = 1;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            // 如果 time &lt;= currentTimeNanos + timeoutMillis，表示触发了空轮训</span><br><span class=\"line\">            // 如果空轮训的次数超过 SELECTOR_AUTO_REBUILD_THRESHOLD (512)，则重建一个新的selctor，避免空轮训</span><br><span class=\"line\">            else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;</span><br><span class=\"line\">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class=\"line\">                logger.warn(</span><br><span class=\"line\">                        &quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;,</span><br><span class=\"line\">                        selectCnt, selector);</span><br><span class=\"line\">    </span><br><span class=\"line\">                // 重建创建一个新的selector</span><br><span class=\"line\">                rebuildSelector();</span><br><span class=\"line\">                selector = this.selector;</span><br><span class=\"line\">    </span><br><span class=\"line\">                // Select again to populate selectedKeys.</span><br><span class=\"line\">                // 对重建后的selector进行一次非阻塞调用，用于获取最新的selectedKeys</span><br><span class=\"line\">                selector.selectNow();</span><br><span class=\"line\">                // 设置select计数</span><br><span class=\"line\">                selectCnt = 1;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            currentTimeNanos = time;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125; catch (CancelledKeyException e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>selectorProvider</strong></p>\n<p>我们调用 <code>Selector selector = Selector.open()</code> 创建 selector 的时候，内部会调用到 SelectorProvider。而在创建 SelectorProvider 对象本身的时候，不同系统会调用各自版本的 JDK 里自带的 sun.nio.ch.DefaultSelectorProvider。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 实际上调用SelectorProvider来创建Selector</span><br><span class=\"line\">public static Selector open() throws IOException &#123;</span><br><span class=\"line\">    return SelectorProvider.provider().openSelector();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// windows版本下SelectorProvider的创建</span><br><span class=\"line\">public class DefaultSelectorProvider &#123;</span><br><span class=\"line\">    public static SelectorProvider create() &#123;</span><br><span class=\"line\">        return new WindowsSelectorProvider();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// mac版本下SelectorProvider的创建</span><br><span class=\"line\">public class DefaultSelectorProvider &#123;</span><br><span class=\"line\">    public static SelectorProvider create() &#123;</span><br><span class=\"line\">        return new KQueueSelectorProvider();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// linux版本下SelectorProvider的创建</span><br><span class=\"line\">public class DefaultSelectorProvider &#123;</span><br><span class=\"line\">    public static SelectorProvider create() &#123;</span><br><span class=\"line\">        String str1 = (String) AccessController.doPrivileged(new GetPropertyAction(</span><br><span class=\"line\">                    &quot;os.name&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">        if (&quot;SunOS&quot;.equals(str1)) &#123;</span><br><span class=\"line\">            return new DevPollSelectorProvider();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (&quot;Linux&quot;.equals(str1)) &#123;</span><br><span class=\"line\">            String str2 = (String) AccessController.doPrivileged(new GetPropertyAction(</span><br><span class=\"line\">                        &quot;os.version&quot;));</span><br><span class=\"line\">            String[] arrayOfString = str2.split(&quot;\\\\.&quot;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">            if (arrayOfString.length &gt;= 2) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    int i = Integer.parseInt(arrayOfString[0]);</span><br><span class=\"line\">                    int j = Integer.parseInt(arrayOfString[1]);</span><br><span class=\"line\"></span><br><span class=\"line\">                    if ((i &gt; 2) || ((i == 2) &amp;&amp; (j &gt;= 6))) &#123;</span><br><span class=\"line\">                        return new EPollSelectorProvider();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; catch (NumberFormatException localNumberFormatException) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return new PollSelectorProvider();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ioRatio</strong></p>\n<p>当 ioRatio 变量为100的时候（默认50），处理 select 事件，处理完之后执行任务队列中的所有任务。 反之当不是 100 的时候，处理 select 事件，之后给定一个时间内执行任务队列中的任务。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">final int ioRatio = this.ioRatio;</span><br><span class=\"line\">if (ioRatio == 100) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        processSelectedKeys();</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        // Ensure we always run tasks.</span><br><span class=\"line\">        runAllTasks();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    final long ioStartTime = System.nanoTime();</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        processSelectedKeys();</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        // Ensure we always run tasks.</span><br><span class=\"line\">        final long ioTime = System.nanoTime() - ioStartTime;</span><br><span class=\"line\">        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"EventLoop-总结\"><a href=\"#EventLoop-总结\" class=\"headerlink\" title=\"EventLoop 总结\"></a>EventLoop 总结</h2><ul>\n<li>EventLoop 可以理解为只有一个死循环线程的线程池。</li>\n<li>EventLoop 归属某个 EventLoopGroup，可以获取在同一个 EventLoopGroup 下的其他 EventLoop 实例。</li>\n<li>EventLoop 可以执行线程池的各种功能，例如启动、提交任务、执行任务和关闭等</li>\n<li>EventLoop 可以执行普通任务、延时任务或者周期性任务等，任务全部放到任务队列里面，按照 FIFO 规则执行，任务队列分类有：<ol>\n<li>scheduledTaskQueue，周期任务队列，例如 IO 操作等。scheduledTaskQueue 中的任务都会取出来先放入 taskQueue，再从 taskQueue 取出来执行。</li>\n<li>taskQueue，用户任务队列</li>\n<li>tailTasks，也是用户任务队列，但优先级比 taskQueue 低，用于存储当前或下一次事件循环(eventloop)迭代结束后需要执行的任务。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"EventLoopGroup\"><a href=\"#EventLoopGroup\" class=\"headerlink\" title=\"EventLoopGroup\"></a>EventLoopGroup</h1><p>EventLoopGroup 是用来管理 EventLoop 的，负责把 Channel 绑定到 EventLoop 上，并返回其管理的 EventLoop 的各种状态。</p>\n<p>EventLoopGroup 接口的继承结构已经包含在 EventLoop 的继承结构里面，下面我们介绍 EventLoopGroup 接口最常用的实现类 NioEventLoopGroup 的继承结构。</p>\n<h2 id=\"NioEventLoopGroup-继承结构\"><a href=\"#NioEventLoopGroup-继承结构\" class=\"headerlink\" title=\"NioEventLoopGroup 继承结构\"></a>NioEventLoopGroup 继承结构</h2><p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/NioEventLoopGroup.png\" alt=\"NioEventLoopGroup\"></p>\n<p>EventLoopGroup 接口及以上的继承结构在上面已经介绍过，下面我们简单介绍下几个抽象类：</p>\n<ul>\n<li>AbstractEventExecutorGroup</li>\n<li>MultithreadEventExecutorGroup</li>\n<li>MultithreadEventLoopGroup</li>\n</ul>\n<h3 id=\"AbstractEventExecutorGroup\"><a href=\"#AbstractEventExecutorGroup\" class=\"headerlink\" title=\"AbstractEventExecutorGroup\"></a>AbstractEventExecutorGroup</h3><p>AbstractEventExecutorGroup 对应 AbstractEventExecutor 的集合，我们看下具体的类方法</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/AbstractEventExecutorGroup.png\" alt=\"AbstractEventExecutorGroup\"></p>\n<p>可以看到和 AbstractEventExecutor 类里面实现的方法基本一致，实际上最终也是调用到 AbstractEventExecutor 类里面的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class=\"line\">\t\t// next()返回下一个EventExecutor实例，最终会调到AbstractEventExecutor类的submit方法</span><br><span class=\"line\">    return next().submit(task);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MultithreadEventExecutorGroup\"><a href=\"#MultithreadEventExecutorGroup\" class=\"headerlink\" title=\"MultithreadEventExecutorGroup\"></a>MultithreadEventExecutorGroup</h3><p>MultithreadEventExecutorGroup 继承了 AbstractEventExecutorGroup，增加了 children 队列存储 EventExecutor 实例，以及选择器 chooser 负责从 children 里面选择 EventExecutor 实例来执行任务。</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/MultithreadEventExecutorGroup.png\" alt=\"MultithreadEventExecutorGroup\"></p>\n<p>MultithreadEventExecutorGroup 的构造方法会初始化包含 n 个 Executor 元素的 children 数组。</p>\n<pre><code>protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args) &#123;\n\n    children = new EventExecutor[nThreads];\n\n    for (int i = 0; i &lt; nThreads; i ++) &#123;\n        boolean success = false;\n        try &#123;\n            children[i] = newChild(executor, args);\n            success = true;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>MultithreadEventExecutorGroup 也包含关闭线程池的方法，看源码我们可以看到实际上是遍历 children 数组，逐个调用 Executor 元素的 <code>shutdownGracefully</code> 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public Future&lt;?&gt; shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) &#123;</span><br><span class=\"line\">    for (EventExecutor l: children) &#123;</span><br><span class=\"line\">        l.shutdownGracefully(quietPeriod, timeout, unit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return terminationFuture();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MultithreadEventLoopGroup\"><a href=\"#MultithreadEventLoopGroup\" class=\"headerlink\" title=\"MultithreadEventLoopGroup\"></a>MultithreadEventLoopGroup</h3><p>MultithreadEventLoopGroup 继承了 MultithreadEventExecutorGroup 类，增加了 DEFAULT_EVENT_LOOP_THREADS 属性，这个属性定义了 children 数组的初始化大小。</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/MultithreadEventLoopGroup.png\" alt=\"MultithreadEventLoopGroup\"></p>\n<p>MultithreadEventLoopGroup 包含一个 static 块，定义 DEFAULT_EVENT_LOOP_THREADS 的值为 CPU 逻辑核数的两倍。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">static &#123;</span><br><span class=\"line\">    DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(</span><br><span class=\"line\">            &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));</span><br><span class=\"line\"></span><br><span class=\"line\">    if (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">        logger.debug(&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;, DEFAULT_EVENT_LOOP_THREADS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在构造方法里面传入 DEFAULT_EVENT_LOOP_THREADS 参数，然后会调用父类 MultithreadEventExecutorGroup 的构造方法，设置 children 数组的长度为 DEFAULT_EVENT_LOOP_THREADS 的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) &#123;</span><br><span class=\"line\">    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外 MultithreadEventLoopGroup 也会负责完成把 Channel 注册到某一个 EventLoop 上。所以假如一共有 n 个 EventLoop，请求过来的第一个 Channel 被注册到第一个 EventLoop 上，第二个 Channel 被注册到下一个也就是第二个 EventLoop 上…..第 n + 1 个 Channel 又注册到第一个 EventLoop 上，如此循环。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public ChannelFuture register(Channel channel) &#123;</span><br><span class=\"line\">\t\t// 这里的next()最终会调用到chooser.next()，由chooser来选择下一个EventLoop</span><br><span class=\"line\">    return next().register(channel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"EventLoopGroup-总结\"><a href=\"#EventLoopGroup-总结\" class=\"headerlink\" title=\"EventLoopGroup 总结\"></a>EventLoopGroup 总结</h2><ul>\n<li>一个 EventLoopGroup 包含多个 EventLoop，使用 children 数组存放 EventLoop 对象，children 的长度初始化为 cpu 逻辑核数 * 2。</li>\n<li>调用 EventLoopGroup 的某个方法时，EventLoopGroup 会通过 chooser 选择策略获取到某个具体的 EventLoop，然后调用该 EventLoop 里面的具体方法，例如注册 Channel。</li>\n</ul>\n<h1 id=\"EventLoopGroup-和-EventLoop-实例化过程\"><a href=\"#EventLoopGroup-和-EventLoop-实例化过程\" class=\"headerlink\" title=\"EventLoopGroup 和 EventLoop 实例化过程\"></a>EventLoopGroup 和 EventLoop 实例化过程</h1><p>下面我们结合 EventLoop 和 EventLoopGroup 的继承结构涉及的接口和类，通过时序图的方式介绍 EventLoop 和 EventLoopGroup 的实例化和启动过程。</p>\n<h2 id=\"NioEventLoopGroup-实例化过程\"><a href=\"#NioEventLoopGroup-实例化过程\" class=\"headerlink\" title=\"NioEventLoopGroup 实例化过程\"></a>NioEventLoopGroup 实例化过程</h2><p>EventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children 数组, 其大小是 nThreads, 这样就构成了一个线程池。如果我们在实例化 NioEventLoopGroup 时, 如果指定线程池大小, 则 nThreads 就是指定的值, 反之是处理器核心数 * 2。MultithreadEventExecutorGroup 中会调用 newChild 抽象方法来初始化 children 数组，抽象方法 newChild 是在 NioEventLoopGroup 中实现的, 它返回一个 NioEventLoop 实例。</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/NioEventLoopGroupInstance.png\" alt=\"NioEventLoopGroupInstance\"></p>\n<h2 id=\"NioEventLoop-实例化过程\"><a href=\"#NioEventLoop-实例化过程\" class=\"headerlink\" title=\"NioEventLoop 实例化过程\"></a>NioEventLoop 实例化过程</h2><p>NioEventLoop 的实例化过程比较简单，主要是向上调用构造函数初始化 parent 等属性。</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/NioEventLoopInstance.png\" alt=\"NioEventLoopInstance\"></p>\n<h2 id=\"NioEventLoop-和-Channel-绑定过程\"><a href=\"#NioEventLoop-和-Channel-绑定过程\" class=\"headerlink\" title=\"NioEventLoop 和 Channel 绑定过程\"></a>NioEventLoop 和 Channel 绑定过程</h2><p>channel 关联 Eventloop 有三种情况</p>\n<ul>\n<li><p>客户端SocketChannel关联EventLoop。</p>\n</li>\n<li><p>服务端ServerSocketChannel关联EventLoop。</p>\n</li>\n<li><p>由服务端ServerSocketChannel创建的SocketChannel关联EventLoop。</p>\n</li>\n</ul>\n<p>Netty 厉害的就是把这三种情况都都能复用 Multithread EventLoopGroup 中的 register 方法</p>\n<p><img src=\"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/NioEventLoopChannel.png\" alt=\"NioEventLoopChannel\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文介绍了 EventLoop 和 EventLoopGroup 的继承结构，最后结合继承结构涉及的类介绍了 EventLoop 和 EventLoopGroup 的实例化过程。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"\">netty源码</a></p>\n<p><a href=\"https://www.jianshu.com/p/f94f7005c2cd\">netty系列之（三）——EventLoop和EventLoopGroup</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000007403873\">Netty 源码分析之 三 我就是大名鼎鼎的 EventLoop(一)</a></p>\n<p><a href=\"https://juejin.im/entry/5c0908ee6fb9a049d131efa7\">Netty进阶：Netty核心NioEventLoop原理解析</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000016875286\"><a href=\"https://segmentfault.com/a/1190000016875286\">Netty NioEventLoop 启动过程源码分析</a></a></p>\n<p><a href=\"https://www.jianshu.com/p/84412c2c34f1\">netty补充NIO的SelectableChannel和SelectorProvider</a></p>\n","categories":["Netty"],"tags":["Netty"]},{"title":"Hexo升级版本","url":"/2021/02/25/Hexo%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/","content":"<blockquote>\n<p>本文介绍了 Hexo 博客框架以及所使用主题 Next 的升级过程。经过一番折腾，最终把 Hexo 从 3.7.1 升级到 6.3.0，把 Next 主题从 4.3.0 升级到 7.8.0。升级后发现性能提升较为明显，特地记录下升级过程，方便下一次版本升级。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"升级-Hexo\"><a href=\"#升级-Hexo\" class=\"headerlink\" title=\"升级 Hexo\"></a>升级 Hexo</h1><ol>\n<li>先全局升级 <code>hexo-cli</code>：<code>hexo</code>本身是一个静态博客生成工具，具备编译Markdown、拼接主题模板、生成 HTML、上传 Git 等基本功能。<code>hexo-cli</code>能够将这些功能封装为命令，提供给用户通过<code>hexo server / hexo deploy</code>等命令调用的模块。<code>CLI = Command Line Interface</code>命令行界面。</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm install hexo-cli -g</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>npm-check</code> 检查系统中的插件是否有升级的，可以看到自己前面都安装了那些插件。</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm install -g npm-check</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm-check</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><code>npm-upgrade</code> 升级系统中的插件</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm install -g npm-upgrade</span></span><br><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm-upgrade</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>更新全局包。<code>-g</code> 参数表示安装到全局 <code>node_modules</code> 目录中，如果不带 <code>-g</code> 参数就表示把包安装到 npm 命令执行所在目录的<code>node_modules</code>目录中。</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm update -g</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>进入 Hexo 安装目录，更新依赖包。<code>—save</code> 参数表示在更新 <code>node_modules</code>目录的同时并且添加到 <code>dependencies</code> 文件中。</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm update --save</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>升级完查看 Hexo 版本</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">hexo vesion</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>然后再查看 <code>dependencies</code> 文件，发现 hexo 版本已经更新到 6.3.0。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class=\"line\">  &quot;private&quot;: true,</span><br><span class=\"line\">  &quot;hexo&quot;: &#123;</span><br><span class=\"line\">    &quot;version&quot;: &quot;6.3.0&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;gitalk&quot;: &quot;^1.8.0&quot;,</span><br><span class=\"line\">    &quot;hexo&quot;: &quot;^6.3.0&quot;,</span><br><span class=\"line\">    &quot;hexo-admin&quot;: &quot;^2.3.0&quot;,</span><br><span class=\"line\">    &quot;hexo-deployer-git&quot;: &quot;^3.0.0&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-archive&quot;: &quot;^2.0.0&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-baidu-sitemap&quot;: &quot;^0.1.9&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-category&quot;: &quot;^2.0.0&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-index&quot;: &quot;^3.0.0&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-searchdb&quot;: &quot;^1.4.1&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-sitemap&quot;: &quot;^3.0.1&quot;,</span><br><span class=\"line\">    &quot;hexo-generator-tag&quot;: &quot;^2.0.0&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-ejs&quot;: &quot;^2.0.0&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-marked&quot;: &quot;^6.0.0&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-stylus&quot;: &quot;^2.1.0&quot;,</span><br><span class=\"line\">    &quot;hexo-renderer-swig&quot;: &quot;^2.0.0&quot;,</span><br><span class=\"line\">    &quot;hexo-server&quot;: &quot;^3.0.0&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;start&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;,</span><br><span class=\"line\">    &quot;debug&quot;: &quot;hexo clean &amp;&amp; hexo g&quot;,</span><br><span class=\"line\">    &quot;deploy&quot;: &quot;hexo clean &amp;&amp; hexo g -d&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"升级-Next-主题\"><a href=\"#升级-Next-主题\" class=\"headerlink\" title=\"升级 Next 主题\"></a>升级 Next 主题</h1><p> NexT 主题升级从 v5 升级到 v7，跨度很大，官方提供了升级指导：<a href=\"https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md\">从 NexT v5.1.x 更新</a>。这里总结一下主题升级步骤。</p>\n<ol>\n<li>克隆新的仓库到任一异于 <code>next</code> 的目录（如 <code>next-reloaded</code>）：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"built_in\">clone</span> https://github.com/theme-next/hexo-theme-next themes/next-reloaded</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在 Hexo 的主配置文件中设置主题：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">theme: next-reloaded</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>如此，你的 <code>next-reloaded</code> 主题将在生成站点时被加载。如果你遇到了任何错误、或只是不喜欢这一新版本，你可以随时切换回旧的 v5.1.x 版本。</p>\n<ol start=\"3\">\n<li>更新语言配置</li>\n</ol>\n<p>从 v6.0.3 版本起，<code>zh-Hans</code> 改名为 <code>zh-CN</code>：<a href=\"https://github.com/theme-next/hexo-theme-next/releases/tag/v6.0.3%E3%80%82%E5%8D%87%E7%BA%A7%E5%88%B0\">https://github.com/theme-next/hexo-theme-next/releases/tag/v6.0.3。升级到</a> v6.0.3 及以后版本的用户，需要显式修改 Hexo 主配置文件 <code>_config.yml</code> 里的 <code>language</code> 配置，否则语言显示不正确。</p>\n<ol start=\"4\">\n<li>修改主题文件</li>\n</ol>\n<p>这里有两种方式，第一种是直接修改主题的_config.yml 文件，但是这样操作，后续 <code>git pull</code> 更新的时候，需要解决冲突问题，即使是手动下载 release 版本，也要手动合并 _config.yml 文件。第二种方式是创建自己单独的 next.yml 进行配置。参考 <a href=\"https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/DATA-FILES.md\">数据文件</a>。</p>\n<ol start=\"5\">\n<li>更新 Hexo 和 Hexo 插件</li>\n</ol>\n<p>如果完成了以上步骤后，执行 <code>hexo s</code> 或 <code>hexo g</code> 出现错误，这意味着可能是旧版的 Hexo 和 Hexo 插件与新版的 NexT 主题产生了冲突。我们建议将 Hexo 升级至 4.0 以上的版本，将 Hexo 插件升级到最新版本。你可以执行 <code>npm outdated</code> 查看所有可以升级的插件。</p>\n<h1 id=\"升级问题汇总\"><a href=\"#升级问题汇总\" class=\"headerlink\" title=\"升级问题汇总\"></a>升级问题汇总</h1><h3 id=\"next主题升级提示错误\"><a href=\"#next主题升级提示错误\" class=\"headerlink\" title=\"next主题升级提示错误\"></a>next主题升级提示错误</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro/post.swig‘ as post_template %&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原因是 hexo 在 5.0 之后把 swig 给删除了，需要自己手动安装。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">$ </span><span class=\"language-bash\">npm i hexo-renderer-swig</span></span><br></pre></td></tr></table></figure>\n\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Java并发系列（三）：底层原理","url":"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","content":"<blockquote>\n<p>这一篇介绍 java 并发的底层原理。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h1><h2 id=\"Unsafe\"><a href=\"#Unsafe\" class=\"headerlink\" title=\"Unsafe\"></a>Unsafe</h2><p>Unsafe类位于rt.jar包，Unsafe类提供了硬件级别的原子操作，类中的方法都是native方法，它们使用JNI的方式访问本地C++实现库。由此提供了一些绕开JVM的更底层功能，可以提高程序效率。</p>\n<blockquote>\n<p>JNI：Java Native Interface。使得Java 与 本地其他类型语言（如C、C++）直接交互。</p>\n</blockquote>\n<p>Unsafe 是用于扩展 Java 语言表达能力、便于在更高层（Java 层）代码里实现原本要在更低层（C 层）实现的核心库功能用的。这些功能包括直接内存的申请&#x2F;释放&#x2F;访问，低层硬件的 atomic&#x2F;volatile 支持，创建未初始化对象，通过偏移量操作对象字段、方法、实现线程无锁挂起和恢复等功能。</p>\n<p>Unsafe作用可以大致归纳为：</p>\n<ul>\n<li>内存管理，包括分配内存、释放内存等。</li>\n<li>非常规的对象实例化。</li>\n<li>操作类、对象、变量。</li>\n<li>自定义超大数组操作。</li>\n<li>多线程同步。包括锁机制、CAS操作等。</li>\n<li>线程挂起与恢复。</li>\n<li>内存屏障。</li>\n</ul>\n<p>一般可以通过单例模式获取 unsafe 对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Field</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> Unsafe.class.getDeclaredField(<span class=\"string\">&quot;theUnsafe&quot;</span>);</span><br><span class=\"line\">    f.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"type\">Unsafe</span> <span class=\"variable\">unsafe</span> <span class=\"operator\">=</span> (Unsafe) f.get(<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参考 <a href=\"https://blog.csdn.net/weixin_43767015/article/details/104643890\">Java Unsafe类的原理详解与使用案例</a></p>\n<h2 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h2><p>CAS（Compare and Swap），翻译过来就是“比较并交换”。CAS 操作包含三个操作数 —— 要更新的字段内存位置V（它的值是我们想要去更新的）、预期原值A（前面从内存中读取的值）和新值B(将要写入的新值)。</p>\n<p>CAS操作过程：首先读取预期原值A，然后在要更新数据的时候再次读取内存位置V的值，如果该值与预期原值A相匹配，那么处理器会自动将该位置V值更新为新值B；如果失败并且允许再次尝试，直到成功，或者允许失败的线程放弃操作。</p>\n<p>JUC 提供了一些类来支持原子操作，如AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值），这些类内部就是使用 CAS 操作来实现的，而这些 CAS 操作 都是基于 Unsafe 类来实现的，Unsafe类也是 JUC 包的实现的基石。例如 AtomicInteger 类的 <code>compareAndSet</code> 方法就调用了 Unsafe 的 <code>compareAndSwapInt</code> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSet</span><span class=\"params\">(<span class=\"type\">int</span> expect, <span class=\"type\">int</span> update)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"built_in\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Unsafe 的 <code>compareAndSwapInt</code> 方法是一个native的方法，一般是 Java 通过借助C、C++来实现直接操作底层系统、直接内存的方法。Unsafe的具体实现是和虚拟机实现相关的，不同的虚拟机具有不同的实现。在openjdk8的hotspot源码(unsafe.cpp)中能看到unsafe的源码，由于hotspot使用C++编写，那么unsafe的对应方法的C++源码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class=\"line\">  UnsafeWrapper(<span class=\"string\">&quot;Unsafe_CompareAndSwapInt&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//获取obj这个对象在jvm里面的对应的内存对象实例</span></span><br><span class=\"line\">  oop p = JNIHandles::resolve(obj);</span><br><span class=\"line\"><span class=\"comment\">//通过对象实例和偏移量获取字段在对象中的偏移地址</span></span><br><span class=\"line\">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class=\"line\"><span class=\"comment\">// 通过判断调用Atomic.cmpxchg方法的结果返回值是不是原来的e值，如果是表示更新成功，否则更新失败。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class=\"line\">UNSAFE_END</span><br></pre></td></tr></table></figure>\n<p>我们可以看到在该方法的最后调用了Atomic::cmpxchg的方法，但是你如果直接去atomic.cpp中是找不到的，并且上面的方法只是C++的源码并没有具体的汇编指令,但是我们在atomic.cpp中能够找到很多预处理指令,即#include “”，该指令会在实现定义的位置查找文件，并将其包含。我们找到：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&quot;runtime/atomic.inline.hpp&quot;</span></span></span><br></pre></td></tr></table></figure>\n<p>进入atomic.inline.hpp，这里面又有很多预处理指令，这些包含的文件均具有Atomic::cmpxchg的不同实现，有windows的也有linux的，一般生产应用运行在linux环境中，因此我们找到其中一个-我们分析Linux的x86的环境：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&quot;atomic_linux_x86.inline.hpp&quot;</span></span></span><br></pre></td></tr></table></figure>\n<p>在atomic_linux_x86.hpp的源码中，终于能找到该方法，汇编指令（CPU指令）可以自由的嵌入C&#x2F;C++，下面的方法就是最好的证明，接下来进入汇编指令的世界：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> jint     <span class=\"title function_\">Atomic::cmpxchg</span>    <span class=\"params\">(jint     exchange_value, <span class=\"keyword\">volatile</span> jint*     dest, jint     compare_value, cmpxchg_memory_order order)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> mp = os::is_MP();</span><br><span class=\"line\">  __asm__ <span class=\"title function_\">volatile</span> <span class=\"params\">(LOCK_IF_MP(%<span class=\"number\">4</span>) <span class=\"string\">&quot;cmpxchgl %1,(%3)&quot;</span></span></span><br><span class=\"line\"><span class=\"params\">                    : <span class=\"string\">&quot;=a&quot;</span> (exchange_value)</span></span><br><span class=\"line\"><span class=\"params\">                    : <span class=\"string\">&quot;r&quot;</span> (exchange_value), <span class=\"string\">&quot;a&quot;</span> (compare_value), <span class=\"string\">&quot;r&quot;</span> (dest), <span class=\"string\">&quot;r&quot;</span> (mp)</span></span><br><span class=\"line\"><span class=\"params\">                    : <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;memory&quot;</span>)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> exchange_value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中__asm__表示汇编指令开始，volatile禁止优化重排序，MP表示multiprocessor，LOCK_IF_MP开始时表示它会判断当前系统是否是多核处理器，如果是，那么就在cmpxchg指令前面加上lock指令前缀，否则就使用cmpxchg一条指令。可以看到Java的CAS操作的最终实现，是通过 <code>lock cmpxchg</code> 汇编指令实现的。这两条指令的解释如下：</p>\n<blockquote>\n<p>cmpxchg</p>\n<p>作用：汇编指令，比较并交换操作数</p>\n<p>该指令只能用于486及其后继机型。第2操作数（源操作数）只能用8位、16位或32位寄存器。第1操作数（目地操作数）则可用寄存器或任一种存储器寻址方式。</p>\n<p>注意：虽然cmpxchg看起来只有一条指令，但在多核cpu下仅比较交换的指令仍然不具有原子性，因为cmpxchg作为复杂指令，同时带有读写操作，在执行时会被分解为一条条的更小的微码（微指令），一般来说只有单一的load、stroe等指令是真正原子性的。</p>\n<p>但是该指令可以与lock同步一起使用，以允许以原子方式执行该指令（来自Intel手册）。</p>\n</blockquote>\n<blockquote>\n<p>lock<br>前缀指令，通常可以与某些指令连用（ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG等指令），它具有如下特性（来自Intel手册）：</p>\n<ul>\n<li><p>确保对内存的读-改-写操作原子执行，即确保lock后面的指令变成一个原子操作。 在Pentium及Pentium之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他处理器暂时无法通过总线访问共享内存，保证内存独占。很显然，这会带来昂贵的开销。从Pentium4、Intel Xeon及P6处理器开始，Intel使用缓存锁定（Cache Locking）来保证指令执行的原子性。缓存锁定将大大降低lock前缀指令的执行开销。这实际上也算一种CPU指令级别的同步。</p>\n</li>\n<li><p>不是内存屏障，但是具有内存屏障的功能，能够禁止该指令与之前和之后的读和写指令重排序。</p>\n</li>\n<li><p>如果lock后面的指令具有写操作，那么lock会导致把写缓冲区中的所有数据刷新到主存中，同时让其它CPU相关缓存行失效，从而重新从主存中加载最新的数据。</p>\n</li>\n</ul>\n</blockquote>\n<p>CAS的三大问题：</p>\n<ol>\n<li><code>ABA问题</code>：CAS需要再操作值的时候，检查值有没有发生变化，如果没有发生变化则更新。但是一个值，如果原来为A，变成了B，又变成了A，那么使用CAS进行compare and set的时候，会发现它的值根本没变化过，但实际上是变化过的。ABA问题的解决思路就是使用版本号，1A-&gt;2B-&gt;3A，在Atomic包中（JDK5），提供了一个现成的AtomicStampedReference类来解决ABA问题，使用的就是添加版本号的方法。</li>\n<li><code>循环时间长开销大</code>：由于线程并不会阻塞，如果CAS自旋长时间不成功，这会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。</li>\n<li><code>只能保证一个共享变量的原子操作</code>：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，由于CAS底层只能锁定单个指令，均是针对单个变量的操作，对多个共享变量操作时意味着多个指令，此时CAS就无法保证所有操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j&#x3D;a，合并一下ij&#x3D;2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</li>\n</ol>\n<p>参考 <a href=\"https://blog.csdn.net/weixin_43767015/article/details/106342879\">Java CAS操作的实现原理深度解析与应用案例</a></p>\n<h2 id=\"CLH\"><a href=\"#CLH\" class=\"headerlink\" title=\"CLH\"></a>CLH</h2><p>CLH是一个基于链表（队列）非线程饥饿的自旋（公平）锁，由于是 Craig、Landin 和 Hagersten三人的发明，因此命名为CLH锁。每一个等待锁的线程封装成节点，不断自旋判断前一个节点的状态，如果前一个节点释放锁就结束自旋。</p>\n<p>CLH锁原理如下：</p>\n<ol>\n<li>首先有一个尾节点指针，通过这个尾结点指针来构建等待线程的逻辑队列（所有每个线程还应该保存前面Node的状态，链表形式），因此能确保线程线程先到先服务的公平性，因此尾指针可以说是构建逻辑队列的桥梁；此外这个尾节点指针是原子引用类型，避免了多线程并发操作的线程安全性问题。</li>\n<li>每个等待锁的线程在自己的前驱节点某个变量上自旋等待，等待前驱解锁之后即可去获取锁。</li>\n</ol>\n<p><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154344258.png\" alt=\"image-20230307154344258\"></p>\n<p>参考 <a href=\"https://cloud.tencent.com/developer/article/1690060\">AQS基础——多图详解CLH锁的原理与实现</a><br><a href=\"https://funzzz.fun/2021/05/19/CLH%E9%94%81/\">CLH lock</a></p>\n<h1 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h1><p>AQS全称为AbstractQueuedSynchronizer，可以叫做队列同步器，为线程的同步和等待等操作提供一个基础模板类。Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AQS的。</p>\n<p><code>一般来说，使用AQS的时候先继承AQS，继承子类应以其他类的内部类的形式存在，然后使用代理模式调用子类和AQS本身的方法实现线程的同步</code>。使用ReentrantLock举例，外界调用ReentrantLock，ReentrantLock内部定义Sync，Sync是AQS的子类，在ReentrantLock的内部实现中调用Sync的方法，最后完成最终的功能，当然ReentrantLock内部稍复杂，又加入和公平锁和非公平锁。</p>\n<h2 id=\"AQS架构\"><a href=\"#AQS架构\" class=\"headerlink\" title=\"AQS架构\"></a>AQS架构</h2><p>AQS 的设计基于「<code>模板模式</code>」。AQS 把大部分底层细节已经封装好了，使用者继承 AQS 后只需要实现几个方法，AQS 在运行的时候会自动调用到作者实现的方法。<br><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154404719.png\" alt=\"image-20230307154404719\"></p>\n<ul>\n<li>上图中有颜色的为Method，无颜色的为Attribution。</li>\n<li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li>\n<li>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li>\n</ul>\n<h2 id=\"AQS原理\"><a href=\"#AQS原理\" class=\"headerlink\" title=\"AQS原理\"></a>AQS原理</h2><p>AQS 主要由三部分组成：</p>\n<ul>\n<li>state 同步状态</li>\n<li>Node 组成的 CLH 队列</li>\n<li>ConditionObject 条件变量（包含 Node 组成的条件单向队列）。</li>\n</ul>\n<p>线程通过 CAS 尝试完成对 State 值的修改，如果修改成功就表示获取锁成功，如果修改失败就把线程封装成一个 Node 节点添加到 CLH 队列；如果是被 Condition 阻塞了，就添加到 ConditionObject 队列。<br><img src=\"evernotecid://1A77DB63-CEBF-4C5E-B653-7DD2D90B3827/appyinxiangcom/9108333/ENResource/p7260\" alt=\"f2585562b0912a10a04058293dadc0d0.png\"></p>\n<h3 id=\"同步状态State\"><a href=\"#同步状态State\" class=\"headerlink\" title=\"同步状态State\"></a>同步状态State</h3><p><code>state 是一个 Volatile 修饰的 int 变量，是 AQS 的核心变量</code>。所有通过 AQS 实现功能的类都是通过修改 state 的状态来操作线程的同步状态。</p>\n<p>AQS提供了操作state的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getState</span><span class=\"params\">()</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">setState</span><span class=\"params\">(<span class=\"type\">int</span> newState)</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSetState</span><span class=\"params\">(<span class=\"type\">int</span> expect, <span class=\"type\">int</span> update)</span></span><br></pre></td></tr></table></figure>\n<p>我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式：</p>\n<ul>\n<li>独占模式：只有一个线程可以获取锁，如果是不可重入锁，state的值只能为0或1；如果是可重入锁，state的值可以为0、1或者大于1（持有锁的线程重入state会累加1）。</li>\n<li>共享模式：多个线程可以获取锁，state的值表示可以同时持有锁的线程数。<br><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154443435.png\" alt=\"image-20230307154443435\"><br><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154457719.png\" alt=\"image-20230307154457719\"></li>\n</ul>\n<h3 id=\"Node组成的CLH队列\"><a href=\"#Node组成的CLH队列\" class=\"headerlink\" title=\"Node组成的CLH队列\"></a>Node组成的CLH队列</h3><p>上面我们有提到 CLH 队列是一个虚拟的单向链表。虚拟的意思是即不存在队列实例，每个节点通过保存前一个节点的引用来形成链表关系，后一个节点阻塞在前一个节点的某个状态变量上。</p>\n<p>AQS 中的队列是 CLH 变体的虚拟双向队列（FIFO）。</p>\n<ul>\n<li>AQS 的节点同时保存了前后两个节点的引用（除了首尾两个边缘节点）。</li>\n<li>AQS 的节点没有阻塞在前一个节点的某个变量上，而是阻塞在前一个节点是否头节点这种状态上。</li>\n</ul>\n<p>CLH 变体队列中的节点数据结构为 <code>Node</code>。获取锁失败的线程被封装成 Node 节点，添加到 CLH 变体队列的队尾。<br><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154511606.png\" alt=\"image-20230307154511606\"></p>\n<p>Node 的几个重要变量：</p>\n<ul>\n<li>waitStatus\t当前节点在队列中的状态</li>\n<li>thread\t表示处于该节点的线程</li>\n<li>prev\t前驱指针</li>\n<li>next\t后继指针</li>\n<li>predecessor\t返回前驱节点，没有的话抛出npe</li>\n<li>nextWaiter\t指向下一个处于CONDITION状态的节点</li>\n</ul>\n<p>线程两种锁的模式：</p>\n<ul>\n<li>SHARED\t表示线程以共享的模式等待锁</li>\n<li>EXCLUSIVE\t表示线程正在以独占的方式等待锁</li>\n</ul>\n<p>waitStatus 的枚举值：</p>\n<ul>\n<li>0\t当一个Node被初始化的时候的默认值</li>\n<li>CANCELLED\t为1，表示线程获取锁的请求已经取消了</li>\n<li>CONDITION\t为-2，表示节点在等待队列中，节点线程等待唤醒</li>\n<li>PROPAGATE\t为-3，当前线程处在SHARED情况下，该字段才会使用</li>\n<li>SIGNAL\t为-1，表示线程已经准备好了，就等资源释放了</li>\n</ul>\n<p>AQS 类成员变量 head 和 tail 字段分别指向 CLH 同步队列的头 Node 和尾 Node。head 节点是虚节点（哨兵节点），不保存除 waitStatus 的其他信息。<br><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154523435.png\" alt=\"image-20230307154523435\"></p>\n<p>当调用 AQS 的 acquire 方法获取资源时，如果资源不足则当前线程会被封装成 Node 结点添加到同步队列的末端（入队），头结点 head 用于记录当前正在持有资源的线程结点，而 head 的后继结点就是下一个将要被调度的线程结点，当 release 方法被调用时，该结点上的线程将被唤醒（出队），继续获取资源。</p>\n<ul>\n<li>入队：获取资源失败的线程需要封装成 Node 节点，接着尾部入队，在 AQS 中提供 addWaiter 函数完成 Node 节点的创建与入队。添加节点的时候，如 CLH 队列已经存在，通过 CAS 快速将当前节点添加到队列尾部，如果添加失败或队列不存在，则初始化同步队列。</li>\n<li>出队：CLH 队列中的节点都是获取资源失败的线程节点，当持有资源的线程释放资源时，会将 head.next 指向的线程节点唤醒（CLH 队列的第二个节点），如果唤醒的线程节点获取资源成功，线程节点清空信息设置为头部节点（新哨兵节点），原头部节点出队（原哨兵节点）。</li>\n</ul>\n<p><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154534411.png\" alt=\"image-20230307154534411\"></p>\n<h3 id=\"ConditionObject\"><a href=\"#ConditionObject\" class=\"headerlink\" title=\"ConditionObject\"></a>ConditionObject</h3><p>上面我们提到的 CLH 变体队列，实际上是 AQS 的<code>同步队列（Sync Queue）</code>，是双向链表，用于存储获取锁失败的线程。</p>\n<p>AQS 内部还有数据结构 <code>ConditionObject</code>，称作<code>等待队列（Wait Queue）</code>，用于存储被阻塞在某个 Condition 上的线程。ConditionObject 复用了 Node 的数据结构，不过是一个单向链表。<br><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154608534.png\" alt=\"image-20230307154608534\"></p>\n<p>因为可以定义多个 Condition，每个 Condition 对应一个等待队列，所以可能存在多个等待队列。<br><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154618354.png\" alt=\"image-20230307154618354\"></p>\n<p>等待队列中通过 signal() 被唤醒的节点，会加入到同步队列的队尾；如果是 signalAll() 唤醒，就把等待队列的所有节点加入同步队列（没有特殊原因尽量别用 signalAll 方法）。<br><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154630431.png\" alt=\"image-20230307154630431\"></p>\n<h2 id=\"AQS使用\"><a href=\"#AQS使用\" class=\"headerlink\" title=\"AQS使用\"></a>AQS使用</h2><h3 id=\"同步器可重写的方法\"><a href=\"#同步器可重写的方法\" class=\"headerlink\" title=\"同步器可重写的方法\"></a>同步器可重写的方法</h3><p>AQS 提供的可重写方法只有5个，这大大方便了锁的使用者。<br><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154646082.png\" alt=\"image-20230307154646082\"></p>\n<p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。为了避免强制重写不相干方法，所以就没有 abstract 来修饰了，但要抛出异常告知不能直接使用该方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryAcquire</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UnsupportedOperationException</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。</p>\n<h3 id=\"同步器提供的模版方法\"><a href=\"#同步器提供的模版方法\" class=\"headerlink\" title=\"同步器提供的模版方法\"></a>同步器提供的模版方法</h3><p>上面我们将同步器的实现方法分为独占式和共享式两类，模版方法其实除了提供以上两类模版方法之外，只是多了响应中断和超时限制 的模版方法供 Lock 使用。<code>这些模板方法都有 final 关键字修饰，说明子类不能重写这个方法，但是模板方法方法最终会调用到上面重写的方法</code>。<br><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154706243.png\" alt=\"image-20230307154706243\"></p>\n<p>实际应用的时候，他们的关系大概如下：<br><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154721517.png\" alt=\"image-20230307154721517\"></p>\n<h3 id=\"共享模式和独占模式\"><a href=\"#共享模式和独占模式\" class=\"headerlink\" title=\"共享模式和独占模式\"></a>共享模式和独占模式</h3><p><code>AbstractQueuedSynchronizer</code> 类继承了 <code>AbstractOwnableSynchronizer</code> 类，后者提供了 <code>exclusiveOwnerThread</code> 属性，用来记录当前持有锁的线程。</p>\n<p>当独占锁已经被某个线程持有时，其他线程只能等待它被释放后，才能去争锁，并且同一时刻只有一个线程能争锁成功。</p>\n<p>而对于共享锁而言，由于锁是可以被共享的，因此它可以被多个线程同时持有。换句话说，如果一个线程成功获取了共享锁，那么其他等待在这个共享锁上的线程就也可以尝试去获取锁，并且极有可能获取成功。</p>\n<p>共享锁的实现和独占锁是对应的，我们可以从下面这张表中看出：<br><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20230307154736955.png\" alt=\"image-20230307154736955\"></p>\n<p>除了最后一个属于共享锁的 doReleaseShared() 方法没有对应外，其他的方法，独占锁和共享锁都是一一对应的。</p>\n<p>在独占锁模式中，我们只有在获取了独占锁的节点释放锁时，才会唤醒后继节点；在共享锁模式下，当一个节点获取到了共享锁，我们在获取成功后就可以调用 doReleaseShared() 唤醒后继节点了，而不需要等到该节点释放锁的时候。这是因为共享锁可以被多个线程同时持有，一个锁获取到了，则后继的节点都可以直接来获取。<code>所以在独占模式下，释放锁的时候才会唤醒后继节点；在共享锁模式下，在获取锁和释放锁结束时，都会唤醒后继节点</code>。</p>\n<p>参考 <a href=\"https://cloud.tencent.com/developer/article/1639473\">万字超强图文讲解AQS以及ReentrantLock应用</a><br><a href=\"https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html\">从ReentrantLock的实现看AQS的原理及应用</a><br><a href=\"https://segmentfault.com/a/1190000016447307\">逐行分析AQS源码(3)——共享锁的获取与释放</a><br><a href=\"https://www.modb.pro/db/151391\">彻底理解 AQS 我是懂了，你呢？</a><br><a href=\"https://www.modb.pro/db/56987\">1.5w字，30图带你彻底掌握 AQS！</a></p>\n","categories":["Java","Java并发"],"tags":["Java"]},{"title":"Java并发系列（一）：Java内存模型","url":"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","content":"<blockquote>\n<p>java 并发系列。先从基础 java 内存模型开始说起。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"并发问题的根源\"><a href=\"#并发问题的根源\" class=\"headerlink\" title=\"并发问题的根源\"></a>并发问题的根源</h1><p>并发的三大特性：</p>\n<ul>\n<li><code>可见性</code>：一个线程对共享变量的修改，另外一个线程能够立刻看到。</li>\n<li><code>原子性</code>：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li>\n<li><code>有序性</code>：即程序执行的顺序按照代码的先后顺序执行。</li>\n</ul>\n<p>只要破坏这三个特性其中之一，就会导致并发问题。</p>\n<h2 id=\"可见性问题：CPU缓存引起\"><a href=\"#可见性问题：CPU缓存引起\" class=\"headerlink\" title=\"可见性问题：CPU缓存引起\"></a>可见性问题：CPU缓存引起</h2><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i &#x3D; 10 这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。 </p>\n<p>此时线程2执行 j &#x3D; i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。</p>\n<p>这就是可见性问题，线程1对变量i修改了分时复用引起之后，线程2没有立即看到线程1修改的值。</p>\n<h2 id=\"原子性问题：分时复用引起\"><a href=\"#原子性问题：分时复用引起\" class=\"headerlink\" title=\"原子性问题：分时复用引起\"></a>原子性问题：分时复用引起</h2><p>i +&#x3D; 1需要三条 CPU 指令</p>\n<ul>\n<li>将变量 i 从内存读取到 CPU寄存器；</li>\n<li>在CPU寄存器中执行 i + 1 操作；</li>\n<li>将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li>\n</ul>\n<p>由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。</p>\n<h2 id=\"有序性问题：重排序引起\"><a href=\"#有序性问题：重排序引起\" class=\"headerlink\" title=\"有序性问题：重排序引起\"></a>有序性问题：重排序引起</h2><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型： </p>\n<ul>\n<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 </li>\n<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>\n<li>内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>\n</ul>\n<p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：<br><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302155212640.png\" alt=\"image-20230302155212640\"></p>\n<p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。</p>\n<p>下面是常见处理器允许的重排序类型的列表：</p>\n<table>\n<thead>\n<tr>\n<th>\\</th>\n<th>Load-Load</th>\n<th>Load-Store</th>\n<th>Store-Store</th>\n<th>Store-Load</th>\n<th>数据依赖</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sparc-TSO</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>x86</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>ia64</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>PowerPC</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n</tbody></table>\n<p>上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。</p>\n<p>从上表我们可以看出：常见的处理器都允许 Store-Load 重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO 和 x86 拥有相对较强的处理器内存模型，它们仅允许对写 - 读操作做重排序（因为它们都使用了写缓冲区）。</p>\n<h1 id=\"顺序一致性模型\"><a href=\"#顺序一致性模型\" class=\"headerlink\" title=\"顺序一致性模型\"></a>顺序一致性模型</h1><p>为了解决并发问题，提出了<code>顺序一致性模型</code>。顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：</p>\n<ul>\n<li>一个线程中的所有操作必须按照程序的顺序来执行。不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。</li>\n<li>每个操作都必须原子执行且立刻对所有线程可见。</li>\n</ul>\n<p>顺序一致性内存模型为程序员提供的视图如下：<br><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302155301224.png\" alt=\"image-20230302155301224\"></p>\n<p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读 &#x2F; 写操作。从上图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读 &#x2F; 写操作串行化。</p>\n<p>假设有两个线程 A 和 B 并发执行。其中 A 线程有三个操作，它们在程序中的顺序是：A1-&gt;A2-&gt;A3。B 线程也有三个操作，它们在程序中的顺序是：B1-&gt;B2-&gt;B3。 </p>\n<p>假设这两个线程使用监视器来正确同步：A 线程的三个操作执行后释放监视器，随后 B 线程获取同一个监视器。那么程序在顺序一致性模型中的执行效果将如下图所示：<br><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302155431666.png\" alt=\"image-20230302155431666\"></p>\n<p>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：<br><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302155525064.png\" alt=\"image-20230302155525064\"></p>\n<p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程 A 和 B 看到的执行顺序都是：B1-&gt;A1-&gt;A2-&gt;B2-&gt;A3-&gt;B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p>\n<p>但是，在 JMM 中就没有这个保证。未同步程序在 JMM 中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，且还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p>\n<h2 id=\"JMM的设计\"><a href=\"#JMM的设计\" class=\"headerlink\" title=\"JMM的设计\"></a>JMM的设计</h2><h3 id=\"JMM的抽象\"><a href=\"#JMM的抽象\" class=\"headerlink\" title=\"JMM的抽象\"></a>JMM的抽象</h3><p><strong>Java 线程之间的通信由 Java 内存模型（JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见</strong>。</p>\n<p>在 java 中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（java 语言规范称之为 formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>\n<p>从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 &#x2F; 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下：<br><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302155730292.png\" alt=\"image-20230302155730292\"></p>\n<p>从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：</p>\n<ol>\n<li>首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。</li>\n<li>然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。</li>\n</ol>\n<p>为了解决重排序问题：</p>\n<ul>\n<li>对于编译器重排序，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。</li>\n<li>对于处理器重排序，由于常见的处理器内存模型比 JMM 要弱，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。JMM 把内存屏障指令分为下列四类：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>屏障类型</th>\n<th>指令示例</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LoadLoad Barriers</td>\n<td>Load1; LoadLoad; Load2</td>\n<td>确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。</td>\n</tr>\n<tr>\n<td>StoreStore Barriers</td>\n<td>Store1; StoreStore; Store2</td>\n<td>确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td>\n</tr>\n<tr>\n<td>LoadStore Barriers</td>\n<td>Load1; LoadStore; Store2</td>\n<td>确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td>\n</tr>\n<tr>\n<td>StoreLoad Barriers</td>\n<td>Store1; StoreLoad; Load2</td>\n<td>确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。</td>\n</tr>\n</tbody></table>\n<p><code>StoreLoad Barriers</code> 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。 StoreLoad Barriers 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p>\n<h3 id=\"happens-before原则\"><a href=\"#happens-before原则\" class=\"headerlink\" title=\"happens-before原则\"></a>happens-before原则</h3><p>从 JDK5 开始，java 使用新的 JSR -133 内存模型（本文除非特别说明，针对的都是 JSR- 133 内存模型）。JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。<code>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。</code></p>\n<p>这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的 happens-before 规则如下：</p>\n<ul>\n<li>程序顺序规则：同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。</li>\n<li>Synchronized 规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。 </li>\n<li>volatile 规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。 </li>\n<li>线程启动规则：线程的start() 方法 happen-before 该线程所有的后续操作。</li>\n<li>线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。</li>\n<li>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li>\n</ul>\n<p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。</p>\n<p>happens-before 与 JMM 的关系如下图所示：<br><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302155756136.png\" alt=\"image-20230302155756136\"></p>\n<p>如上图所示，一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。</p>\n<p>在 happens-before 的原则基础上，JMM 对于不同性质的重排序，采取了不同的策略：</p>\n<ul>\n<li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。</li>\n<li>对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不作要求（JMM 允许这种重排序）。</li>\n</ul>\n<p><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302155811154.png\" alt=\"image-20230302155811154\"></p>\n<p>从上图可以看出两点： </p>\n<ul>\n<li>JMM 向程序员提供的 happens- before 规则能满足程序员的需求。JMM 的 happens- before 规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的 A happens- before B）。 </li>\n<li>JMM 对编译器和处理器的束缚已经尽可能的少。从上面的分析我们可以看出，JMM 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个 volatile 变量仅仅只会被单个线程访问，那么编译器可以把这个 volatile 变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。</li>\n</ul>\n<h3 id=\"as-if-serial语义\"><a href=\"#as-if-serial语义\" class=\"headerlink\" title=\"as-if-serial语义\"></a>as-if-serial语义</h3><p>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p>\n<p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。</p>\n<h3 id=\"JMM内存可见性保证\"><a href=\"#JMM内存可见性保证\" class=\"headerlink\" title=\"JMM内存可见性保证\"></a>JMM内存可见性保证</h3><p>Java 程序的内存可见性保证按程序类型可以分为下列三类： </p>\n<ul>\n<li>单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>\n<li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM 通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li>\n<li>未同步 &#x2F; 未正确同步的多线程程序。JMM 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</li>\n</ul>\n<p><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302155826515.png\" alt=\"image-20230302155826515\"></p>\n<h2 id=\"关键字的内存语义\"><a href=\"#关键字的内存语义\" class=\"headerlink\" title=\"关键字的内存语义\"></a>关键字的内存语义</h2><h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><p>volatile 主要有两个特性：</p>\n<ul>\n<li><code>可见性</code>：通过<code>lock前缀</code>实现，lock前缀可实现嗅探机制，每个处理器都会有一个嗅探机制，去看自己的工作内存中的数值与主内存中那个的是否一致，不一致，会将自己的工作内存中的数值设置成无效，同时会从主内存中读取数值更新到自己的工作内存中。</li>\n<li><code>有序性</code>：通过<code>内存屏障</code>实现的，禁止指令重排，内存屏障还可以强制刷出各种CPU的缓存数据保证可见性。</li>\n</ul>\n<p>注意 volatile 不保证原子性的实际含义：对volatile变量的单次读&#x2F;写操作可以保证原子性的，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。</p>\n<h4 id=\"lock-前缀\"><a href=\"#lock-前缀\" class=\"headerlink\" title=\"lock 前缀\"></a>lock 前缀</h4><p>用 volitle 修饰的变量，hsdis 和 jitwatch 工具可以得到编译后的汇编代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">0x000000000295157f: and    $0x37f,%rax</span><br><span class=\"line\">0x0000000002951586: mov    %rax,%rdi</span><br><span class=\"line\">0x0000000002951589: or     %r15,%rdi</span><br><span class=\"line\">0x000000000295158c: lock movl %rdi,(%rdx)  //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令</span><br><span class=\"line\">0x0000000002951591: jne    0x0000000002951a15</span><br><span class=\"line\">0x0000000002951597: jmpq   0x00000000029515f8</span><br><span class=\"line\">0x000000000295159c: mov    0x8(%rdx),%edi</span><br></pre></td></tr></table></figure>\n<p>lock 前缀是一个特殊的信号，movl 是一个汇编指令，执行过程如下：</p>\n<ul>\n<li>对总线和缓存上锁。</li>\n<li>强制所有lock信号之前的指令，都在此之前被执行，并同步相关缓存。</li>\n<li>执行lock后的指令（如cmpxchg）。</li>\n<li>释放对总线和缓存上的锁。</li>\n<li>强制所有lock信号之后的指令，都在此之后被执行，并同步相关缓存。</li>\n</ul>\n<p>lock 前缀有两种实现途径：</p>\n<ul>\n<li>锁总线（lock bus）：在 Pentium 和早期的 IA-32 处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其它处理器暂时无法通过总线访问内存。锁总线的开销比较大。</li>\n<li>锁缓存（lock cache）：在新的处理器中，Intel使用缓存锁定来保证指令执行的原子性，缓存锁定将大大降低lock前缀指令的执行开销。这里锁缓存（Cache Locking）就是用了Ringbus + MESI协议。</li>\n</ul>\n<p>缓存一致性协议保证两件事情：</p>\n<ul>\n<li>将当前处理器缓存行的数据写回到系统内存。</li>\n<li>写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li>\n</ul>\n<h4 id=\"内存屏障\"><a href=\"#内存屏障\" class=\"headerlink\" title=\"内存屏障\"></a>内存屏障</h4><p>内存屏障，又称内存栅栏，是一个 CPU 指令。插入一条内存屏障会告诉编译器和 CPU，<code>不管什么指令都不能和这条 Memory Barrier 指令重排序</code>。</p>\n<p>前面说了 lock 只是一个前缀，lock 后面才是真正要执行的指令。lock 之前的读写请求都不能越过lock指令进行重排。<code>lock 前缀 + 执行指令</code>达到了内存屏障的效果。查看 jdk 源码四种内存屏障的实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">OrderAccess::loadload</span><span class=\"params\">()</span>   &#123; acquire(); &#125;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">OrderAccess::storestore</span><span class=\"params\">()</span> &#123; release(); &#125;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">OrderAccess::loadstore</span><span class=\"params\">()</span>  &#123; acquire(); &#125;</span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">OrderAccess::storeload</span><span class=\"params\">()</span>  &#123; fence(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">OrderAccess::acquire</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> <span class=\"type\">intptr_t</span> local_dummy;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> AMD64</span></span><br><span class=\"line\">  __asm__ <span class=\"title function_\">volatile</span> <span class=\"params\">(<span class=\"string\">&quot;movq 0(%%rsp), %0&quot;</span> : <span class=\"string\">&quot;=r&quot;</span> (local_dummy) : : <span class=\"string\">&quot;memory&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">  __asm__ <span class=\"title function_\">volatile</span> <span class=\"params\">(<span class=\"string\">&quot;movl 0(%%esp),%0&quot;</span> : <span class=\"string\">&quot;=r&quot;</span> (local_dummy) : : <span class=\"string\">&quot;memory&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// AMD64</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">OrderAccess::release</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Avoid hitting the same cache-line from</span></span><br><span class=\"line\">  <span class=\"comment\">// different threads.</span></span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> jint local_dummy = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">OrderAccess::fence</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (os::is_MP()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// always use locked addl since mfence is sometimes expensive</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> AMD64</span></span><br><span class=\"line\">    __asm__ <span class=\"title function_\">volatile</span> <span class=\"params\">(<span class=\"string\">&quot;lock; addl $0,0(%%rsp)&quot;</span> : : : <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;memory&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">    __asm__ <span class=\"title function_\">volatile</span> <span class=\"params\">(<span class=\"string\">&quot;lock; addl $0,0(%%esp)&quot;</span> : : : <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;memory&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不同的内存屏障通过 lock 后面跟不同的指令来实现，例如 storeload 屏障通过 <code>lock addl $0x0,(%rsp)</code> 来实现。</p>\n<p>JSR-133 增强了模型。旧内存模型允许 volatile 变量与普通变量重排序。JSR-133 严格限制 volatile 变量与普通变量的重排序，使 volatile 的写 - 读和锁的释放 - 获取具有相同的内存语义。JMM 会针对编译器制定 volatile 重排序规则表：<br><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302155921306.png\" alt=\"image-20230302155921306\"></p>\n<p>“ NO “ 表示禁止重排序。为了实现 volatile 内存语义，Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。最保守的策略是：</p>\n<ul>\n<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li>\n<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li>\n<li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li>\n<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li>\n</ul>\n<p>volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。<br><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302155933684.png\" alt=\"image-20230302155933684\"></p>\n<p>使用 volatile 必须具备的条件：</p>\n<ul>\n<li>对变量的写操作不依赖于当前值。</li>\n<li>该变量没有包含在具有其他变量的不变式中。</li>\n<li>只有在状态真正独立于程序内其他内容时才能使用 volatile。</li>\n</ul>\n<p>使用 volatile 的场景：</p>\n<ul>\n<li>状态标志。例如完成初始化这种一次性事件。</li>\n<li>定期发布观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</li>\n<li>双重检查。</li>\n</ul>\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><p>synchronized 是利用锁的机制来实现同步的。synchronized 的特性是：</p>\n<ul>\n<li>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程中的协调机制，这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。</li>\n<li>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</li>\n</ul>\n<p>synchronized有三种用法：</p>\n<ul>\n<li>修饰普通实例方法，锁对象为this</li>\n<li>修饰静态方法，锁对象为当前类的class对象</li>\n<li>修饰代码块：<ul>\n<li>synchronized(this|object)：锁对象为this</li>\n<li>synchronized(类.class)：锁对象为指定类的class对象</li>\n</ul>\n</li>\n</ul>\n<p>每个对象有一个监视器锁（monitor），当monitor被占用时就会处于锁定状态。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得。为了获取 monitor 的拥有权，synchronized 底层通过 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码来实现：</p>\n<ul>\n<li>monitorenter：尝试获取monitor锁的所有权。<ul>\n<li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</li>\n<li>如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加。</li>\n<li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</li>\n</ul>\n</li>\n<li>monitorexit：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。</li>\n</ul>\n<p>JVM中的 monitorenter 和 monitorexit 字节码依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用 Mutex Lock 那么将严重的影响程序的性能。</p>\n<p>jdk1.6为了减少获取锁和释放锁的性能消耗，引入「偏向锁」和「轻量级锁」的概念，优化后的 synchronied 同步锁一共有四种状态：</p>\n<ul>\n<li><code>无锁</code></li>\n<li><code>偏向锁</code></li>\n<li><code>轻量级锁</code></li>\n<li><code>重量级锁</code></li>\n</ul>\n<p>另外还有其他优化手段：</p>\n<ul>\n<li><code>适应性自旋</code></li>\n<li><code>锁消除</code></li>\n<li><code>锁粗化</code></li>\n</ul>\n<p>锁会随着竞争情况发生膨胀，锁膨胀方向：<code>无锁 → 偏向锁 → 轻量级锁 → 重量级锁</code>。锁可以升级但是不可以降级。</p>\n<p>synchronized 用的锁存在于Java对象头，Java对象头里面包含三部分信息：</p>\n<ul>\n<li><code>Mark Word</code>，用于存储自身的运行时数据，如：HashCode、GC分代年龄、锁标记、偏向锁线程ID等。</li>\n<li><code>类型指针</code>，即对象指向它的类元信息，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>\n<li><code>数组长度（可选）</code>，如果java对象是一个数组，那么对象头中还必须有一块用于记录数组长度的数据。</li>\n</ul>\n<p>锁记录在对象头中的「Mark Word」。在32位虚拟机中，Mark Word 存储结构如下图：<br><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302155954882.png\" alt=\"image-20230302155954882\"></p>\n<p>在64位虚拟机中，“Mark Word”存储结构如下图：<br><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302160005197.png\" alt=\"image-20230302160005197\"></p>\n<h4 id=\"无锁\"><a href=\"#无锁\" class=\"headerlink\" title=\"无锁\"></a>无锁</h4><p>jvm会有4秒的偏向锁开启的延迟时间，在这个偏向延迟内对象处于为无锁态。如果关闭偏向锁启动延迟、或是经过4秒且没有线程竞争对象的锁，那么对象会进入<code>无锁可偏向</code>状态。</p>\n<p>准确来说，无锁可偏向状态应该叫做<code>匿名偏向</code>(Anonymously biased)状态，因为这时对象的mark word中后三位已经是101，但是threadId指针部分仍然全部为0，它还没有向任何线程偏向。另外可以通过 -XX:-UseBiasedLocking 参数关闭偏向锁。综上所述：</p>\n<ul>\n<li><code>如果没有关闭偏向锁，对象在刚被创建时，根据jvm的配置对象可能会处于「无锁」或「匿名偏向」两个状态，mark word后三位为101</code>。</li>\n<li><code>如果关闭偏向锁，那么直到有线程获取这个锁对象之前，会一直处于无锁不可偏向状态，mark word后三位为001</code>。在无锁不可偏向状态下，如果有线程试图获取锁，那么将跳过升级偏向锁的过程，直接使用轻量级锁。</li>\n</ul>\n<blockquote>\n<p>为什么会有偏向锁启动有延迟？</p>\n<p>JVM内部的代码有很多地方也用到了synchronized，明确在这些地方存在线程的竞争，如果还需要从偏向状态再逐步升级，会带来额外的性能损耗，所以JVM设置了一个偏向锁的启动延迟，来降低性能损耗。</p>\n</blockquote>\n<p>在目前的基础上，可以用流程图概括上面的过程：<br><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302160018811.png\" alt=\"image-20230302160018811\"></p>\n<h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h4><p><code>偏向锁适用于同一线程多次申请同一个锁的场景</code>。如果大部分时间一个锁都是被一个线程持有和竞争，使用 monitor 的话每次都会发生用户态和内核态的切换，性能低下。</p>\n<p>偏向锁获取：</p>\n<ol>\n<li>首先获取锁对象头中的 Mark Word，判断当前对象是否处于可偏向状态（即偏向锁打开，且当前没有其他对象获得偏向锁）。</li>\n<li>如果是可偏向状态，则通过 CAS 原子操作，尝试把当前线程的ID写入到 MarkWord，如果 CAS 成功，表示获得偏向锁成功。</li>\n<li>如果是不可偏向状态，检查Mark Word中的ThreadID是否和自己相等，如果相等则不需要再次获得锁，可以直接执行同步代码块，如果不相等，说明当前偏向的是其他线程，需要撤销偏向锁并升级到轻量级锁。</li>\n</ol>\n<p>偏向锁撤销：</p>\n<ol>\n<li>偏向锁的撤销并不是把对象恢复到无锁可偏向状态（因为偏向锁并不存在锁释放的概念），而是直接把被偏向的锁对象升级到被加了轻量级锁的状态。</li>\n<li>偏向锁的撤销需要等待全局安全点Safe Point（安全点是 jvm为了保证在垃圾回收的过程中引用关系不会发生变化设置的安全状态，在这个状态上会暂停所有线程工作），在这个安全点会挂起获得偏向锁的线程。</li>\n<li>在暂停线程后，会通过遍历当前jvm的所有线程的方式，检查持有偏向锁的线程状态是否存活：<ul>\n<li>如果线程还存活，且线程正在执行同步代码块中的代码，则升级为轻量级锁。</li>\n<li>如果持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向：<ul>\n<li>不允许重偏向，则撤销偏向锁，将mark word升级为轻量级锁，进行CAS竞争锁</li>\n<li>允许重偏向，设置为匿名偏向锁状态，CAS将偏向锁重新指向新线程</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>完成上面的操作后，唤醒暂停的线程，从安全点继续执行代码。</li>\n</ol>\n<p><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302160039038.png\" alt=\"image-20230302160039038\"></p>\n<p>一旦出现其它线程竞争锁资源，偏向锁就会被撤销。</p>\n<p>另外有两点需要注意：</p>\n<ul>\n<li>偏向锁在java 6之后是默认启动的（java 15开始已经废弃了偏向锁），但是在应用程序启动几秒后才激活，可以使用参数关闭延迟：<code>-XXBiaseLockingStartupDelay=0</code></li>\n<li>如果我们确定代码中同步资源一直是被多线程访问的，那么建议是关闭偏向锁，因为开启反而会因为偏向锁撤销操作而引起更多的资源消耗。使用参数关闭偏向锁：<code>-XX:UseBiaseLocking=false</code>。程序默认直接进入轻量级锁状态。</li>\n</ul>\n<h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h4><p><code>轻量级锁适用于两个线程在交替使用锁的场景</code>。由于没有同时抢锁，属于一种比较和谐的状态，就可以使用轻量级锁。</p>\n<p>轻量级锁加锁：</p>\n<ol>\n<li>在代码访问同步资源时，如果锁对象处于无锁不可偏向状态，jvm首先将在当前线程的栈帧中创建一条锁记录（<code>lock record</code>），用于存放：<ul>\n<li><code>displaced mark word</code>（置换标记字）：存放锁对象当前的mark word的拷贝。</li>\n<li><code>owner</code>指针：指向当前的锁对象的指针，在拷贝mark word阶段暂时不会处理它。</li>\n</ul>\n</li>\n<li>在拷贝mark word完成后，首先会挂起线程，jvm 使用 CAS 操作尝试将锁对象的 mark word 中的 lock record 指针指向刚才创建的线程栈帧中的 lock record，并将 lock record 中的 owner 指针指向锁对象的 mark word。如果 CAS 替换成功，表示竞争锁对象成功，则将锁标志位设置成 <code>00</code>，表示对象处于轻量级锁状态。<br><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302160103162.png\" alt=\"image-20230302160103162\"></li>\n<li>如果CAS替换失败，则判断锁对象的 mark word 是否指向当前线程的栈帧：<ul>\n<li>如果是则表示当前线程已经持有对象的锁，执行下面<code>轻量级锁重入的过程</code>，可以直接执行同步代码块。</li>\n<li>否则说明该其他线程已经持有了该对象的锁，执行下面<code>轻量级锁自旋和升级的过程</code>。如果在自旋一定次数后仍未获得锁，那么轻量级锁需要升级为重量级锁，将锁标志位变成10，后面等待的线程将会进入阻塞状态。</li>\n</ul>\n</li>\n</ol>\n<p>轻量级锁重入：</p>\n<ol>\n<li>轻量级锁的每次重入，都会在栈中生成一个lock record，但是保存的数据不同：<ul>\n<li>首次分配的lock record，displaced mark word复制了锁对象的mark word，owner指针指向锁对象</li>\n<li>之后重入时在栈中分配的lock record中的displaced mark word为null，只存储了指向对象的owner指针<br> <img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302160123685.png\" alt=\"image-20230302160123685\"></li>\n</ul>\n</li>\n<li>重入的次数等于该锁对象在栈帧中lock record的数量，这个数量隐式地充当了锁重入机制的计数器。这里需要计数的原因是每次解锁都需要对应一次加锁，只有最后解锁次数等于加锁次数时，锁对象才会被真正释放。在释放锁的过程中，如果是重入则删除栈中的lock record，直到没有重入时则使用CAS替换锁对象的mark word。</li>\n</ol>\n<p>轻量级锁自旋和升级：</p>\n<ol>\n<li>在jdk1.6以前，默认轻量级锁自旋次数是10次，可以通过 <code>-XX:PreBlockSpin</code> 参数修改。jdk1.6以后加入了<code>自适应自旋锁</code>，自旋的次数不再固定，由jvm自己控制，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：<ul>\n<li>对于某个锁对象，如果自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而允许自旋等待持续相对更长时间</li>\n<li>对于某个锁对象，如果自旋很少成功获得过锁，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</li>\n</ul>\n</li>\n<li>如果自旋超过设定次数或自旋线程数超过CPU核数的一半，就会升级为重量级锁。</li>\n</ol>\n<p>轻量级锁解锁：</p>\n<ol>\n<li>轻量级锁的释放同样使用了CAS操作，尝试将displaced mark word 替换回mark word，这时需要检查锁对象的mark word中lock record指针是否指向当前线程的锁记录：<ul>\n<li>如果替换成功，则表示没有竞争发生，整个同步过程就完成了</li>\n<li>如果替换失败，则表示当前锁资源存在竞争，有可能其他线程在这段时间里尝试过获取锁失败，导致自身被挂起，并修改了锁对象的mark word升级为重量级锁，最后在执行重量级锁的解锁流程后唤醒被挂起的线程</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302160145523.png\" alt=\"image-20230302160145523\"></p>\n<h4 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h4><p>重量级锁是依赖对象内部的 monitor（监视器&#x2F;管程）来实现的，任意一个对象都有自己的 monitor，而 monitor 又依赖于操作系统底层的 Mutex Lock（互斥锁）实现。使用重量级锁之后，被阻塞的线程便进入内核（Linux）调度状态，系统切换线程需要在用户态与内核态之间来回切换，严重影响锁的性能。</p>\n<p>monitor中的核心概念：</p>\n<ul>\n<li>owner：标识拥有该monitor的线程，初始时和锁被释放后都为null</li>\n<li>cxq (ConnectionList)：竞争队列，所有竞争锁的线程都会首先被放入这个队列中</li>\n<li>EntryList：候选者列表，当owner解锁时会将cxq队列中的线程移动到该队列中</li>\n<li>OnDeck：在将线程从cxq移动到EntryList时，会指定某个线程为Ready状态（即OnDeck），表明它可以竞争锁，如果竞争成功那么称为owner线程，如果失败则放回EntryList中</li>\n<li>WaitSet：因为调用wait()或wait(time)方法而被阻塞的线程会被放在该队列中</li>\n<li>count：monitor的计数器，数值加1表示当前对象的锁被一个线程获取，线程释放monitor对象时减1</li>\n<li>recursions：线程重入次数</li>\n</ul>\n<p>用图来表示线程竞争的的过程：<br><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302160208972.png\" alt=\"image-20230302160208972\"><br>当线程调用wait()方法，将释放当前持有的monitor，将owner置为null，进入WaitSet集合中等待被唤醒。当有线程调用notify()或notifyAll()方法时，也会释放持有的monitor，并唤醒WaitSet的线程重新参与monitor的竞争。</p>\n<p>重量级锁加锁：</p>\n<ol>\n<li>当升级为重量级锁的情况下，锁对象的mark word中的指针不再指向线程栈中的lock record，而是指向堆中与锁对象关联的monitor对象。当多个线程同时访问同步代码时，这些线程会先尝试获取当前锁对象对应的monitor的所有权：<ul>\n<li>获取成功，判断当前线程是不是重入，如果是重入那么recursions+1。<ul>\n<li>获取失败，当前线程会被阻塞，等待其他线程解锁后被唤醒，再次竞争锁对象。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"锁膨胀过程\"><a href=\"#锁膨胀过程\" class=\"headerlink\" title=\"锁膨胀过程\"></a>锁膨胀过程</h4><p><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302160232981.png\" alt=\"image-20230302160232981\"><br>锁膨胀过程中锁对象的 mark word 变化过程：<br><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302160248180.png\" alt=\"image-20230302160248180\"></p>\n<h4 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h4><p>这属于编译器对锁的优化，JIT 编译器在动态编译同步块时，会使用逃逸分析技术，判断同步块的锁对象是否只能被一个对象访问，以及不会逃逸出去从而被其他线程访问到。</p>\n<p>如果确认没有逃逸，JVM就把它们当作栈上数据对待，认为这些数据是线程独有的。JIT 编译器就不会生成 Synchronized 对应的锁申请和释放的机器码，就消除了锁的使用。</p>\n<h4 id=\"锁粗化\"><a href=\"#锁粗化\" class=\"headerlink\" title=\"锁粗化\"></a>锁粗化</h4><p>JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程反复申请、释放同一个锁所带来的性能开销。</p>\n<h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p>final声明的变量，要么在声明语句里面赋值，要么在构造函数里面赋值。如果字段由static和final修饰，仅能在声明时赋值或声明后在静态代码块中赋值。</p>\n<p>写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：</p>\n<ul>\n<li>JMM禁止编译器把final域的写重排序到构造函数之外</li>\n<li>编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</li>\n</ul>\n<p><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302160301472.png\" alt=\"image-20230302160301472\"></p>\n<p>读final域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个LoadLoad屏障。读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。</p>\n<p><img src=\"/2021/03/02/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20230302160314419.png\" alt=\"image-20230302160314419\"></p>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"双重检查锁\"><a href=\"#双重检查锁\" class=\"headerlink\" title=\"双重检查锁\"></a>双重检查锁</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton uniqueSingleton;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> == uniqueSingleton) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> == uniqueSingleton) &#123;</span><br><span class=\"line\">                    uniqueSingleton = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uniqueSingleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意这里不能漏掉volatile修饰，禁止重排序，保证所有的写（write）操作都将发生在读（read）操作之前。</p>\n","categories":["Java","Java并发"],"tags":["Java"]},{"title":"Netty系列（七）：ByteBuf","url":"/2020/06/11/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AByteBuf/","content":"<blockquote>\n<p>上一节我们介绍了 Netty 的通讯通道 Channel，这一节我们开始介绍 Netty 的数据容器 ByteBuf，包括 ByteBuf 的原理、内存管理和常用方法等。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"ByteBuf是什么\"><a href=\"#ByteBuf是什么\" class=\"headerlink\" title=\"ByteBuf是什么\"></a>ByteBuf是什么</h2><p>ByteBuf 是 Netty 的数据容器，简单来说就是申请一块内存，后续可以在这块内存中执行读写数据等操作。相比起 NIO 原生的数据容器 ByteBuffer，ByteBuf 做了许多优化和改进：</p>\n<ul>\n<li>Bytebuffer 只有一个 index，读写公用，写模式到读模式转换需要调用 flip()，设置 index 值；Bytebuf 有读写两个 index,模式转换不用调用 flip()。</li>\n<li>Bytebuffer 不能扩容，每次 put 操作时，都会对可用空间进行校检，如果剩余空间不足，需要重新创建一个新的 ByteBuffer，然后将旧的 ByteBuffer 复制到新的 ByteBuffer 中去；而 ByteBuf 支持自动扩容。</li>\n<li>ByteBuf 用其内置的复合缓冲区可实现透明的零拷贝。</li>\n<li>ByteBuf 支持方法链接调用。</li>\n<li>ByteBuf 支持引用计数。</li>\n<li>ByteBuf 支持池技术(比如：线程池、数据库连接池)。</li>\n</ul>\n<h2 id=\"ByteBuf的工作原理\"><a href=\"#ByteBuf的工作原理\" class=\"headerlink\" title=\"ByteBuf的工作原理\"></a>ByteBuf的工作原理</h2><h3 id=\"ByteBuf的结构\"><a href=\"#ByteBuf的结构\" class=\"headerlink\" title=\"ByteBuf的结构\"></a>ByteBuf的结构</h3><p><strong>ByteBuf 本质是一个由不同的索引分别控制读访问和写访问的字节数组</strong>。以下是官方提供的 ByteBuf 的结构图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">+-------------------+------------------+------------------+</span><br><span class=\"line\">| discardable bytes |  readable bytes  |  writable bytes  |</span><br><span class=\"line\">|                   |     (CONTENT)    |                  |</span><br><span class=\"line\">+-------------------+------------------+------------------+</span><br><span class=\"line\">|                   |                  |                  |</span><br><span class=\"line\">0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span><br></pre></td></tr></table></figure>\n\n<p>ByteBuf 包含三个参数：</p>\n<ul>\n<li>readerIndex：读索引，不超过 writerIndex，调用 <code>readXXX()</code> 或 <code>skipBytes()</code> 方法会移动该索引，调用 <code>getXXX()</code> 方法则不会移动。</li>\n<li>writerIndex：写索引，不超过 capacity，调用 <code>writeXXX()</code> 方法会移动该索引，调用 <code>setXXX()</code> 则不会移动。</li>\n<li>capacity：容量，超过 capacity 后会自动扩容，最大容量不超过 Integer.MAX_VALUE。</li>\n</ul>\n<p>ByteBuf 被起始索引和这三个参数所在的索引分成三部分：</p>\n<ul>\n<li>discardable bytes（可丢弃字节）：范围为 0 ~ readerIndex，这部分字节数据已经被读取完，空间等待回收。</li>\n<li>readable bytes（可读字节）：范围为 readerIndex ~ writerIndex，这部分字节数据已经准备好，等待用户读取。</li>\n<li>writable bytes（可写字节）：范围为 writerIndex ~ capacity，这部分空闲空间可写入字节。</li>\n</ul>\n<h3 id=\"ByteBuf的的工作过程\"><a href=\"#ByteBuf的的工作过程\" class=\"headerlink\" title=\"ByteBuf的的工作过程\"></a>ByteBuf的的工作过程</h3><h4 id=\"1、初始化\"><a href=\"#1、初始化\" class=\"headerlink\" title=\"1、初始化\"></a>1、初始化</h4><p><img src=\"/2020/06/11/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AByteBuf/work1.png\" alt=\"work1\"></p>\n<p>ByteBuf 初始化后 readerIndex 和 writeIndex 的取值一开始都是 0。</p>\n<h4 id=\"2、写入数据\"><a href=\"#2、写入数据\" class=\"headerlink\" title=\"2、写入数据\"></a>2、写入数据</h4><p><img src=\"/2020/06/11/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AByteBuf/work2.png\" alt=\"work2\"></p>\n<p>写入 N 个数据后（N &lt; capacity），writerIndex &#x3D; N。</p>\n<h4 id=\"3、读取数据\"><a href=\"#3、读取数据\" class=\"headerlink\" title=\"3、读取数据\"></a>3、读取数据</h4><p><img src=\"/2020/06/11/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AByteBuf/work3.png\" alt=\"work3\"></p>\n<p>读取 M 个数据后（M &lt; writerIndex），readerIndex &#x3D; M。</p>\n<h4 id=\"4、丢弃数据\"><a href=\"#4、丢弃数据\" class=\"headerlink\" title=\"4、丢弃数据\"></a>4、丢弃数据</h4><p><img src=\"/2020/06/11/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AByteBuf/work4.png\" alt=\"work4\"></p>\n<p>读取完数据后，我们调用 <code>discardReadBytes()</code> 丢弃 0 ~ readerIndex 间的数据，相当于 readerIndex 和 writerIndex 同时向前移动 M 个字节，最后 readerIndex &#x3D; 0，writerIndex &#x3D; N - M。</p>\n<h4 id=\"5、清空数据\"><a href=\"#5、清空数据\" class=\"headerlink\" title=\"5、清空数据\"></a>5、清空数据</h4><p><img src=\"/2020/06/11/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AByteBuf/work5.png\" alt=\"work5\"></p>\n<p>当我们已经读取完所有的数据后，可以调用 <code>clear()</code> 使 ByteBuf 恢复到初始状态，这时候 readerIndex &#x3D; writerIndex &#x3D; 0。</p>\n<h4 id=\"6、注意\"><a href=\"#6、注意\" class=\"headerlink\" title=\"6、注意\"></a>6、注意</h4><ul>\n<li>调用 <code>clear() </code>的开销没有 <code>discardReadBytes() </code>那么大，因为它不需要任何内存复制。</li>\n<li>readerIndex 和 writerIndex 超过边界值，会发生 IndexOutOfBoundException 异常。</li>\n</ul>\n<h2 id=\"ByteBuf的内存管理\"><a href=\"#ByteBuf的内存管理\" class=\"headerlink\" title=\"ByteBuf的内存管理\"></a>ByteBuf的内存管理</h2><h3 id=\"ByteBuf内存类型\"><a href=\"#ByteBuf内存类型\" class=\"headerlink\" title=\"ByteBuf内存类型\"></a>ByteBuf内存类型</h3><p>ByteBuf 按照数据的存储位置，可以分为 <strong>堆缓冲区(HEAP BUFFER)<strong>、</strong>直接缓冲区(DIRECT BUFFER)</strong> 和 **复合缓冲区(COMPOSITE BUFFER)**。</p>\n<ul>\n<li><p>堆缓冲区(HEAP BUFFER)：将数据存储在 JVM 的堆内存中，这些内存需要被 jvm 管理。</p>\n</li>\n<li><p>直接缓冲区(DIRECT BUFFER)：将数据存在  JVM 的堆内存外面，这些内存不需要被 jvm 管理。</p>\n</li>\n<li><p>复合缓冲区(COMPOSITE BUFFER)：以上两种方式的混合。</p>\n</li>\n</ul>\n<h4 id=\"1-1、堆缓冲区\"><a href=\"#1-1、堆缓冲区\" class=\"headerlink\" title=\"1.1、堆缓冲区\"></a>1.1、堆缓冲区</h4><p>最常用的模式，这种模式直接将数据存储在 JVM 的堆空间中，这种情况下 ByteBuf 数组被称为支撑数组（backing array）。</p>\n<blockquote>\n<p>优点：能在没有使用池化的情况下提供快速的分配和释放，非常适合于有遗留的数据需要处理的情况。</p>\n<p>缺点：在 socket 发送前，需要先把数据拷贝到直接缓冲区，导致 IO 效率不高。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 创建支撑数组</span><br><span class=\"line\">ByteBuf buf = new UnpooledHeapByteBuf(ByteBufAllocator.DEFAULT, initalCapacity, maxCapacity);</span><br><span class=\"line\">// 检查 ByteBuf 是否有一个支撑数组，当 hasArray()方法返回 false 时，尝试访问支撑数组将触发一个 UnsupportedOperationException。</span><br><span class=\"line\">if (buf.hasArray()) &#123; </span><br><span class=\"line\">  byte[] array = buf.array();</span><br><span class=\"line\">  // 处理</span><br><span class=\"line\">  handleArray(array);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2、直接缓冲区\"><a href=\"#1-2、直接缓冲区\" class=\"headerlink\" title=\"1.2、直接缓冲区\"></a>1.2、直接缓冲区</h4><p>将数据存储在 JVM 堆以外的内存，需要调用系统级别的 API</p>\n<blockquote>\n<p>优点：免去中间交换的内存拷贝，提高 IO 速度。</p>\n<p>缺点：分配和释放代价大，下文中池化的缓冲区可以缓解这个缺点。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 创建直接缓冲区</span><br><span class=\"line\">ByteBuf buf = new UnpooledDirectByteBuf(ByteBufAllocator.DEFAULT, initalCapacity, maxCapacity);</span><br><span class=\"line\">// buf.hasArray() 为 false表示为这是直接缓冲区</span><br><span class=\"line\">if (!buf.hasArray()) &#123; </span><br><span class=\"line\">  byte[] array = buf.array();</span><br><span class=\"line\">  // 处理</span><br><span class=\"line\">  handleArray(array);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3、复合缓冲区\"><a href=\"#1-3、复合缓冲区\" class=\"headerlink\" title=\"1.3、复合缓冲区\"></a>1.3、复合缓冲区</h4><p>Netty通过ByteBuf的子类 CompositeByteBuf，提供了将多个 buffer 虚拟成一个合并的 Buffer 的技术。CompositeByteBuf 中的 ByteBuf 实例可能同时包含堆缓冲区的和直接缓冲区的。如果 CompositeByteBuf 只含有一个实例，调用 hasArray() 方法会返回这个实例的 hasArray() 方法的值；否则总是返回 false。</p>\n<p>例如一条消息包含 header 和 body 两部分，每条消息需要使用不同的 header 搭配同一个 body，就可以使用复合缓冲区。</p>\n<p>![image-20200706211316006](&#x2F;Users&#x2F;mochuangbiao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20200706211316006.png)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CompositeByteBuf messageBuf = Unpooled.compositeBuffer();</span><br><span class=\"line\">// header使用堆内存每次分配</span><br><span class=\"line\">ByteBuf headerBuf = new UnpooledHeapByteBuf(ByteBufAllocator.DEFAULT, initalCapacity, maxCapacity);</span><br><span class=\"line\">// body需要重复使用，所以使用直接缓冲区，省去每次复制内存导致效率下降</span><br><span class=\"line\">ByteBuf bodyBuf = new UnpooledDirectByteBuf(ByteBufAllocator.DEFAULT, initalCapacity, maxCapacity);</span><br><span class=\"line\">// 将headerBuf和bodyBuf添加到CompositeByteBuf中</span><br><span class=\"line\">messageBuf.addComponents(headerBuf, bodyBuf);</span><br><span class=\"line\">.....</span><br><span class=\"line\">//遍历messageBuf中的ByteBuf</span><br><span class=\"line\">for (ByteBuf buf : messageBuf) &#123;</span><br><span class=\"line\">    System.out.println(buf.toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>按内存对象是否可以重复利用，可以分为 <strong>池化内存(Pooled)</strong> 和 **非池化内存(Unpooled)**。</p>\n<ul>\n<li>池化内存(Pooled)：每次都从预先分配好的内存中去取出一段连续内存封装成一个 ByteBuf 给应用程序使用。</li>\n<li>非池化内存(Unpooled)：每次分配内存的时候，直接调用系统 api，向操作系统申请一块内存。</li>\n</ul>\n<h4 id=\"2-1、池化内存\"><a href=\"#2-1、池化内存\" class=\"headerlink\" title=\"2.1、池化内存\"></a>2.1、池化内存</h4><p>Netty 会先向系统申请一大块内存，通过池化算法管理这块内存，并向上层提供申请内存接口。我们需要使用内存的时候，再通过接口申请一段连续内存封装成一个 ByteBuf 给应用程序使用。</p>\n<blockquote>\n<p>优点：池对象可以回收复用，提高内存分配的效率。</p>\n<p>缺点：需要对预先申请的内存进行管理。</p>\n</blockquote>\n<h4 id=\"2-2、非池化内存\"><a href=\"#2-2、非池化内存\" class=\"headerlink\" title=\"2.2、非池化内存\"></a>2.2、非池化内存</h4><p>同 java 对象的创建销毁过程，直接向 JVM 申请内存创建 ByteBuf 对象，使用完后交给 JVM 进行 gc 回收。</p>\n<blockquote>\n<p>优点：使用简单</p>\n<p>缺点：对象不能复用，创建销毁代价很大。</p>\n</blockquote>\n<h3 id=\"创建ByteBuf实例\"><a href=\"#创建ByteBuf实例\" class=\"headerlink\" title=\"创建ByteBuf实例\"></a>创建ByteBuf实例</h3><h4 id=\"1、ByteBufAllocator\"><a href=\"#1、ByteBufAllocator\" class=\"headerlink\" title=\"1、ByteBufAllocator\"></a>1、ByteBufAllocator</h4><p>Netty 为创建 ByteBuf 实例专门提供了一个接口 <strong>ByteBufAllocator</strong>，该接口有 <strong>PooledByteBufAllocator</strong> 和 <strong>UnpooledByteBufAllocator</strong> 两种实现。前者返回池化实例，后者则直接返回非池化的新实例。</p>\n<p>Netty 默认使用了池化的 ByteBufAllocator，但我们可以在 Bootstrap 配置参数来自定义使用池化还是非池化分配器。</p>\n<p>ByteBufAllocator 适用于可以获取到 channelHandlerContext 或 channel 实例的场景。</p>\n<ul>\n<li>使用 PooledByteBufAllocator 创建 ByteBuf</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 通过 channelHandlerContext 获取 allocator</span><br><span class=\"line\">ByteBufAllocator allocator1 = ctx.alloc();</span><br><span class=\"line\">// 通过 channel 获取 allocator</span><br><span class=\"line\">ByteBufAllocator allocator2 = ctx.channel().alloc();</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回一个直接内存或者堆内存对象，具体实现由 netty 根据环境自动配置</span><br><span class=\"line\">ByteBuf buf = allocator1.buffer();</span><br><span class=\"line\">// 创建直接内存对象</span><br><span class=\"line\">ByteBuf directBuf = allocator1.directBuffer();</span><br><span class=\"line\">// 创建堆内存对象</span><br><span class=\"line\">ByteBuf heapBuf = allocator1.heapBuffer();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 UnpooledByteBufAllocator 创建 ByteBuf</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 在 bootstrap 中配置参数使用 UnpooledByteBufAllocator</span><br><span class=\"line\">bootstrap.option(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT)</span><br><span class=\"line\"></span><br><span class=\"line\">// 后面使用同 PooledByteBufAllocator</span><br><span class=\"line\">ByteBufAllocator allocator1 = ctx.alloc();</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、Unpooled\"><a href=\"#2、Unpooled\" class=\"headerlink\" title=\"2、Unpooled\"></a>2、Unpooled</h4><p>当没有办法获取到 channelHandlerContext 或 channel 实例的时候，推荐使用 Unpooled 类来创建 ByteBuf。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 创建堆内存对象</span><br><span class=\"line\">ByteBuf heapBuf = Unpooled.buffer();</span><br><span class=\"line\">// 创建直接内存对象</span><br><span class=\"line\">ByteBuf directBuf = Unpooled.directBuffer();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ByteBuf引用计数\"><a href=\"#ByteBuf引用计数\" class=\"headerlink\" title=\"ByteBuf引用计数\"></a>ByteBuf引用计数</h3><p>上面谈到 Netty 主要有四种类型的 ByteBuf，其中 UnpooledHeapByteBuf 能够依赖 JVM GC 回收器自动回收；UnpooledDirectByteBuf 除了等 JVM GC，最好也能主动进行回收；而 PooledHeapByteBuf 和 PooledDirectByteBuf，则必须要主动将用完的 bytebuf 放回池里，如果不释放，内存池会越来越大，直到内存溢出。所以，Netty ByteBuf 需要在 JVM 的 GC 机制之外，有自己的引用计数器和回收过程（主要是回收到netty申请的内存池）。</p>\n<p>所有 ByteBuf 的引用计数器初始值为1。可以增加&#x2F;减少 ByteBuf 的引用计数器，当 ByteBuf 的引用计数器为 0 时该对象就会被释放内存或回收到内存池。访问一个被释放的 ByteBuf 会抛 IllegalReferenceCountException 异常。</p>\n<p>ByteBuf 引用计数器的常用方法有：</p>\n<ul>\n<li><code>release()</code>：计数器减1。从 InBound 里读取的 ByteBuf 和自己创建的 ByteBuf 要自己调用 <code>release()</code> 手动释放，写入到 OutBound 的 Bytebuf 例如调用 <code>writeAndFlush()</code> 由 netty 负责释放，不需要手动调用<code>release()</code>。</li>\n<li><code>retain()</code>：计数器加1。在使用派生缓冲区的时候，为了防止源 ByteBuf 突然被释放导致派生缓冲区操作异常，需要调用 <code>retain()</code> 来显示派生缓冲区的存在。</li>\n<li><code>refCnt()</code>：返回计数器的值。</li>\n<li><code>copy()</code>：返回源 ByteBuf 的完全拷贝。该拷贝和源 ByteBuf 完全独立，在新 ByteBuf 上修改不会影响旧 ByteBuf。</li>\n</ul>\n<p>以上方法都是直接在原生内存上进行操作，ByteBuf 还提供了一种视图的方式来读写内容，这种视图被称作<strong>派生缓冲区</strong>。派生缓冲区维护单独的 readIndex、writeIndex 和 markIndex，但与原生 ByteBuf 共享数据和引用计数器，这意味着派生缓冲区的创建开销很低，但是如果修改了其他内容，也同时修改对应的原生 ByteBuf。派生缓冲区的常用方法有：</p>\n<ul>\n<li><code>duplicate()</code>：返回源 ByteBuf 的完全拷贝的派生缓冲区区。该方法内部不会调用 <code>retain()</code> 方法，所以计数器不会增加。</li>\n<li><code>slice()</code>：返回源 ByteBuf 已经写入数据区域的拷贝的派生缓冲区。该方法内部不会调用 <code>retain()</code> 方法，所以计数器不会增加。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>ByteBuf 本质是一个由不同的索引分别控制读访问和写访问的字节数组。</li>\n<li>ByteBuf 有 readerIndex、writerIndex 和 capacity 三个参数，这三个负责控制 ByteBuf 的读写操作。</li>\n<li>ByteBuf 的内存管理，按照数据的存储位置，可以分为堆缓冲区、直接缓冲区和复合缓冲区；按内存对象是否可以重复利用，可以分为池化内存和非池化内存。</li>\n<li>创建 ByteBuf 实例，可以使用 ByteBufAllocator 接口或者 Unpooled 工具类。</li>\n<li>ByteBuf 具有引用计数器的概念，当引用计数器为 0 时 ByteBuf 对象会被回收。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"\">《Netty In Action》</a></p>\n<p><a href=\"https://www.jianshu.com/p/3fbf54b8e8ec\">ByteBuf：Netty的数据容器</a></p>\n<p><a href=\"https://www.dazhuanlan.com/2019/11/09/5dc5cfc71d669/\">ByteBuf工作原理</a></p>\n<p><a href=\"https://www.jianshu.com/p/175cd3644728\">ByteBuf : Netty的数据容器类</a></p>\n","categories":["Netty"],"tags":["Netty"]},{"title":"Java并发系列（二）：线程模型","url":"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/","content":"<blockquote>\n<p>这一篇介绍 java 的线程模型。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h2><p>Java中线程的状态分为6种：</p>\n<ol>\n<li><code>初始(NEW)</code>：新创建了一个线程对象，但还没有调用start()方法。</li>\n<li><code>运行(RUNNABLE)</code>：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li>\n<li><code>阻塞(BLOCKED)</code>：表示线程阻塞于锁。一般是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</li>\n<li><code>等待(WAITING)</code>：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。该状态的线程必须被显式地唤醒，否则会处于无限期等待的状态。</li>\n<li><code>超时等待(TIMED_WAITING)</code>：状态类似于WAITING，但不同于WAITING，它可以在指定的时间后自行返回。</li>\n<li><code>终止(TERMINATED)</code>：表示该线程已经执行完毕。</li>\n</ol>\n<p>线程队列中有两种类型：</p>\n<ul>\n<li><code>同步队列（SynchronizedQueue）</code>：处于BLOCKED状态的线程队列。</li>\n<li><code>等待队列（WatiQueue）</code>：处于WAITING或者TIMED_WAITING状态的线程队列。</li>\n</ul>\n<p>java六种状态的完整变迁图如下：<br><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230307152728759.png\" alt=\"image-20230307152728759\"></p>\n<h2 id=\"线程的实现\"><a href=\"#线程的实现\" class=\"headerlink\" title=\"线程的实现\"></a>线程的实现</h2><p>有三种使用线程的方法：</p>\n<ul>\n<li>实现 Runnable 接口。</li>\n<li>实现 Callable 接口。</li>\n<li>继承 Thread 类。</li>\n</ul>\n<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>\n<h2 id=\"线程方法\"><a href=\"#线程方法\" class=\"headerlink\" title=\"线程方法\"></a>线程方法</h2><h3 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start()\"></a>start()</h3><p>实现 Runnable 接口或者继承 Thread 可以得到一个线程类，new一个实例出来，线程就进入了 NEW 状态。</p>\n<p>调用线程的 start() 方法，线程就进入 RUNNABLE 状态。RUNNABLE状态的线程不一定在运行，有可能处于 READY 状态，也有可能处于 RUNNING 状态，这主要看是否被调度器调度运行。</p>\n<h3 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield()\"></a>yield()</h3><p><code>只能当前线程调用此方法，所以yield()是静态方法</code>。当线程的 CPU 时间片用完或调用 yield() 函数主动放弃 CPU 时间片，由 RUNNING 状态变为 READY 状态，但不释放锁资源，让线程调度器再次选择线程。</p>\n<p>yield()的作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证 yield() 达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield() 不会导致阻塞。该方法与 sleep() 类似，只是不能由用户指定暂停多长时间。</p>\n<h3 id=\"sleep-long-millis\"><a href=\"#sleep-long-millis\" class=\"headerlink\" title=\"sleep(long millis)\"></a>sleep(long millis)</h3><p><code>只能当前线程调用此方法，所以sleep(long millis)是静态方法</code>。当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。</p>\n<p>sleep()的作用：给其它线程执行机会的最佳方式。</p>\n<h3 id=\"join-x2F-join-long-millis\"><a href=\"#join-x2F-join-long-millis\" class=\"headerlink\" title=\"join()&#x2F;join(long millis)\"></a>join()&#x2F;join(long millis)</h3><p><code>当前线程里调用其它线程的join方法</code>。当前线程进入 WAITING&#x2F;TIMED_WAITING 状态，但不会释放已经持有的对象锁。等待其他线程执行完毕或者 millis 时间到，当前线程一般情况下进入 RUNNABLE 状态，也有可能进入 BLOCKED 状态（因为 join 是基于 wait 实现的）。</p>\n<p>join()的作用：等待其他进程完成后再执行下一步动作。</p>\n<h3 id=\"wait-notify-notifyAll\"><a href=\"#wait-notify-notifyAll\" class=\"headerlink\" title=\"wait() notify() notifyAll()\"></a>wait() notify() notifyAll()</h3><p><code>两个不同线程分别调用中间对象的这三个方法</code>：</p>\n<ol>\n<li>线程 A 调用了对象 O 的 wait() 方法进入等待状态，并释放对象锁。</li>\n<li>另一个线程 B 获取对象锁，执行完自己的任务后，调用了对象 O 的 notify() 或者 notifyAll() 方法。</li>\n<li>线程 A 收到通知后，等待线程 B 释放对象锁，重新获取对象锁，然后从对象 O 的 wait() 方法返回，进而执行后续操作。</li>\n</ol>\n<p>上述两个线程通过对象 O 来完成交互，而对象 O 上的 wait() 和 notify&#x2F;notifyAll() 的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</p>\n<p>注意事项：</p>\n<ol>\n<li>使用 wait()、notify() 和 notifyAll() 之前需要先用 synchronized 对调用对象加锁。</li>\n<li>调用 wait() 方法后，线程状态由 RUNNING 变为 WAITING，并将当前线程放置到对象的等待队列。</li>\n<li>notify() 或 notifyAll() 方法调用后，等待线程依旧不会立刻从 wait() 返回，需要调用 notify() 或 notifAll() 的线程释放了锁，等待线程获得了锁之后，才会从 wait() 返回。</li>\n<li>notify() 方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而 notifyAll() 方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由 WAITING 变为 BLOCKED。</li>\n<li>任意一个object以及其子类对象都有两个队列<ul>\n<li>同步队列：所有尝试获取该对象Monitor失败的线程，都加入同步队列排队获取锁。</li>\n<li>等待队列：已经拿到锁的线程在等待其他资源时，主动释放锁，置入该对象等待队列中，等待被唤醒。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"/2021/03/07/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20230307152802376.png\" alt=\"image-20230307152802376\"><br>如上图所示：</p>\n<ol>\n<li>WaitThread 首先获取了对象的锁，然后调用对象的 wait() 方法，从而放弃了锁并进入了对象的等待队列 WaitQueue 中，进入等待状态。</li>\n<li>由于 WaitThread 释放了对象的锁，NotifyThread 随后获取了对象的锁，在执行完自己的任务后，并调用对象的 notify() 方法，将WaitThread 从 WaitQueue 移到 SynchronizedQueue 中，此时WaitThread 的状态变为 BLOCKED 状态。</li>\n<li>NotifyThread 释放了锁之后，WaitThread 再次获取到锁并从 wait() 方法返回继续执行。</li>\n</ol>\n<p>sleep() 和 wait() 的区别：</p>\n<ul>\n<li>释放锁时机不同：wait() 释放锁，sleep() 不释放锁。</li>\n<li>用法不同：sleep() 是 Thread 类的静态方法，在任何地方都能使用；wait() 是 Object 类的方法，必须放在 synchronized 块里面。</li>\n<li>苏醒不同：sleep() 方法睡眠指定时间之后，线程会自动苏醒；<br>wait() 方法被调用后，可以通过 notify() 或 notifyAll() 来唤醒。</li>\n<li>使用场景不同：sleep() 一般用于当前线程休眠，或者轮循暂停操作；wait() 则多用于多线程之间的通信。</li>\n</ul>\n<h3 id=\"interrupt\"><a href=\"#interrupt\" class=\"headerlink\" title=\"interrupt()\"></a>interrupt()</h3><p><code>当前线程里调用其它线程的interrupt()方法</code>。通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于BLOCKED、WAITING 或者TIME_WAITING 状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。</p>\n<h3 id=\"LockSupport\"><a href=\"#LockSupport\" class=\"headerlink\" title=\"LockSupport\"></a>LockSupport</h3><p>LockSupport 是 <code>rt.jar</code> 提供的工具类，用于阻塞或唤醒一个线程，是构建同步组件（AQS、Condition等）的基础工具。LockSupport 定义了一组的公共静态方法，以 <code>park</code> 开头的方法用来阻塞当前线程，以及 <code>unpark(Thread thread)</code>方法来唤醒一个被阻塞的线程。下面是主要函数：</p>\n<ul>\n<li><code>void park()</code>: 阻塞当前线程，如果调用 unpark(Thread thread) 方法或者当前线程被中断，才能从 park()方法返回。</li>\n<li><code>void parkNanos(long nanos)</code>: 阻塞当前线程，最长不超过 nanos 纳秒，返回条件在park() 的基础上增加了超时返回。</li>\n<li><code>void parkUntil(long deadline)</code>: 阻塞当前线程，知道 deadline 时间 （从 1970 年开始到 deadline 时间的毫秒数）。</li>\n<li><code>void unpark(Thread thread)</code>: 唤醒处于阻塞状态的线程 thread。</li>\n<li><code>void park(Object blocker)</code>: 阻塞当前线程，blocker 用来标识当前线程在等待的对象，<code>该对象主要用于问题排查和系统监控</code>。</li>\n<li><code>parkNanos(Object blocker, long nanos)</code>: 比 void park(Object blocker) 增加一个超时时间。</li>\n<li><code>parkUntil(Object blocker, long deadline)</code>: 比 void parkUntil(long deadline)  多一个阻塞当前对象。</li>\n</ul>\n<p><code>LockSupport 的 park 类方法不需要获得锁就可以让线程进入 WAITING/TIMED_WAITING 状态</code>，因此可以在任何地方执行，比 wait 方法更灵活。</p>\n<h3 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h3><p>任意一个 Java 对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括 wait()、wait(long timeout)、notify() 以及 notifyAll() 方法，这些方法与 synchronized 同步关键字配合，可以实现等待&#x2F;通知模式。</p>\n<p>Condition 接口也提供了类似 Object 的监视器方法，await()、signal() 和 signalAll() 方法分别对应 Object 的 wait()、notify() 和 notifyAll() 方法。Condition 底层是使用 LockSupport 工具来实现的。</p>\n<p>Condition 的主要函数有：</p>\n<ul>\n<li><code>void await()</code>：当前线程进入等待状态直到被通知（signal）或中断。如果当前等待线程从 await() 方法返回，那么表明该线程已经获取了Condition 对象所对应的锁。当前线程从 await() 方法返回的情况包括：1、其他线程调用该 Condition 的 signal() 或 signalAll() 方法 ，而当前线程被选中唤醒；2、其他线程调用 Interrupt()方法中断当前线程</li>\n<li><code>void awaitUninterruptibly()</code>：当前线程进入等待状态被通知，从方法返回名称上可以看出该方法对中断不敏感</li>\n<li><code>long awaitNanos(long nanosTimeout)</code>：当前线程进入等待状态直到被通知，中断或者超时。返回值表示剩余的时间，如果在 nanosTimeout 纳秒之前被唤醒，那么返回值就是 （nanosTimeout-实际耗时）。如果返回 0 或者负数，那么可以认定已经超时了</li>\n<li><code>boolean awaitUntil(Date deadline)</code>：当前线程进入等待状态知道被通知、中断或者到某一个时间。如果没有到指定时间就被通知，方法返回 true ，否则，表示到了指定时间，方法返回 false。</li>\n<li><code>void signal()</code>：唤醒一个等待在 Condition 上的线程，该线程从等待方法返回前必须获得与 Condition 相关的锁</li>\n<li><code>void signalAll()</code>：唤醒所有等待在 Condition 上的线程，能够从等待方法返回的线程必须获得与 Condition相关的锁</li>\n</ul>\n<p>Condition 一般和 Lock 的实现类一起搭配使用，获取一个 Condition 必须通过 Lock 的 <code>newCondition()</code> 方法。</p>\n<blockquote>\n<p>Thread.sleep()、Object.wait() 和 LockSupport.park() 的区别？</p>\n</blockquote>\n<p>这三个方法都会使线程变成 <code>WAITING</code> 状态，他们的区别是：</p>\n<ol>\n<li>锁资源：Thread.sleep() 和 LockSupport.park() 不会释放占有的锁；Object.wait() 会释放占有的锁。</li>\n<li>传参：Thread.sleep() 必须传入时间，时间了会自动唤醒，然后继续执行；LockSupport.park()&#x2F;Object.wait() 可传可不传，不传会一直阻塞下去，直到被另外一个线程使用。Object.notify()&#x2F;LockSupport.unpark() 唤醒。</li>\n<li>唤醒执行：Thread.sleep()时间到了会继续执行；LockSupport.park()超时或者被LockSupport.unpark()唤醒后也会立刻执行；Object.wait()超时了或者被 Object.notify() 不一定会立刻执行，要等到获取锁资源才会立刻执行。</li>\n<li>使用场地：Thread.sleep() 和 LockSupport.park() 都是静态方法，可以随时执行，Object.wait()需要使用 synchronized 获取锁才能执行。</li>\n<li>异常：Thread.sleep() 和 Object.wait() 需要捕获异常，LockSupport.park()不需要捕获中断异常。</li>\n<li>实现：Thread.sleep() 和 Object.wait() 本身就是 native 方法；LockSupport.park() 底层是调用的 Unsafe 的 native 方法。</li>\n</ol>\n<blockquote>\n<p>Object.wait()和Condition.await()，以及Object.notify()和Condition.signal()的区别？</p>\n</blockquote>\n<p>Object.wait()和Condition.await()的原理是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。 实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"等待-x2F-通知的经典范式\"><a href=\"#等待-x2F-通知的经典范式\" class=\"headerlink\" title=\"等待&#x2F;通知的经典范式\"></a>等待&#x2F;通知的经典范式</h3><p>等待方遵循如下原则：</p>\n<ol>\n<li>获取对象的锁。</li>\n<li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</li>\n<li>条件满足则执行对应的逻辑。</li>\n</ol>\n<p>对应的伪代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(对象) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(条件不满足) &#123;</span><br><span class=\"line\">        对象.wait();</span><br><span class=\"line\">    &#125; 对应的处理逻辑</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通知方遵循如下原则。</p>\n<ol>\n<li>获得对象的锁。</li>\n<li>改变条件。</li>\n<li>通知所有等待在对象上的线程。</li>\n</ol>\n<p>对应的伪代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(对象) &#123;</span><br><span class=\"line\">    改变条件</span><br><span class=\"line\">    对象.notifyAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Java","Java并发"],"tags":["Java"]},{"title":"Java并发系列（四）：并发容器","url":"/2021/03/08/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/","content":"<blockquote>\n<p>这一篇介绍 java 的并发容器</p>\n</blockquote>\n<span id=\"more\"></span>\n\n\n\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>JCU 包里面几乎所有的有关锁、多线程并发以及线程同步器等重要组件的实现都是基于 AQS 这个框架。</p>\n<ul>\n<li><code>ReentrantLock</code>\t使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</li>\n<li><code>Semaphore</code>\t使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</li>\n<li><code>CountDownLatch</code>\t使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</li>\n<li><code>ReentrantReadWriteLock</code>\t使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</li>\n<li><code>ThreadPoolExecutor</code>\t线程被封装成内部类 Worker，Worker 实现了 Runnable 接口和继承了 AQS，使用 state 表示线程的运行状态。</li>\n</ul>\n<h1 id=\"并发工具\"><a href=\"#并发工具\" class=\"headerlink\" title=\"并发工具\"></a>并发工具</h1><h2 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h2><p><code>ReentrantLock</code> 是 java 中 Lock 接口的实现类，是支持重入功能的互斥锁。相比于 <code>synchronized</code> 加锁，ReentrantLock 增加了以下功能：</p>\n<ul>\n<li>等待可中断</li>\n<li>可实现公平锁</li>\n<li>可绑定多个条件</li>\n<li>可限定最大等待时间</li>\n</ul>\n<p>所以 ReentrantLock 的使用比 synchronized 更加灵活。ReentrantLock 在 AQS 的基础上，对外只提供 lock() &#x2F; unlock() 这些最简单的 API，至于具体实现过程使用锁的用户不需要关心，大大降低了使用难度。<br><img src=\"/2021/03/08/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/image-20230307155742094.png\" alt=\"image-20230307155742094\"></p>\n<h3 id=\"ReentrantLock的实现\"><a href=\"#ReentrantLock的实现\" class=\"headerlink\" title=\"ReentrantLock的实现\"></a>ReentrantLock的实现</h3><p><img src=\"/2021/03/08/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/image-20230307155755036.png\" alt=\"image-20230307155755036\"></p>\n<p>ReentrantLock 的大致实现：</p>\n<ul>\n<li>有一个 <code>Sync</code> 类型的成员属性 <code>sync</code>，所有的方法都是调用该属性的方法。<code>Sync</code> 继承 AbstractQueuedSynchronizer（简称 AQS），AQS 封装了锁和线程等待队列的基本实现。</li>\n<li>Sync 有两个子类 <code>NonfairSync</code> 和 <code>FairSync</code>，分别对应非公平锁和公平锁。</li>\n<li>AQS 内部使用 volatile int state表示同步状态，在 ReentrantLock 中 state 表示占有线程对锁的持有数量，为 0 表示锁未被持有，为 1 表示锁被某个线程持有，&gt; 1 表示锁被某个线程持有多次（即重入）。</li>\n</ul>\n<p>NonfairSync 和 Sync 在 state &#x3D; 0 的时候，尝试获取锁的时候的逻辑有所不同，锁的释放等其他逻辑都是相同的：</p>\n<ul>\n<li>如果当前线程不是锁的占有者，则 NonfairSync 直接使用 compareAndSwap 去进行锁的占用，并不判断是否有同步队列。如果锁是由当前线程释放的（时间片用完或者被中断退出），但当前线程的业务逻辑没有完成，当前线程继续参与下一轮锁竞争的时候极有可能会继续获取锁成功（因为可以减少线程切换开销，线程调度器更倾向于当前线程），所以才叫非公平锁，容易会造成其他线程饥饿。</li>\n<li>如果当前线程不是锁的占有者,则 FairSync 需要检查当前线程是否是同步队列的第一个，如果不是的话就获取锁失败，然后把当前线程线程放到同步队列的队尾。</li>\n</ul>\n<p>如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了，否则那就用公平锁还大家一个公平。</p>\n<p><img src=\"/2021/03/08/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/image-20230307155808340.png\" alt=\"image-20230307155808340\"></p>\n<p>在代码上的实现更加简单，公平锁只比非公平锁多了 <code>!hasQueuedPredecessors()</code> 一个判断，<code>hasQueuedPredecessors()</code> 这个方法在当前线程是同步队列的第一个元素或者同步队列为空的时候才会返回 false，<code>!hasQueuedPredecessors()</code> 才为true，才会进行后面的逻辑。Sync 保证了没有线程等待时间超过当前线程，保证了 FIFO 先进先出的公平性。</p>\n<h3 id=\"ReentrantLock的使用\"><a href=\"#ReentrantLock的使用\" class=\"headerlink\" title=\"ReentrantLock的使用\"></a>ReentrantLock的使用</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BoundedBuffer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Lock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">    <span class=\"comment\">// notFull 是 buffer 没有到最大值的条件</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">notFull</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\">    <span class=\"comment\">// notEmpty 是 buffer 不为空的条件</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">notEmpty</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// buffer 最大值为 100</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] items = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[<span class=\"number\">100</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> putptr, takeptr, count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(Object x)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count == items.length)</span><br><span class=\"line\">                <span class=\"comment\">// buffer 满了就挂起，直到收到 notFull 的信号</span></span><br><span class=\"line\">                notFull.await();</span><br><span class=\"line\">            items[putptr] = x;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++ putptr == items.length) putptr = <span class=\"number\">0</span>;</span><br><span class=\"line\">            ++ count;</span><br><span class=\"line\">            <span class=\"comment\">// buffer 新增 item，发送 notEmpty 信号</span></span><br><span class=\"line\">            notEmpty.signal();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"comment\">// buffer 为空就挂起，直到收到 notEmpty 的信号</span></span><br><span class=\"line\">                notEmpty.await();</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> items[takeptr];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++ takeptr == items.length) takeptr = <span class=\"number\">0</span>;</span><br><span class=\"line\">            -- count;</span><br><span class=\"line\">            <span class=\"comment\">// buffer 取走 item，发送 notFull 信号</span></span><br><span class=\"line\">            notFull.signal();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假如线程A和线程B使用同一个锁LOCK，此时线程A首先获取到锁LOCK.lock()，并且始终持有不释放。如果此时B要去获取锁，有四种方式：</p>\n<ul>\n<li>LOCK.lock(): 此方式会始终处于等待中，即使调用B.interrupt()也不能中断，除非线程A调用LOCK.unlock()释放锁。</li>\n<li>LOCK.lockInterruptibly(): 此方式会等待，但当调用B.interrupt()会被中断等待，并抛出InterruptedException异常，否则会与lock()一样始终处于等待中，直到线程A释放锁。</li>\n<li>LOCK.tryLock(): 该处不会等待，获取不到锁并直接返回false，去执行下面的逻辑。</li>\n<li>LOCK.tryLock(10, TimeUnit.SECONDS)：该处会在10秒时间内处于等待中，但当调用B.interrupt()会被中断等待，并抛出InterruptedException。10秒时间内如果线程A释放锁，会获取到锁并返回true，否则10秒过后会获取不到锁并返回false，去执行下面的逻辑。</li>\n</ul>\n<blockquote>\n<p>Lock和TryLock的区别</p>\n<ol>\n<li>lock拿不到锁会一直等待。tryLock是去尝试，拿不到就返回false，拿到返回true。</li>\n<li>tryLock是可以被打断的，被中断的，lock是不可以。</li>\n</ol>\n</blockquote>\n<p>参考 <a href=\"https://www.jianshu.com/p/d1cee89c1dda\">线程安全之 ReentrantLock 完全解析</a><br><a href=\"https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html\">从ReentrantLock的实现看AQS的原理及应用\n</a></p>\n<h2 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a>ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock 是 JCU 包中读写锁接口 ReadWriteLock 的重要实现类。ReentrantReadWriteLock 同时实现了共享锁和互斥锁的功能，它提供<code>Read Lock（读锁）</code>和<code>Write Lock（写锁）</code>两种锁，可以实现读共享 + 写互斥功能。<br>线程进入读锁的前提条件：</p>\n<ul>\n<li>没有其他线程的写锁。</li>\n<li>持有写锁的线程和想加读锁的线程是同一个线程，这时候会发生锁降级，即写锁降级成为读锁。</li>\n</ul>\n<p>线程进入写锁的前提条件：</p>\n<ul>\n<li>没有其他线程的读锁。</li>\n<li>没有其他线程的写锁。</li>\n</ul>\n<p>读写锁有以下三个重要的特性：</p>\n<ol>\n<li>公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</li>\n<li>重进入：读锁和写锁都支持线程重进入。</li>\n<li>锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。</li>\n</ol>\n<h3 id=\"ReentrantReadWriteLock实现\"><a href=\"#ReentrantReadWriteLock实现\" class=\"headerlink\" title=\"ReentrantReadWriteLock实现\"></a>ReentrantReadWriteLock实现</h3><p><img src=\"/2021/03/08/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/image-20230307155833819.png\" alt=\"image-20230307155833819\"></p>\n<p>ReentrantReadWriteLock 的内部结构如上所示：</p>\n<ul>\n<li><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> 接口，需要实现 <code>readLock()</code> 和 <code>writeLock()</code> 两个方法。不同于一般的 <code>Lock</code> 接口实现类只需要实现一个锁，<code>ReadWriteLock</code> 接口实现类需要实现读锁和写锁两个锁。</li>\n<li><code>ReentrantReadWriteLock</code> 的内部类 <code>Sync</code> 继承了 <code>AQS</code>，可以实现重入的功能。<code>Sync</code> 还有两个子类 <code>NonfairSync</code> 和 <code>FairSync</code> 分别实现了非公平锁和公平锁的功能，以上和 ReentrantLock 的实现思路相同。</li>\n<li>注意 <code>ReentrantReadWriteLock</code> 本身并没有实现 <code>Lock</code> 接口，所以 <code>ReentrantReadWriteLock</code> 本身并没有提供 <code>lock()/tryLock()</code> 这些方法，但 <code>ReentrantReadWriteLock</code> 提供一个全局的 <code>Sync</code> 类的属性 <code>sync</code>。<code>ReentrantReadWriteLock</code> 的内部类 <code>ReadLock</code> 和 <code>WriteLock</code> 实现了 <code>Lock</code> 接口，内部使用了同一个属性 <code>sync</code>，所以两者的实现方法 <code>lock()/tryLock()</code> 都基于同一个属性 <code>sync</code>，也就是基于同一个 <code>sync</code> 内部的 <code>state</code> 状态。</li>\n<li><code>ReadLock</code> 调用了 <code>sync</code> 的 <code>acquireShared/releaseShared</code> 方法，实现了共享锁功能；而 <code>WriteLock</code> 调用了 <code>sync</code> 的 <code>acquire/release</code> 方法，实现了互斥锁功能。</li>\n</ul>\n<p>看完上面你可能会好奇，一个 int 类型的 state 变量怎么可以同时被两个锁使用呢？<code>int 类型的变量的长度是 32 位，分割成高 16 位和低 16 位，分别表示读状态和写状态</code>。<br><img src=\"/2021/03/08/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/image-20230307155846095.png\" alt=\"image-20230307155846095\"></p>\n<p>当前同步状态表示一个线程已经获取了写锁，且重进入了2次，同时也连续获取了两次读锁。同步状态是通过位运算进行更新的，假设当前同步状态是S，写状态等于S &amp; EXCLUSIVE_MASK，即S &amp; 0x0000FFFF，读状态等于S &gt;&gt;&gt; 16.当写状态加1时，等于S+1，当读状态加1时，等于S+SHARED_UNIT，即S+(1 &lt;&lt; 16)，也就是S + 0x00010000。<br>即读锁和写锁的状态获取和设置如下：</p>\n<ul>\n<li>读锁状态的获取：S &gt;&gt; 16</li>\n<li>读锁状态的增加：S + (1 &lt;&lt; 16)</li>\n<li>写锁状态的获取：S &amp; 0x0000FFFF</li>\n<li>写锁状态的增加：S + 1</li>\n</ul>\n<p><code>锁降级</code>是指写锁降级成为读锁。如果当前线程先获取写锁，然后释放写锁，再获取读锁，这个分段完成的过程不能称之为锁降级。<code>锁降级是指先获取写锁，再获取读锁，然后释放写锁的次序</code>。</p>\n<h3 id=\"ReentrantReadWriteLock的使用\"><a href=\"#ReentrantReadWriteLock的使用\" class=\"headerlink\" title=\"ReentrantReadWriteLock的使用\"></a>ReentrantReadWriteLock的使用</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Counter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ReadWriteLock</span> <span class=\"variable\">rwlock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantReadWriteLock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Lock</span> <span class=\"variable\">rlock</span> <span class=\"operator\">=</span> rwlock.readLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Lock</span> <span class=\"variable\">wlock</span> <span class=\"operator\">=</span> rwlock.writeLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span>[] counts = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">inc</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        wlock.lock(); <span class=\"comment\">// 加写锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            counts[index] += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            wlock.unlock(); <span class=\"comment\">// 释放写锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] get() &#123;</span><br><span class=\"line\">        rlock.lock(); <span class=\"comment\">// 加读锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            rlock.unlock(); <span class=\"comment\">// 释放读锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参考 <a href=\"https://blog.csdn.net/qq_38293564/article/details/80533821\">Java并发编程之ReentrantReadWriteLock详解</a><br><a href=\"https://segmentfault.com/a/1190000015768003\">图解ReentrantReadWriteLock实现分析</a><br><a href=\"https://juejin.cn/post/6844903680370556941\">Java并发（7）- 你真的了解 ReentrantReadWriteLock 吗？</a></p>\n<h2 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h2><p>CountDownLatch 的功能是允许一个或多个线程等待其他线程完成操作。一般有两个使用场景：</p>\n<ul>\n<li>让多个线程等待，例如模拟并发，让多个并发线程等待到同一个时间点一起执行。实现过程：<ol>\n<li>创建CountDownLatch并设置计数器值，值为1。</li>\n<li>启动多线程，每个线程调用 await() 方法，子线程会在这里阻塞住。</li>\n<li>主线程调用 countDown() 方法，这样所有线程就可以一起往下执行。</li>\n</ol>\n</li>\n<li>让单个线程等待，例如一个线程等待多个线程完成后，进行汇总合并。实现过程：<ol>\n<li>创建CountDownLatch并设置计数器值，值和线程数相同。</li>\n<li>启动多线程，每个线程调用 countDown() 方法。</li>\n<li>主线程调用 await() 方法，这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务，count值为0，主线程继续执行。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"CountDownLatch实现\"><a href=\"#CountDownLatch实现\" class=\"headerlink\" title=\"CountDownLatch实现\"></a>CountDownLatch实现</h3><p>CountDownLatch 的内部类 Sync 实现了 AQS 的共享模式，所以实现了 <code>tryAcquireShared/tryReleaseShared</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">int</span> <span class=\"title function_\">tryAcquireShared</span><span class=\"params\">(<span class=\"type\">int</span> acquires)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// state变量的值为0时才会返回1，否则返回-1。在共享模式里面，返回大于0表示获取锁成功，返回小于0表示获取锁失败</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (getState() == <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryReleaseShared</span><span class=\"params\">(<span class=\"type\">int</span> releases)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// for(;;) 与 while(true) 一样的死循环</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取state同步变量值</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> getState();</span><br><span class=\"line\">        <span class=\"comment\">// 如果state同步变量值已经是0，则返回false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 将state同步变量值进行减一</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">nextc</span> <span class=\"operator\">=</span> c-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 使用AQS提供的CAS算法方法更新state变量值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(c, nextc))</span><br><span class=\"line\">            <span class=\"comment\">// 如果nextc等于0，代表此时state同步变量值为0了，返回true</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> nextc == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后 CountDownLatch 的实现方法 <code>await()/countDown()</code> 再分别调用 <code>sync</code> 里面的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用Sync内部类的父类AQS的模版方法 acquireSharedInterruptibly()方法</span></span><br><span class=\"line\">    sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">countDown</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用Sync内部类的父类AQS的 releaseShared()共享锁释放模版方法</span></span><br><span class=\"line\">    sync.releaseShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为初始化 state 值是大于 0 的整数，线程拿到锁后要把 state 的值减 1，和互斥锁拿到锁后要把 state 值加 1 不同，这里要使用逆向思维：</p>\n<ul>\n<li><code>countDown()</code> 是子线程调用的，用于将 state 值减1，这是一个释放锁的操作，所以调用了 <code>sync</code> 的 <code>tryReleaseShared()</code> 方法，没有被阻塞继续往下执行；而在互斥锁里面子线程一般会调用 <code>acquireShared()</code> 方法获取锁然后被阻塞。</li>\n<li><code>await()</code> 是被阻塞线程调用的。因为这是一个获取锁的操作，所以调用了 <code>sync</code> 的 <code>tryAcquireShared()</code> 方法。</li>\n</ul>\n<h3 id=\"CountDownLatch的使用\"><a href=\"#CountDownLatch的使用\" class=\"headerlink\" title=\"CountDownLatch的使用\"></a>CountDownLatch的使用</h3><p>使用 CountDownLatch 同时启动多个线程，实现最大的并行性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CountDownLatchTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">CountDownLatch</span> <span class=\"variable\">countDownLatch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 启动了10个线程，但10个线程启动后都被阻塞了，2s后才开始执行业务</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker1</span>(countDownLatch)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;wait for starting...&quot;</span>);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker1</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CountDownLatch countDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\">    Worker1(CountDownLatch countDownLatch) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.countDownLatch = countDownLatch;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; start &quot;</span> + System.currentTimeMillis());</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h2><p>CountDownLatch 可以实现多个线程等待一个执行条件满足后再继续往下执行，但是他在某些场景下不能很好的适用：</p>\n<ul>\n<li>CountDownLatch 只能使用一次，如果需要多次使用只能创建多个 CountDownLatch 实例。</li>\n<li>CountDownLatch 需要显式使用 countDown() 去唤醒被阻塞的线程。</li>\n</ul>\n<p>CyclicBarrier 又名为循环屏障，功能类似于 CountDownLatch，但是比 CountDownLatch 更强大一点。<code>CyclicBarrier 在多个线程到达屏障后会自动释放线程，而且会自动重置屏障，也就是说 CyclicBarrier 可以多次使用</code>。</p>\n<h3 id=\"CyclicBarrier实现\"><a href=\"#CyclicBarrier实现\" class=\"headerlink\" title=\"CyclicBarrier实现\"></a>CyclicBarrier实现</h3><p>CyclicBarrier 的实现并没有使用内部类继承 AQS，而是直接使用 <code>ReentrantLock + Condition</code> 来实现整个同步逻辑。CyclicBarrier 的主要属性：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重入锁</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"><span class=\"comment\">// 条件锁，名称为trip，绊倒的意思，可能是指线程来了先绊倒，等达到一定数量了再唤醒</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">Condition</span> <span class=\"variable\">trip</span> <span class=\"operator\">=</span> lock.newCondition();</span><br><span class=\"line\"><span class=\"comment\">// 需要等待的线程数量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> parties;</span><br><span class=\"line\"><span class=\"comment\">// 当唤醒的时候执行的命令</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable barrierCommand;</span><br><span class=\"line\"><span class=\"comment\">// 代</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">Generation</span> <span class=\"variable\">generation</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Generation</span>();</span><br><span class=\"line\"><span class=\"comment\">// 当前这一代还需要等待的线程数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> count;</span><br></pre></td></tr></table></figure>\n<p><code>Generation</code> 是 CyclicBarrier 的内部类，表示代的概念，因为 CyclicBarrier 是可以复用的，那么每次所有的线程通过了栅栏，就表示一代过去了，<code>Generation</code> 就会被自动重置。下一代开始，依然需要相同数目的线程到达栅栏才会释放。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Generation</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">broken</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CyclicBarrier的工作流程：</p>\n<ol>\n<li>假如初始时 <code>count = parties = 5</code>，当第一个线程到达栅栏处，count减1，然后把它加入到 Condition 的等待队列中，第二个线程到达栅栏处也是如此，如此重复。</li>\n<li>最后一个线程到达栅栏处，count 减为 0，调用 Condition 的 <code>signalAll()</code> 唤醒其他所有线程，所有线程从 Condition 的等待队列被加入 AQS 的同步队列。</li>\n<li>等待当前线程运行完毕，调用 <code>lock.unlock()</code> 的时候依次从 AQS 的等待队列中唤醒一个线程继续运行，也就是说实际上线程先依次（排队）到达栅栏处，再依次往下运行。</li>\n</ol>\n<p>CyclicBarrier 和 CountDownLatch 两者都能实现阻塞一组线程等待被唤醒，两者的区别：</p>\n<ol>\n<li>CyclicBarrier 是最后一个线程到达时自动唤醒；CountDownLatch 需要通过显式地调用 countDown() 来唤醒。</li>\n<li>CyclicBarrier 基于 <code>ReentrantLock + Condition</code> 来实现；CountDownLatch 基于 AQS 来实现。</li>\n<li>CyclicBarrier 具有「代」的概念，可以重复使用；CountDownLatch 只能使用一次。</li>\n<li>CyclicBarrier 只能实现多个线程到达栅栏处一起运行，但是可以携带一个在栅栏处执行的任务；CountDownLatch 不仅可以实现多个线程等待一个线程条件成立，还能实现一个线程等待多个线程条件成立</li>\n</ol>\n<h3 id=\"CyclicBarrier的使用\"><a href=\"#CyclicBarrier的使用\" class=\"headerlink\" title=\"CyclicBarrier的使用\"></a>CyclicBarrier的使用</h3><p>实现五个线程到达栅栏后再同时执行，注意每个线程在唤醒前的 sleep 时间是不同的，但是最终打印是同时打印的（都等到最大等待时长5s后打印），而且这个栅栏可以循环使用，每次打印完都会重置栅栏。                    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CylicBarrierTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">CyclicBarrier</span> <span class=\"variable\">cyclicBarrier</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CyclicBarrier</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker2</span>(cyclicBarrier, i)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker2</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CyclicBarrier cyclicBarrier;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> sleepSecond;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">lastFinishTime</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    Worker2(CyclicBarrier cyclicBarrier, <span class=\"type\">int</span> sleepSecond) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sleepSecond = sleepSecond;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; ; ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(sleepSecond * <span class=\"number\">1000</span>);</span><br><span class=\"line\">                cyclicBarrier.await();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; wait &quot;</span> + (System.currentTimeMillis() - lastFinishTime) + <span class=\"string\">&quot; execute at &quot;</span>+ System.currentTimeMillis());</span><br><span class=\"line\">            lastFinishTime = System.currentTimeMillis();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参考 <a href=\"https://www.cnblogs.com/tong-yuan/p/CyclicBarrier.html\">死磕 java同步系列之CyclicBarrier源码解析——有图有真相</a></p>\n<h2 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h2><p>Semaphore 可以限制指定数量的线程线程同时访问一个资源，可以用于流量控制和资源控制。</p>\n<h3 id=\"Semaphore实现\"><a href=\"#Semaphore实现\" class=\"headerlink\" title=\"Semaphore实现\"></a>Semaphore实现</h3><p><img src=\"/2021/03/08/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/image-20230307155907367.png\" alt=\"image-20230307155907367\"><br>Semaphore 内部有 3 个类，继承了 AQS。一个公平锁，一个非公平锁，这点和 ReentrantLock 一摸一样。</p>\n<p>Semaphore 有两个重要的方法，<code>acquire</code> 用于获取令牌，<code>release</code> 用于释放令牌。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">semaphore.acquire();</span><br><span class=\"line\">// doSomeing.....</span><br><span class=\"line\">semaphore.release();</span><br></pre></td></tr></table></figure>\n\n<p>如果你看过 ReentrantLock 的源码，Semaphore 的源码还是非常简单的。</p>\n<h3 id=\"Semaphore的使用\"><a href=\"#Semaphore的使用\" class=\"headerlink\" title=\"Semaphore的使用\"></a>Semaphore的使用</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SemaphoreTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Semaphore</span> <span class=\"variable\">semaphore</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker3</span>(semaphore)).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker3</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore semaphore;</span><br><span class=\"line\"></span><br><span class=\"line\">    Worker3(Semaphore semaphore) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.semaphore = semaphore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; ; ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                semaphore.acquire();</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; get permit&quot;</span>);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                semaphore.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考 <a href=\"https://juejin.cn/post/7042287897931677726\">一看就懂的Semaphore源码分析</a></p>\n<h2 id=\"Phaser\"><a href=\"#Phaser\" class=\"headerlink\" title=\"Phaser\"></a>Phaser</h2><p>Phaser（移相器，一种电子元件）是JDK7中引入的新的并发工具辅助类，oralce 官网文档描述 Phaser 是一个可重复使用的同步栅栏，功能上与 CountDownLatch 和 CyclicBarrier 类似但支持的场景更加灵活，这个类可能是目前并发包里面实现最复杂的一个了。</p>\n<p>Phaser 并没有采用 AQS 同步框架实现，而是单独定义了相关功能api，其中state采用64位的long类型表示，然后64bit又分成4个定义分别代表没有到达栅栏的数量（0-15bit），注册的数量（16-31bit），栅栏的代数量（32-62bit），最后一位（63bit）代表当前的Phaser是否是终止状态，这也意味着我们能够注册的最大数量不能超过65535，否则会抛出不合法参数异常，这一点在使用时需要注意。</p>\n<p><img src=\"/2021/03/08/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/image-20230307155918250.png\" alt=\"image-20230307155918250\"></p>\n<p>参考 <a href=\"https://cloud.tencent.com/developer/article/1350849\">理解Java并发工具类Phaser</a></p>\n<h2 id=\"Exchanger\"><a href=\"#Exchanger\" class=\"headerlink\" title=\"Exchanger\"></a>Exchanger</h2><p>Exchanger 可以在两个线程之间交换数据，只能是2个线程，他不支持更多的线程之间互换数据。它提供一个同步点，在这个同步点两个线程建议交换彼此的数据。</p>\n<p>这两个线程通过 exchange 方法交换数据：第一个线程先执行 exchange() 方法，它会一直等待第二个线程也执行 exchange 方法，等两个线程都到达同步点，这两个线程就可以交换数据。</p>\n<p>Exchanger 可以用于校对工作，比如我们需要将纸质银行流水人工录入成电子银行流水，为了避免错误，采用 AB 岗两人录入，录入完再对比是否一致。</p>\n<h1 id=\"并发集合\"><a href=\"#并发集合\" class=\"headerlink\" title=\"并发集合\"></a>并发集合</h1><h2 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap 是线程安全的 map 容器，其中利用了锁分段的思想提高了并发度。线程安全的 map 其实还有其他实现类（例如ConcurrentSkipListMap），但 ConcurrentHashMap 是最常用的 map 实现类。</p>\n<h3 id=\"1-7和1-8版本的区别\"><a href=\"#1-7和1-8版本的区别\" class=\"headerlink\" title=\"1.7和1.8版本的区别\"></a>1.7和1.8版本的区别</h3><p>ConcurrentHashMap 在 jdk1.7 以前和 jdk1.8 以后的实现方法大大不同。</p>\n<p>jdk1.7 版本中采用 <code>Segment</code> + <code>HashEntry</code> 的方式进行实现：</p>\n<ul>\n<li>Segment 继承了 ReentrantLock 充当锁的角色，为每一个 Segment 提供了线程安全的保障；</li>\n<li>每个 Segment包含一个 HashEntry 数组，每个 HashEntry 元素都是链表结构。</li>\n</ul>\n<p><img src=\"/2021/03/08/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/image-20230307155932768.png\" alt=\"image-20230307155932768\"></p>\n<p>jdk1.8 版本放弃了 <code>Segment</code> 臃肿的设计，取而代之的是采用 <code>Node + CAS + Synchronized</code> 来保证并发安全。至于为什么不用 ReentrantLock 而是 Synchronzied 呢？实际上，synchronzied 做了很多的优化，包括偏向锁，轻量级锁，重量级锁等，在某种程度上，使用 synchronized 相较于 ReentrantLock 的性能会持平甚至在某些情况更优。另外，底层数据结构改变为采用 <code>数组+链表+红黑树</code> 的数据形式，这种设计其实与 HashMap 趋于类似。<br><img src=\"/2021/03/08/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/image-20230307155945152.png\" alt=\"image-20230307155945152\"></p>\n<h3 id=\"内部关键属性、类和方法\"><a href=\"#内部关键属性、类和方法\" class=\"headerlink\" title=\"内部关键属性、类和方法\"></a>内部关键属性、类和方法</h3><p>在了解ConcurrentHashMap的具体方法实现前，我们需要系统的来看一下几个关键的地方。</p>\n<p>ConcurrentHashMap的关键属性：</p>\n<ul>\n<li><code>table</code>：volatile Node&lt;K,V&gt;[] table，装载Node的数组，作为ConcurrentHashMap的数据容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为2的幂次方。</li>\n<li><code>nextTable</code>：volatile Node&lt;K,V&gt;[] nextTable，扩容时使用，平时为null，只有在扩容的时候才为非null</li>\n<li><code>sizeCtl</code>：volatile int sizeCtl，该属性用来控制table数组的大小，根据是否初始化和是否正在扩容有几种情况：<ul>\n<li>当值为负数时：如果为-1表示正在初始化，如果为-N则表示当前正有N-1个线程进行扩容操作；</li>\n<li>当值为正数时：如果当前数组为null的话表示table在初始化过程中，sizeCtl表示为需要新建数组的长度；<br>  若已经初始化了，表示当前数据容器（table数组）可用容量也可以理解成临界值（插入节点数超过了该临界值就需要扩容），具体指为数组的长度n 乘以 加载因子loadFactor；</li>\n<li>当值为0时，即数组长度为默认初始值。</li>\n</ul>\n</li>\n<li><code>U</code>：sun.misc.Unsafe，在ConcurrentHashMap 的实现中可以看到大量的 U.compareAndSwapXXXX 的方法去修改 ConcurrentHashMap 的一些属性。</li>\n</ul>\n<p>ConcurrentHashMap 中关键内部类：</p>\n<ul>\n<li><code>Node</code>：Node类实现了Map.Entry接口，主要存放key-value对，并且具有next域。</li>\n<li><code>TreeNode</code>：树节点，继承于承载数据的Node类。而红黑树的操作是针对TreeBin类的，从该类的注释也可以看出，也就是TreeBin会将TreeNode进行再一次封装。</li>\n<li><code>TreeBin</code>：包装的很多TreeNode节点。实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象。</li>\n<li><code>ForwardingNode</code>：在扩容时才会出现的特殊节点，其key,value,hash全部为null。并拥有nextTable指针引用新的table数组。</li>\n</ul>\n<p>CAS 关键方法：</p>\n<ul>\n<li><code>tabAt</code>：该方法用来获取table数组中索引为i的Node元素。</li>\n<li><code>casTabAt</code>：利用CAS操作设置table数组中索引为i的元素。</li>\n<li><code>setTabAt</code>：该方法用来设置table数组中索引为i的元素。</li>\n</ul>\n<h3 id=\"put实现\"><a href=\"#put实现\" class=\"headerlink\" title=\"put实现\"></a>put实现</h3><ol>\n<li>首先对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在 table中的位置；</li>\n<li>如果当前table数组还未初始化，先将table数组进行初始化操作；</li>\n<li>如果这个位置是null的，那么使用CAS操作直接放入；</li>\n<li>如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果该节点fh&#x3D;&#x3D;MOVED(代表forwardingNode，数组正在进行扩容)的话，说明正在进行扩容；</li>\n<li>如果是链表节点（fh&gt;0），则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到key相同的节点，则只需要覆盖该结点的value值即可。否则依次向后遍历，直到链表尾插入这个结点；</li>\n<li>如果这个节点的类型是TreeBin的话，直接调用红黑树的插入方法进行插入新的节点；</li>\n<li>插入完节点之后再次检查链表长度，如果长度大于8，就把这个链表转换成红黑树；</li>\n<li>对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容。</li>\n</ol>\n<h3 id=\"get实现\"><a href=\"#get实现\" class=\"headerlink\" title=\"get实现\"></a>get实现</h3><p>首先先看当前的hash桶数组节点即table[i]是否为查找的节点，若是则直接返回；若不是，则继续再看当前是不是树节点？通过看节点的hash值是否为小于0，如果小于0则为树节点。如果是树节点在红黑树中查找节点；如果不是树节点，那就只剩下为链表的形式的一种可能性了，就向后遍历查找节点，若查找到则返回节点的value即可，若没有找到就返回null。</p>\n<h3 id=\"transfer实现\"><a href=\"#transfer实现\" class=\"headerlink\" title=\"transfer实现\"></a>transfer实现</h3><p>当ConcurrentHashMap容量不足的时候，需要对table进行扩容。这个方法的基本思想跟HashMap是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。我想这样做的目的不仅仅是为了满足concurrent的要求，而是希望利用并发处理去减少扩容带来的时间影响。</p>\n<p>代码逻辑请看注释,整个扩容操作分为两个部分：</p>\n<p><strong>第一部分</strong>是构建一个nextTable,它的容量是原来的两倍，这个操作是单线程完成的。新建table数组的代码为:Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node<?,?>[n &lt;&lt; 1],在原容量大小的基础上右移一位。</p>\n<p><strong>第二个部分</strong>就是将原来table中的元素复制到nextTable中，主要是遍历复制的过程。<br>根据运算得到当前遍历的数组的位置i，然后利用tabAt方法获得i位置的元素再进行判断：</p>\n<ol>\n<li>如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点；</li>\n<li>如果这个位置是Node节点（fh&gt;&#x3D;0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上</li>\n<li>如果这个位置是TreeBin节点（fh&lt;0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上</li>\n<li>遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。设置为新容量的0.75倍代码为 sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1)，仔细体会下是不是很巧妙，n&lt;&lt;1相当于n右移一位表示n的两倍即2n，n&gt;&gt;&gt;1左右一位相当于n除以2即0.5n,然后两者相减为2n-0.5n&#x3D;1.5n，是不是刚好等于新容量的0.75倍即2n*0.75&#x3D;1.5n。</li>\n</ol>\n<p><img src=\"/2021/03/08/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/image-20230307160001315.png\" alt=\"image-20230307160001315\"></p>\n<p>参考 <a href=\"https://blog.csdn.net/thinkwon/article/details/102506447\">并发容器之ConcurrentHashMap详解(JDK1.8版本)与源码分析</a><br><a href=\"https://www.jianshu.com/p/e694f1e868ec?u_atoken=4d3cb102-7372-4bdf-8846-0906ed974785&u_asession=01USjK3LS5roRzABsspbwadbl6unf4Y-UAPxa16OinaL8xaNtCYSBVaPe7ICjz9I89X0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K_YcXx114QLleS6n96C0RFvMKWrbBzYAhXhkL4v5_cjQmBkFo3NEHBv0PZUm6pbxQU&u_asig=05wLUJhxR1Jl_DtooV63PVi0KcclHsCu8OvK-mE4wgTpj1UyH_AGgzLD5URVDj06vqvIQ5sPU57A9tnB-77u-xJmNSlaDgU4v3BTVL7eNHJpV7tPXohwFBTFuMkXzh0SnzNfqZf7r_CXEPZ0s0ta5FJdWHSK3pwGewor8bUBQm2r79JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzYGR_fPd3Ob07oL-gX3IdP_g1yCo7pB3XiNjlFCnMLACdf9JIAkyKervFWgmMgV8j-3h9VXwMyh6PgyDIVSG1W80ZxtCyEnbCtkBUDmJYFCuBLVvARzSRGyCKC5RnRJ1yBf83Uk1t8aOqPo49RlbOmihs_0EIBI5NS6l00HCaI3VmWspDxyAEEo4kbsryBKb9Q&u_aref=WB7eyuuJcg8kIQV8e9vzyzrbAl8=\">谈谈ConcurrentHashMap1.7和1.8的不同实现</a></p>\n<h2 id=\"ConcurrentLinkedQueue\"><a href=\"#ConcurrentLinkedQueue\" class=\"headerlink\" title=\"ConcurrentLinkedQueue\"></a>ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue 是线程安全的 linkedlist 容器，使用 CAS 原子指令来处理对数据的并发访问，这是一种非阻塞的实现方式。</p>\n<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改。</p>\n<p>参考 <a href=\"https://blog.csdn.net/qq_38293564/article/details/80798310\">Java并发编程之ConcurrentLinkedQueue详解</a></p>\n<h2 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList 是线程安全的 arraylist 容器。利用 “写时复制” 思想，保证读&#x2F;写同时进行不会冲突。只有当多个线程同时进行写操作的时候，才需要同步，适用于“读多写少”的场景。</p>\n<p>CopyOnWriteArrayList内部：</p>\n<ul>\n<li>通过一个Object[]数组来保存数据。</li>\n<li>通过一个Object对象lock来对写操作进行加锁，使用的是synchronized (lock)方式。</li>\n<li>CopyOnWriteArrayList 的所有读方法都不会加锁，所有增、删、改方法都会加锁。</li>\n</ul>\n<p>CopyOnWriteArrayList 总结如下：</p>\n<ul>\n<li>由于使用了 “写时复制” 的思想，适用于 “读多写少” 的场景；</li>\n<li>由于在进行写操作的时候会复制原数组，对内存的占用会比较大，不适用于大数据量的场景；</li>\n<li>只能保证最终的数据一致性，不能保证实时的数据一致性——读操作只能从旧数组中读取数据，而此时可能已经复制了一个新数组，并且正在修改新数组的数据。</li>\n<li>迭代是对快照进行的，不会抛出 ConcurrentModificationException，且迭代过程中不支持修改操作。</li>\n</ul>\n<p>参考 <a href=\"https://blog.csdn.net/hbtj_1216/article/details/114954367\">CopyOnWriteArrayList学习笔记</a></p>\n<h1 id=\"阻塞队列\"><a href=\"#阻塞队列\" class=\"headerlink\" title=\"阻塞队列\"></a>阻塞队列</h1><p>阻塞队列（BlockingQueue）是 JDK5 新增的线程安全的高效队列类，基于生产者-消费者模式。相比起传统队列，增加支持阻塞的插入和移除方法：</p>\n<ul>\n<li>当线程向队列中插入元素时，如果队列已满，则阻塞线程，直到队列有空闲位置（非满）；</li>\n<li>当线程从队列中取元素（删除队列元素）时，如果队列为空，则阻塞线程，直到队列有元素；</li>\n</ul>\n<p>BlockingQueue 支持的插入&#x2F;移除方法如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法 &#x2F; 处理方式</th>\n<th>抛出异常</th>\n<th>返回特殊值</th>\n<th>一直阻塞</th>\n<th>超时退出</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>插入方法</td>\n<td>add(e)</td>\n<td>offer(e)</td>\n<td>put(e)</td>\n<td>offer(e,time,unit)</td>\n</tr>\n<tr>\n<td>移除方法</td>\n<td>remove()</td>\n<td>poll()</td>\n<td>take()</td>\n<td>poll(time,unit)</td>\n</tr>\n<tr>\n<td>检查方法（从队列头取回但不移除）</td>\n<td>element()</td>\n<td>peek()</td>\n<td>&#x2F;</td>\n<td>&#x2F;</td>\n</tr>\n<tr>\n<td>说明：</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<ul>\n<li><code>抛出异常</code>：当队列满时，如果再往队列里插入元素，会抛出 IllegalStateException（”Queue full”）异常。当队列空时，从队列里获取元素会抛出 NoSuchElementException异常</li>\n<li><code>返回特殊值</code>：当往队列插入元素时，会返回元素是否插入成功，成功返回 true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回 null</li>\n<li><code>一直阻塞</code>：当阻塞队列满时，如果生产者线程往队列里 put 元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take 元素，队列会阻塞住消费者线程，直到队列不为空</li>\n<li><code>超时退出</code>：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出<blockquote>\n<p>注意：如果是无界阻塞队列，队列不可能会出现满的情况，所以使用 put 或 offer 方法永远不会被阻塞，而且使用 offer 方法时，该方法永远返回 true。</p>\n</blockquote>\n</li>\n</ul>\n<p>可以看到，对于每种基本方法，“抛出异常”和“返回特殊值”的方法定义和Queue是完全一样的。BlockingQueue只是增加了两类和阻塞相关的方法：put(e)、take()；offer(e, time, unit)、poll(time, unit)。</p>\n<ul>\n<li>put(e)和take()方法会一直阻塞调用线程，直到线程被中断或队列状态可用；</li>\n<li>offer(e, time, unit)和poll(time, unit)方法会限时阻塞调用线程，直到超时或线程被中断或队列状态可用。</li>\n</ul>\n<p>BlockingQueue 其他操作：</p>\n<ul>\n<li>size()：队列大小。</li>\n<li>remainingCapacity()：剩余可用容量。</li>\n<li>toArray()：返回包含集合所有元素的数组，数组顺序和原有集合一致。返回的数组存在于新的内存空间，和原有队列的修改操作不会互相影响。</li>\n<li>toArray(arr[])：待储存集合空间充足，将队列所有元素按序存于数组，并将多余元素置为null;待储存集合空间不足，将队列所有元素按序存于【新的数组】。</li>\n<li>forEach(Consumer&lt;? super String&gt; action)、parallelStream()、spliterator().forEachRemaining、removeIf(filter)等JDK8新增特性见测试代码。</li>\n</ul>\n<p>注意事项：</p>\n<ul>\n<li>BlockingQueue 不接受null元素，会throw NullPointerException，null用于标记poll操作的失败。</li>\n<li>BlockingQueue接口的实现类都必须是线程安全的，实现类一般通过“锁”保证线程安全；</li>\n<li>BlockingQueue 可以是限定容量的。对于没有容量限制的BlockingQueue实现，该方法总是返回 Integer.MAX_VALUE。</li>\n</ul>\n<p>JDK8 提供了7个阻塞队列，如下：</p>\n<ul>\n<li><code>ArrayBlockingQueue</code>：一个由数组结构组成的有界阻塞队列</li>\n<li><code>LinkedBlockingQueue</code>：一个由链表结构组成的有界阻塞队列</li>\n<li><code>PriorityBlockingQueue</code>：一个支持优先级排序的无界阻塞队列</li>\n<li><code>DelayQueue</code>：一个使用优先级队列实现的无界阻塞队列</li>\n<li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列</li>\n<li><code>LinkedTransferQueue</code>：一个由链表结构组成的无界阻塞队列</li>\n<li><code>LinkedBlockingDeque</code>：一个由链表结构组成的双向阻塞队列。</li>\n</ul>\n<h2 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h2><ul>\n<li>ArrayBlockingQueue 是一个用数组实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。在创建 ArrayBlockingQueue 对象时必须制定容量大小。</li>\n<li>ArrayBlockingQueue 内部的阻塞队列是通过重入锁 ReenterLock 和 Condition 条件队列实现的，所以 ArrayBlockingQueue 中的元素存在公平访问与非公平访问的区别。<ul>\n<li>对于公平访问队列，被阻塞的线程可以按照阻塞的先后顺序访问队列，即先阻塞的线程先访问队列。</li>\n<li>而非公平队列，当队列可用时，阻塞的线程将进入争夺访问资源的竞争中，也就是说谁先抢到谁就执行，没有固定的先后顺序。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h2><ul>\n<li>LinkedBlockingQueue 是一个用链表实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。在创建LinkedBlockingQueue 对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE。</li>\n<li>LinkedBlockingQueue 的实现有点类似于 ArrayBlockingQueue，内部也是通过 ReenterLock 来加锁。但是 ArrayBlockingQueue中插入元素和移除元素时都需要获取同一个锁，即这两个动作不能同时进行；LinkedBlockingQueue中插入元素和从链表头移除元素是两把锁，两个操作同时进行效率，效率更高。</li>\n</ul>\n<p>参考 <a href=\"https://blog.csdn.net/qq_31865983/article/details/105390529\">Java8 LinkedBlockingQueue和DelayQueue 源码解析</a></p>\n<h2 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a>PriorityBlockingQueue</h2><ul>\n<li>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化 PriorityBlockingQueu e时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</li>\n</ul>\n<h2 id=\"DelayQueue\"><a href=\"#DelayQueue\" class=\"headerlink\" title=\"DelayQueue\"></a>DelayQueue</h2><ul>\n<li>DelayQueue 是一个支持延时获取元素的无界阻塞队列。队列使用 PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素</li>\n<li>DelayQueue非常有用，可以将DelayQueue运用在以下应用场景:<ul>\n<li>缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了</li>\n<li>定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如 TimerQueue 就是使用 DelayQueue 实现的</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"SynchronousQueue\"><a href=\"#SynchronousQueue\" class=\"headerlink\" title=\"SynchronousQueue\"></a>SynchronousQueue</h2><ul>\n<li>SynchronousQueue 是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个take操作，否则不能继续添加元素</li>\n<li>它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法可以创建公平性访问的 SynchronousQueue，如果设置为 true，则等待的线程会采用先进先出的顺序访问队列。</li>\n<li>SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue。</li>\n</ul>\n<h2 id=\"LinkedTransferQueue\"><a href=\"#LinkedTransferQueue\" class=\"headerlink\" title=\"LinkedTransferQueue\"></a>LinkedTransferQueue</h2><ul>\n<li>LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。<ul>\n<li>transfer方法：如果当前有消费者正在等待接收元素（消费者使用take0方法或带时间限制的poll0方法时），transfer方法可以把生产者传人的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</li>\n<li>tryTransfer方法：用来试探生产者传人的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。对于带有时间限制的tryTransfer(E e，long timeout，TimeUnit unit)方法，试图把生产者传人的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"LinkedBlockingDeque\"><a href=\"#LinkedBlockingDeque\" class=\"headerlink\" title=\"LinkedBlockingDeque\"></a>LinkedBlockingDeque</h2><ul>\n<li>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时人队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取( peek)或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。</li>\n<li>在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。</li>\n</ul>\n","categories":["Java","Java并发"],"tags":["Java"]},{"title":"Java并发系列（五）：线程池","url":"/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/","content":"<blockquote>\n<p>这一篇介绍 java 的线程池内容</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"Executor框架\"><a href=\"#Executor框架\" class=\"headerlink\" title=\"Executor框架\"></a>Executor框架</h1><p>Executor 框架是一个用于统一创建与运行的接口，实现的就是线程池的功能。严格意义上讲 Executor 并不是一个线程池，只是一个执行工具，真正的线程池接口是 ExecutorService。</p>\n<p>Executor 框架的成员如下：</p>\n<ul>\n<li>任务。也就是工作单元，包括被执行任务需要实现的接口：<code>Runnable</code> 接口或者 <code>Callable</code> 接口；</li>\n<li>任务的执行。包括任务执行机制的核心接口 <code>Executor</code>，以及继承自 <code>Executor</code> 的 <code>ExecutorService</code> 接口。<code>Executor</code> 框架有两个关键类实现了 <code>ExecutorService</code> 接口（<code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code>）。</li>\n<li>异步计算的结果。包括 <code>Future</code> 接口及实现了 <code>Future</code> 接口的 <code>FutureTask</code> 类。</li>\n</ul>\n<p>Executor 框架包含的主要的类与接口：</p>\n<ul>\n<li><code>Executor</code> 接口：是一个接口，它是 Executor 框架的基础，它将任务的提交与任务的执行分离开来。</li>\n<li><code>ExecutorService</code> 接口：是真正的线程池接口。</li>\n<li><code>ScheduledExecutorService</code> 接口：定期任务线程池的接口，继承了 ExecutorService。<br><code>AbstractExecutorService</code>：实现了ExecutorService接口，实现了其中大部分的方法（有没有实现的方法，所以被声明为Abstract）。</li>\n<li><code>ThreadPoolExecutor</code> ：<strong>继承了 AbstractExecutorService，是 ExecutorService 接口的默认实现类，是线程池的最核心实现类</strong>。</li>\n<li><code>ScheduledThreadPoolExecutor</code> 实现类：ScheduledExecutorService 接口的实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor 比 Timer 更灵活，功能更强大。ScheduledThreadPoolExecutor 可以通过 Executors 创建。</li>\n<li><code>Future</code> 接口：实现类是 <code>FutureTask</code>，代表异步计算的结果。</li>\n<li><code>Runnable</code> 和 <code>Callable</code> 接口：可以被 ThreadPoolExecutor 或者 ScheduledThreadPoolExecutor 直接执行。两者的区别是 Runnable 不会返回结果，Callable 可以返回结果。</li>\n<li><code>Executors</code> 工厂类：提供了常见配置线程池的方法，因为 ThreadPoolExecutor 的参数众多且意义重大，为了避免配置出错，才有了 Executors 工厂类。利用 Executors 可以基于 ThreadPoolExecutor 实现类快速创建线程池：<ul>\n<li><code>FixedThreadPool</code>：固定线程数的线程池。</li>\n<li><code>SingleThreadExecutor</code>：单个线程的线程池。</li>\n<li><code>CachedThreadPool</code>：根据需要创建新线程，大小无界的线程</li>\n</ul>\n</li>\n</ul>\n<p>它们的继承关系图如下：<br><img src=\"/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307160944978.png\" alt=\"image-20230307160944978\"></p>\n<p>Executor 框架的使用过程：</p>\n<ol>\n<li>首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。工具类 <code>Executors</code> 还可以把一个 <code>Runnable</code> 对象封装为一个 <code>Callable</code> 对象。</li>\n<li>然后可以把 <code>Runnable</code> 对象直接交给 <code>ExecutorService</code> 执行（ExecutorService.execute（Runnable command））；或者也可以把 <code>Runnable</code> 对象或 <code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（ExecutorService.submit（Runnable task）或 ExecutorService.submit（Callabletask））。</li>\n<li>如果执行 ExecutorService.submit（…），<code>ExecutorService</code> 将返回一个实现 <code>Future</code> 接口的对象 （到目前为止的JDK中，返回的是 FutureTask 对象）。由于 <code>FutureTask</code> 实现了 <code>Runnable</code>，程序员也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li>\n<li>最后，主线程可以执行 FutureTask.get() 方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</li>\n</ol>\n<p><img src=\"/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307160958861.png\" alt=\"image-20230307160958861\"></p>\n<h2 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h2><p>ThreadPoolExecutor 是 Execuotr 框架最核心的实现类，下面介绍怎么使用 ThreadPoolExecutor。</p>\n<h3 id=\"1、创建线程池。\"><a href=\"#1、创建线程池。\" class=\"headerlink\" title=\"1、创建线程池。\"></a>1、创建线程池。</h3><p>ThreadPoolExecutor 的构造函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor(<span class=\"type\">int</span> corePoolSize, <span class=\"type\">int</span> maximumPoolSize, <span class=\"type\">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>corePoolSize</code>：核心线程池大小。如果调用了 prestartAllCoreThreads() 或者 prestartCoreThread() 方法，会直接预先创建corePoolSize的线程；否则会等有任务来之后，才创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把暂时无法处理的任务放到缓存队列当中。</li>\n<li><code>maximumPoolSize</code>：最大线程池大小。表示在线程池中最多能创建多少个线程，如果运行中的线程超过了这个数字，那么相当于线程池已满，新来的任务会使用 RejectedExecutionHandler 进行处理。</li>\n<li><code>keepAliveTime</code>：线程最大空闲时间。如果线程数超过 corePoolSize 且线程空闲时长超过 keepAliveTime，就会减少线程数维持在 corePoolSize 大小。</li>\n<li><code>unit</code>：时间单位。参数 keepAliveTime 的时间单位。</li>\n<li><code>workQueue</code>：线程等待队列。一个阻塞队列，用来存储等待执行的任务，如果当前对线程的需求超过了 corePoolSize 大小，才会放在这里。可供使用的阻塞队列有：<ul>\n<li><code>LinkedBlockingQueue</code>：链表实现的有界阻塞队列，最常用的阻塞队列。在初始化时指定一个大小，如果不指定就会使用默认大小为 Integer.MAX_VALUE 的容量。注意要配置一下队列大小，设置成有界队列。否则可能会把内存撑爆。用于 FixedThreadPool 和 SingleThreadExecutor。</li>\n<li><code>ArrayBlockingQueue</code>：数组实现的有界队列。</li>\n<li><code>DelayQueue</code>：延时队列。用于周期任务线程池中。</li>\n<li><code>PriorityBlockingQueue</code>：优先级队列。</li>\n<li><code>SynchronousQueue</code>：同步队列，用于 CachedThreadPool。</li>\n</ul>\n</li>\n<li><code>threadFactory</code>：线程创建工厂，主要用来创建线程，比如可以指定线程的名字。默认可以使用 Executors.defaultThreadFactory()。</li>\n<li><code>handler</code>：拒绝策略。当线程池满了的时候，用于处理新任务的策略。可以通过实现 RejectedExecutionHandler 接口自定义拒绝策略，ThreadPoolExecutor 内部也提供了四种拒绝策略：<ul>\n<li><code>AbortPolicy</code>：这是默认的策略，直接抛出异常。</li>\n<li><code>CallerRunsPolicy</code>：由调用者所在线程来运行任务。</li>\n<li><code>DiscardOldestPolicy</code>：丢弃队列中最老的任务，并执行当前任务。</li>\n<li><code>DiscardPolicy</code>：不处理，直接把当前任务丢弃。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2、向线程池提交任务。\"><a href=\"#2、向线程池提交任务。\" class=\"headerlink\" title=\"2、向线程池提交任务。\"></a>2、向线程池提交任务。</h3><p>提交任务的两种方法：<code>execute()</code> 和<code>submit()</code>。</p>\n<ul>\n<li>execute() 用于提交没有返回值的任务，所以无法判断任务是否被线程执行过</li>\n<li>submit() 用于提交需要返回值的对象。返回一个future对象，可以通过future对象判断任务是否被线程执行；可以通过future对象的get（）方法获取返回的值，get（）方法会阻塞当前线程直到future对象被返回，也可以调用get（long timeout, TimeUnit unit）来实现由等待时间的获取返回值，如果超时仍没有返回值，那么立刻返回，这时候任务可能没有执行完成。</li>\n</ul>\n<p>线程池任务的执行过程：</p>\n<ol>\n<li>当任务量小于 corePoolSize 的时候，它会创建一个线程来执行此任务。</li>\n<li>当任务量大于 corePoolSize，并且没有空闲线程的时候，且线程池的线程数小于 maximumPoolSize，此时会将任务存到 workQueue 里面。</li>\n<li>当前任务量继续增大，并且 workQueue 已经满了，就创建线程来执行任务，直到线程数等于 maximumPoolSize。<br>4.当 workQueue 已经满了，且线程数等于 maximumPoolSize，这时候就会对处理不过来的任务执行拒绝策略。</li>\n</ol>\n<p><img src=\"/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307161012998.png\" alt=\"image-20230307161012998\"></p>\n<h3 id=\"3、关闭线程池。\"><a href=\"#3、关闭线程池。\" class=\"headerlink\" title=\"3、关闭线程池。\"></a>3、关闭线程池。</h3><p>关闭的原理：遍历线程池中的线程，逐个调用线程的 interrupt() 方法来中断线程，所以不响应中断的线程可能永远无法终止。可以通过 <code>shutdown()</code> 或者 <code>shutDownNow()</code> 来关闭线程池。</p>\n<ul>\n<li>shutDown:把线程池的状态设置为SHUTDOWN，然后中断所有没有正在执行任务的线程，而已经在执行任务的线程继续执行直到任务执行完毕。</li>\n<li>shutDownNow：把当前线程池状态设为STOP，尝试停止所有的正在执行或者暂停的线程，并返回等待执行的任务的列表。</li>\n</ul>\n<p>在调用了 shutDown 或者s hutDownNow 后，调用 isShutDown() 返回 true；当所有任务都关闭后，调用 isTerminaed() 方法返回 true。（注意关闭线程池和所有线程关闭是不同的）</p>\n<h4 id=\"FixedThreadPool\"><a href=\"#FixedThreadPool\" class=\"headerlink\" title=\"FixedThreadPool\"></a>FixedThreadPool</h4><p>FixedThreadPool 是线程数量固定的线程池，适用于为了满足资源管理的需求，而需要适当限制当前线程数量的情景，适用于负载比较重的服务器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newFixedThreadPool</span><span class=\"params\">(<span class=\"type\">int</span> nThreads)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(nThreads, nThreads, <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>FixedThreadPool 的实现解析：</p>\n<ul>\n<li>把线程池最大线程数量 maxmumPoolSize 和核心线程池的数量 corePoolSize 设置为相等，值为 FixedThreadPool 时指定的参数nThreads，所以线程数量是固定的。</li>\n<li>keepAliveTime 设置为0L，意味着多余的空闲线程会被立即终止。因为 maxmumPoolSize 和 corePoolSize 相等，所以这是个无效参数。</li>\n<li>使用 LinkedBlockingQueue 作为阻塞队列，但是没有设置队列大小，默认为 Integer.MAX_VALUE，约等于无限队列，所以不会执行拒绝策略。所以 handler 也是个无效参数。</li>\n</ul>\n<p>FixedThreadPool 的工作流程如下：<br><img src=\"/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307161033121.png\" alt=\"image-20230307161033121\"></p>\n<ol>\n<li>当前核心线程池总线程数量小于 corePoolSize，那么创建线程并执行任务。</li>\n<li>如果当前线程数量等于 corePoolSize，那么把任务添加到阻塞队列中。</li>\n<li>由于使用无界队列，FixedThreadPool 不会拒绝任务，执行完任务线程会源源不断从阻塞队列取出新的任务。</li>\n</ol>\n<h4 id=\"SingleThreadExecutor\"><a href=\"#SingleThreadExecutor\" class=\"headerlink\" title=\"SingleThreadExecutor\"></a>SingleThreadExecutor</h4><p>SingleThreadExecutor 是只有单个线程的线程池。适用于需要让线程顺序执行，并且在任意时间，只能有一个任务被执行，而不能有多个线程同时执行的场景。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newSingleThreadExecutor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FinalizableDelegatedExecutorService</span></span><br><span class=\"line\">            (<span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>SingleThreadExecutor 的实现解析：</p>\n<ul>\n<li>corePoolSize 和 maximumPoolSize 被设置为1。其他参数与 FixedThreadPool 相同。</li>\n</ul>\n<p>SingleThreadPool 的工作流程也和 FixedThreadPool 类似。<br><img src=\"/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307161044027.png\" alt=\"image-20230307161044027\"></p>\n<h4 id=\"CachedThreadPool\"><a href=\"#CachedThreadPool\" class=\"headerlink\" title=\"CachedThreadPool\"></a>CachedThreadPool</h4><p>CachedThreadPool可以创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class=\"line\">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CachedThreadPool 的实现解析：</p>\n<ol>\n<li>corePoolSize 被设置为 0，maximumPoolSize 被设置为 Integer.MAX_VALUE，相当于无限，所以最大线程数不受限制。</li>\n<li>keepAliveTime 设置为 60L，意味着 CachedThreadPool 中的空闲线程等待新任务的最长时间为60秒。</li>\n<li>使用没有容量的 SynchronousQueue 作为线程池的工作队列，但是因为 maximumPool 是无界的，如果主线程提交任务的速度高于 maximumPool 中线程处理任务的速度时，CachedThreadPool 会不断创建新线程。</li>\n</ol>\n<p>CachedThreadPool 的工作流程如下：<br><img src=\"/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307161055227.png\" alt=\"image-20230307161055227\"></p>\n<ol>\n<li>首先执行SynchronousQueue.offer（Runnable task）。如果当前maximumPool中有空闲线程正在执行SynchronousQueue.poll（keepAliveTime，TimeUnit.NANOSECONDS），那么主线程执行offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行，execute()方法执行完成；否则执行下面的步骤2）。</li>\n<li>当初始maximumPool为空，或者maximumPool中当前没有空闲线程时，将没有线程执行SynchronousQueue.poll<br>（keepAliveTime，TimeUnit.NANOSECONDS）。这种情况下，步骤1）将失败。此时CachedThreadPool会创建一个新线程执行任务，execute()方法执行完成。</li>\n<li>在步骤2）中新创建的线程将任务执行完后，会执行SynchronousQueue.poll（keepAliveTime，<br>TimeUnit.NANOSECONDS）。这个poll操作会让空闲线程最多在SynchronousQueue中等待60秒钟。如果60秒钟内主线程提交了一个新任务（主线程执行步骤1）），那么这个空闲线程将执行主线程提交的新任务；否则，这个空闲线程将终止。由于空闲60秒的空闲线程会被终止，因此长时间保持空闲的CachedThreadPool不会使用任何资源。</li>\n</ol>\n<h2 id=\"ScheduledThreadPoolExecutor\"><a href=\"#ScheduledThreadPoolExecutor\" class=\"headerlink\" title=\"ScheduledThreadPoolExecutor\"></a>ScheduledThreadPoolExecutor</h2><p>ScheduledThreadPoolExecutor 主要用来在给定的延迟之后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而 ScheduledThreadPoolExecutor 可以在构造函数中指定多个对应的后台线程数</p>\n<p>ScheduledThreadPoolExecutor通常使用工厂类Executors来创建，可以创建2种类型的 ScheduledThreadPoolExecutor：</p>\n<ul>\n<li><code>ScheduledThreadPoolExecutor</code>：包含若干个线程的ScheduledThreadPoolExecutor。</li>\n<li><code>SingleThreadScheduledExecutor</code>：只包含一个线程的ScheduledThreadPoolExecutor。<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 创建ScheduledThreadPoolExecutor</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ScheduledThreadPoolExecutor</span><span class=\"params\">(<span class=\"type\">int</span> corePoolSize)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(corePoolSize, Integer.MAX_VALUE, <span class=\"number\">0</span>, TimeUnit.NANOSECONDS, <span class=\"keyword\">new</span> <span class=\"title class_\">DelayedWorkQueue</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"># 创建SingleThreadScheduledExecutor，内部其实也是调用了ScheduledThreadPoolExecutor的构造函数</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title function_\">newSingleThreadScheduledExecutor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DelegatedScheduledExecutorService</span></span><br><span class=\"line\">            (<span class=\"keyword\">new</span> <span class=\"title class_\">ScheduledThreadPoolExecutor</span>(<span class=\"number\">1</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\nScheduledThreadPoolExecutor 实现解析：</li>\n</ul>\n<ol>\n<li>corePoolSize 由使用者自行设置，maximumPoolSize 虽然被设置为 Integer.MAX_VALUE ，但是由于 DelayedWorkQueue 是无界队列，所以 maximumPoolSize 的大小没有意义，相当于无效参数。</li>\n<li>待调度的任务（ScheduledFutureTask）放到一个DelayQueue，DelayQueue 封装了一个 PriorityQueue，这个 PriorityQueue 会对队列中的 ScheduledFutureTask 进行排序。排序时，time 小的排在前面（时间早的任务将被先执行）。</li>\n</ol>\n<p>ScheduledThreadPoolExecutor 的执行过程：<br><img src=\"/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307161111502.png\" alt=\"image-20230307161111502\"></p>\n<ol>\n<li>当调用 ScheduledThreadPoolExecutor 的 scheduleAtFixedRate() 方法或者 scheduleWithFixedDelay() 方法时，会向 ScheduledThreadPoolExecutor 的 DelayQueue 添加一个实现了 RunnableScheduledFutur 接口的 ScheduledFutureTask。</li>\n<li>线程池中的线程从 DelayQueue 中获取 ScheduledFutureTask，然后执行任务。</li>\n</ol>\n<h2 id=\"Runnable和Callable接口\"><a href=\"#Runnable和Callable接口\" class=\"headerlink\" title=\"Runnable和Callable接口\"></a>Runnable和Callable接口</h2><p>java.lang.Runnable 接口只声明了一个 run() 方法，run() 的返回值为 void，执行完任务之后无法返回任何结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Runnable</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Callable 接口位于 java.util.concurrent 下，很明显是为了解决 Runnable 没有返回值的问题后面才加上的，也只声明了一个 call() 方法，返回的类型就是传递进来的V类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Callable</span>&lt;V&gt; &#123;</span><br><span class=\"line\">    V <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Runnable 和 Callable 接口都可以配合 ExecutorService 来使用的，在 ExecutorService 接口中声明了若干个 submit 方法的重载版本。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;T&gt; Future&lt;T&gt; <span class=\"title function_\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span>;</span><br><span class=\"line\">&lt;T&gt; Future&lt;T&gt; <span class=\"title function_\">submit</span><span class=\"params\">(Runnable task, T result)</span>;</span><br><span class=\"line\">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>\n<p>一般情况下我们使用第一个submit方法和第三个submit方法，第二个submit方法很少使用。</p>\n<h2 id=\"FutureTask\"><a href=\"#FutureTask\" class=\"headerlink\" title=\"FutureTask\"></a>FutureTask</h2><p>Future 就是对于具体的 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过 get 方法获取执行结果，该方法会阻塞直到任务返回结果。</p>\n<p>Future 是一个接口，位于 java.util.concurrent 包下，提供了五个方法：</p>\n<ul>\n<li>V get() ：获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。</li>\n<li>V get(Long timeout , TimeUnit unit) ：获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，如果阻塞时间超过设定的timeout时间，该方法将抛出异常。</li>\n<li>boolean isDone() ：如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。</li>\n<li>boolean isCancelled() ：如果任务完成前被取消，则返回true。</li>\n<li>boolean cancel(boolean mayInterruptRunning) ：如果任务还没开始，执行cancel(…)方法将返回false；如果任务已经启动，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果停止成功，返回true；当任务已经启动，执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时返回false；当任务已经完成，执行cancel(…)方法将返回false。mayInterruptRunning参数表示是否中断执行中的线程。</li>\n</ul>\n<p>通过方法分析我们也知道实际上 Future 提供了3种功能：</p>\n<ol>\n<li>能够中断执行中的任务。</li>\n<li>判断任务是否执行完成。</li>\n<li>获取任务执行完成后额结果。</li>\n</ol>\n<p>FutureTask 是 Future 接口的实现类，除了实现了 Future 接口外还实现了 Runnable 接口。因此 FutureTask 可以交给 Executor 执行，也可以由调用线程直接执行（FutureTask.run()）。根据 FutureTask.run() 方法执行的时机，FutureTask 可以处于以下三种执行状态：</p>\n<ul>\n<li>未启动：在FutureTask.run()还没执行之前，FutureTask处于未启动状态。当创建一个FutureTask对象，并且run()方法未执行之前，FutureTask处于未启动状态。</li>\n<li>已启动：FutureTask对象的run方法启动并执行的过程中，FutureTask处于已启动状态。</li>\n<li>已完成：FutureTask正常执行结束，或者FutureTask执行被取消(FutureTask对象cancel方法)，或者FutureTask对象run方法执行抛出异常而导致中断而结束，FutureTask都处于已完成状态。</li>\n</ul>\n<p><img src=\"/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307161126599.png\" alt=\"image-20230307161126599\"></p>\n<p>FutureTask 的 get 和 cancel 的执行过程：</p>\n<ol>\n<li>当FutureTask 处于未启动或者已启动的状态时，调用 FutureTask 对象的 get 方法会将导致调用线程阻塞。当 FutureTask 处于已完成的状态时，调用 FutureTask 的 get 方法会立即放回调用结果或者抛出异常。</li>\n<li>当FutureTask 处于未启动状态时，调用 FutureTask 对象的 cancel 方法将导致线程永远不会被执行；当 FutureTask 处于已启动状态时，调用 FutureTask 对象 cancel(true) 方法将以中断执行此任务的线程的方式来试图停止此任务；当FutureTask 处于已启动状态时，调用 FutureTask 对象 cancel(false) 方法将不会对正在进行的任务产生任何影响；当 FutureTask 处于已完成状态时，调用 FutureTask 对象 cancel 方法将返回 false。</li>\n</ol>\n<p><img src=\"/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307161136998.png\" alt=\"image-20230307161136998\"></p>\n<p>FutureTask 的使用：</p>\n<ol>\n<li>可以把 FutureTask 交给 Executor 执行</li>\n<li>可以通 ExecutorService.submit（…）方法返回一个 FutureTask，然后执行 FutureTask.get() 方法或 FutureTask.cancel（…）方法。</li>\n<li>单独使用 FutureTask。创建 FutureTask，然后运行 FutureTask .run() 方法。</li>\n</ol>\n<p>FutureTask  适用于当一个线程需要等待另一个线程把某个任务执行完后它才能继续执行的场景。</p>\n<p>FutureTask 的实现：在 jdk1.8 以前 FutureTask 是通过内部类 Sync 继承 AQS 来实现的，在 jdk1.8 中移除了 Sync 组件，直接使用 state 变量和对 state 变量进行 CAS 操作，以及一个简单的 Treiber 堆栈来保存等待的线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FutureTask</span>&lt;V&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">RunnableFuture</span>&lt;V&gt; &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当前任务的运行状态。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 可能存在的状态转换</span></span><br><span class=\"line\"><span class=\"comment\">     * NEW -&gt; COMPLETING -&gt; NORMAL（有正常结果）</span></span><br><span class=\"line\"><span class=\"comment\">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL（结果为异常）</span></span><br><span class=\"line\"><span class=\"comment\">     * NEW -&gt; CANCELLED（无结果）</span></span><br><span class=\"line\"><span class=\"comment\">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED（无结果）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> state;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">NEW</span>          <span class=\"operator\">=</span> <span class=\"number\">0</span>;  <span class=\"comment\">//初始状态</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">COMPLETING</span>   <span class=\"operator\">=</span> <span class=\"number\">1</span>;  <span class=\"comment\">//结果计算完成或响应中断到赋值给返回值之间的状态。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">NORMAL</span>       <span class=\"operator\">=</span> <span class=\"number\">2</span>;  <span class=\"comment\">//任务正常完成，结果被set</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">EXCEPTIONAL</span>  <span class=\"operator\">=</span> <span class=\"number\">3</span>;  <span class=\"comment\">//任务抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CANCELLED</span>    <span class=\"operator\">=</span> <span class=\"number\">4</span>;  <span class=\"comment\">//任务已被取消</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">INTERRUPTING</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;  <span class=\"comment\">//线程中断状态被设置ture，但线程未响应中断</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">INTERRUPTED</span>  <span class=\"operator\">=</span> <span class=\"number\">6</span>;  <span class=\"comment\">//线程已被中断</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">//将要执行的任务</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Callable&lt;V&gt; callable;</span><br><span class=\"line\">    <span class=\"comment\">//用于get()返回的结果，也可能是用于get()方法抛出的异常</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object outcome; <span class=\"comment\">// non-volatile, protected by state reads/writes</span></span><br><span class=\"line\">    <span class=\"comment\">//执行callable的线程，调用FutureTask.run()方法通过CAS设置</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Thread runner;</span><br><span class=\"line\">    <span class=\"comment\">//栈结构的等待队列，该节点是栈中的最顶层节点。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> WaitNode waiters;</span><br><span class=\"line\">    ....</span><br></pre></td></tr></table></figure>\n<p>FutureTask 使用 <code>volatile int state</code> 来保存 FutureTask 的状态，所有操作都围绕 state 变量展开，state 有以下状态：</p>\n<ul>\n<li><code>NEW</code>：表示是个新的任务或者还没被执行完的任务。这是初始状态。</li>\n<li><code>COMPLETING</code>：任务已经执行完成或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果，如果发生异常，则用来保存异常原因)的时候，状态会从NEW变更到COMPLETING。但是这个状态会时间会比较短，属于中间状态。</li>\n<li><code>NORMAL</code>：任务已经执行完成并且任务执行结果已经保存到outcome字段，状态会从COMPLETING转换到NORMAL。这是一个最终态。</li>\n<li><code>EXCEPTIONAL</code>：任务执行发生异常并且异常原因已经保存到outcome字段中后，状态会从COMPLETING转换到EXCEPTIONAL。这是一个最终态。</li>\n<li><code>CANCELLED</code>：任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了cancel(false)方法取消任务且不中断任务执行线程，这个时候状态会从NEW转化为CANCELLED状态。这是一个最终态。</li>\n<li><code>INTERRUPTING</code>：任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了cancel(true)方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从NEW转化为INTERRUPTING。这是一个中间状态。</li>\n<li><code>INTERRUPTED</code>：调用interrupt()中断任务执行线程之后状态会从INTERRUPTING转换到INTERRUPTED。这是一个最终态。</li>\n</ul>\n<p>各个状态之间的可能转换关系如下图所示：<br><img src=\"/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307161152678.png\" alt=\"image-20230307161152678\"></p>\n<p>参考 <a href=\"https://blog.csdn.net/u014082714/article/details/81180379\">FutureTask源码解析(JDK1.8)</a></p>\n<h2 id=\"手动创建线程池\"><a href=\"#手动创建线程池\" class=\"headerlink\" title=\"手动创建线程池\"></a>手动创建线程池</h2><p>如果我们不想使用 Executors 工厂类来创建线程池，也可以自己使用 ThreadPoolExecutor 构造函数自行创建线程池，这也是阿里推荐的方式。</p>\n<blockquote>\n<p>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>\n</blockquote>\n<p>阿里巴巴开发手册为什么禁止使用 Executors 去创建线程池？原因就是 newFixedThreadPool() 和 newSingleThreadExecutor()两个方法允许请求的最大队列长度是 Integer.MAX_VALUE ，可能会出现任务堆积，出现OOM。newCachedThreadPool()允许创建的线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，导致发生OOM。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyExecutorService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(</span><br><span class=\"line\">            <span class=\"number\">5</span>,</span><br><span class=\"line\">            <span class=\"number\">10</span>,</span><br><span class=\"line\">            <span class=\"number\">60</span>,</span><br><span class=\"line\">            TimeUnit.SECONDS,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;&gt;(<span class=\"number\">10</span>),</span><br><span class=\"line\">            Executors.defaultThreadFactory(),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            executorService.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker1</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker1</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; Run Task Finish&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"线程池的实现原理\"><a href=\"#线程池的实现原理\" class=\"headerlink\" title=\"线程池的实现原理\"></a>线程池的实现原理</h1><p>在向线程池提交任务时有两个比较中要的参数会决定任务的去向，这两个参数分别是线程池的状态和线程池中的线程数。因为涉及多线程的操作，这里为了保证原子性，<strong>在ThreadPoolExecutor内部使用了一个AtomicInteger类型的整数ctl来表示这两个参数</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">ctl</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(ctlOf(RUNNING, <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">COUNT_BITS</span> <span class=\"operator\">=</span> Integer.SIZE - <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CAPACITY</span>   <span class=\"operator\">=</span> (<span class=\"number\">1</span> &lt;&lt; COUNT_BITS) - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// runState is stored in the high-order bits</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">RUNNING</span>    <span class=\"operator\">=</span> -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">SHUTDOWN</span>   <span class=\"operator\">=</span>  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">STOP</span>       <span class=\"operator\">=</span>  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">TIDYING</span>    <span class=\"operator\">=</span>  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">TERMINATED</span> <span class=\"operator\">=</span>  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Packing and unpacking ctl</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">runStateOf</span><span class=\"params\">(<span class=\"type\">int</span> c)</span>     &#123; <span class=\"keyword\">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">workerCountOf</span><span class=\"params\">(<span class=\"type\">int</span> c)</span>  &#123; <span class=\"keyword\">return</span> c &amp; CAPACITY; &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">ctlOf</span><span class=\"params\">(<span class=\"type\">int</span> rs, <span class=\"type\">int</span> wc)</span> &#123; <span class=\"keyword\">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>\n<p>其高3位用于维护线程池运行状态，低29位维护线程池中线程数量。其中状态有：</p>\n<ul>\n<li>RUNNING：-1&lt;&lt;COUNT_BITS，即高3位为1，低29位为0，该状态的线程池会接收新任务，也会处理在阻塞队列中等待处理的任务</li>\n<li>SHUTDOWN：0&lt;&lt;COUNT_BITS，即高3位为0，低29位为0，该状态的线程池不会再接收新任务，但还会处理已经提交到阻塞队列中等待处理的任务</li>\n<li>STOP：1&lt;&lt;COUNT_BITS，即高3位为001，低29位为0，该状态的线程池不会再接收新任务，不会处理在阻塞队列中等待的任务，而且还会中断正在运行的任务</li>\n<li>TIDYING：2&lt;&lt;COUNT_BITS，即高3位为010，低29位为0，所有任务都被终止了，workerCount为0，为此状态时还将调用terminated()方法</li>\n<li>TERMINATED：3&lt;&lt;COUNT_BITS，即高3位为100，低29位为0，terminated()方法调用完成后变成此状态</li>\n</ul>\n<p>另外有三个操作ctl的方法，保证获取和修改ctl的原子性：</p>\n<ul>\n<li>runStateOf(int c)  方法：c &amp; 高3位为1，低29位为0的~CAPACITY，用于获取高3位保存的线程池状态</li>\n<li>workerCountOf(int c)方法：c &amp; 高3位为0，低29位为1的CAPACITY，用于获取低29位的线程数量</li>\n<li>ctlOf(int rs, int wc)方法：参数rs表示runState，参数wc表示workerCount，即根据runState和workerCount打包合并成ctl</li>\n</ul>\n<p>ThreadPoolExecutor 类中，最核心的任务提交方法是 execute() 方法，虽然通过 submit 也可以提交任务，但是实际上 submit 方法里面最终调用的还是 execute() 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">execute</span><span class=\"params\">(Runnable command)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> ctl.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"literal\">true</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        c = ctl.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">recheck</span> <span class=\"operator\">=</span> ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            addWorker(<span class=\"literal\">null</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"literal\">false</span>))</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果线程池当前线程数量少于 corePoolSize，则 addWorker(command, true) 创建新 worker 线程，如创建成功返回，如没创建成功，则执行后续步骤；addWorker(command, true)失败的原因可能是：<ul>\n<li>线程池已经 shutdown，shutdown 的线程池不再接收新任务。</li>\n<li>workerCountOf(c) &lt; corePoolSize 判断后，由于并发，别的线程先创建了 worker 线程，导致 workerCount&gt;&#x3D;corePoolSize。</li>\n</ul>\n</li>\n<li>如果线程池还在 running 状态，将 task 加入 workQueue 阻塞队列中，如果加入成功，进行 double-check，如果加入失败（可能是队列已满），则执行后续步骤。double-check 主要目的是判断刚加入 workQueue 阻塞队列的 task 是否能被执行<ul>\n<li>如果线程池已经不是 running 状态了，应该拒绝添加新任务，从 workQueue 中删除任务</li>\n<li>如果线程池是运行状态，或者从 workQueue 中删除任务失败（刚好有一个线程执行完毕，并消耗了这个任务），确保还有线程执行任务（只要有一个就够了）</li>\n</ul>\n</li>\n<li>如果线程池不是 running 状态或者无法入队列，尝试开启新线程，扩容至 maxPoolSize，如果 addWork(command, false) 失败了，拒绝当前 command。</li>\n</ol>\n<p>这里有两种个关键类</p>\n<ul>\n<li><strong>Task</strong>：任务，实现了 Runnable接口，但是并没有通过 start 方法执行，而是被 Worker 调用了 run 方法来执行。</li>\n<li><strong>Worker</strong>：线程，线程池会把每个线程封装成一个 Worker 对象。Worker 类本身既实现了 Runnable，又继承了 AQS，所以其既是一个可执行的线程，又可以达到锁的效果。</li>\n</ul>\n<p>使用 Worker 执行 Task 的过程：</p>\n<ol>\n<li><code>execute(Runnable command) 提交任务</code>：如果线程池当前线程数量少于 corePoolSize，则使用 addWorker(command, true) 创建新 worker 线程。</li>\n<li><code>addWorker(Runnable firstTask, boolean core) 添加任务</code>：将线程和任务封装到了 Worker 中，然后将 Worker 添加到 HashSet 集合中，添加成功后通过 Worker 的 start 方法启动线程执行任务。</li>\n<li><code>runwork(Worker w) 执行任务</code>：Worker 线程启动后，通过 Worker 类的 run() 方法调用 runWorker(this) 开始执行firstTask，调用 task.run()，在执行任务前会上锁 worker.lock()，在执行完任务后会解锁。</li>\n<li><code>getTask() 获取新任务</code>：正常执行完当前 task 后，会通过 getTask() 从阻塞队列中获取新任务，当队列中没有任务，且获取任务超时，那么当前 worker 也会进入退出流程。</li>\n<li><code>processWorkerExit(Worker w,boolean completedAbruptly) worker 线程退出</code>：从 Workers Set 中移除 worker，删除时需要上锁 mainlock。</li>\n</ol>\n<h1 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h1><h2 id=\"ThreadLocal是什么\"><a href=\"#ThreadLocal是什么\" class=\"headerlink\" title=\"ThreadLocal是什么\"></a>ThreadLocal是什么</h2><p>ThreadLocal 是一个将在多线程中为每一个线程创建单独的变量副本的类; 当使用 ThreadLocal 来维护变量时, ThreadLocal 会为每个线程创建单独的变量副本, 避免因多线程操作共享变量而导致的数据不一致的情况。</p>\n<h2 id=\"ThreadLocal的使用\"><a href=\"#ThreadLocal的使用\" class=\"headerlink\" title=\"ThreadLocal的使用\"></a>ThreadLocal的使用</h2><p>最常用的就是应用于数据库连接，为每个线程保存一个当前线程可见的连接。这样在 Client 获取 Connection 的时候，每个线程获取到的 Connection 都是该线程独有的，做到 Connection 的线程隔离，所以并不存在线程安全问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DBConnectionFactory</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Connection&gt; dbConnectionLocal = <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadLocal</span>&lt;Connection&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> Connection <span class=\"title function_\">initialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> DriverManager.getConnection(<span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dbConnectionLocal.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ThreadLocal的实现原理\"><a href=\"#ThreadLocal的实现原理\" class=\"headerlink\" title=\"ThreadLocal的实现原理\"></a>ThreadLocal的实现原理</h2><p><img src=\"/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307161210661.png\" alt=\"image-20230307161210661\"><br>ThreadLocal的早期设计，每个ThreadLocal都创建一个Map,然后用线程作为Map的Key,要存储的局部变量作为Map的value，这样就能达到各个线程的局部变量隔离的效果。<br>但这种设计有一个问题，如果调用线程一直不终止，那么这个本地变量会一直存放在ThreadLocal变量里面，容易造成内存泄漏，解决办法是当不需要使用本地变量时可以通过调用ThreadLocal变量的remove方法。<br><img src=\"/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307161222190.png\" alt=\"image-20230307161222190\"><br>JDK后面优化了设计方案，在JDK8中 ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap，这个Map的key是ThreadLocal实例本身，value才是真正要存储的值Object。</p>\n<ul>\n<li>每个Thread线程内部都有一个ThreadLocalMap类型的变量threadLocals。</li>\n<li>ThreadLocalMap 没有继承 Map 接口，而是自定义 <code>Entry</code> 类，Entry 的 Key 是 Threadlocal 对象的弱引用，value 事真正要存储的值。然后使用数组 <code>Entry[]</code> 去实现每个线程可以关联多个ThreadLocal变量。</li>\n<li>ThreadLocal就相当于一个工具壳，它通过set方法把value值放入调用线程的threadLocals变量里面并存放起来，当调用线程调用它的get方法时，再从当前线程的threadLocals变量里面将其拿出来使用。</li>\n<li>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</li>\n</ul>\n<p>这种方案设计的好处：</p>\n<ul>\n<li>每个Map存储的Entry数量变少。因为之前的存储数量由Thread的数量决定，现在是由ThreadLocal的数量决定。在实际开发中，ThreadLocal的数量往往少于线程的数量。数量变少也可以尽量避免哈希冲突。</li>\n<li>当Thread销毁的时候，ThreadLocalMap也会随之销毁，减少内存的使用。</li>\n</ul>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><p><strong>1、ThreadLocal真的只对当前线程可见吗？</strong></p>\n<p>ThreadLocal 的实例仍然是存储在 java 堆上，而不是存放在栈上。只是通过了特殊的方式只让当前线程可见。</p>\n<p>我们也可以通过特殊的方式，使用 InheritableThreadLocal 可以实现多个线程访问 ThreadLocal 的值。例如我们在主线程中创建一个 InheritableThreadLocal 的实例，然后在子线程中得到这个 InheritableThreadLocal 实例设置的值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testInheritableThreadLocal</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ThreadLocal</span> <span class=\"variable\">threadLocal</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InheritableThreadLocal</span>();</span><br><span class=\"line\">    threadLocal.set(<span class=\"string\">&quot;droidyue.com&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">super</span>.run();</span><br><span class=\"line\">            Log.i(LOGTAG, <span class=\"string\">&quot;testInheritableThreadLocal =&quot;</span> + threadLocal.get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    t.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2、内存泄露问题</strong><br>实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，弱引用的特点是，如果这个对象只存在弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p>\n<p>所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。</p>\n<p>ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。如果说会出现内存泄漏，那只有在出现了 key 为 null 的记录后，没有手动调用 remove() 方法，并且之后也不再调用 get()、set()、remove() 方法的情况下。</p>\n<p>建议回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。 尽量在代理中使用try-finally块进行回收。</p>\n<h1 id=\"Fork-x2F-Join框架\"><a href=\"#Fork-x2F-Join框架\" class=\"headerlink\" title=\"Fork&#x2F;Join框架\"></a>Fork&#x2F;Join框架</h1><h2 id=\"Fork-x2F-Join框架是什么\"><a href=\"#Fork-x2F-Join框架是什么\" class=\"headerlink\" title=\"Fork&#x2F;Join框架是什么\"></a>Fork&#x2F;Join框架是什么</h2><p>Fork&#x2F;Join 框架是一种在 JDK 7 引入的线程池，用于并行执行把一个大任务拆成多个小任务并行执行，最终汇总每个小任务结果得到大任务结果的特殊任务。通过其命名也很容易看出框架主要分为 Fork 和 Join 两个阶段，第一阶段 Fork 是把一个大任务拆分为多个子任务并行的执行，第二阶段 Join 是合并这些子任务的所有执行结果，最后得到大任务的结果。</p>\n<p>Fork&#x2F;Join 框架的核心思想是<code>分而治之</code>，并且使用了<code>工作窃取算法（work-stealing）</code>。工作窃取算法是指某个线程从其他队列里窃取任务来执行。</p>\n<p>我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。</p>\n<p>但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>\n<p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>\n<p><img src=\"/2021/03/10/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20230307161241317.png\" alt=\"image-20230307161241317\"></p>\n<ol>\n<li>ForkJoinPool 的每个工作线程都维护着一个工作队列（WorkQueue），这是一个双端队列（Deque），里面存放的对象是任务（ForkJoinTask）。</li>\n<li>每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是 LIFO 方式，也就是说每次从队尾取出任务来执行。</li>\n<li>每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。</li>\n<li>在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。</li>\n<li>在既没有自己的任务，也没有可以窃取的任务时，进入休眠。</li>\n</ol>\n<p>Java 8 Stream 的并行操作底层就是用到了 Fork&#x2F;Join 框架。但 Fork&#x2F;Join 是使用多个线程协作来计算的，所以会有线程通信和线程切换的开销。不是所有的场景都适合使用 Fork&#x2F;Join 框架。</p>\n<h2 id=\"Fork-x2F-Join框架原理\"><a href=\"#Fork-x2F-Join框架原理\" class=\"headerlink\" title=\"Fork&#x2F;Join框架原理\"></a>Fork&#x2F;Join框架原理</h2><p>Fork&#x2F;Join 框架包括三部分：</p>\n<ul>\n<li><code>ForkJoinPool</code>：线程池。</li>\n<li><code>ForkJoinTask</code>：任务，但其本身是抽象类，通过会使用它的实现类：<ul>\n<li><code>RecursiveAction</code>：一个递归无结果的ForkJoinTask（没有返回值）。</li>\n<li><code>RecursiveTask</code>：一个递归有结果的ForkJoinTask（有返回值）</li>\n</ul>\n</li>\n<li><code>ForkJoinWorkerThread</code>：负责执行任务。</li>\n</ul>\n<p><img src=\"en-resource://database/11527:1\" alt=\"0fc66bd0e0f8d5cb5b01c2d43dfcc3d6.png\"></p>\n<h2 id=\"ForkJoinPool\"><a href=\"#ForkJoinPool\" class=\"headerlink\" title=\"ForkJoinPool\"></a>ForkJoinPool</h2><p>ForkJoinPool 是 Fork&#x2F;Join 框架的核心类，是用于执行 ForkJoinTask 任务的执行（线程）池。ForkJoinPool 同时维护着执行池中的线程和任务队列。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ForkJoinPool</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractExecutorService</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 任务队列</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> WorkQueue[] workQueues;   </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WorkQueue</span> &#123;</span><br><span class=\"line\">\t\tForkJoinTask&lt;?&gt;[] array;   <span class=\"comment\">// the elements (initially unallocated)</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ForkJoinPool pool;   <span class=\"comment\">// the containing pool (may be null)</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ForkJoinWorkerThread owner;\t<span class=\"comment\">// owning thread or null if shared</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>ForkJoinPool 有一个核心内部类 WorkQueue，这是一个双端队列，用于存储，WorkQueue中有执行任务的线程（ForkJoinWorkerThread owner），还有这个线程需要处理的任务（ForkJoinTask&lt;?&gt;[] array）。ForkJoinPool 维护了一个工作队列数组（WorkQueue[] workQueues），即每个工作线程都维护着一个工作队列。</p>\n<p>当工作线程在处理自己的工作队列时，会从队列首取任务来执行（FIFO）；如果是窃取其他队列的任务时，窃取的任务位于所属任务队列的队尾（LIFO）。</p>\n<h2 id=\"ForkJoinTask\"><a href=\"#ForkJoinTask\" class=\"headerlink\" title=\"ForkJoinTask\"></a>ForkJoinTask</h2><p>ForkJoinTask 表示 ForkJoin 任务，在使用框架时首先必须先定义任务，通常只需要继承自 ForkJoinTask 类的子类 RecursiveAction(无返回结果) 或者 RecursiveTask(有返回结果)即可。ForkJoinTask 也是 Future 的子类，所以也需要等待返回结果。</p>\n<p>ForkJoinTask 有一个 int 类型的 status 字段：</p>\n<ul>\n<li>高16位存储任务执行状态：<ul>\n<li>NORMAL 已完成</li>\n<li>CANCELLED 被取消</li>\n<li>SIGNAL 信号</li>\n<li>EXCEPTIONAL 发生异常</li>\n</ul>\n</li>\n<li>低16位预留用于用户自定义的标记。<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">int</span> status; <span class=\"comment\">// accessed directly by pool and workers</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DONE_MASK</span>   <span class=\"operator\">=</span> <span class=\"number\">0xf0000000</span>;  <span class=\"comment\">// mask out non-completion bits</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">NORMAL</span>      <span class=\"operator\">=</span> <span class=\"number\">0xf0000000</span>;  <span class=\"comment\">// must be negative</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CANCELLED</span>   <span class=\"operator\">=</span> <span class=\"number\">0xc0000000</span>;  <span class=\"comment\">// must be &lt; NORMAL</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">EXCEPTIONAL</span> <span class=\"operator\">=</span> <span class=\"number\">0x80000000</span>;  <span class=\"comment\">// must be &lt; CANCELLED</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">SIGNAL</span>      <span class=\"operator\">=</span> <span class=\"number\">0x00010000</span>;  <span class=\"comment\">// must be &gt;= 1 &lt;&lt; 16</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">SMASK</span>       <span class=\"operator\">=</span> <span class=\"number\">0x0000ffff</span>;  <span class=\"comment\">// short bits for tags</span></span><br></pre></td></tr></table></figure>\n任务未完成之前status大于等于0，完成之后就是NORMAL、CANCELLED或EXCEPTIONAL这几个小于0的值，这几个值也是按大小顺序的：0（初始状态） &gt; NORMAL &gt; CANCELLED &gt; EXCEPTIONAL.</li>\n</ul>\n<p>ForkJoinTask 常用方法：</p>\n<ul>\n<li><code>fork()</code>    在当前线程运行的线程池中安排一个异步执行。简单的理解就是再创建一个子任务。</li>\n<li><code>join()</code>    当任务完成的时候返回计算结果。</li>\n<li><code>invoke()</code>    开始执行任务，如果必要，等待计算完成。</li>\n</ul>\n<p><strong>fork() 方法</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ForkJoinTask&lt;V&gt; <span class=\"title function_\">fork</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    Thread t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((t = Thread.currentThread()) <span class=\"keyword\">instanceof</span> ForkJoinWorkerThread)</span><br><span class=\"line\">        ((ForkJoinWorkerThread)t).workQueue.push(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        ForkJoinPool.common.externalPush(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>fork() 做的工作很简单，将任务通过push方法加入到当前工作线程的工作队列或者提交队列（外部非ForkJoinWorkerThread线程通过submit、execute方法提交的任务），等待被线程池调度执行，这是一个非阻塞的立即返回方法。</p>\n<p><strong>join()方法</strong><br>join() 的工作则复杂得多，也是 join() 可以使得线程免于被阻塞的原因——不像同名的 Thread.join()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title function_\">join</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s;</span><br><span class=\"line\">    <span class=\"comment\">// doJoin()方法来获取当前任务的执行状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class=\"line\">        <span class=\"comment\">// 任务异常，抛出异常</span></span><br><span class=\"line\">        reportException(s);</span><br><span class=\"line\">    <span class=\"comment\">// 任务正常完成，获取返回值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getRawResult();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * doJoin()方法用来返回当前任务的执行状态</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">doJoin</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class=\"line\">    <span class=\"comment\">// 先判断任务是否执行完毕，执行完毕直接返回结果（执行状态）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (s = status) &lt; <span class=\"number\">0</span> ? s :</span><br><span class=\"line\">    <span class=\"comment\">// 如果没有执行完毕，先判断是否是ForkJoinWorkThread线程</span></span><br><span class=\"line\">    ((t = Thread.currentThread()) <span class=\"keyword\">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class=\"line\">        <span class=\"comment\">// 如果是，先判断任务是否处于工作队列顶端（意味着下一个就执行它）</span></span><br><span class=\"line\">        <span class=\"comment\">// tryUnpush()方法判断任务是否处于当前工作队列顶端，是返回true</span></span><br><span class=\"line\">        <span class=\"comment\">// doExec()方法执行任务</span></span><br><span class=\"line\">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class=\"line\">        <span class=\"comment\">// 如果是处于顶端并且任务执行完毕，返回结果</span></span><br><span class=\"line\">        tryUnpush(<span class=\"built_in\">this</span>) &amp;&amp; (s = doExec()) &lt; <span class=\"number\">0</span> ? s :</span><br><span class=\"line\">        <span class=\"comment\">// 如果不在顶端或者在顶端却没未执行完毕，那就调用awitJoin()执行任务</span></span><br><span class=\"line\">        <span class=\"comment\">// awaitJoin()：使用自旋使任务执行完成，返回结果</span></span><br><span class=\"line\">        wt.pool.awaitJoin(w, <span class=\"built_in\">this</span>, <span class=\"number\">0L</span>) :</span><br><span class=\"line\">    <span class=\"comment\">// 如果不是ForkJoinWorkThread线程，执行externalAwaitDone()返回任务结果</span></span><br><span class=\"line\">    externalAwaitDone();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>检查调用 join() 的线程是否是 ForkJoinThread 线程。如果不是（例如 main 线程），则阻塞当前线程，等待任务完成。如果是，则不阻塞。</li>\n<li>查看任务的完成状态，如果已经完成，直接返回结果。</li>\n<li>如果任务尚未完成，但处于自己的工作队列内，则完成它。</li>\n<li>如果任务已经被其他的工作线程偷走，则窃取这个小偷的工作队列内的任务（以 FIFO 方式），执行，以期帮助它早日完成欲 join 的任务。</li>\n<li>如果偷走任务的小偷也已经把自己的任务全部做完，正在等待需要 join 的任务时，则找到小偷的小偷，帮助它完成它的任务。</li>\n<li>递归地执行第5步。</li>\n</ol>\n<h2 id=\"ForkJoinWorkerThread\"><a href=\"#ForkJoinWorkerThread\" class=\"headerlink\" title=\"ForkJoinWorkerThread\"></a>ForkJoinWorkerThread</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class ForkJoinWorkerThread extends Thread &#123;</span><br><span class=\"line\">    final ForkJoinPool pool;                // the pool this thread works in</span><br><span class=\"line\">    final ForkJoinPool.WorkQueue workQueue; // work-stealing mechanics</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ForkJoinWorkThread 比较简单，继承了 Thread 类，持有 ForkJoinPool 和 ForkJoinPool.WorkQueue 的引用，以表明该线程属于哪个线程池，它的工作队列是哪个。其他的和普通线程差不多。</p>\n<h2 id=\"Fork-x2F-Join框架使用\"><a href=\"#Fork-x2F-Join框架使用\" class=\"headerlink\" title=\"Fork&#x2F;Join框架使用\"></a>Fork&#x2F;Join框架使用</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CountTask</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">THRESHOLD</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> end;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">CountTask</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.end = end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Integer <span class=\"title function_\">compute</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">canCompute</span> <span class=\"operator\">=</span> (end - start) &lt;= THRESHOLD;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canCompute) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; start to compute [&quot;</span> + start + <span class=\"string\">&quot;, &quot;</span> + end + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt;= end; i++) &#123;</span><br><span class=\"line\">                sum += i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; start to split [&quot;</span> + start + <span class=\"string\">&quot;, &quot;</span> + end + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">middle</span> <span class=\"operator\">=</span> (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">CountTask</span> <span class=\"variable\">leftTask</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountTask</span>(start, middle);</span><br><span class=\"line\">            <span class=\"type\">CountTask</span> <span class=\"variable\">rightTask</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountTask</span>(middle + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">            leftTask.fork();</span><br><span class=\"line\">            rightTask.fork();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">leftResult</span> <span class=\"operator\">=</span> leftTask.join();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rightResult</span> <span class=\"operator\">=</span> rightTask.join();</span><br><span class=\"line\">            sum = leftResult + rightResult;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ForkJoinPool</span> <span class=\"variable\">forkJoinPool</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ForkJoinPool</span>();</span><br><span class=\"line\">        <span class=\"type\">CountTask</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountTask</span>(<span class=\"number\">1</span>, <span class=\"number\">22</span>);</span><br><span class=\"line\">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(result.get());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参考 <a href=\"https://juejin.cn/post/6906424424967667725\">并发编程之ForkJoin框架原理分析</a></p>\n","categories":["Java","Java并发"],"tags":["Java"]},{"title":"Linux系列（一）：硬件结构","url":"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/","content":"<blockquote>\n<p>Linux系列（一）：硬件结构</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"冯诺依曼模型\"><a href=\"#冯诺依曼模型\" class=\"headerlink\" title=\"冯诺依曼模型\"></a>冯诺依曼模型</h2><p><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115502558.png\" alt=\"image-20230319115502558\"></p>\n<p>冯诺依曼模型定义计算机基本结构为 5 个部分， 分别是<code>中央处理器(CPU)</code>、<code>内存</code>、<code>输入设备</code>、<code>输出设备</code>、<code>总线</code>。</p>\n<h3 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h3><p>中央处理器也就是我们常说的 CPU，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：</p>\n<ul>\n<li>32 位 CPU 一次可以计算 4 个字节</li>\n<li>64 位 CPU 一次可以计算 8 个字节</li>\n</ul>\n<p>CPU 内部还有一些组件：</p>\n<ul>\n<li><code>控制单元</code>负责控制 CPU 工作</li>\n<li><code>逻辑运算单元</code>负责计算</li>\n<li><code>寄存器</code>存储计算时的数据</li>\n</ul>\n<p>而寄存器可以分为多种类，每种寄存器的功能又不尽相同。</p>\n<ul>\n<li><code>通用寄存器</code>，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。</li>\n<li><code>程序计数器（PC）</code>，用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。</li>\n<li><code>指令寄存器</code>，用来存放程序计数器指向的指令，也就是当前正在执行的指令本身，指令被执行完成之前，指令都存储在这里。</li>\n</ul>\n<h3 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h3><p>我们的程序和数据都是存储在内存，存储的区域是线性的。</p>\n<p>数据存储的单位是一个二进制位(bit)，即 0 或 1。最小的存储单位是字节(byte)，1 字节等于 8 位。</p>\n<p>内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。</p>\n<h3 id=\"总线\"><a href=\"#总线\" class=\"headerlink\" title=\"总线\"></a>总线</h3><p>总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：</p>\n<ul>\n<li><code>地址总线</code>：用于指定 CPU 将要操作的内存地址。</li>\n<li><code>数据总线</code>：用于读写内存的数据。</li>\n<li><code>控制总线</code>：用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线。</li>\n</ul>\n<p>当 CPU 要读写内存数据的时候，一般需要通过两个总线：首先要通过「地址总线」来指定内存的地址，再通过「数据总线」来传输数据。</p>\n<h3 id=\"输入输出设备\"><a href=\"#输入输出设备\" class=\"headerlink\" title=\"输入输出设备\"></a>输入输出设备</h3><p>输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘， 按下按键时是需要和 CPU 进行交互的，这时就需要用到「控制总线」了。</p>\n<h3 id=\"程序执行\"><a href=\"#程序执行\" class=\"headerlink\" title=\"程序执行\"></a>程序执行</h3><p>程序实际上是一条一条指令，一个通用 CPU 要完成各类计算、推理、判断和控制工作，它的指令种类少则几十种，多则数百种，CPU的各种指令的集合称为CPU的<code>指令集</code>。</p>\n<p>指令集决定了处理器的架构，处理器架构就是处理器的硬件架构，称为<code>微架构</code>。是一堆硬件电路，去实现指令集所规定的操作运算。</p>\n<p>简单来说，指令集是CPU的顶层设计规范，微架构是这个顶层规范的物理实现，这种实现可以有多种，实现方法可以有变化。<code>一般说的CPU架构包含了CPU指令集和微架构两个东西</code>。</p>\n<h3 id=\"指令集类型\"><a href=\"#指令集类型\" class=\"headerlink\" title=\"指令集类型\"></a>指令集类型</h3><p>指令集分为两种主流类型：</p>\n<ul>\n<li><code>CISC</code>(Complex Instruction Set Computers，复杂指令集)</li>\n<li><code>RISC</code>(Reduced Instruction Set Computers，精简指令集)</li>\n</ul>\n<p>CISC指令集：CISC的指令能力强，指令长度变长，但多数指令使用率低，增加了CPU的复杂度，增加CPU功耗和发热。</p>\n<ul>\n<li><code>x86</code>：x86 是典型的CISC指令集，适用于PC机，桌面等设备。</li>\n</ul>\n<p>RISC指令集：大部分为单周期指令，指令长度固定，操作寄存器，只有Load&#x2F;Store操作内存，适用于移动端设备。</p>\n<ul>\n<li><code>ARM</code>：最流行的RISC指令集，占移动设备端90%以上的市场。</li>\n<li><code>MIPS</code>：MIPS是RISC的开山之作，但是生态没有起来。</li>\n<li><code>RISC-V</code>：综合以上特点新开发的，完全开源，但是生态链还在路上。</li>\n</ul>\n<h3 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a>执行过程</h3><p>上面我们提到程序执行的过程实际上是执行一条一条指令，负责执行指令的就是 CPU 了。<br><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115546761.png\" alt=\"image-20230319115546761\"></p>\n<ol>\n<li>第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作 「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总 线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。</li>\n<li>第二步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把 指令交给「逻辑运算单元」运算;如果是存储类型的指令，则交由「控制单元」执行。</li>\n<li>第三步，CPU 执行完指令后，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数 器」的值会自增 4。</li>\n</ol>\n<h3 id=\"执行周期\"><a href=\"#执行周期\" class=\"headerlink\" title=\"执行周期\"></a>执行周期</h3><p>指令执行是按照周期来执行的，CPU 的工作就是一个周期接着一个周期，周而复始。<br><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115601204.png\" alt=\"image-20230319115601204\"></p>\n<ol>\n<li>CPU 通过程序计数器读取对应内存地址的指令，这个部分称为 Fetch(取得指令)。</li>\n<li>CPU 对指令进行解码，这个部分称为 Decode(指令译码)。</li>\n<li>CPU 执行指令，这个部分称为 Execution(执行指令)。</li>\n<li>CPU 将计算结果存回寄存器或者将寄存器的值存入内存，这个部分称为 Store(数据回写)。</li>\n</ol>\n<p>对CPU整个生命周期的不同粒度的划分，可以划分为：</p>\n<ul>\n<li><code>时钟周期</code></li>\n<li><code>机器周期</code></li>\n<li><code>指令周期</code></li>\n</ul>\n<p>CPU的最小生命单位就是时钟周期，一个机器周期包括若干个时钟周期，一个指令周期包含若干个机器周期。所以按粒度排序，<code>指令周期 &gt; 机器周期 &gt; 时钟周期</code>。</p>\n<h4 id=\"时钟周期\"><a href=\"#时钟周期\" class=\"headerlink\" title=\"时钟周期\"></a>时钟周期</h4><p><code>时钟周期</code>也称为振荡周期，代表完成一次脉冲信号高低电平的转换，是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。</p>\n<p>时钟周期定义为<code>1/时钟脉冲频率</code>，比如我们有一个 1 GHz 的 CPU，指的是时钟频率是 1 G，代表着 1 秒 会产生 1G 次数的脉冲信号，每一次脉冲信号高低电平的转换就是一个周期，所以时间周期市场为 1s&#x2F;1G &#x3D; 1ms。</p>\n<p>在8051单片机中把一个时钟周期定义为一个节拍(用P表示)，二个节拍定义为一个状态周期(用S表示)。</p>\n<h4 id=\"机器周期\"><a href=\"#机器周期\" class=\"headerlink\" title=\"机器周期\"></a>机器周期</h4><p>在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶段，每一阶段完成一项工作。例如，取指令、存储器读、存储器写等，这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为<code>机器周期</code>。</p>\n<p>一般情况下，一个机器周期由若干个S周期(状态周期)组成。8051系列单片机的一个机器周期同6个S周期(状态周期)组成。前面已说过一个时钟周期定义为一个节拍(用P表示)，二个节拍定义为一个<code>状态周期</code>(用S表示)，8051单片机的机器周期由6个状态周期组成，也就是说<code>一个机器周期=6个状态周期=12个时钟周期</code>。</p>\n<h4 id=\"指令周期\"><a href=\"#指令周期\" class=\"headerlink\" title=\"指令周期\"></a>指令周期</h4><p><code>指令周期</code>是执行一条指令所需要的时间，一般由若干个机器周期组成。指令不同，所需的机器周期数也不同。对于一些简单的的单字节指令，在取指令周期中，指令取出到指令寄存器后，立即译码执行，不再需要其它的机器周期。对于一些比较复杂的指令，例如转移指令、乘法指令，则需要两个或者两个以上的机器周期。</p>\n<p>通常含一个机器周期的指令称为单周期指令，包含两个机器周期的指令称为双周期指令。</p>\n<h4 id=\"相互关系\"><a href=\"#相互关系\" class=\"headerlink\" title=\"相互关系\"></a>相互关系</h4><p><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115617135.png\" alt=\"image-20230319115617135\"></p>\n<h3 id=\"硬中断和软中断\"><a href=\"#硬中断和软中断\" class=\"headerlink\" title=\"硬中断和软中断\"></a>硬中断和软中断</h3><p>有时候我们向cpu发出一些指令的时候希望得到cpu的快速响应执行。比如我们从键盘上输入文字的时候，肯定是希望屏幕上立刻显示出来，而不是等电脑播放完当前的音乐后再显示出来。这时候我们就需要引入<code>中断机制</code>。</p>\n<p>中断是系统用来响应硬件设备请求的一种机制，<code>操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求</code>。</p>\n<p>中断处理程序在响应中断时，会「打断其他进程的运行」，可能还会「临时关闭中断」，系统中其他的中断请求都无法被响应，也就说中断有可能会丢失，所以我们要求中断处理程序尽快执行完。</p>\n<p>为了解决中断处理程序执行时长过长的问题，linux将中断过程分成两个阶段：</p>\n<ul>\n<li>上半部对应<code>硬中断</code>，由<code>硬件</code>触发中断，<code>会打断 CPU 正在执行的任务，然后立即执行中断处理程序</code>。主要是负责耗时短的工作，特点是快速执行。</li>\n<li>下半部对应<code>软中断</code>，由<code>内核</code>触发中断，<code>负责上半部未完成的工作，以内核线程的方式执行</code>，并且每一个 CPU 都对应一个软中断内核线程，名字通常为 「ksoftirqd&#x2F;CPU 编号」。通常都是耗时比较⻓的事情，特点是延迟执行。</li>\n</ul>\n<p>常⻅的网卡接收网络包的例子。网卡收到网络包后，会通过硬件中断通知内核有新的数据到了，于是内核就会调用对应的中断处理程序来 响应该事件，这个事件的处理也是会分成上半部和下半部。</p>\n<ul>\n<li>上部分要做到快速处理，所以只要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态，比如把状态更新为表示数据已经读到内存中的状态值。接着内核会触发一个软中断，就可以返回硬中断响应了。</li>\n<li>下半部分把一些处理比较耗时且复杂的事情，交给「软中断处理程序」去做，其主要是需要从内存中找到网络数据，再按照网络协议栈，对网络数据进行逐层解析和 处理，最后把数据送给应用程序。</li>\n</ul>\n<h2 id=\"存储器结构\"><a href=\"#存储器结构\" class=\"headerlink\" title=\"存储器结构\"></a>存储器结构</h2><p><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115631476.png\" alt=\"image-20230319115631476\"></p>\n<p>存储器通常可以分为这么几个级别：</p>\n<ul>\n<li>寄存器</li>\n<li>CPU Cache<ul>\n<li>1-Cache</li>\n<li>L2-Cache</li>\n<li>L3-Cahce</li>\n</ul>\n</li>\n<li>内存</li>\n<li>SSD&#x2F;HDD 硬盘</li>\n</ul>\n<h3 id=\"寄存器\"><a href=\"#寄存器\" class=\"headerlink\" title=\"寄存器\"></a>寄存器</h3><p><code>寄存器</code>是最靠近 CPU 的控制单元和逻辑计算单元的存储器。存储器的数量通常在几十到几百之间，32 位 CPU 中单个寄存器可以存储 4 个字节，64 位 CPU 中大多数寄存器可以存储 8 个字节，所以寄存器的总大小大概是<code>几百个字节</code>。</p>\n<p>寄存器的访问速度非常快，一般要求在<code>半个 CPU 时钟周期</code>内完成读写。</p>\n<h3 id=\"CPU-Cache\"><a href=\"#CPU-Cache\" class=\"headerlink\" title=\"CPU Cache\"></a>CPU Cache</h3><p><code>CPU Cache</code> 也存在 CPU 内部，处理速度相比寄存器慢了一点，但是能存储的数据也稍微多了一些。</p>\n<p>CPU Cache 用的是一种叫 <code>SRAM</code>(Static Random-Access Memory，静态随机存储器) 的芯片。SRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。</p>\n<p>CPU Cache 通常会分为 L1、L2、L3 三层。<br><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115647816.png\" alt=\"image-20230319115647816\"></p>\n<ul>\n<li><code>L1 高速缓存</code>：访问速度几乎和寄存器一样快，通常只需要 <code>2~4 个时钟周期</code>，大小在<code>几十 KB 到几百 KB</code> 不等，每个 CPU 都有<code>单独的 L1 高速缓存</code>。L1 高速缓存通常分成<code>指令缓存</code>和<code>数据缓存</code>。分别存储指令和数据。</li>\n<li><code>L2 高速缓存</code>：访问速度为 <code>10~20 个时钟周期</code>，大小在<code>几百 KB 到几 MB</code> 不等，每个 CPU 都有<code>单独的 L2 高速缓存</code>。</li>\n<li><code>L3 高速缓存</code>：访问速度在 <code>20~60 个时钟周期</code>，大小在<code>几 MB 到几十 MB</code> 不等，多个 CPU <code>共享</code>相同的 L3 高速缓存。</li>\n</ul>\n<h3 id=\"内存-1\"><a href=\"#内存-1\" class=\"headerlink\" title=\"内存\"></a>内存</h3><p><code>内存</code>存在 CPU 外部，使用的是 <code>DRAM</code> (Dynamic Random Access Memory，动态随机存取存储器) 的芯片。</p>\n<p>DRAM 存储一个 bit 数据，只需要一个晶体管和一个电容就能存储，但是因为数据会被存储在电容里，电 容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。</p>\n<p>DRAM 的访问的速度会更慢，内存速度大概在 <code>200~300 个时钟周期</code>之间。</p>\n<h3 id=\"SSD-x2F-HDD硬盘\"><a href=\"#SSD-x2F-HDD硬盘\" class=\"headerlink\" title=\"SSD&#x2F;HDD硬盘\"></a>SSD&#x2F;HDD硬盘</h3><p><code>SSD</code>(Solid-state disk) 就是我们常说的固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。内存的读写速度比 SSD 大概快 <code>10~1000</code> 倍。</p>\n<p>SSD由<code>主控芯片</code>、<code>闪存颗粒</code>和<code>缓存芯片</code>三部分组成。</p>\n<p><strong>主控芯片</strong><br>当前主流的主控芯片厂商有 marvell 迈威（俗称“马牌”）、SandForce、siliconmotion慧荣、phison群联、jmicron智微等。</p>\n<p><strong>闪存颗粒</strong><br>闪存(Flash Memory)颗粒本质上是一种长寿命的非易失性(在断电情况下仍能保持所存储的数据信息)的存储器，其中<code>NAND闪存</code>是应用规模最广泛的颗粒。</p>\n<p>根据NAND闪存中电子单元密度的差异，又可以分为SLC、MLC、TLC和QLC颗粒。</p>\n<ul>\n<li><code>SLC</code>：每个Cell单元存储<code>1bit</code>信息，也就是只有0、1两种电压变化，结构简单，电压控制也快速，写入数据时电压变化区间小，寿命长，读写次数在10万次以上，造价高，多用于企业级高端产品。</li>\n<li><code>MLC</code>：每个cell单元存储<code>2bit</code>信息，需要更复杂的电压控制，有00,01,10,11四种变化，寿命长，造价可接受，多用民用高端产品，读写次数在5000左右。</li>\n<li><code>TLC</code>：每个cell单元存储<code>3bit</code>信息，电压从000到001有8种变化，容量比MLC再次增加1&#x2F;3，成本更低，但是架构更复杂，使命寿命低，读写次数在1000~2000左右，是当下主流厂商首选闪存颗粒。</li>\n<li><code>QLC</code>：每个cell单元存储<code>4bit</code>信息，电压有16种变化，但是容量能增加33%，就是写入性能、P&#x2F;E寿命与TLC相比会进一步降低，主要应用于低端市场。</li>\n</ul>\n<p><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115702867.png\" alt=\"image-20230319115702867\"></p>\n<p><strong>缓存芯片</strong><br>缓存芯片在SSD中属于锦上添花的作用，部分低端的SSD出于成本控制可能都没有缓存芯片。</p>\n<p>由于固态硬盘内部的磨损机制，就导致固态硬盘在读写小文件和常用文件时，会不断进行数据的整块的写入缓存，然而导出到闪存颗粒，这个过程需要大量缓存维系。特别是在进行大数量级的碎片文件的读写进程，高缓存的作用更是明显。<code>而没有缓存芯片的固态硬盘在用了一段时间后，开始掉速</code>。</p>\n<p>当然，还有一款传统的硬盘，也就是机械硬盘(Hard Disk Drive, HDD)，它是通过物理读写的方式来访问 数据的，因此它访问速度是非常慢的，它的速度比内存慢 <code>10W</code> 倍左右。由于 SSD 的价格快接近机械硬盘了，因此机械硬盘已经逐渐被 SSD 替代了。</p>\n<h3 id=\"相互关系-1\"><a href=\"#相互关系-1\" class=\"headerlink\" title=\"相互关系\"></a>相互关系</h3><p><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115718432.png\" alt=\"image-20230319115718432\"></p>\n<p>当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即 可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还 是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据。</p>\n<h2 id=\"一致性问题\"><a href=\"#一致性问题\" class=\"headerlink\" title=\"一致性问题\"></a>一致性问题</h2><h3 id=\"CPU-Cache-Line\"><a href=\"#CPU-Cache-Line\" class=\"headerlink\" title=\"CPU Cache Line\"></a>CPU Cache Line</h3><p>CPU Cache 的数据是从内存中读取过来的，它是以一小块一小块读取数据的，每一小块称为 <code>Cache Line</code>(缓存块)。<code>CPU Line 是 CPU 从内存读取数据的基本单位</code>。一般来说，L1 Cache Line 大小是 64 字节，也就意味着 <code>L1 Cache 一次载入数据的大小是 64 字节</code>。</p>\n<p>比如，有一个 int array[100] 的数组，当载入 array[0] 时，由于这个数组元素的大小在内存只占 4 字节，不足 64 字节，CPU 就会顺序加载数组元素到 array[15] ，意味着 array[0]~array[15] 数组元素都会被缓存在 CPU Cache 中了，因此当下次访问这些数组元素时，会直接从 CPU Cache 读取，而不用再从内存中读取。</p>\n<p>每一行 CPU Line 都和一块内存地址形成映射。CPU 要根据内存地址读取数据的时候，无论数据是否存放到 Cache 中，CPU 都是先访问 Cache，只有当 Cache 中找不到数据时，才会去访问内存，并把内存中的数据读入到 Cache 中，CPU 再从 CPU Cache 读取数据。</p>\n<p>CPU 在从 CPU Cache 读取数据的时候，并不是读取 CPU Line 中的整个数据块，而是读取 CPU 所需要的一个数据片段，这样的数据统称为一个<code>字(Word)</code>。CPU 通过包括<code>组标记</code>、<code>CPU Line 索引</code>、<code>偏移量</code>这三种信息，在 CPU Cache Line 中查找需要的字。而对于 CPU Cache 里的数据结构，则是由<code>索引</code> + <code>有效位</code> + <code>组标记</code> + <code>数据块</code>组成。<br><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115735878.png\" alt=\"image-20230319115735878\"></p>\n<p>如果内存中的数据已经在 CPU Cache 中了，那 CPU 访问一个内存地址的时候，会经历这 4 个步骤：</p>\n<ol>\n<li>根据内存地址中索引信息，计算在 CPU Cahe 中的索引，也就是找出对应的 CPU Line 的地址。</li>\n<li>找到对应 CPU Line 后，判断 CPU Line 中的有效位，确认 CPU Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行。</li>\n<li>对比内存地址中组标记和 CPU Line 中的组标记，确认 CPU Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行。</li>\n<li>根据内存地址中偏移量信息，从 CPU Line 的数据块中，读取对应的字。</li>\n</ol>\n<h3 id=\"写回策略\"><a href=\"#写回策略\" class=\"headerlink\" title=\"写回策略\"></a>写回策略</h3><p>当我们更新了 CPU Cache Line 的内容时，需要在适当的时机把更新的内容写回内存。根据更新的时机，可以分为：</p>\n<ul>\n<li><code>写直达</code>(Write Through)：把数据同时写入内存和 Cache 中。安全性高，但性能较差。</li>\n<li><code>写回</code>(Write Back)：当发生写操作时，只有在缓存不命中，同时数据对应的 Cache 中 的 Cache Block 为脏标记的情况下，才会将数据写到内存中；而在缓存命中的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。减少了数据写回内存的频率，这样便可以提高系统的性能。</li>\n</ul>\n<h3 id=\"缓存一致性问题\"><a href=\"#缓存一致性问题\" class=\"headerlink\" title=\"缓存一致性问题\"></a>缓存一致性问题</h3><p>现代 CPU 都是多核的，每个核心都会有单独的 L1&#x2F;L2 缓存，<code>同一块内存地址的数据可能会被读取到不同个核心的 CPU Cache Line 上</code>，如果不能处理好 CPU Cache Line 上的数据写回内存的时机，容易发生<code>缓存一致性问题</code>。</p>\n<p>假设 A 号核心和 B 号核心同时运行两个线程，都操作共同的变量 i(初始值为 0 )。<br><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115751158.png\" alt=\"image-20230319115751158\"></p>\n<ol>\n<li>A 号核心执行了 i++ 语句的时候，为了考虑性能，使用了我们前面所说的写回策略，先把值为 1 的执行结果写入到 L1&#x2F;L2 Cache 中，然后把 L1&#x2F;L2 Cache 中对应的 Block 标记为脏的，这个时候数据其实没有被同步到内存中的，因为写回策略，只有在 A 号核心中的这个 Cache Block 要被替换的时候，数据才会写入到内存里。</li>\n<li>B 号核心尝试从内存读取 i 变量的值，则读到的将会是错误的值，因为刚才 A 号核心更新 i 值还没写入到内存中，内存中的值还依然是 0。</li>\n</ol>\n<p>这个就是所谓的缓存一致性问题。要解决这一问题，就需要一种机制，来同步两个不同核心里面的缓存数据。要实现的这个机制的话，要保证做到下面这 2 点：</p>\n<ul>\n<li>某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为写传播 (Wreite Propagation)。</li>\n<li>某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串形化(Transaction Serialization)。</li>\n</ul>\n<h3 id=\"MESI协议\"><a href=\"#MESI协议\" class=\"headerlink\" title=\"MESI协议\"></a>MESI协议</h3><p>早期有一种<code>总线嗅探(Bus Snooping)</code>的技术来保证写传播：</p>\n<ul>\n<li>当 A 号 CPU 核心修改了 L1 Cache 中 i 变量的值，通过总线把这个事件广播通知给其他所有的核心，然后每个 CPU 核心都会监听总线上的广播事件，并 检查是否有相同的数据在自己的 L1 Cache 里面，如果 B 号 CPU 核心的 L1 Cache 中有该数据，那么也需要把该数据更新到自己的 L1 Cache。</li>\n</ul>\n<p>总线嗅探的原理非常简单，但是缺点也很明显：</p>\n<ul>\n<li>CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，这无疑会加重总线的负载。</li>\n<li>只是保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串形化。</li>\n</ul>\n<p><code>MESI 协议</code>基于总线嗅探机制实现了事务串形化，也用状态机机制降低了总线带宽压力，实现了 CPU 缓存一致性。</p>\n<p><code>MESI 协议把 Cache Line 标记为 4 种不同的状态</code>，MESI 其实是 4 个状态单词的开头字母缩写：</p>\n<ul>\n<li><code>Modified</code>，已修改，代表该 Cache Block 上的数据已经被更新过，但是还没有写 到内存里。</li>\n<li><code>Exclusive</code>，独占，代表 Cache Block 里的数据是干净的，且数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。</li>\n<li><code>Shared</code>，共享，代表 Cache Block 里的数据是干净的，且相同的数据在多个 CPU 核心的 Cache 里都有。</li>\n<li><code>Invalidated</code>，已失效，代表 Cache Block 里的数据已经失效了，不可以读取该状态的数据。</li>\n</ul>\n<blockquote>\n<p>「独占」和「共享」的数据都是干净的，差别在于：</p>\n<ul>\n<li><code>「独占」状态表示数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据</code>。这个时候，如果要向独占的 Cache 写数据，就可以直接自由地写入，而 不需要通知其他 CPU 核心，因为只有你这有这个数据，就不存在缓存一致性的问题了，于是就可以随便操作该数据。在「独占」状态下的数据，如果有其他核心从内存读取了相同的数据到各自的 Cache ，那么这个时 候，独占状态下的数据就会变成共享状态。</li>\n<li><code>「共享」状态代表着相同的数据在多个 CPU 核心的 Cache 里都有</code>。所以当我们要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后再更新当前 Cache 里面的数据。</li>\n</ul>\n</blockquote>\n<p>事实上，整个 MESI 的状态可以用一个<code>有限状态机</code>来表示它的状态流转。还有一点，对于不同状态触发的事件操作，可能是来自本地 CPU 核心发出的广播事件，也可以是来自其他 CPU 核心通过总线发出的广播事件。下图即是 MESI 协议的状态图：<br><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115812304.png\" alt=\"image-20230319115812304\"><br><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115824899.png\" alt=\"image-20230319115824899\"></p>\n<p>可以发现当 Cache Line 状态是「已修改」或者「独占」状态时，修改更新其数据不需要发送广播给其他 CPU 核心，这在一定程度上减少了总线带宽压力。</p>\n<h3 id=\"伪共享问题\"><a href=\"#伪共享问题\" class=\"headerlink\" title=\"伪共享问题\"></a>伪共享问题</h3><p>上面我们提高 MESI 协议，<code>解决了同一个变量被读取到不同 CPU 的 CPU Cache Line 的一致性问题</code>。</p>\n<p>如果两个不同的变量被读取到两个不同 CPU 的 CPU Cache Line，每个 CPU 只读写其 Cache 上的单个变量，理论上，两个变量各自的执行应该没有任何关系，互相也不会受到影响。但是如果使用了 MESI 协议，就会引发新的问题：<code>伪共享问题</code>。</p>\n<p><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115845086.png\" alt=\"image-20230319115845086\"></p>\n<ul>\n<li>1 号核心读取变量 A，由于 CPU 从内存读取数据到 Cache 的单位是 Cache Line，也正好变量 A 和 变 量 B 的数据归属于同一个 Cache Line，所以 A 和 B 的数据都会被加载到 Cache，并将此 Cache Line 标 记为「独占」状态。</li>\n</ul>\n<p><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115856919.png\" alt=\"image-20230319115856919\"></p>\n<ul>\n<li>接着，2 号核心开始从内存里读取变量 B，同样的也是读取 Cache Line 大小的数据到 Cache 中，此 Cache Line 中的数据也包含了变量 A 和 变量 B，此时 1 号和 2 号核心的 Cache Line 状态变为「共享」状 态。</li>\n</ul>\n<p><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115909199.png\" alt=\"image-20230319115909199\"></p>\n<ul>\n<li>1 号核心需要修改变量 A，发现此 Cache Line 的状态是「共享」状态，所以先需要通过总线发送消息 给 2 号核心，通知 2 号核心把 Cache 中对应的 Cache Line 标记为「已失效」状态，然后 1 号核心对应的 Cache Line 状态变成「已修改」状态，并且修改变量 A。</li>\n</ul>\n<p><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319115923946.png\" alt=\"image-20230319115923946\"></p>\n<ul>\n<li>2 号核心需要修改变量 B，此时 2 号核心的 Cache 中对应的 Cache Line 是已失效状态，另外由 于 1 号核心的 Cache 也有此相同的数据，且状态为「已修改」状态，所以要先把 1 号核心的 Cache 对应 的 Cache Line 写回到内存，然后 2 号核心再从内存读取 Cache Line 大小的数据到 Cache 中，最后把变 量 B 修改到 2 号核心的 Cache 中，并将状态标记为「已修改」状态。</li>\n</ul>\n<p>可以发现如果 1 号和 2 号 CPU 核心这样持续交替的分别修改变量 A 和 B，Cache 并没有起到缓存的效果，虽然变量 A 和 B 之间其实并没有任何的关系，但是因为同时归属 于一个 Cache Line ，这个 Cache Line 中的任意数据被修改后，都会相互影响。这种因为多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为 <code>伪共享(False Sharing)</code>。</p>\n<p><strong>避免伪共享</strong></p>\n<ol>\n<li><p>使用Linux 内核中的 <code>__cacheline_aligned_in_smp</code> 宏定义。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 结构体里的两个成员变量 a 和 b 在物理内存地址上是连续的，于是它们可能会位于同一个 Cache Line</span><br><span class=\"line\"> struct test &#123;</span><br><span class=\"line\"> \tint a;</span><br><span class=\"line\"> \tint b;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319120000708.png\" alt=\"image-20230319120000708\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 将 b 的地址设置为 Cache Line 对⻬地址，这样 a 和 b 变量就不会在同一个 Cache Line 中</span><br><span class=\"line\"> struct test &#123;</span><br><span class=\"line\"> \tint a;</span><br><span class=\"line\"> \tint b __cacheline_aligned_in_smp;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319120012283.png\" alt=\"image-20230319120012283\"></p>\n</li>\n<li><p>手动「字节填充 + 继承」。例如 Java 并发框架 Disruptor 里面的 RingBuffer 类。</p>\n</li>\n</ol>\n<p><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319120031295.png\" alt=\"image-20230319120031295\"></p>\n<ul>\n<li>RingBufferPad 定义了 p1 ～ p7 7 个 long 类型的变量。</li>\n<li>RingBufferFields 继承了 RingBufferPad，里面定义的全是 final 类型的字段。</li>\n<li>RingBuffer 继承了RingBufferFields，再次定义了 p1 ～ p7 7 个 long 类型的变量。</li>\n</ul>\n<p>CPU Cache 从内存读取数据的单位是 CPU Line，一般 64 位 CPU 的 CPU Line 的大小是 64 个字节，一个 long 类型的数据是 8 个字节，所以 CPU 一下会加载 8 个 long 类型的数据。</p>\n<p>根据 JVM 对象继承关系中父类成员和子类成员，内存地址是连续排列布局的，因此 RingBufferPad 中的 7 个 long 类型数据作为 <code>Cache Line 前置填充</code>，而 RingBuffer 中的 7 个 long 类型数据则作为 <code>Cache Line 后置填充</code>，这 14 个 long 变量没有任何实际用途，更不会对它们进行读写操作。</p>\n<p>而且 RingBufferFelds 里面定义的这些变量都是 final 修饰的，意味着第一次加载之后不会再修改， 又 由于「前后」各填充了 7 个不会被读写的 long 类型变量，所以无论怎么加载 Cache Line，这整个 Cache Line 里都没有会发生更新操作的数据，于是只要数据被频繁地读取访问，就自然没有数据被换出 Cache 的可能，也因此不会产生伪共享的问题。<br><img src=\"/2021/03/19/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/image-20230319120044434.png\" alt=\"image-20230319120044434\"></p>\n","categories":["Linux"],"tags":["Linux"]},{"title":"Linux系列（二）：内存管理","url":"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","content":"<blockquote>\n<p>Linux系列（二）：内存管理</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h2><p>如果进程可以直接使用绝对物理地址，容易造成同一个物理地址被两个不同的进程同时占用，从而导致进程出错的问题。解决办法是，<code>操作系统为每个进程分配独立的一套「虚拟地址」，然后操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来</code>。如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。这就是<code>虚拟内存</code>。</p>\n<p>虚拟内存的工作过程：进程只持有虚拟内存地址，然后会通过 CPU 芯片中的内存管理单元(<code>MMU</code>)的映射关系，来转换变成物理内存地址，然后再通过物理内存地址访问内存。<br><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121231645.png\" alt=\"image-20230319121231645\"></p>\n<h2 id=\"内存分页管理\"><a href=\"#内存分页管理\" class=\"headerlink\" title=\"内存分页管理\"></a>内存分页管理</h2><p>按照虚拟内存和物理内存的映射形式，可以分为：</p>\n<ul>\n<li><code>内存分段</code></li>\n<li><code>内存分页</code></li>\n</ul>\n<h3 id=\"内存分段\"><a href=\"#内存分段\" class=\"headerlink\" title=\"内存分段\"></a>内存分段</h3><p>在内存分段的机制下，虚拟内存和物理内存通过 <code>内存段表</code> 进行映射。<br><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121255911.png\" alt=\"image-20230319121255911\"></p>\n<ol>\n<li>把虚拟内存地址分为<code>段选择子</code>和<code>段内偏移量</code>。<ul>\n<li>段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。</li>\n<li>段内偏移量应该位于 0 和段界限之间，将段基地址加上段内偏移量得到物理内存地址。</li>\n</ul>\n</li>\n<li>将段表划分为这个<code>段基地址</code>、<code>段界限</code>和<code>特权等级</code>等，每一项段表项对应虚拟内存地址的一个段号。</li>\n<li>分段机制会把程序的虚拟地址分成 4 个段， 每个段在段表中有一个。虚拟内存地址通过段号在段表找到对应项的段基地址，再加上段内偏移量，即可就能找到物理内存中的地址。<br><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121314946.png\" alt=\"image-20230319121314946\"></li>\n</ol>\n<p>内存分段会有两个问题：</p>\n<ul>\n<li>第一个就是<code>内存碎片</code>的问题。</li>\n<li>第二个就是<code>内存交换的效率低</code>的问题。</li>\n</ul>\n<h3 id=\"内存分页\"><a href=\"#内存分页\" class=\"headerlink\" title=\"内存分页\"></a>内存分页</h3><p>为了解决内存分段的问题，后面就出现了内存分页。分⻚是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间， 我们叫<code>⻚(Page)</code>。在 Linux 下，每一⻚的大小为 4KB 。<code>虚拟地址与物理地址之间通过⻚表来映射</code>。<br><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121336342.png\" alt=\"image-20230319121336342\"></p>\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>页表是存在于内存的，一般是在内核态。</li>\n<li>每个进程都有一个单独的页表，而且每个进程的页表都会映射全部物理内存。</li>\n<li>MMU是在CPU内部的，功能是将虚拟内存地址转换成物理地址。</li>\n</ul>\n</blockquote>\n<p>在内存分页机制，虚拟内存和物理内存通过 <code>内存页表</code> 进行映射。<br><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121353529.png\" alt=\"image-20230319121353529\"></p>\n<ol>\n<li>虚拟地址分为两部分：<code>⻚号</code>和<code>⻚内偏移</code>。⻚号作为⻚表的索引，页内偏移量等于物理地址上的偏移量。</li>\n<li>⻚表分为<code>虚拟页号</code>和<code>物理页号</code>，虚拟页号对应虚拟地址的页号，物理⻚对应物理内存的基地址。</li>\n<li>虚拟地址根据⻚号，从⻚表里面，查询对应的物理⻚号，再加上页内偏移量就得到了物理内存地址。<br><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121409453.png\" alt=\"image-20230319121409453\"></li>\n</ol>\n<p>而且在分⻚的形式下，我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们只需要在进行虚拟内存和物理内存的⻚之间完成映射，而不用真的把⻚加载到物理内存里。<code>只有在程序运行中，需要用到对应虚拟内存⻚里面的指令和数据时，再加载到物理内存里面去</code>。</p>\n<p>内存的加载和释放都是<code>以页为单位</code>的：</p>\n<ul>\n<li>将分页从物理内存写入硬盘，称为<code>换出(Swap Out)</code>。</li>\n<li>将内存从硬盘写入物理内存，称为<code>换入(Swap In)</code>。</li>\n</ul>\n<h3 id=\"多级页表\"><a href=\"#多级页表\" class=\"headerlink\" title=\"多级页表\"></a>多级页表</h3><p>内存分页虽然解决了内存分段的碎片化问题，但是也存在空间消耗上的问题。</p>\n<p>上面我们提到 linux 下的分页大小是 4KB，假如每一页对应的页表项大小为 4 个字节，那么分页和页表项的大小对比比例就是1000:1，换而言之，总内存和页表的大小对比比例就是1000:1。</p>\n<p>假如32位系统下系统内存是4G，页表项大小为 4 个字节，那么就需要2^20个页表项，对应的页表大小就是4MB。因为每个进程都有单独的页表，假如有100个进程，就需要 400MB 的内存来存储⻚表。这是比较高的空间消耗了。</p>\n<p>为了解决空间消耗的问题，提出<code>多级⻚表(Multi-Level Page Table)</code>的解决方案。<br><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121426172.png\" alt=\"image-20230319121426172\"></p>\n<p>把 2^20 个「⻚表项」的单级⻚表进行二次分⻚：</p>\n<ul>\n<li>一级页表包含1024个页表项，每项指向一个二级页表地址。</li>\n<li>二级页表也包含1024个页表项，每项指向物理内存地址。</li>\n<li>虚拟地址同时包含一级页号和二级页号。</li>\n</ul>\n<p>理论上，使用二级页表需要的内存空间好像更多了，需要 4KB(一级⻚表)+ 4MB(二级⻚表)，但实际情况是：<code>一个进程往往用不到那么多内存，部分对应的⻚表项都是空的，根本没有分配，我们可以在进程真的用到内存的时候再分配内存。但是不管进程用了多少内存，⻚表映射一定要覆盖全部虚拟内存地址</code>。</p>\n<p>如果使用单个页表就需要有 2^20 个⻚表项来映射全部虚拟内存地址。使用二级页表的话，<code>一级页表只需要 1024 个页表项就可以映射全部虚拟内存地址，二级页表在需要用到的时候再进行创建</code>。</p>\n<p>二级分⻚再推广到多级⻚表，就会发现⻚表占用的内存空间更少了，例如 64  位的系统下变成了四级目录：</p>\n<ul>\n<li>全局⻚目录项 PGD(Page Global Directory)</li>\n<li>上层⻚目录项 PUD(Page Upper Directory)</li>\n<li>中间⻚目录项 PMD(Page Middle Directory)</li>\n<li>⻚表项 PTE(Page Table Entry)</li>\n</ul>\n<p><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121438006.png\" alt=\"image-20230319121438006\"></p>\n<h3 id=\"TLB\"><a href=\"#TLB\" class=\"headerlink\" title=\"TLB\"></a>TLB</h3><p>多级页表虽然解决了单表带来的空间消耗的问题，但是如果每次查找虚拟内存地址对应的物理内存地址都要经过多次查找，就会带来效率上的问题。</p>\n<p>程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。利用这一特性，<code>把程序最常访问的⻚表项存到 Cache 然后放到 CPU 里面</code>，这个 Cache 就是 <code>TLB</code>(Translation Lookaside Buffer)。<br><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121451415.png\" alt=\"image-20230319121451415\"></p>\n<p>有了 TLB 后，CPU 在通过 MMU 查找物理内存地址的时候，先查 TLB，如果没找到，才会继续查常规的⻚表。</p>\n<h3 id=\"linux内存管理\"><a href=\"#linux内存管理\" class=\"headerlink\" title=\"linux内存管理\"></a>linux内存管理</h3><h4 id=\"虚拟内存和物理内存\"><a href=\"#虚拟内存和物理内存\" class=\"headerlink\" title=\"虚拟内存和物理内存\"></a>虚拟内存和物理内存</h4><p>linux 下也分为虚拟内存和物理内存，虚拟内存是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存。用作虚拟内存的磁盘空间被称为交换空间（又称 <code>swap</code> 空间）。</p>\n<p>Linux 会在物理内存不足时，使用「最近最经常使用」算法，将一些不经常使用的页面文件写到 swap 区，这样一来，物理内存得到了释放，这块内存就可以用于其他目的；当需要用到原始的内容时，这些信息会被重新从 swap 区读入物理内存。</p>\n<p>但内存交换也不一定在内存不足的时候才发生，<code>Linux 系统会不时地进行页面交换操作，以保持尽可能多的空闲物理内存</code>。即使并没有什么事情需要内存，Linux 也会交换出暂时不用的内存页面，因为这样可以大大节省等待交换所需的时间。有时我们会看到这么一个现象，Linux 物理内存还有很多，但是 swap 区也使用了很多，其实这并不奇怪。例如，一个占用很大内存的进程运行时，需要耗费很多内存资源，此时就会有一些不常用页面文件被交换到虚拟内存中，但后来这个占用很多内存资源的进程结束并释放了很多内存时，刚才被交换出去的页面文件并不会自动交换进物理内存（除非有这个必要），那么此时系统物理内存就会空闲很多，同时交换空间也在被使用，就出现了刚才所说的现象了。</p>\n<p>但现在 swap 区用的比较少，频率的内存交换会影响系统的性能，一些服务器甚至会禁用掉 swap 区的功能。<code>一般情况下，如果已经用到 swap 区说明硬件配置已经不太够了，需要升级硬件了</code>。</p>\n<h4 id=\"分页管理\"><a href=\"#分页管理\" class=\"headerlink\" title=\"分页管理\"></a>分页管理</h4><p><code>Linux 的内存管理采取的是分页管理</code>，但是也涉及一点分段的概念。</p>\n<p><code>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间(32 位环境下)，也就是所有的段的虚拟地址空间都是一样的</code>。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间(虚拟地址)，这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于 访问控制和内存保护。</p>\n<p>虚拟地址空间的内部又被分为<code>内核空间</code>和<code>用户空间</code>两部分，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p>\n<ul>\n<li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li>\n<li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</li>\n</ul>\n<p><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121550748.png\" alt=\"image-20230319121550748\"></p>\n<p>虽然每个进程都各自有独立的虚拟内存，但是<code>每个虚拟内存中的内核地址关联的都是相同的物理内存</code>。这样，进程切换到内核态后，就可以访问相同的内核空间内存。<br><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121603798.png\" alt=\"image-20230319121603798\"></p>\n<p>不同位数的系统，地址空间的范围也不同。比如最常⻅的 32 位和 64 位系统：<br><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121617311.png\" alt=\"image-20230319121617311\"></p>\n<ul>\n<li>32 位系统的内核空间占用 1G ，位于最高处，剩下的 3G 是用户空间;</li>\n<li>64 位系统的内核空间和用户空间都是 128T ，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。</li>\n</ul>\n<h4 id=\"缺页异常\"><a href=\"#缺页异常\" class=\"headerlink\" title=\"缺页异常\"></a>缺页异常</h4><p>当 CPU 访问的⻚面不在物理内存时，便会产生一个<code>缺页异常</code>（Page Fault），请求操作系统将所缺⻚调入到物理内存。<br><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121629896.png\" alt=\"image-20230319121629896\"></p>\n<ol>\n<li>在 CPU 里访问一条 Load M 指令，然后 CPU 会去找 M 所对应的⻚表项。</li>\n<li>如果该⻚表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「无效的」，则 CPU 则会发送缺⻚中断请求。</li>\n<li>操作系统收到了缺⻚中断，则会执行缺⻚中断处理函数，先会查找该⻚面在磁盘中的⻚面的位置。</li>\n<li>找到磁盘中对应的⻚面后，需要把该⻚面换入到物理内存中，但是在换入前，需要在物理内存中找空闲⻚，如果找到空闲⻚，就把⻚面换入到物理内存中。</li>\n<li>⻚面从磁盘换入到物理内存完成后，则把⻚表项中的状态位修改为「有效的」。</li>\n<li>最后，CPU 重新执行导致缺⻚异常的指令。</li>\n</ol>\n<p>缺页异常触发通常有两三种情况：</p>\n<ol>\n<li>地址空间映射关系未建立<ul>\n<li>malloc&#x2F;mmap申请虚拟的地址空间并未分配实际物理页，首次访问触发缺页异常。</li>\n</ul>\n</li>\n<li>地址空间映射关系已建立<ul>\n<li>要访问的页面已经被swapping到了磁盘，访问时触发缺页异常。</li>\n<li>fork子进程时，子进程共享父进程的地址空间，写是触发缺页异常(COW技术)。</li>\n<li>要访问的页面被KSM合并，写时触发缺页异常(COW技术)。</li>\n<li>兼容的ARM32体系架构模拟PTE_DIRTY PTE_YOUNG比特。</li>\n</ul>\n</li>\n<li>访问的地址空间不合法<ul>\n<li>用户空间访问内核空间地址，触发缺页异常。</li>\n<li>内核空间访问用户空间地址，触发缺页异常。(不包括copy_to&#x2F;from_user的情况)</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"内存页面置换算法\"><a href=\"#内存页面置换算法\" class=\"headerlink\" title=\"内存页面置换算法\"></a>内存页面置换算法</h2><p>上面提到处理缺页中断的过程中，会在物理内存找到一个空闲⻚载入磁盘上的内存页。如果此时内存满了，就需要一个<code>内存页面置换算法</code>来腾出内存页，选择一个合适的内存页写入磁盘。常⻅的⻚面置换算法有如下几种：</p>\n<ul>\n<li>最佳⻚面置换算法(OPT)</li>\n<li>先进先出置换算法(FIFO)</li>\n<li>最近最久未使用的置换算法(LRU)</li>\n<li>时钟⻚面置换算法(CLock)</li>\n<li>最不常用置换算法(LFU)</li>\n</ul>\n<h3 id=\"最佳⻚面置换算法\"><a href=\"#最佳⻚面置换算法\" class=\"headerlink\" title=\"最佳⻚面置换算法\"></a>最佳⻚面置换算法</h3><p><code>最佳⻚面置换算法(OPT)</code>的思路是：<code>置换在「未来」最⻓时间不访问的⻚面</code>。</p>\n<p><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121648769.png\" alt=\"image-20230319121648769\"></p>\n<p>在这个请求的⻚面序列中，缺⻚共发生了 <code>7</code> 次(空闲⻚换入 3 次 + 最优⻚面置换 4 次)，⻚面置换共发生了 <code>4</code> 次。</p>\n<p>但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。<code>最佳置换算法可以用来评价其他算法的效率</code>。</p>\n<h3 id=\"先进先出算法\"><a href=\"#先进先出算法\" class=\"headerlink\" title=\"先进先出算法\"></a>先进先出算法</h3><p><code>先进先出置换算法(FIFO)</code>的思路：<code>置换在内存驻留时间最⻓的⻚面</code>。</p>\n<p><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121728714.png\" alt=\"image-20230319121728714\"></p>\n<p>在这个请求的⻚面序列中，缺⻚共发生了 <code>10</code> 次，⻚面置换共发生了 <code>7</code> 次，跟最佳⻚面置换算法比较起来，性能明显差了很多。</p>\n<h3 id=\"最近最久未使用算法\"><a href=\"#最近最久未使用算法\" class=\"headerlink\" title=\"最近最久未使用算法\"></a>最近最久未使用算法</h3><p><code>最近最久未使用的置换算法(LRU)</code>的思路：<code>置换最⻓时间没有被访问的⻚面</code>。</p>\n<p><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121745363.png\" alt=\"image-20230319121745363\"></p>\n<p>在这个请求的⻚面序列中，缺⻚共发生了 <code>9</code> 次，⻚面置换共发生了 <code>6</code> 次，跟先进先出置换算法比较起来，性能提高了。</p>\n<p>最近最久未使用算法近似于最优置换算法，最优置换算法是通过「未来」的使用情况来推测要淘汰的⻚面，而 LRU 则是 通过「历史」的使用情况来推测要淘汰的⻚面。</p>\n<p>虽然 LRU 在理论上是可以实现的，但实现起来比较困难：为了完全实现 LRU，需要在内存中维护一个所有⻚面的链表，页面按照「最近访问时间」排序，最近最多访问的⻚面在表头，最近最少访问的⻚面在表尾。每次访问内存的时候都要遍历整个链表找到指定页面，然后把他移动到表头。</p>\n<p>所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。</p>\n<h3 id=\"时钟置换算法\"><a href=\"#时钟置换算法\" class=\"headerlink\" title=\"时钟置换算法\"></a>时钟置换算法</h3><p>LRU算法的性能接近于OPT，但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。<code>时钟⻚面置换算法(CLock)</code>结合了两者的优点，现代操作系统置换算法很多都是时钟⻚面置换算法的变体。</p>\n<p>时钟⻚面置换算法(CLock)的思路是：<code>把所有的⻚面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的⻚面</code>。当发生缺⻚中断时，算法首先检查表针指向的⻚面：</p>\n<ul>\n<li>如果它的访问位位是 0 就淘汰该⻚面，并把新的⻚面插入这个位置，然后把表针前移一个位置。</li>\n<li>如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的⻚面为止。</li>\n</ul>\n<p><img src=\"/2021/03/20/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20230319121807575.png\" alt=\"image-20230319121807575\"></p>\n<h3 id=\"最不常用算法\"><a href=\"#最不常用算法\" class=\"headerlink\" title=\"最不常用算法\"></a>最不常用算法</h3><p><code>最不常用置换算法(LFU)</code>的思路：<code>置换访问次数最少的页面</code>。</p>\n<p>它的实现方式是：对每个⻚面设置一个「访问计数器」，每当一个⻚面被访问时，该⻚面的访问计数器就 累加 1。在发生缺⻚中断时，淘汰计数器值最小的那个⻚面。</p>\n<p>但实际问题是：</p>\n<ul>\n<li>如果要对这个计数器查找哪个⻚面访问次数最小，查找链表本身，如果链表⻓度很大，是非常耗时的，效率不高。</li>\n<li>只考虑了频率问题，没考虑时间的问题，比如有些⻚面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的⻚面由于没有这些⻚面访问的次数高，在发生缺⻚中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的⻚面。</li>\n</ul>\n<p>由于最不常用算法效率不高，命中率也不高，实际很少应用。</p>\n","categories":["Linux"],"tags":["Linux"]},{"title":"Linux系列（三）：进程管理","url":"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","content":"<blockquote>\n<p>Linux系列（三）：进程管理</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h2><h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><h4 id=\"进程是什么\"><a href=\"#进程是什么\" class=\"headerlink\" title=\"进程是什么\"></a>进程是什么</h4><p>通俗易懂的解释，<code>进程就是一个正在运行的程序</code>。</p>\n<p>程序的运行往往需要依赖一定的系统资源，例如CPU、内存等，所以<code>进程是资源分配的基本单位</code>。</p>\n<p>为了表示进程占用的资源和状态信息，操作系统用<code>进程控制块(process control block，PCB)</code>数据结构来描述进程。在 linux 下 PCB 为 <code>task_struct</code>。</p>\n<p><code>PCB 是进程存在的唯一标识</code>。这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。</p>\n<p>PCB 包含的内容有：</p>\n<ul>\n<li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符。</li>\n<li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务。</li>\n<li>进程当前状态：如 new、ready、running、waiting 或 blocked 等。</li>\n<li>进程优先级：进程抢占 CPU 时的优先级。</li>\n<li>PC计数器：程序中即将被执行的下一条指令的地址</li>\n<li>上下文数据：进程执行时处理器的寄存器中的数据</li>\n<li>内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针。</li>\n<li>文件I&#x2F;O信息：所打开文件的列表和所使用的 I&#x2F;O 设备信息。</li>\n</ul>\n<h4 id=\"进程的状态\"><a href=\"#进程的状态\" class=\"headerlink\" title=\"进程的状态\"></a>进程的状态</h4><p>虽然进程被描述为一个正在运行的程序，但事实上进程从产生到消亡并不是一直都处于运行状态。进程可能会因为某种原因而暂停运行处于等待状态，当使它暂停的原因消失后，它又进入准备运行状态。</p>\n<p>一个完整的进程活动周期可能会存在五种状态：<br><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319122804947.png\" alt=\"image-20230319122804947\"></p>\n<ul>\n<li><code>创建状态(new)</code>：进程正在被创建时的状态。</li>\n<li><code>运行状态(Runing)</code>：该时刻进程占用 CPU。</li>\n<li><code>就绪状态(Ready)</code>：可运行，由于其他进程处于运行状态而暂时停止运行。</li>\n<li><code>阻塞状态(Blocked)</code>：该进程正在等待某一事件发生(如等待输入&#x2F;输出操作的完成)而暂时停止运行，这时，即使给它CPU控制权，它也无法运行。</li>\n<li><code>结束状态(Exit)</code>：进程正在从系统中消失时的状态。</li>\n</ul>\n<p>如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间。在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。就需要一个新的状态，来描述进程没有占用实际的物理内存空间的情况，这个状态就是<code>挂起状态</code>。</p>\n<ul>\n<li><code>阻塞挂起状态</code>：进程在外存(硬盘)并等待某个事件的出现。</li>\n<li><code>就绪挂起状态</code>：进程在外存(硬盘)，但只要进入内存，即刻立刻运行。<br><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319122818687.png\" alt=\"image-20230319122818687\"></li>\n</ul>\n<p>导致进程挂起的原因不只是因为进程所使用的内存空间不在物理内存，还包括如下情况：</p>\n<ul>\n<li>通过 sleep 让进程间歇性挂起，其工作原理是设置一个定时器，到期后唤醒进程。</li>\n<li>用户希望挂起一个程序的执行，比如在 Linux 中用 Ctrl+Z 挂起进程;</li>\n</ul>\n<p><code>PCB 通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列</code>。</p>\n<ul>\n<li><code>就绪队列</code>：将所有处于就绪状态的进程链在一起。</li>\n<li><code>阻塞队列</code>：把所有因等待某事件而处于等待状态的进程链在一起。</li>\n<li><code>运行队列</code>：将所有处于进行状态的进程链在一起。在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。</li>\n</ul>\n<p>在 linux 下进程也被称为 <code>task</code>，进程 PCB 也被称为 <code>task_struct</code>。linux 下的进程分为七种状态：</p>\n<ul>\n<li>执行状态：<ul>\n<li><code>R (TASK_RUNNING)</code>：可执行状态。只有在该状态的进程才可能在CPU上运行。linux下把正在CPU上执行的进程和可执行但是尚未被CPU调度的进程状态统一为TASK_RUNNING状态，所以同一时刻可能有多个进程处于TASK_RUNNING状态，但只有一个进程在占用CPU。</li>\n</ul>\n</li>\n<li>睡眠状态：<ul>\n<li><code>S (TASK_INTERRUPTIBLE)</code>：可中断的睡眠状态。处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态。</li>\n<li><code>D (TASK_UNINTERRUPTIBLE)</code>：不可中断的睡眠状态。不可中断指的是进程不响应异步信号，例如用 kill -9 无法杀死一个TASK_UNINTERRUPTIBLE状态的进程。一般用于内核某些某些处理流程是不能被打断的线程，例如读写设备文件。</li>\n</ul>\n</li>\n<li>停止状态：<ul>\n<li><code>T (TASK_STOPPED)</code>：暂停状态。向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态；向进程发送一个SIGCONT信号，可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态。</li>\n<li><code>T (TASK_TRACED)</code>：跟踪状态。类似于TASK_STOPPED状态，但是不能被SIGCONT信号唤醒。</li>\n</ul>\n</li>\n<li>退出状态：<ul>\n<li><code>X (EXIT_DEAD)</code>：退出状态，进程即将被销毁。被标记为的EXIT_DEAD状态的进程会立即被彻底释放。</li>\n<li><code>Z (EXIT_ZOMBIE)</code>，退出状态，进程成为僵尸进程。进程占有的除了task_struct结构的其他资源将被回收，只剩下task_struct一个空壳。</li>\n</ul>\n</li>\n</ul>\n<p>linux 下进程状态的变迁却只有两个方向：<code>从TASK_RUNNING状态变为非TASK_RUNNING状态、或者从非TASK_RUNNING状态变为TASK_RUNNING状态</code>。</p>\n<ul>\n<li>进程从非TASK_RUNNING状态变为TASK_RUNNING状态，是由别的进程（也可能是中断处理程序）执行唤醒操作来实现的。</li>\n<li>进程从TASK_RUNNING状态变为非TASK_RUNNING状态，则有以下途径：<ul>\n<li>响应信号而进入TASK_STOPED状态、或TASK_DEAD状态；</li>\n<li>执行系统调用主动进入TASK_INTERRUPTIBLE状态（如nanosleep系统调用）、或TASK_DEAD状态（如exit系统调用）</li>\n<li>由于执行系统调用需要的资源得不到满足，而进入TASK_INTERRUPTIBLE状态或TASK_UNINTERRUPTIBLE状态（如select系统调用）</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>如果从一个非TASK_RUNNING状态变成另一个非TASK_RUNNING状态？</p>\n<ul>\n<li>例如给一个TASK_INTERRUPTIBLE状态的进程发送SIGKILL信号，这个进程将先被唤醒（进入TASK_RUNNING状态），然后再响应SIGKILL信号而退出（变为TASK_DEAD状态）。并不会从TASK_INTERRUPTIBLE状态直接退出。</li>\n</ul>\n<p>什么是僵尸进程？</p>\n<ul>\n<li>子进程先退出，但退出后的资源不会被完全释放，而是把退出状态发送给父进程，让父进程来释放子进程的资源。</li>\n<li>父进程再退出，但没有释放子进程的资源，那么这个时候子进程就变成了僵尸进程，占用着系统资源不释放。</li>\n<li>僵尸进程会造成内存泄漏。</li>\n</ul>\n<p>什么是孤儿进程？</p>\n<ul>\n<li>父进程先退出，但是子进程被init进程领养，那么这时候的子进程就是孤儿进程。他的资源也由init进程回收释放。</li>\n</ul>\n</blockquote>\n<h4 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h4><p>既然进程是资源分配的基本单位，如果一个进程要访问另外一个进程的资源，就需要用到<code>进程间通信</code>的方式。常见的进程通信方式有：</p>\n<ul>\n<li>管道</li>\n<li>消息队列</li>\n<li>共享内存</li>\n<li>信号量</li>\n<li>信号</li>\n<li>Socket</li>\n</ul>\n<h5 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h5><p><code>管道创造一个管道文件，两个不同文件通过管道文件实现数据单向传输</code>。管道又分为<code>命名管道</code>和<code>匿名管道</code>两种，匿名管道只能用于父子进程间通信；命名管道通过 <code>mkfifo</code> 命令创建，可以实现两个不相关的进程间的通信。</p>\n<p><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319122844503.png\" alt=\"image-20230319122844503\"><br>使用 fork 创建子进程，创建的子进程会复制父进程的文件描述符，这样就做到了两个进程各有 两个「 fd[0] 与 fd[1] 」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。同时：</p>\n<ul>\n<li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]</li>\n<li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]</li>\n</ul>\n<p>在 shell 里面执行 A | B 命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在 父子关系，它俩的父进程都是 shell。<br><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319122902718.png\" alt=\"image-20230319122902718\"></p>\n<ul>\n<li>shell把读写管道端都关闭</li>\n<li>一个子进程关闭读端管道，一个子进程关闭写端管道</li>\n</ul>\n<p>进程写入的管道数据都是缓存在内核中。管道这种通信方式效率低，不适合进程间频繁地交换数据。</p>\n<h5 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h5><p><code>消息队列</code>用于解决管道效率低下的问题。消息队列<code>是保存在内核中的消息链表</code>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体(数据块)，消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型， 所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p>\n<p>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。</p>\n<p>消息队列的缺点：</p>\n<ul>\n<li>对消息件也有大小限制，不适合比较大数据的传输。</li>\n<li>存在用户态与内核态之间的数据拷⻉开销，因为进程写入数据到内核中的消息队列时，会发生从用户态拷⻉数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷⻉数据到用户态的过程。</li>\n</ul>\n<h5 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h5><p><code>共享内存</code>用于解决消息队列需要在用户态和内核态来回拷贝数据的问题。共享内存就是<code>两个不同的进程分别拿出一块虚拟地址空间（可以完全不同），映射到相同的物理内存中</code>。<br><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319122936706.png\" alt=\"image-20230319122936706\"></p>\n<h5 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h5><p>使用共享内存的通信方式，如果两个进程同时修改同一块共享内存，很有可能造成冲突。为了防止多进程竞争共享资源，而造成的数据错乱，就出现了<code>信号量</code>保护机制。<code>信号量主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</code>。</p>\n<p>信号量是一个计数器，表示资源的数量，控制信号量的方式有两种原子操作：</p>\n<ul>\n<li><code>P 操作</code>：这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需 阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li>\n<li><code>V 操作</code>：这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进 程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程。</li>\n</ul>\n<p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，<code>这两个操作是必须成对出现的</code>。</p>\n<p>两个进程互斥访问共享内存，我们可以初始化信号量为 1 。<br><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319122953593.png\" alt=\"image-20230319122953593\"></p>\n<p>具体的过程如下:</p>\n<ul>\n<li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后 信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</li>\n<li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已 被占用，因此进程 B 被阻塞。</li>\n<li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始 值 1。</li>\n</ul>\n<h5 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h5><p><code>信号</code>用于通知接收进程某个事件已经发生。当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。</p>\n<p>信号只是用于通知进程发生了某个事件，<code>除了信号本身的信息之外，并不具备传递用户数据的功能</code>。</p>\n<p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 <code>kill -l</code> 来查看所有的信号。注意信号编号是从 1 开始的。</p>\n<p>常见的信号有：</p>\n<table>\n<thead>\n<tr>\n<th>信号</th>\n<th>编号</th>\n<th>解释</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SIGHUP</td>\n<td>1</td>\n<td>挂起</td>\n<td>终端连接断开导致进程结束</td>\n</tr>\n<tr>\n<td>SIGINT</td>\n<td>2</td>\n<td>程序终止(interrupt)</td>\n<td>用户输入INTR字符(Ctrl+C)触发</td>\n</tr>\n<tr>\n<td>SIGQUIT</td>\n<td>3</td>\n<td>程序退出</td>\n<td>用户输入QUIT字符(Ctrl+&#x2F;)触发，退出时会产生core文件</td>\n</tr>\n<tr>\n<td>SIGILL</td>\n<td>4</td>\n<td>非法指令</td>\n<td>通常是因为可执行文件本身出现错误，或者试图执行数据段，或者堆栈溢出</td>\n</tr>\n<tr>\n<td>SIGKILL</td>\n<td>9</td>\n<td>杀死程序</td>\n<td>立即结束程序的运行，该信号不能被处理和忽略</td>\n</tr>\n<tr>\n<td>SIGALRM</td>\n<td>14</td>\n<td>定时器到期</td>\n<td>由alarm发出的信号</td>\n</tr>\n<tr>\n<td>SIGTERM</td>\n<td>15</td>\n<td>程序结束(terminate)</td>\n<td>程序自己正常退出，该信号可以被处理和忽略</td>\n</tr>\n<tr>\n<td>SIGSTOP</td>\n<td>19</td>\n<td>程序暂停(stopped)</td>\n<td>暂停程序的运行，但程序还没结束，该信号不可以被处理和忽略</td>\n</tr>\n<tr>\n<td>SIGTSTP</td>\n<td>20</td>\n<td>程序停止(tty stopped)</td>\n<td>用户输入SUSP字符(Ctrl+Z)触发，类似于SIGSTOP，该信号可以被处理和忽略</td>\n</tr>\n</tbody></table>\n<p>注意：</p>\n<ul>\n<li>无法被捕捉和忽略的信号：SIGKILL，SEGSTOP</li>\n<li>不能恢复至默认动作的信号有：SIGILL，SIGTRAP</li>\n<li>默认会导致进程停止的信号有SIGSTOP，SIGTSTP，SIGTTIN，SIGTTOU。</li>\n</ul>\n<p><code>信号是进程间通信机制中唯一的异步通信机制</code>，因此可以在任何时候发送信号给某一进程。一旦有信号产生，我们就有下面这几种用户进程对信号的处理方式：</p>\n<ol>\n<li>执行默认操作。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</li>\n<li>捕捉信号。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</li>\n<li>忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP ，它们用于在任何时候中断或结束某一进程。</li>\n</ol>\n<h5 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h5><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信。<code>Socket</code>通信不仅可以实现同主机上进程间通信，还可以实现跨网络不同主机上的进程之间通信。</p>\n<p>socket 的系统调用为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int socket(int domain, int type, int protocal)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>domain 参数用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、 AF_LOCAL&#x2F;AF_UNIX 用于本机;</li>\n<li>type 参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字;</li>\n<li>protocal 参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完 成，protocol 目前一般写成 0 即可;</li>\n</ul>\n<p>根据创建 socket 类型的不同，通信的方式也就不同:</p>\n<ul>\n<li>实现 TCP 字节流通信: socket 类型是 AF_INET 和 SOCK_STREAM;</li>\n<li>实现 UDP 数据报通信:socket 类型是 AF_INET 和 SOCK_DGRAM;</li>\n<li>实现本地进程间通信: 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据 报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket;</li>\n</ul>\n<p>针对 tcp 协议的 socket 通信模型：<br><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319123043824.png\" alt=\"image-20230319123043824\"></p>\n<p>针对 udp 协议的 socket 通信模型：<br><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319123059517.png\" alt=\"image-20230319123059517\"></p>\n<h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><h4 id=\"线程是什么\"><a href=\"#线程是什么\" class=\"headerlink\" title=\"线程是什么\"></a>线程是什么</h4><p><code>线程是进程当中的一条执行流程</code>。同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。<code>进程是资源分配的基本单位，线程是cpu调度的基本单位</code>。<br><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319123114516.png\" alt=\"image-20230319123114516\"></p>\n<h4 id=\"进程和线程比较\"><a href=\"#进程和线程比较\" class=\"headerlink\" title=\"进程和线程比较\"></a>进程和线程比较</h4><ul>\n<li>进程是资源分配的单位，线程是 CPU 调度的单位。</li>\n<li>进程有单独的内存空间，线程共享所属进程的内存空间，只有单独的程序计数器（pc）和堆栈。</li>\n<li>进程切换需要切换⻚表，开销大，速度慢；线程切换不需要切换页表，开销小，速度快。</li>\n<li>进程间的通信需要借助工具（管道、消息队列等）实现，同一进程下的线程通信因为共享内存空间可以直接通信。</li>\n</ul>\n<h4 id=\"线程的实现\"><a href=\"#线程的实现\" class=\"headerlink\" title=\"线程的实现\"></a>线程的实现</h4><p>线程的实现也有一个线程控制块(Thread Control Block, TCB)，主要有三种线程的实现方式：</p>\n<ul>\n<li><code>用户线程</code>(User Thread)：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库 来完成线程的管理。</li>\n<li><code>内核线程</code>(Kernel Thread)：在内核中实现的线程，是由内核管理的线程。</li>\n<li><code>轻量级进程</code>(LightWeight Process)：在内核中来支持用户线程。</li>\n</ul>\n<h5 id=\"用户线程\"><a href=\"#用户线程\" class=\"headerlink\" title=\"用户线程\"></a>用户线程</h5><p>用户线程是基于用户态的线程管理库来实现的，那么TCB也是在 库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。</p>\n<p>所以，用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程 的管理，包括线程的创建、终止、同步和调度等。</p>\n<p>用户线程的优点：</p>\n<ul>\n<li>每个进程都需要有它私有的线程控制块(TCB)列表，用来跟踪记录它各个线程状态信息(PC、栈指针、寄存器)，TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统。</li>\n<li>用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快。</li>\n</ul>\n<p>用户线程的缺点：</p>\n<ul>\n<li>由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。</li>\n<li>当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法 运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用 户线程不是由操作系统管理的。</li>\n<li>由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢。</li>\n</ul>\n<h5 id=\"内核线程\"><a href=\"#内核线程\" class=\"headerlink\" title=\"内核线程\"></a>内核线程</h5><p>内核态线程由内核管理的，TCB 放在内核态，这样线程的创建、终止和管理都是由内核负责。</p>\n<p>内核线程的优点：</p>\n<ul>\n<li>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行;</li>\n<li>分配给线程，多线程的进程获得更多的 CPU 运行时间。</li>\n</ul>\n<p>内核线程的缺点：</p>\n<ul>\n<li>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB。</li>\n<li>线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大。</li>\n</ul>\n<h5 id=\"轻量级进程\"><a href=\"#轻量级进程\" class=\"headerlink\" title=\"轻量级进程\"></a>轻量级进程</h5><p><code>轻量级进程(Light-weight process，LWP)是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持</code>。</p>\n<p>另外，LWP 只能由内核管理并像普通进程一样被调度，Linux 内核是支持 LWP 的典型例子。</p>\n<p>在大多数系统中，<code>LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息</code>。一般来说，一个进程代表程序的一个实例，而 LWP 代表程序的执行线程，因为一个执行线程不像进程那样需要那么多状态信息，所以 LWP 也不带有这样的信息。</p>\n<h5 id=\"linux下的线程实现\"><a href=\"#linux下的线程实现\" class=\"headerlink\" title=\"linux下的线程实现\"></a>linux下的线程实现</h5><p>注意，并不是所有的操作系统都支持线程。windows原生支持了线程的实现，Linux没有原生语义的线程支持，<code>所以在linux平台的线程都是使用轻量级进程来实现线程，一个线程就是一个轻量级进程</code>。每一个执行实体都是一个task_struct结构, 通常称之为进程。</p>\n<p>Linux2.0~2.4实现的是俗称LinuxThreads的多线程方式，到了2.6，基本上都是NPTL的方式了，目前最新实现算法是NGPT。</p>\n<p>LinuxThreads专门为每一个进程构造了一个管理线程，负责处理线程相关的管理工作。当进程第一次调用pthread_create()创建一个线程的时候就会创建并启动管理线程。然后管理线程再来创建用户请求的线程。也就是说，用户在调用pthread_create后，先是创建了管理线程，再由管理线程创建了用户的线程。</p>\n<p>NPTL中，内核有了线程组的概念, task_struct结构中增加了一个tgid(thread group id)字段.如果这个task是一个”主线程”, 则它的tgid等于pid, 否则tgid等于进程的pid(即主线程的pid)。</p>\n<p>linux的和进程&#x2F;线程相关的各种ID：</p>\n<ul>\n<li><code>pid</code>: 进程ID。</li>\n<li><code>lwp</code>: 线程ID。在用户态的命令(比如ps)中常用的显示方式。</li>\n<li><code>tid</code>: 线程ID，等于lwp。tid在系统提供的接口函数中更常用，比如syscall(SYS_gettid)和syscall(__NR_gettid)。</li>\n<li><code>tgid</code>: 线程组ID，也就是线程组leader的进程ID，等于pid。</li>\n<li>——分割线——</li>\n<li>pgid: 进程组ID，也就是进程组leader的进程ID。</li>\n<li>pthread id: pthread库提供的ID，生效范围不在系统级别，可以忽略。</li>\n<li>sid: session ID for the session leader。</li>\n<li>tpgid: tty process group ID for the process group leader。</li>\n</ul>\n<p>从上面的列表看出，<code>各种ID最后都归结到pid和lwp(tid)上</code>。所以理解各种ID，最终归结为理解pid和lwp(tid)的联系和区别。</p>\n<p><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319123150327.png\" alt=\"image-20230319123150327\"></p>\n<p>上图很好地描述了用户视角(user view)和内核视角(kernel view)看到线程的差别：</p>\n<ul>\n<li>从用户视角出发，在pid 42中产生的tid 44线程，属于tgid(线程组leader的进程ID) 42。甚至用ps和top的默认参数，你都无法看到tid 44线程。</li>\n<li>从内核视角出发，tid 42和tid 44是独立的调度单元，可以把他们视为”pid 42”和”pid 44”。</li>\n</ul>\n<p>需要指出的是，有时候在Linux中进程和线程的区分也是不是十分严格的。即使线程和进程混用，pid和tid混用，根据上下文，还是可以清楚地区分对方想要表达的意思。上图中，从内核视角出发看到了pid 44，是从调度单元的角度出发，但是在top或ps命令中，你是绝对找不到一个pid为44的进程的，只能看到一个lwp(tid)为44的线程。</p>\n<h3 id=\"上下文切换\"><a href=\"#上下文切换\" class=\"headerlink\" title=\"上下文切换\"></a>上下文切换</h3><h4 id=\"CPU上下文切换\"><a href=\"#CPU上下文切换\" class=\"headerlink\" title=\"CPU上下文切换\"></a>CPU上下文切换</h4><p><code>CPU 上下文切换</code>是指先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p>\n<p>CPU 上下文切换的种类有：</p>\n<ul>\n<li>系统调用（进程内部线程切换）</li>\n<li>进程上下文切换</li>\n<li>线程上下文切换 </li>\n<li>中断上下文切换</li>\n</ul>\n<h4 id=\"系统调用\"><a href=\"#系统调用\" class=\"headerlink\" title=\"系统调用\"></a>系统调用</h4><p><code>系统调用</code>完成<code>从用户态到内核态的互相转化</code>。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。系统调用的过程：</p>\n<ol>\n<li>保存 CPU 寄存器里原来用户态的指令位，CPU 寄存器更新为内核态指令的新位置。</li>\n<li>跳转到内核态运行内核任务。</li>\n<li>当系统调用结束后，CPU 寄存器恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。</li>\n</ol>\n<p>一次系统调用的过程，其实是发生了两次 CPU 上下文切换。（用户态-内核态-用户态）。系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：<code>进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用过程中一直是同一个进程在运行</code>。</p>\n<h4 id=\"进程上下文切换\"><a href=\"#进程上下文切换\" class=\"headerlink\" title=\"进程上下文切换\"></a>进程上下文切换</h4><p>因为 CPU 在同一时间只能执行一个进程的任务，在多个进程共享 CPU 资源的情况下，需要让 CPU 切换轮流执行多个进程。从一个进程切换到另一个进程运行，称为<code>进程的上下文切换</code>。进程是由内核管理和调度的，所以进程的切换只能发生在内核态。</p>\n<p>因为进程切换是属于不同进程之间的切换，所以进程还需要保存用户态的资源。<code>进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态</code>。</p>\n<p>因此，进程的上下文切换就比系统调用时多了一步</p>\n<ul>\n<li>在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来</li>\n<li>加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。<br><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319123206177.png\" alt=\"image-20230319123206177\"></li>\n</ul>\n<p>发生进程上下文切换的场景：</p>\n<ul>\n<li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。</li>\n<li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</li>\n<li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</li>\n<li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</li>\n<li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li>\n</ul>\n<h4 id=\"线程上下文切换\"><a href=\"#线程上下文切换\" class=\"headerlink\" title=\"线程上下文切换\"></a>线程上下文切换</h4><p>线程与进程最大的区别在于：线程是调度的基本单位，而进程则是资源拥有的基本单位。说白了，所谓<code>内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源</code>。</p>\n<p>所以，对于线程和进程，我们可以这么理解： - 当进程只有一个线程时，可以认为进程就等于线程。 - 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p>\n<p>发生线程上下文切换的场景：</p>\n<ul>\n<li>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。</li>\n<li>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</li>\n</ul>\n<h4 id=\"中断上下文切换\"><a href=\"#中断上下文切换\" class=\"headerlink\" title=\"中断上下文切换\"></a>中断上下文切换</h4><p>为了快速响应硬件的事件，<code>中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件</code>。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p>\n<p><code>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态</code>。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。</p>\n<p><code>对同一个 CPU 来说，中断处理比进程拥有更高的优先级</code>，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p>\n<p>另外，跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能。所以，当你发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。</p>\n<h3 id=\"同步和互斥\"><a href=\"#同步和互斥\" class=\"headerlink\" title=\"同步和互斥\"></a>同步和互斥</h3><p><code>同步</code>就是并发进程&#x2F;线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程&#x2F;线程同步。</p>\n<p><code>互斥</code>是指保证一个线程在占用共享资源区时，其他线程应该被阻止进入共享资源区。</p>\n<p>同步与互斥是两种不同的概念：</p>\n<ul>\n<li>同步就好比：「操作 A 应在操作 B 之前执行」，「操作 C 必须在操作 A 和操作 B 都完成之后才能执行」</li>\n<li>互斥就好比：「操作 A 和操作 B 不能在同一时刻执行」</li>\n</ul>\n<p>为了实现进程&#x2F;线程间正确的协作，操作系统必须提供实现进程协作的措施和方法，主要的方法有两种:</p>\n<ul>\n<li>锁：加锁、解锁操作。</li>\n<li>信号量：P、V 操作。</li>\n</ul>\n<h4 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h4><p>锁的原理：任何想进入临界区的线程，必须先执行加锁操作。若加锁操作顺利通过，则线程可进入临界区；在完成对临界资源的访问后再执行解锁操作，以释放该临界资源。</p>\n<p>锁的种类有：</p>\n<ul>\n<li>互斥锁和自旋锁</li>\n<li>读写锁</li>\n<li>乐观锁和悲观锁</li>\n</ul>\n<h5 id=\"互斥锁和自旋锁\"><a href=\"#互斥锁和自旋锁\" class=\"headerlink\" title=\"互斥锁和自旋锁\"></a>互斥锁和自旋锁</h5><p>最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。</p>\n<p>当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：</p>\n<ul>\n<li><code>互斥锁加锁失败后，线程会释放 CPU ，给其他线程</code>。</li>\n<li><code>自旋锁加锁失败后，线程会忙等待，直到它拿到锁</code>。</li>\n</ul>\n<p>对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的：</p>\n<ul>\n<li>当加锁失败时，会从用户态陷入到内核态，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程。</li>\n<li>等到锁被释放后，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行，然后从内核态切回用户态。</li>\n</ul>\n<p>因此有互斥锁加锁失败有两次线程上下文切换的成本。</p>\n<p>自旋锁是通过 CPU 提供的 CAS 函数(Compare And Swap)，在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。一般加锁的过程，包含两个步骤:</p>\n<ol>\n<li>查看锁的状态，如果锁是空闲的，则执行第二步。</li>\n<li>将锁设置为当前线程持有。</li>\n</ol>\n<p>CAS 函数就把这两个步骤合并成一条硬件级指令，形成原子指令，这样就保证了这两个步骤是不可分割 的，要么一次性执行完两个步骤，要么两个步骤都不执行。</p>\n<p><code>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁</code>。</p>\n<h5 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a>读写锁</h5><p>读写锁的工作原理是：</p>\n<ul>\n<li>当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</li>\n<li>一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li>\n</ul>\n<p>所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。</p>\n<p>根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」：</p>\n<ul>\n<li><code>读优先锁</code>：读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是:当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以 成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。</li>\n<li><code>写优先锁</code>：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候， 会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁 的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取读锁。</li>\n</ul>\n<h5 id=\"乐观锁和悲观锁\"><a href=\"#乐观锁和悲观锁\" class=\"headerlink\" title=\"乐观锁和悲观锁\"></a>乐观锁和悲观锁</h5><p>前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。</p>\n<p>悲观锁做事比较悲观，它认为<code>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁</code>。</p>\n<p>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：<code>先修改完共享资源，再验证这段时间内 有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作</code>。乐观锁全程并没有加锁，所以它也叫无锁编程。</p>\n<p>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</p>\n<h5 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h5><p>当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，两个线程都在等待对方释放锁，在没有外力的作用下，这些线程会一直相互等待，就没办 法继续运行，这种情况就是发生了<code>死锁</code>。</p>\n<p>死锁只有同时满足以下四个条件才会发生:</p>\n<ul>\n<li>互斥条件：多个线程不能同时使用同一个资源，例如如果线程 A 已经持有的资源，不能再同时被线程 B 持有。</li>\n<li>持有并等待条件：线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1。</li>\n<li>不可剥夺条件：当线程已经持有了资源，在自己使用完之前不能被其他线程获取。</li>\n<li>环路等待条件：两个线程获取资源的顺序构成了环形链。</li>\n</ul>\n<p>避免死锁问题就只需要破环其中一个条件就可以，最常⻅的并且可行的就是使用<code>资源有序分配法</code>，来破环环路等待条件。</p>\n<ul>\n<li>线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候， 线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。</li>\n</ul>\n<h4 id=\"信号量-1\"><a href=\"#信号量-1\" class=\"headerlink\" title=\"信号量\"></a>信号量</h4><p>信号量表示资源的数量，对应的变量是一个整型( sem )变量。另外，还有两个原子操作的系统调用函数来控制信号量：</p>\n<ul>\n<li>P 操作：将 sem 减 1 ，相减后，如果 sem &lt; 0 ，说明资源不足，目前已经有线程在等待，则当前线程进入阻塞等待；如果 sem &gt;&#x3D; 0，说明资源充足，当前线程可以直接执行。</li>\n<li>V 操作：将 sem 加 1 ，相加后，如果 sem &lt;&#x3D; 0 ，说明有线程在等待，唤醒一个等待中的进程&#x2F;线程；如果 sem &gt; 0，说明没有线程在等待，没有其他操作。</li>\n</ul>\n<p>对于两个并发线程，互斥信号量的值仅取 1、0 和 -1 三个值，分别表示：</p>\n<ul>\n<li>如果互斥信号量为 1，表示没有线程进入临界区;</li>\n<li>如果互斥信号量为 0，表示有一个线程进入临界区;</li>\n<li>如果互斥信号量为 -1，表示一个线程进入临界区，另一个线程等待进入。</li>\n</ul>\n<p>通过互斥信号量的方式，就能保证临界区任何时刻只有一个线程在执行，就达到了互斥的效果。</p>\n<h2 id=\"进程调度算法\"><a href=\"#进程调度算法\" class=\"headerlink\" title=\"进程调度算法\"></a>进程调度算法</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>进程调度算法的本质是<code>为cpu选择下一个要运行的进程</code>，使多个进程轮流使用cpu，造成多个进程同时运行的错觉。所以调度器的工作主要分为两个部分，<code>调度策略</code>和<code>上下文切换</code>：</p>\n<ul>\n<li>调度策略：决策什么时候切换进程和下一个获得CPU的进程。对于多核整体来讲，调度策略还要负责决策进程在那一个核心上运行。</li>\n<li>上下文切换：切换进程的时候要保存当前进程的上下文信息，以便于日后恢复执行。</li>\n</ul>\n<h3 id=\"进程的分类\"><a href=\"#进程的分类\" class=\"headerlink\" title=\"进程的分类\"></a>进程的分类</h3><p>按照<code>优先级</code>来分类：</p>\n<ul>\n<li>实时进程(RT进程)： 既然叫实时进程，则就对快速响应的要求就很高。比如航天系统，里面的计算就要求必须是实时的。否则就会出大事情，所以航天方面的操作系统一般不用linux，因为linux不是实时操作系统。</li>\n<li>普通进程： 普通进程就是实际进程的反面，对实时性要求不是很高，但是普通进程还是需要得到CPU的调度，不能饿死。</li>\n</ul>\n<p>按照<code>CPU的运行状态</code>来分类：</p>\n<ul>\n<li>CPU消耗型： CPU消耗型，此类进程就是一直占用CPU忙于计算，CPU利用率贼高，比如编译android系统则就是CPU消耗型，服务器上的后台程序，都是默默无闻的在一直干活</li>\n<li>IO消耗型： IO消耗型就是会涉及到IO，需要和用户交互，比如键盘输入，鼠标滑动，占用CPU不是很高，大多数时间实在等待IO。</li>\n</ul>\n<p>根据<code>进程任务在占用CPU时使用权是否会被夺取</code>分为：</p>\n<ul>\n<li>非抢占式调度：进程任务一旦占用CPU只有当任务完成或者因为某些原因主动释放CPU，除上述两种情况外不能被其他进程夺走。</li>\n<li>抢占式调度：进程任务占用CPU期间可以被其他进程夺走，具体由操作系统调度器决定下一个占用CPU的进程。</li>\n</ul>\n<p>Linux采用抢占式调度，其可以提高CPU利用率、降低进程的响应时间等，同时也增加了切换进程时的开销，各有利弊。</p>\n<h3 id=\"调度器设计\"><a href=\"#调度器设计\" class=\"headerlink\" title=\"调度器设计\"></a>调度器设计</h3><p>我们一般会先设计<code>调度器法</code>，然后在调度器算法的基础实现<code>调度器</code>，在实际应用中再根据实际情况选择合适<code>调度策略</code>。</p>\n<h4 id=\"六种调度算法\"><a href=\"#六种调度算法\" class=\"headerlink\" title=\"六种调度算法\"></a>六种调度算法</h4><table>\n<thead>\n<tr>\n<th>调度算法</th>\n<th>说明</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>先来先服务(First Come First Severd, FCFS)</td>\n<td>先来后到，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</td>\n<td>长作业先运行，造成短作业饥渴</td>\n</tr>\n<tr>\n<td>最短作业优先(Shortest Job First, SJF)</td>\n<td>优先选择运行时间最短的进程来运行</td>\n<td>短作业过多，造成长作业饥渴</td>\n</tr>\n<tr>\n<td>高响应比优先(Highest Response Ratio Next, HRRN)</td>\n<td>每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行</td>\n<td>同时兼顾长短作业，但是首次运行的作业无法预知运行时间，只能通过历史执行时间来预测</td>\n</tr>\n<tr>\n<td>时间片轮转(Round Robin, RR)</td>\n<td>每个进程被分配一个时间段，称为时间片(Quantum)，即允许该进程在该时间段中运行。如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。</td>\n<td>相对比较公平的调度算法</td>\n</tr>\n<tr>\n<td>最高优先级(Highest Priority First，HPF)</td>\n<td>从就绪队列中选择最高优先级的进程进行运行</td>\n<td>低优先级的进程永远不会运行</td>\n</tr>\n<tr>\n<td>多级反馈队列(Multilevel Feedback Queue，MLFQ)</td>\n<td>「时间片轮转算法」和「最高优先级算法」的 综合和发展，见下详解</td>\n<td>兼顾了⻓短作业，同时有较好的响应时间。</td>\n</tr>\n</tbody></table>\n<p>MLFQ算法是O(1)&#x2F;CFS调度器的基础，是一个比较经典的调度算法。<br><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319123233488.png\" alt=\"image-20230319123233488\"></p>\n<ul>\n<li>有多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，同时优先级越高时间片越短。</li>\n<li>新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成;</li>\n<li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行。</li>\n</ul>\n<p>可以发现，对于短作业可能可以在第一级队列很快被处理完。对于⻓作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变⻓了，但是运行时间也会更⻓了，所以该算法很好的兼 顾了⻓短作业，同时有较好的响应时间。</p>\n<h4 id=\"五种调度类\"><a href=\"#五种调度类\" class=\"headerlink\" title=\"五种调度类\"></a>五种调度类</h4><table>\n<thead>\n<tr>\n<th>调度类</th>\n<th>说明</th>\n<th>算法</th>\n<th>对应进程</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>stop_sched_class</td>\n<td>优先级最高的调度类，可以抢占其他所有进程，不能被其他进程抢占，用于处理内核紧急任务。</td>\n<td>&#x2F;</td>\n<td>仅内核使用</td>\n</tr>\n<tr>\n<td>dl_sched_class</td>\n<td>使用红黑树，把进程按照绝对截止期限进行排序，选择最小进程进行调度运行</td>\n<td>EDF</td>\n<td>&#x2F;</td>\n</tr>\n<tr>\n<td>rt_sched_class</td>\n<td>调度实时进程，存在两种policy：SCHED_FIFO和SCHED_RR</td>\n<td>FIFO和RR</td>\n<td>实时进程</td>\n</tr>\n<tr>\n<td>fair_sched_class</td>\n<td>调度普通的非实时进程，有两种policy：SCHED_NORMAL和SCHED_BATCH</td>\n<td>CFS</td>\n<td>普通进程</td>\n</tr>\n<tr>\n<td>idel_sched_class</td>\n<td>每个CPU都会有一个idle线程，当没有其他进程可以调度时，调度运行idle线程</td>\n<td>CFS</td>\n<td>IDEL进程</td>\n</tr>\n</tbody></table>\n<h4 id=\"三种调度实体和队列\"><a href=\"#三种调度实体和队列\" class=\"headerlink\" title=\"三种调度实体和队列\"></a>三种调度实体和队列</h4><table>\n<thead>\n<tr>\n<th>实体</th>\n<th>说明</th>\n<th>对应队列</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sched_dl_entity</td>\n<td>Deadline调度实体，对应dl_sched_class</td>\n<td>dl_rq</td>\n</tr>\n<tr>\n<td>sched_rt_entity</td>\n<td>RT调度实体，对应rt_sched_class</td>\n<td>rt_rq</td>\n</tr>\n<tr>\n<td>sched_entity</td>\n<td>普通进程调度实体，对应fair_sched_class</td>\n<td>cfs_rq</td>\n</tr>\n</tbody></table>\n<p>调度器只考虑处于TASK_RUNNING状态的进程，其他状态进程调度器并不考虑。<br>调度器，会首先查看实时运行队列rt_rq，然后查看普通运行队列cfs_rq，最后查看idle运行队列。</p>\n<h4 id=\"六种调度策略\"><a href=\"#六种调度策略\" class=\"headerlink\" title=\"六种调度策略\"></a>六种调度策略</h4><table>\n<thead>\n<tr>\n<th>策略类别</th>\n<th>描述</th>\n<th>调度类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SCHED_RR</td>\n<td>轮转调度算法，属于实时调度策略，采用Round-Robin语义，相同优先级的任务在当前时间片用完后放置到队列尾部，以保证公平性，高优先级的任务可以抢占低优先级的任务。</td>\n<td>RT</td>\n</tr>\n<tr>\n<td>SCHED_FIFO</td>\n<td>先进先出调度算法，属于实时调度策略，相同优先级的任务先到先服务，高优先级的任务可以抢占低优先级的任务</td>\n<td>RT</td>\n</tr>\n<tr>\n<td>SCHED_DEADLINE</td>\n<td>Earliest Deadline First(EDF)调度算法，针对突发型计算，且的对延迟和完成时间高度敏感的任务使用</td>\n<td>DL</td>\n</tr>\n<tr>\n<td>SCHED_NORMAL</td>\n<td>用于普通进程，通过CFS调度器实现。SCHED_BATCH用于非交互的处理器消耗型进程，SCHED_IDLE是在系统负载很低时使用</td>\n<td>CFS</td>\n</tr>\n<tr>\n<td>SCHED_BATCH</td>\n<td>是SCHED_NORMAL调度策略的一种，采用分时策略，根据动态优先级（nice接口），分配CPU运算资源，不支持抢占，允许任务运行更长时间，更好地使用高速缓存，适合批处理工作</td>\n<td>CFS</td>\n</tr>\n<tr>\n<td>SCHED_IDLE</td>\n<td>优先级最低，在系统空闲的时候才运行这类进程.</td>\n<td>CFS-IDL</td>\n</tr>\n</tbody></table>\n<h4 id=\"相互关系\"><a href=\"#相互关系\" class=\"headerlink\" title=\"相互关系\"></a>相互关系</h4><p><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319123255719.png\" alt=\"image-20230319123255719\"></p>\n<h4 id=\"调度触发时机\"><a href=\"#调度触发时机\" class=\"headerlink\" title=\"调度触发时机\"></a>调度触发时机</h4><p>Linux内核调度器有两种触发机制：</p>\n<ul>\n<li>主动放弃机制：进程打算睡眠或处于其他原因，放弃CPU</li>\n<li>周期性机制：以固定频率发生中断，检查是否需要进行调度切换</li>\n</ul>\n<p>从调度机制出发，当前Linux内核具有两个调度器组成</p>\n<ul>\n<li>主调度器scheduler：当需要重新分配CPU资源时，需要使用调度函数schedule或__schedule进行实际调度。</li>\n<li>周期性调度器scheduler_tick：由内核时钟周期性触发，由所属类的task_tick操作完成周期性调度的通知和配置工作; 通过resched_curr或resched_task函数设置TIF_NEED_RESCHED，接下来在合适的时机由主调度函数完成真正的调度。</li>\n</ul>\n<p>调度器触发时机：</p>\n<ul>\n<li>显式调用schedlue触发。</li>\n<li>调用cond_resched。</li>\n<li>系统调用或异常中断，从内核态返回用户空间时。</li>\n<li>中断上下文返回用户空间时。</li>\n</ul>\n<p>内核抢占(默认开启)开启时，除了上述出发时机：</p>\n<ul>\n<li>在系统调用或异常中断上下文中，调用preempt_enable。</li>\n<li>在中断上下文中，上半部执行完毕，从中断处理函数返回到可抢占上下文时。</li>\n</ul>\n<h3 id=\"调度器实现\"><a href=\"#调度器实现\" class=\"headerlink\" title=\"调度器实现\"></a>调度器实现</h3><p>调度器的发展历史：</p>\n<ul>\n<li>O(n) 调度器\tlinux0.11 - 2.4</li>\n<li>O(1) 调度器\tlinux2.6</li>\n<li>CFS调度器\tlinux2.6至今</li>\n</ul>\n<h4 id=\"O-n-调度器\"><a href=\"#O-n-调度器\" class=\"headerlink\" title=\"O(n)调度器\"></a>O(n)调度器</h4><p>O(n) 调度器是在内核2.4以及更早期版本采用的算法，O(n)代表的是寻找一个合适的任务的时间复杂度。调度器的特点是：</p>\n<ul>\n<li>定义了一个 <code>runqueue</code> 的运行队列，将进程的状态变为 Running 的不管是实时进程，还是普通进程都会添加到此运行队列中，队列里面的进程排序是无序的。</li>\n<li>当需要从运行队列中选择一个合适的任务时，就需要<code>从头到尾遍历队列</code>，比较每个进程的优先级，优先级高的先运行。遍历的时间复杂度是O(n)，运行队列中的任务数目越大，调度器的效率就越低。</li>\n<li>进程和线程统一采用<code>task_struct</code>结构，实时进程采用的是SCHED_RR或者SCHED_FIFO调度策略，普通进程采用的是SCHED_OTHER调度策略。</li>\n<li>task_struct里面使用 <code>nice</code>值代表这个进程的静态优先级。nice值的取值范围是<code>[-20.19]</code>, 取值越小优先级越高。进程的默认nice值是0，则进程默认的静态优先级就等于20。以上针对普通进程，实时进程则是直接是在实时进程的静态优先级上加上1000。</li>\n<li><code>多个cpu共享全局队列</code>，并非每个cpu有单独的队列。</li>\n</ul>\n<p><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319123419719.png\" alt=\"image-20230319123419719\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">struct task_struct &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    long counter;</span><br><span class=\"line\">    long nice;</span><br><span class=\"line\">    unsigned long policy;</span><br><span class=\"line\">    int processor;</span><br><span class=\"line\"> </span><br><span class=\"line\">    unsigned long cpus_runnable, cpus_allowed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>counter代表的是进程的时间片，就是进程在一个调度周期中可与运行的时间。</li>\n<li>nice代表这个进程的静态优先级。通过宏NICE_TO_TICKS，可以将对应的nice值转化为对应的时间片，存储在counter中</li>\n<li>policy就是进程的调度策略，实时进程采用的是SCHED_RR或者SCHED_FIFO。普通进程采用的是SCHED_OTHER<ul>\n<li>SCHED_RR：同等优先级采用轮转的方式，不同优先级还是高优先级先调度</li>\n<li>SCHED_FIFO：同等优先级采用先来后到的次序，就是先调度的进程如果没运行完毕，后面的只能排队。不同优先级还是高优先级的优先。如果高优先级的实时进程没运行完，低优先级的也是不能运行的。</li>\n</ul>\n</li>\n<li>pocessor: 代表当前进程运行在那个处理器上，会在SMP系统中使用</li>\n<li>cpu_allowed：代表当前进程允许在那些CPU上可以运行。</li>\n</ul>\n<p>O(n)调度器的缺点：</p>\n<ul>\n<li>时间复杂度问题，时间复杂度是O(n),当系统中的进程很少的时候性能还可以，但是当系统中的进程逐渐增多，选择下一个进程的时间则是逐渐增大。而且当系统中无可运行的进程时，重新初始化进程的时间片也是相当耗时，在系统中进程很多的情况系下。</li>\n<li>SMP扩展问题。当需要picknext下一个进程时，需要对整个runqueue队列进行加锁的操作，spin_lock_irq(&amp;runqueue_lock);当系统中进程数目比较多的时候，则在临界区的时间就比较长，导致其余的CPU自旋比较浪费</li>\n<li>实时进程的运行效率问题，因为实时进程和普通进程在一个列表中，每次查实时进程时，都需要全部扫描整个列表，导致实时进程不是很“实时”</li>\n<li>CPU资源浪费问题：因为系统中只有一个runqueue,则当运行队列中的进程少于CPU的个数时，其余的CPU则几乎是idle状态，浪费资源</li>\n<li>cache缓存问题：当系统中的进程逐渐减少时，原先在CPU1上运行的进程，不得不在CPU2上运行，导致在CPU2上运行时，cacheline则几乎是空白的，影响效率。</li>\n</ul>\n<p>总之O(n)调度器有很多问题，不过有问题肯定要解决的。所以在Linux2.6引入了O(1)的调度器。</p>\n<p>参考 <a href=\"https://dragonkingzhu.blog.csdn.net/article/details/104428914\">Linux O(n)调度器</a></p>\n<h4 id=\"O-1-调度器\"><a href=\"#O-1-调度器\" class=\"headerlink\" title=\"O(1)调度器\"></a>O(1)调度器</h4><p>O(1)算法用于解决O(n)的问题，他的特点是：</p>\n<ul>\n<li>实现了per-cpu-runqueue，<code>每个CPU都有一个runqueue</code>。</li>\n<li>每一个runqueue运行队列维护两个数组：<code>活跃数组active</code>和<code>过期数组expired</code>，分别存储分别存储就绪进程和时间片用完的进程。数组元素按照进程的优先级从低到高排列。O(n)采用全局优先级：实时进程[0,99]，普通进程[100,139]，数值越低优先级越高，更容易被调度。</li>\n<li>每个数组元素对应一个<code>进程链表</code>，链表元素是优先级相同的进程。</li>\n<li>每个数组都提供了一个<code>bitmap</code>结构，从高位到低位每bit对应优先级从高到低的每个数组元素。如果该bit的值为1，说明对应优先级的链表不为空；如果该bit的值为0，说明对应优先级的链表为空。</li>\n</ul>\n<p><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319123410036.png\" alt=\"image-20230319123410036\"></p>\n<p>O(1)pciknext的过程：</p>\n<ol>\n<li>去active数组的bitmap里面从高位到低位查找第一个为1的bit。</li>\n<li>查找该bit对应的数组元素，即寻找优先级最高且非空的数组元素。因为数组元素是一个进程链表，直接取链表的第一个元素，这个就是要执行的下一个进程。<code>所以每次查找进程的时间复杂度为O(1)</code>。</li>\n<li>该进程的时间片执行完后，把他放进expire数组。（优先级可能会改变，所以放进expire数组的位置可能会和active数组不同）。</li>\n<li>当acitve数组中无进程可运行时，说明该轮调度周期所有进程的时间片都已经耗光，这时候调换active和expired的指针，开始下一轮调度周期。</li>\n</ol>\n<p><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319123442235.png\" alt=\"image-20230319123442235\"></p>\n<p>总的来说 O(1) 调度器的出现是为了解决 O(n) 调度器不能解决的问题，但 O(1) 调度器有个问题，一个高优先级多线程的应用会比低优先级单线程的应用获得更多的资源，这就会导致一个调度周期内，低优先级的应用可能一直无法响应，直到高优先级应用结束。</p>\n<p>参考<a href=\"https://blog.csdn.net/longwang155069/article/details/104457109\">Linux O(1)调度器</a></p>\n<h4 id=\"CFS调度器\"><a href=\"#CFS调度器\" class=\"headerlink\" title=\"CFS调度器\"></a>CFS调度器</h4><p>CFS(Completely Fair Scheduler)调度器采用和O(1)&#x2F;O(n)调度器完全不同的设计思路，基于楼梯调度算法（Staircase Deadline Schedule, SD）和 基于公平策略RSDL调度器(The Rotating Staircase Deadline Schedule)，目的是<code>实现完全公平的调度</code>。</p>\n<p>在2.6.23内核中引入scheduling class的概念，将调度器模块化，系统中可以有多种调度器，使用不同策略调度不同类型的进程：</p>\n<ul>\n<li>DL Scheduler 采用sched_deadline策略</li>\n<li>RT Scheduler  采用sched_rr和sched_fifo策略</li>\n<li>CFS Scheduler  采用sched_normal和sched_batch策略</li>\n<li>IDEL Scheduler  采用sched_idle策略</li>\n</ul>\n<p>所以CFS调度器就不关心实时进程了，专注于普通进程就可以了。CFS调度器的特点：</p>\n<ul>\n<li>CFS摒弃了固定时间片分配，采用<code>动态时间片分配</code>。O(1)和O(n)都将CPU资源划分为时间片，采用了固定额度分配机制，在每个调度周期进程可使用的时间片是确定的，调度周期结束才重新分配。CFS的动态调度中进程可占用的时间与进程总数、总CPU时间、进程权重等均有关系，每个调度周期的值都可能会不一样。</li>\n<li>保留普通进程的优先级piro范围[100,139]和nice范围[-20, 19]，引入新的概念<code>权重weight</code>，建立了优先级(或者说nice)和权重之间的映射关系，把优先级转换为权重来计算进程所能获取的运行时间百分比。</li>\n<li>引入<code>虚拟时间vruntime</code>的概念。vruntime类似于在一次调度周期时间轴上里面每个进程的开始位置，vruntime越小，进程在时间轴上的位置越靠前，在本次调度周期里面所能获得的物理运行时间也就越长。<code>CFS的绝对公平思想，是保证所有进程的vruntime相同，而不是保证所有进程的物理运行时间相同</code>。</li>\n<li>采用了<code>红黑树结构</code>来保存活跃进程任务。红黑树的key是进程已经使用的vruntime，并且把vruntime值最小的放到最左的叶子节点，这个节点就是下一个被pick的进程了。当vruntime耗尽则从红黑树中删除，下个调度周期开始后再添加到红黑树上。</li>\n<li>当进程的数目小于8时，则调度周期为<code>6ms</code>。当系统的进程数目大于8时，则调度器周期等于<code>进程的数目乘以0.75ms</code>。可以理解为在一个调度周期中一个进程至少保证执行0.75ms。</li>\n</ul>\n<h5 id=\"vruntime计算\"><a href=\"#vruntime计算\" class=\"headerlink\" title=\"vruntime计算\"></a>vruntime计算</h5><p>CFS 保留普通进程的优先级prio范围[100,139]和nice值范围[-20, 19]，<code>(prio-120)或者nice和权重weight是一一对应的关系</code>。数值越小代表优先级越大，同时也意味着权重值越大。nice值和权重之间的转换关系是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">weight = 1024 / 1.25nice</span><br></pre></td></tr></table></figure>\n<p>代码中已经事先计算好了nice和weight的对应表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const int sched_prio_to_weight[40] = &#123;</span><br><span class=\"line\">/* -20 */     88761,     71755,     56483,     46273,     36291,</span><br><span class=\"line\">/* -15 */     29154,     23254,     18705,     14949,     11916,</span><br><span class=\"line\">/* -10 */      9548,      7620,      6100,      4904,      3906,</span><br><span class=\"line\">/*  -5 */      3121,      2501,      1991,      1586,      1277,</span><br><span class=\"line\">/*   0 */      1024,       820,       655,       526,       423,</span><br><span class=\"line\">/*   5 */       335,       272,       215,       172,       137,</span><br><span class=\"line\">/*  10 */       110,        87,        70,        56,        45,</span><br><span class=\"line\">/*  15 */        36,        29,        23,        18,        15,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>nice&#x3D;0 虚拟运行时间 &#x3D; 物理运行时间<br>nice&gt;0 虚拟运行时间 &gt; 物理运行时间<br>nice&lt;0 虚拟运行时间 &lt; 物理运行时间</p>\n</blockquote>\n<p>通过以上对应表，<code>根据进程优先级（或者nice）计算进程的实际运行时间</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">实际运行时间 = 调度周期 * 进程权重 / 所有进程权重之和</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>比如现有进程A sched_prio&#x3D;0，进程B sched_prio&#x3D;-5，通过sched_prio_to_weight的映射：<br>进程A weight&#x3D;1024，进程B weight &#x3D; 3121<br>进程A的CPU占比 &#x3D; 1024&#x2F;(1024+3121)&#x3D; 24.7%<br>进程B的CPU占比 &#x3D; 3121&#x2F;(1024+3121) &#x3D; 75.3%<br>假如CPU总时间是10ms，那么根据A占用2.47ms，B占用7.53ms</p>\n</blockquote>\n<p>每个进程的物理运行时间都是不同的，我们需要把<code>物理运行时间来映射成vruntime</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">virtual_time = wall_time * nice_0_weight/sched_prio_to_weigh</span><br></pre></td></tr></table></figure>\n<ul>\n<li>wall_time：实际运行时间</li>\n<li>nice_0_weight：nice值为0对应的weight值，也就是1024</li>\n<li>sched_prio_to_weigh：进程优先级对应的weight<blockquote>\n<p>接着上面计算<br>A的wall_time&#x3D;2.47ms，B的wall_time&#x3D;7.53ms<br>nice_0_weight表示sched_prio&#x3D;0的权重为1024<br>进程A的虚拟时间：2.47<em>1024&#x2F;1024&#x3D;2.47ms<br>进程B的虚拟时间：7.53</em>1024&#x2F;3121&#x3D;2.47ms</p>\n</blockquote>\n</li>\n</ul>\n<p>经过这样映射，多个进程的vruntime就相等了，就是实现了“完全公平”的思想。</p>\n<h5 id=\"vruntime存储结构\"><a href=\"#vruntime存储结构\" class=\"headerlink\" title=\"vruntime存储结构\"></a>vruntime存储结构</h5><p>为了能够快速找到虚拟运行时间最小的进程，Linux 内核使用红黑树来保存可运行的进程。红黑树的key是vruntime的值，红黑树的左节点比父节点小，而右节点比父节点大。所以查找最小节点时，只需要获取红黑树的最左节点即可。<br><img src=\"/2021/03/21/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/image-20230319123500824.png\" alt=\"image-20230319123500824\"></p>\n<p>实际运行时间映射成红黑树的过程：每个sched_latency周期内，根据各个任务的权重值，可以计算出运行时间runtime；运行时间runtime可以转换成虚拟运行时间vruntime；根据虚拟运行时间的大小，插入到CFS红黑树中，虚拟运行时间少的调度实体放置到左边。在下一次任务调度的时候，选择虚拟运行时间少的调度实体来运行，即从 CFS 红黑树最左边节点获取一个调度实体。<br>参考 <a href=\"https://dragonkingzhu.blog.csdn.net/article/details/104512696\">CFS Scheduler（CFS调度器）</a></p>\n","categories":["Linux"],"tags":["Linux"]},{"title":"Linux系列（四）：文件系统","url":"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","content":"<blockquote>\n<p>Linux系列（四）：文件系统</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"文件系统结构\"><a href=\"#文件系统结构\" class=\"headerlink\" title=\"文件系统结构\"></a>文件系统结构</h2><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。</p>\n<p>linux支持的文件系统类型有：</p>\n<ul>\n<li><code>磁盘的文件系统</code>，它是直接把数据存储在磁盘中，比如 Ext 2&#x2F;3&#x2F;4、XFS 等都是这类文件系统。</li>\n<li><code>内存的文件系统</code>，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 &#x2F;proc 和 &#x2F;sys 文件系统都属于这一类读写这类文件，实际上是读写内核中相关的数据。</li>\n<li><code>网络的文件系统</code>，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。</li>\n</ul>\n<h3 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h3><p>文件系统的基本数据单位是<code>文件</code>。Linux 最经典的一句话是:「<code>一切皆文件</code>」，不仅普通的文件和目录，就连块设备、管道、socket 等，也 都是统一交给文件系统管理的。</p>\n<p>一个文件由目录项、inode和数据块组成</p>\n<ul>\n<li><code>目录项(directory entry)</code>：用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，<code>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</code>。</li>\n<li><code>索引节点(index node，inode)</code>：<code>用来记录文件的元信息</code>，比如 inode 编号、文件大小、访问权限、创建时 间、修改时间、数据在磁盘的位置等等。<code>索引节点是文件的唯一标识</code>，同样都会被存储在硬盘中，所以<code>索引节点同样占用磁盘空间</code>。</li>\n<li><code>数据块(data block)</code>：存储数据的地方。</li>\n</ul>\n<p>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以<code>目录项和索引节点的关系是多对一</code>。也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</p>\n<p><code>目录是特殊文件</code>，和普通文件不同的是：<code>普通文件的data block里面保存的是文件数据，而目录文件的data block里面保存的是一项项的文件信息</code>。<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319124545628.png\" alt=\"image-20230319124545628\"></p>\n<p>通常，第一项是「 . 」，表示当前目录，第二项是「 .. 」，表示上一级目录，接下来就是一个哈希表，对文件名进行哈希计算，把哈希值和对应的 inode 保存起来。</p>\n<blockquote>\n<p>目录和目录项的区别和联系：</p>\n<ul>\n<li>目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。</li>\n<li>目录文件保存的内容相当于一个目录项列表，目录项的内容是文件名和指向inode的指针。</li>\n</ul>\n</blockquote>\n<p>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位， 那这读写的效率会非常低。所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块(数据块)，<code>Linux 中的逻辑块大小为 4KB</code>，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p>\n<p>整个文件结构大概如下所示：<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319124558896.png\" alt=\"image-20230319124558896\"></p>\n<p>另外，磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。</p>\n<ul>\n<li>超级块，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。</li>\n<li>索引节点区，用来存储索引节点。</li>\n<li>数据块区，用来存储文件或目录数据。</li>\n</ul>\n<h3 id=\"虚拟文件系统\"><a href=\"#虚拟文件系统\" class=\"headerlink\" title=\"虚拟文件系统\"></a>虚拟文件系统</h3><p>文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中 间层，这个中间层就称为<code>虚拟文件系统(Virtual File System，VFS)</code>。</p>\n<p>VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。</p>\n<p><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319124613490.png\" alt=\"image-20230319124613490\"></p>\n<h3 id=\"软链接和硬链接\"><a href=\"#软链接和硬链接\" class=\"headerlink\" title=\"软链接和硬链接\"></a>软链接和硬链接</h3><p><code>硬链接是多个目录项中的「索引节点」指向同一个 inode</code>。但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。 由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319124632752.png\" alt=\"image-20230319124632752\"></p>\n<p><code>软链接的多个目录项的「索引节点」分别指向不同的 inode，inode 对应的 data block 的内容是另外一个文件的地址</code>。所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319124643911.png\" alt=\"image-20230319124643911\"></p>\n<h3 id=\"文件的存储\"><a href=\"#文件的存储\" class=\"headerlink\" title=\"文件的存储\"></a>文件的存储</h3><h4 id=\"分配文件空间\"><a href=\"#分配文件空间\" class=\"headerlink\" title=\"分配文件空间\"></a>分配文件空间</h4><p>文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：</p>\n<ul>\n<li>连续空间存放方式：文件存放在磁盘「连续的」物理空间中。这种模式下，文件的数据都是紧密相连，读写效率很高，因为一次磁盘寻道就可以读出整个文件；但是存在「磁盘空间碎片」和「文件⻓度不易扩展」的问题。</li>\n<li>非连续空间存放方式：非连续空间存放方式分为「链表方式」和「索引方式」。</li>\n</ul>\n<h5 id=\"链表方式分配\"><a href=\"#链表方式分配\" class=\"headerlink\" title=\"链表方式分配\"></a>链表方式分配</h5><p>根据实现的方式的不同，链表可分为「隐式链表」和「显式链接」两种形式。</p>\n<p><code>隐式链表是指文件头要包含「第一块」和「最后一块」的位置， 并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置，这样一个数据块连着一个数据块，从链头开是就可以顺着指针找到所有的数据块，所以存放的方式可以是不连续的</code>。<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319124700993.png\" alt=\"image-20230319124700993\"></p>\n<p>隐式链表的存放方式的缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间。隐式链接分配的稳定性较差，系统在运行过程中由于软件或者硬件错误导致链表中的 指针丢失或损坏，会导致文件数据的丢失。</p>\n<p><code>显式链接是指把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中，每个表项中存放链接指针，指向下一个数据块号。该表在整个磁盘仅设置一张</code>。这个表格称为<code>文件分配表(File Allocation Table，FAT)</code>。<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319194815845.png\" alt=\"image-20230319194815845\"></p>\n<p>由于查找记录的过程是在内存中进行的，因而不仅显著地提高了检索速度，而且大大减少了访问磁盘的次 数。但也正是整个表都存放在内存中的关系，它的主要的缺点是不适用于大磁盘。比如，对于 200GB 的磁盘和 1KB 大小的块，这张表需要有 2 亿项，每一项对应于这 2 亿个磁盘块中的一 个块，每项如果需要 4 个字节，那这张表要占用 800MB 内存，很显然 FAT 方案对于大磁盘而言不太合适。</p>\n<h5 id=\"索引方式分配\"><a href=\"#索引方式分配\" class=\"headerlink\" title=\"索引方式分配\"></a>索引方式分配</h5><p>索引的实现是为每个文件创建一个「索引数据块」，里面存放的是指向「索引数据块」的指针列表。<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319194915087.png\" alt=\"image-20230319194915087\"></p>\n<p>这样只需要在创建文件的时候再创建索引数据块，而不需要创建一张全局的FAT。但是由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，就会造成额外开销。</p>\n<h5 id=\"linux文件存储的实现\"><a href=\"#linux文件存储的实现\" class=\"headerlink\" title=\"linux文件存储的实现\"></a>linux文件存储的实现</h5><p><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319194928721.png\" alt=\"image-20230319194928721\"></p>\n<p>根据文件的大小，存放的方式会有所变化:</p>\n<ul>\n<li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式。</li>\n<li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式。</li>\n<li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式。</li>\n<li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式。</li>\n</ul>\n<p>那么，文件头(Inode)就需要包含 13 个指针:</p>\n<ul>\n<li>10 个指向数据块的指针。</li>\n<li>第 11 个指向索引块的指针。</li>\n<li>第 12 个指向二级索引块的指针。</li>\n<li>第 13 个指向三级索引块的指针。</li>\n</ul>\n<p>所以，这种方式能很灵活地支持小文件和大文件的存放：</p>\n<ul>\n<li>对于小文件使用直接查找的方式可减少索引数据块的开销。</li>\n<li>对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询。</li>\n</ul>\n<h4 id=\"空闲空间管理\"><a href=\"#空闲空间管理\" class=\"headerlink\" title=\"空闲空间管理\"></a>空闲空间管理</h4><p>前面说到的文件的存储是针对已经被占用的数据块组织和管理，磁盘的空闲空间管理用于快速找出一个新的空闲地址空间用于存储新的数据块。接下来介绍几种常⻅的方法：</p>\n<ul>\n<li>空闲表法</li>\n<li>空闲链表法</li>\n<li>位图法</li>\n</ul>\n<h5 id=\"空闲表法\"><a href=\"#空闲表法\" class=\"headerlink\" title=\"空闲表法\"></a>空闲表法</h5><p>空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319194947998.png\" alt=\"image-20230319194947998\"></p>\n<p>当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。</p>\n<h5 id=\"空闲链表法\"><a href=\"#空闲链表法\" class=\"headerlink\" title=\"空闲链表法\"></a>空闲链表法</h5><p>我们也可以使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。如下图：<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319195003571.png\" alt=\"image-20230319195003571\"></p>\n<p>当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。</p>\n<p>这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效 率低，因为每当在链上增加或移动空闲块时需要做很多 I&#x2F;O 操作，同时数据块的指针消耗了一定的存储空间。</p>\n<p>空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。</p>\n<h5 id=\"位图法\"><a href=\"#位图法\" class=\"headerlink\" title=\"位图法\"></a>位图法</h5><p>位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1111110011111110001110110111111100111 ...</span><br></pre></td></tr></table></figure>\n\n<p>在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。</p>\n<h3 id=\"文件系统结构-1\"><a href=\"#文件系统结构-1\" class=\"headerlink\" title=\"文件系统结构\"></a>文件系统结构</h3><p>数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 4 * 1024 * 8 &#x3D; 2^15 个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 2^15 * 4 *<br>1024 &#x3D; 2^27 个 byte，也就是 128M。「一个块的位图 + 一系列的块」这种数据结构就表示一个<code>块组</code>。linux 文件系统由大量块组组成。<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319195043863.png\" alt=\"image-20230319195043863\"></p>\n<p>最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下:</p>\n<ul>\n<li><code>超级块</code>，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。</li>\n<li><code>块组描述符</code>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包 含了文件系统中「所有块组的组描述符信息」。</li>\n<li><code>数据位图和 inode 位图</code>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。</li>\n<li><code>inode 列表</code>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。</li>\n<li><code>数据块</code>，包含文件的有用数据。</li>\n</ul>\n<h2 id=\"文件系统I-x2F-O\"><a href=\"#文件系统I-x2F-O\" class=\"headerlink\" title=\"文件系统I&#x2F;O\"></a>文件系统I&#x2F;O</h2><h3 id=\"多种I-x2F-O模型\"><a href=\"#多种I-x2F-O模型\" class=\"headerlink\" title=\"多种I&#x2F;O模型\"></a>多种I&#x2F;O模型</h3><p>根据<code>调用方在发起数据请求后，是否会被阻塞等待数据返回</code>，I&#x2F;O模型分为：</p>\n<ul>\n<li>阻塞I&#x2F;O：调用方会被阻塞，直到数据返回。</li>\n<li>非阻塞I&#x2F;O：调用方不会被阻塞，可以先做自己的事情，等数据准备好了之后再得到数据。</li>\n</ul>\n<p>根据<code>调用方是主动还是被动接受准备好的数据</code>，I&#x2F;O模型分为：</p>\n<ul>\n<li>同步I&#x2F;O：调用方主动轮询数据是否准备好，如果准备好就主动拉取数据。</li>\n<li>异步I&#x2F;O：调用方只需要被动等待准备好的数据。</li>\n</ul>\n<p>总共可以分为以下四种I&#x2F;O模型<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319195057586.png\" alt=\"image-20230319195057586\"></p>\n<h4 id=\"同步阻塞I-x2F-O\"><a href=\"#同步阻塞I-x2F-O\" class=\"headerlink\" title=\"同步阻塞I&#x2F;O\"></a>同步阻塞I&#x2F;O</h4><p><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319195110693.png\" alt=\"image-20230319195110693\"></p>\n<p><code>同步阻塞 I/O</code>：当用户程序执行 read ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷⻉到应用程序的缓冲区中，当拷⻉过程完成， read 才会返回。 </p>\n<p>注意，<code>阻塞等待的是「内核数据准备好」和「数据从内核态拷⻉到用户态」这两个过程</code>。</p>\n<h4 id=\"同步非阻塞I-x2F-O\"><a href=\"#同步非阻塞I-x2F-O\" class=\"headerlink\" title=\"同步非阻塞I&#x2F;O\"></a>同步非阻塞I&#x2F;O</h4><p><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319195127368.png\" alt=\"image-20230319195127368\"></p>\n<p>同步非阻塞 I&#x2F;O：非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往 下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷⻉到应用程序缓冲区， read 调用 才可以获取到结果。</p>\n<p>这里最后一次 read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷⻉到用户程序的缓存区这个过程。</p>\n<p>但是单纯的同步非阻塞I&#x2F;O其实应用意义不大，因为应用程序一直轮询内核的 I&#x2F;O 是否准备好。如果轮询频率太高，应用程序相当于什么也做不了，只是在循环，和同步阻塞I&#x2F;O没什么区别；如果轮询频率太低，可能不能及时获取数据。</p>\n<p>那能不能把轮询的任务交给一个单独的线程专门完成？这就衍生了I&#x2F;O多路复用技术。</p>\n<h4 id=\"I-x2F-O多路复用\"><a href=\"#I-x2F-O多路复用\" class=\"headerlink\" title=\"I&#x2F;O多路复用\"></a>I&#x2F;O多路复用</h4><p><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319195142787.png\" alt=\"image-20230319195142787\"></p>\n<p>I&#x2F;O多路复用把轮询任务交给专门的系统函数（select&#x2F;poll&#x2F;epoll），当内核数据准备好时，系统函数再以事件通知应用程序进行操作。</p>\n<h4 id=\"异步I-x2F-O\"><a href=\"#异步I-x2F-O\" class=\"headerlink\" title=\"异步I&#x2F;O\"></a>异步I&#x2F;O</h4><p>实际上，无论是阻塞 I&#x2F;O、非阻塞 I&#x2F;O，还是基于非阻塞 I&#x2F;O 的多路复用都是同步调用。<code>因为它们在 read 调用时，内核将数据从内核空间拷⻉到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的</code>。如果内核实现的拷⻉效率不高，read 调用就会在这个同步过程中等待比较⻓的时间。</p>\n<p>而真正的异步 I&#x2F;O 是「内核数据准备好」和「数据从内核态拷⻉到用户态」这两个过程都不用等待。<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319195157353.png\" alt=\"image-20230319195157353\"></p>\n<h4 id=\"select-x2F-poll-x2F-epoll\"><a href=\"#select-x2F-poll-x2F-epoll\" class=\"headerlink\" title=\"select&#x2F;poll&#x2F;epoll\"></a>select&#x2F;poll&#x2F;epoll</h4><p>select&#x2F;poll&#x2F;epoll 是内核提供给用户态的多路复用系统调用，进程可以通过一个系统调用函数从内核中获取多个事件。</p>\n<h5 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h5><p>select 实现多路复用的方式是：</p>\n<ol>\n<li>将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将文件描述符集合拷⻉到内核里。</li>\n<li>内核遍历文件描述符集合检查是否有网络事件产生。当检查到有事件产生后，将此 Socket 标记为可读或可写。</li>\n<li>把整个文件描述符集合拷⻉回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。</li>\n</ol>\n<p>select函数的格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure>\n<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>\n<p>select 这种方式，需要进行 <code>2 次「遍历文件描述符集合」</code>和 <code>2 次「拷⻉文件描述符集合」</code>。select 使用固定长度的 BitsMap 来表示文件描述符集合，支持最大数量为 <code>1024</code>。select 目前几乎在所有的平台上支持。</p>\n<h5 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h5><p>poll 和 select 唯一的区别是：不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p>\n<p>poll函数的格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int poll (struct pollfd *fds, unsigned int nfds, int timeout);</span><br></pre></td></tr></table></figure>\n<p>不同与 select 使用三个 BitsMap 来表示三个 fdset 的方式，poll 使用一个 pollfd 的指针实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">struct pollfd &#123;</span><br><span class=\"line\">    int fd; /* file descriptor */</span><br><span class=\"line\">    short events; /* requested events to watch */</span><br><span class=\"line\">    short revents; /* returned events witnessed */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>pollfd 结构包含了要监视的 event 和发生的 event，不再使用select “参数-值”传递的方式。同时，pollfd 并没有最大数量限制（但是数量过大后性能也是会下降）。 和 select 函数一样，poll 返回后，需要轮询 pollfd 来获取就绪的描述符。</p>\n<p><code>select 和 poll 都需要在返回后，通过遍历文件描述符来获取已经就绪的 socket</code>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>\n<h5 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h5><p>epoll 是在 2.6 内核中提出的，用于解决 select 和 poll 的性能问题和描述符限制问题。</p>\n<p>epoll 需要三个函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int epoll_create(int size)；</span><br><span class=\"line\">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class=\"line\">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>epoll_create：<code>创建一个 epoll 的句柄</code>，size 用来告诉内核这个监听的数目一共有多大。参数 size 并不是限制了 epoll 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。当创建好 epoll 句柄后，它就会占用一个 fd 值。</li>\n<li>epoll_ctl：<code>把需要监控的 socket 加入内核中的红黑树里</code>。epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字符。这样就不需要像 select&#x2F;poll 每次操作时都传入整个 socket 集合，只需要传入一个待检测的 socket。</li>\n<li>epoll_wait：<code>从内核返回有事件发生的文件描述符的个数</code>。内核里维护了一个链表来记录就绪事件，并且采用<code>事件驱动</code>的机制，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件链表中。不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</li>\n</ul>\n<p><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319195221093.png\" alt=\"image-20230319195221093\"></p>\n<p>epoll 支持两种事件触发模式，分别是<code>边缘触发(edge-triggered，ET)</code>和<code>水平触发(level-triggered，LT)</code>。</p>\n<ul>\n<li>边缘触发模式：当被监控的 Socket 描述符上有可读事件发生时，<code>服务器端只会从 epoll_wait 中苏醒一次</code>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完。</li>\n<li>水平触发模式：当被监控的 Socket 上有可读事件发生时，<code>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</code>。</li>\n</ul>\n<p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。</p>\n<p>如果使用边缘触发模式，I&#x2F;O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会循环从文件描述符读写数据，那么如果 文件描述符是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。<code>所以使用边缘触发模式一般和非阻塞 I/O 搭配使用，程序会一直执行 I/O 操作</code>，直到系统调用(如 read 和 write )返回错误，错误类型为 EAGAIN 或 EWOULDBLOCK 。</p>\n<h3 id=\"零拷贝\"><a href=\"#零拷贝\" class=\"headerlink\" title=\"零拷贝\"></a>零拷贝</h3><h4 id=\"DMA\"><a href=\"#DMA\" class=\"headerlink\" title=\"DMA\"></a>DMA</h4><p>在了解零拷贝之前，我们先了解下 DMA 技术。在没有 DMA 技术前，I&#x2F;O 的过程是这样的：<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319195236679.png\" alt=\"image-20230319195236679\"></p>\n<p>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。而且由于网络传输和数据复制的速度远远低于 CPU 的速度，CPU 大部分时间都是空等，造成性能的极大浪费。所以就出现了 <code>DMA (Direct Memory Access)</code>技术。</p>\n<p>DMA 技术的原理：<code>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</code>。使用 DMA 技术后的 I&#x2F;O 的过程是这样的：<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319195248755.png\" alt=\"image-20230319195248755\"></p>\n<p>但是注意<code>数据从内核缓冲区拷贝到用户缓冲区这个过程，还是由 CPU 来完成的</code>。而且read函数的调用和返回都会发生用户态和内核态的切换。这些都是比较耗时的过程。所谓的<code>零拷贝</code>技术，其实就是减少两个过程：</p>\n<ul>\n<li>减少数据在内核缓冲区拷贝和用户缓冲区的来回复制</li>\n<li>减少上下文切换</li>\n</ul>\n<h4 id=\"传统文件传输（read-write）\"><a href=\"#传统文件传输（read-write）\" class=\"headerlink\" title=\"传统文件传输（read + write）\"></a>传统文件传输（read + write）</h4><p>传统文件传输直接调用 <code>read</code> 和 <code>write</code> 函数：<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319195302942.png\" alt=\"image-20230319195302942\"></p>\n<p>发生了 4 次上下文切换，2 次 CPU 拷贝，2 次 DMA 拷贝。</p>\n<h4 id=\"mmap-write\"><a href=\"#mmap-write\" class=\"headerlink\" title=\"mmap + write\"></a>mmap + write</h4><p>可以用 mmap() 替换 read() 系统调用函数。mmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，这样，操作系统内核与用户空 间就不需要再进行任何的数据拷⻉操作。<code>这样就减少 1 次 CPU 拷贝</code>。<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319195318100.png\" alt=\"image-20230319195318100\"></p>\n<p>发生了 4 次上下文切换，1 次 CPU 拷贝，2 次 DMA 拷贝。</p>\n<h4 id=\"sendfile\"><a href=\"#sendfile\" class=\"headerlink\" title=\"sendfile\"></a>sendfile</h4><p>sendfile() 可以替代 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就<code>减少了 2 次上下文切换的开销</code>。其次，该系统调用，可以直接把内核缓冲区里的数据拷⻉到 socket 缓冲区里，不再拷⻉到用户态，这样就<code>减少 1 次 CPU 拷贝</code>。<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319195333530.png\" alt=\"image-20230319195333530\"></p>\n<p>发生了 2 次上下文切换，1 次 CPU 拷贝，2 次 DMA 拷贝。</p>\n<p>如果网卡支持 <code>SG-DMA</code>(The Scatter-Gather Direct Memory Access) 技术，我们还可以把这 1 次 CPU 拷贝也省略。</p>\n<p>查看网卡是否支持 scatter-gather 特性：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ethtool -k eth0 | grep scatter-gather</span><br><span class=\"line\">scatter-gather: on</span><br></pre></td></tr></table></figure>\n\n<p>Linux 内核 2.4 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， sendfile() 系统调用的过程如下：<br><img src=\"/2021/03/22/Linux%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230319195347396.png\" alt=\"image-20230319195347396\"></p>\n<p>发生了 2 次上下文切换，2 次 DMA 拷贝。</p>\n","categories":["Linux"],"tags":["Linux"]},{"title":"计算机网络系列（二）：http篇","url":"/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Ahttp%E7%AF%87/","content":"<blockquote>\n<p>计算机网络系列（二）：http篇</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http\"></a>http</h2><h3 id=\"http是什么\"><a href=\"#http是什么\" class=\"headerlink\" title=\"http是什么\"></a>http是什么</h3><p>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。它可以拆成三个部分：</p>\n<ul>\n<li>超文本</li>\n<li>传输</li>\n<li>协议</li>\n</ul>\n<p>重点是什么叫超文本？我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。</p>\n<p>再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。例如HTML 就是最常⻅的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网⻚了。</p>\n<p>所以综合以上定义，<code>HTTP 是一个在计算机世界里专⻔在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范</code>」。</p>\n<h3 id=\"http状态码\"><a href=\"#http状态码\" class=\"headerlink\" title=\"http状态码\"></a>http状态码</h3><p><img src=\"/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Ahttp%E7%AF%87/image-20230319212624188.png\" alt=\"image-20230319212624188\"></p>\n<ul>\n<li><code>1xx</code> 类状态码属于<code>提示信息</code>，是协议处理中的一种中间状态，实际用到的比较少。</li>\n<li><code>2xx</code> 类状态码表示<code>成功处理</code>，服务器成功处理了客户端的请求，也是我们最愿意看到的状态。<ul>\n<li>「200 OK」是最常⻅的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body<br>  数据。</li>\n<li>「204 No Content」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>\n<li>「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>\n</ul>\n</li>\n<li><code>3xx</code> 类状态码表示<code>重定向</code>，客户端请求的资源发送了变动，需要客户端用新的 URL 新发送请求获取资源。<ul>\n<li>「301 Moved Permanently」表示永久定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li>\n<li>「302 Found」表示临时定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。301 和 302 都会在响应头里使用字段 Location ，指明后续要跳转的 URL，浏览器会自动􏰀定向新的 URL。</li>\n<li>「304 Not Modified」不具有跳转的含义，表示资源未修改，􏰀定向已存在的缓冲文件，也称缓存定向，用于缓存控制。</li>\n</ul>\n</li>\n<li><code>4xx</code> 类状态码表示<code>客户端错误</code>，客户端发送的报文有误，服务器无法处理。<ul>\n<li>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</li>\n<li>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</li>\n<li>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>\n</ul>\n</li>\n<li><code>5xx</code> 类状态码表示<code>服务器错误</code>，客户端请求报文正确，但是服务器处理时内部发生了错误。<ul>\n<li>「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>\n<li>「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>\n<li>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>\n<li>「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后试”的意思。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"http常见字段\"><a href=\"#http常见字段\" class=\"headerlink\" title=\"http常见字段\"></a>http常见字段</h3><ul>\n<li>Host：客户端指定服务器的域名。</li>\n<li>Content-Length：服务器返回数据的数据长度。</li>\n<li>Connection：客户端要求服务器使用 TCP 持久连接，以便其他请求复用。例如 <code>Connection: keep-alive</code>。</li>\n<li>Content-Type：服务器返回数据的格式。例如 <code>Content-Type: text/html; charset=utf-8</code></li>\n<li>Content-Encoding：服务器返回的数据使用的压缩格式。</li>\n<li>Accept-Encoding：客户端可以接受的压缩格式。</li>\n</ul>\n<h3 id=\"http版本的升级演变\"><a href=\"#http版本的升级演变\" class=\"headerlink\" title=\"http版本的升级演变\"></a>http版本的升级演变</h3><h4 id=\"http1-1的升级特点\"><a href=\"#http1-1的升级特点\" class=\"headerlink\" title=\"http1.1的升级特点\"></a>http1.1的升级特点</h4><p>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进:</p>\n<ul>\n<li><code>⻓连接</code>，改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li>\n<li><code>管道(pipeline)网络传输</code>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li>\n</ul>\n<p>但 HTTP&#x2F;1.1 还是有性能瓶颈:</p>\n<ul>\n<li>头部冗长。只能压缩 Body 的部分，请求&#x2F;响应头部(Header)未经压缩就发送，首部信息越多延迟越大。每次互相发送相同的头部造成的浪费较多。</li>\n<li>队头阻塞。服务器是按请求的顺序响应的，如果服务器响应慢，会导致客户端一直请求不到数据。</li>\n<li>没有请求优先级控制。</li>\n<li>请求只能从客户端开始，服务器只能被动响应。</li>\n</ul>\n<h4 id=\"http2的升级特点\"><a href=\"#http2的升级特点\" class=\"headerlink\" title=\"http2的升级特点\"></a>http2的升级特点</h4><p>那 HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进:</p>\n<ul>\n<li><code>头部压缩</code>：通过 HPACK 算法，在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，每个字段对应一个索引号，以后就不发送同样字段了，使用索引号代替字段，大大减小头部长度。</li>\n<li><code>二进制格式</code>：不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧(frame):头信息帧和数据帧。</li>\n<li><code>Steam设计和多路复用</code>：每个请求或回应的所有数据包，称为一个数据流(Stream)。每个Stream有独立的编号，客户端可以指定Stream的优先级。优先级高的Stream会被服务器优先响应。多个 Stream 复用一条 TCP 连接，不同 Stream 的帧是可以乱序发送的（Stream内部必须是有序的），达到并发的效果。</li>\n<li><code>服务器推送</code>：服务器可以主动向客户端发送消息。例如在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待</li>\n<li><code>引入SSL/TLS提高安全性</code>：HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</li>\n</ul>\n<p><img src=\"/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Ahttp%E7%AF%87/image-20230319212645173.png\" alt=\"image-20230319212645173\"></p>\n<h2 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https\"></a>https</h2><p>HTTP 是明文传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL&#x2F;TLS 安全协议，使得报文能够加密传输。HTTPS 在 TCP 三次握手之 后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。</p>\n<h3 id=\"SSL-x2F-TLS协议\"><a href=\"#SSL-x2F-TLS协议\" class=\"headerlink\" title=\"SSL&#x2F;TLS协议\"></a>SSL&#x2F;TLS协议</h3><p>SSL&#x2F;TLS协议采用 <code>对称加密</code> + <code>非对称加密</code> 结合的「混合加密」方式：</p>\n<ul>\n<li>在通信建立前采用非对称加密的方式交换「会话秘钥」。服务器保存私钥，客户端保存公钥，双方验证成功后生成「会话秘钥」，</li>\n<li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</li>\n</ul>\n<p>SSL&#x2F;TSL协议基本过程：</p>\n<ol>\n<li>客户端向服务器端索要并验证公钥。</li>\n<li>双方协商生成”对话密钥”。</li>\n<li>双方采用”对话密钥”进行加密通信。</li>\n</ol>\n<h4 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h4><p>客户端验证服务器的公钥的合法性是SSL&#x2F;TSL交互过程的关键，验证结果可以确定该地址是否正确的服务器地址而不是钓鱼网站地址。</p>\n<p>如何保证公钥不被篡改和信任度？为了提高公钥传输的安全性，第三方机构应运而生——证书颁发机构(CA，Certificate Authority)。CA 默认是受信任的第三方。CA 会将服务器公钥放在数字证书，然后向各个服务器颁发证书，证书存储在服务器上，只要证书是可信的，公钥就是可信的。</p>\n<p>基于数字证书的通信过程：</p>\n<ol>\n<li>服务器把自己的公钥注册到CA。</li>\n<li>CA对服务器的公钥采用散列技术生成一个摘要，使用 CA 私钥对该摘要进行加密，附在数字证书上，然后向服务器返回数字证书。</li>\n<li>客户端向服务器发起请求，在三次握手成功后服务器向客户端返回服务器密钥+数字证书。</li>\n<li>客户端使用 CA 公钥（一般已经事先存在系统上或浏览器上）对数字证书进行解密，同时对消息进行散列处理，得到摘要。比较摘要，验证数字证书的真实性。</li>\n<li>客户端确认证书真实性后，使用服务器公钥对数据进行加密返回。</li>\n<li>服务器收到数据使用服务器私钥进行解密，基于数字证书的通信过程完成。</li>\n</ol>\n<p><img src=\"/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Ahttp%E7%AF%87/image-20230319212738494.png\" alt=\"image-20230319212738494\"></p>\n<h4 id=\"SSL-x2F-TLS四次握手过程\"><a href=\"#SSL-x2F-TLS四次握手过程\" class=\"headerlink\" title=\"SSL&#x2F;TLS四次握手过程\"></a>SSL&#x2F;TLS四次握手过程</h4><p><img src=\"/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Ahttp%E7%AF%87/image-20230319212751943.png\" alt=\"image-20230319212751943\"></p>\n<ol>\n<li>客户端发出请求（ClientHello），客户端主要向服务器发送以下信息:<ul>\n<li>客户端支持的 SSL&#x2F;TLS 协议版本，如 TLS 1.2 版本。</li>\n<li>客户端生产的随机数( Client Random )，后面用于生产「会话秘钥」。</li>\n<li>客户端支持的加密方法，如 RSA 加密算法。</li>\n<li>客户端支持的压缩方法。</li>\n</ul>\n</li>\n<li>服务器回应（SeverHello），服务器回应的内容有：<ul>\n<li>确认 SSL&#x2F; TLS 协议版本，如果浏览器不支持，则关闭加密通信。</li>\n<li>服务器生产的随机数( Server Random )，后面用于生产「会话秘钥」。</li>\n<li>使用的加密方法，如 RSA 加密算法。</li>\n<li>服务器的数字证书。</li>\n</ul>\n</li>\n<li>客户端回应，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。 如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：<ul>\n<li>一个随机数( pre-master key )。该随机数会被服务器公钥加密。 </li>\n<li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li>\n<li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li>\n</ul>\n</li>\n<li>服务器回应，服务器收到客户端的第三个随机数( pre-master key )之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：<ul>\n<li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li>\n<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘 要，用来供客户端校验。</li>\n</ul>\n</li>\n</ol>\n<p>至此，整个 SSL&#x2F;TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p>\n<p>简单的来说，SSL&#x2F;TSL通过四次握手，主要交换三个信息：</p>\n<ul>\n<li><code>数字证书</code>：该证书包含了公钥等信息，一般是由服务器发给客户端，接收方通过验证这个证书是不是由信赖的CA签发，或者与本地的证书相对比，来判断证书是否可信；假如需要双向验证，则服务器和客户端都需要发送数字证书给对方验证；</li>\n<li><code>三个随机数</code>：这三个随机数构成了后续通信过程中用来对数据进行对称加密解密的“对话密钥”。首先客户端先发第一个随机数N1，然后服务器回了第二个随机数N2（这个过程同时把之前提到的证书发给客户端），这两个随机数都是明文的；而第三个随机数N3（这个随机数被称为Premaster secret），客户端用数字证书的公钥进行非对称加密，发给服务器；而服务器用只有自己知道的私钥来解密，获取第三个随机数。这样，服务端和客户端都有了三个随机数N1+N2+N3，然后两端就使用这三个随机数来生成“对话密钥”，在此之后的通信都是使用这个“对话密钥”来进行对称加密解密。因为这个过程中，服务端的私钥只用来解密第三个随机数，从来没有在网络中传输过，这样的话，只要私钥没有被泄露，那么数据就是安全的。</li>\n<li><code>加密通信协议</code>：就是双方商量使用哪一种对称加密方式，假如两者支持的加密方式不匹配，则无法进行通信。常用的对称加密算法有两种，分别是 RSA 和 ECDHE 算法。RSA 是比较传统的密钥交换算法，它不具备前向安全的性质，因此现在很少服务器使用的。而 ECDHE 算法 具有前向安全，所以被广泛使用。</li>\n</ul>\n<h3 id=\"http和https的区别\"><a href=\"#http和https的区别\" class=\"headerlink\" title=\"http和https的区别\"></a>http和https的区别</h3><p><img src=\"/2021/03/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Ahttp%E7%AF%87/image-20230319212807754.png\" alt=\"image-20230319212807754\"></p>\n","categories":["计算机网络"],"tags":["计算机网络"]},{"title":"计算机网络系列（一）：基础篇","url":"/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/","content":"<blockquote>\n<p>计算机网络系列（一）：基础篇</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h3 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h3><p>国际标标准化组织制定的标准网络模型是<code>OSI网络模型</code>，一共有七层：</p>\n<ul>\n<li>应用层，负责给应用程序提供统一的接口</li>\n<li>表示层，负责把数据转换成兼容另一个系统能识别的格式</li>\n<li>会话层，负责建立、管理和终止表示层实体之间的通信会话</li>\n<li>传输层，负责端到端的数据传输</li>\n<li>网络层，负责数据的路由、转发、分片</li>\n<li>数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址</li>\n<li>物理层，负责在物理网络中传输数据帧</li>\n</ul>\n<p>由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。事实上，我们比较常⻅，也比较实用的是四层模型，即 <code>TCP/IP网络模型</code>，Linux 系统正是按照这套网络模型来实现网络协议栈的。一共有四层：</p>\n<ul>\n<li>应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等</li>\n<li>传输层，负责端到端的通信，比如 TCP、UDP 等</li>\n<li>网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等</li>\n<li>网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传 输网络帧等</li>\n</ul>\n<p><img src=\"/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/image-20230319210000609.png\" alt=\"image-20230319210000609\"></p>\n<p><img src=\"/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/image-20230319210014812.png\" alt=\"image-20230319210014812\"></p>\n<h3 id=\"网络协议栈\"><a href=\"#网络协议栈\" class=\"headerlink\" title=\"网络协议栈\"></a>网络协议栈</h3><p>在TCP&#x2F;IP网络模型里面，数据在每一层都会经过一次包装<br><img src=\"/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/image-20230319210058147.png\" alt=\"image-20230319210058147\"></p>\n<ul>\n<li>传输层：给应用数据前面增加了 TCP 头，单位为 <code>segment</code>。</li>\n<li>网络层，给 TCP 数据包前面增加了 IP 头，单位为 <code>packet</code>。</li>\n<li>网络接口层，给 IP 数据* 包前后分别增加了帧头和帧尾，单位为 <code>frame</code>。</li>\n</ul>\n<h3 id=\"linux系统收发网络\"><a href=\"#linux系统收发网络\" class=\"headerlink\" title=\"linux系统收发网络\"></a>linux系统收发网络</h3><p><img src=\"/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/image-20230319210114083.png\" alt=\"image-20230319210114083\"></p>\n<h4 id=\"linux接收网络包的过程\"><a href=\"#linux接收网络包的过程\" class=\"headerlink\" title=\"linux接收网络包的过程\"></a>linux接收网络包的过程</h4><p>如果每当网卡收到一个网络包，就触发一个中断告诉操作系统，会造成cpu频繁中断。Linux 内核在 2.6 版本中引入了 NAPI 机制，它是混合「中断和轮询」的 方式来接收网络包，它的核心概念就是不采用中断的方式读取数据，而是首先采用中断唤醒数据接收的服务程序， 然后 poll 的方法来轮询数据。</p>\n<ol>\n<li>当有网络包到达时，通过 DMA 技术，将网络包放入到 Ring Buffer，触发中断。</li>\n<li>网卡发起硬件中断，于是会执行网卡硬件中断处理函数，中断处理函数处理完需要「暂时屏蔽中断」，然后唤醒「软中断」来轮询处理数据，直到没有新数据时才恢复中断。</li>\n<li>「软中断」从 Ring Buffer 中拷⻉数据到内核 struct sk_buff 缓冲区，作为一个网络包交给网络协议栈进行逐层处理。</li>\n<li>进入网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。</li>\n<li>进入网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。</li>\n<li>进入传输层，取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的Socket，并把数据拷⻉到 Socket 的接收缓冲区。</li>\n<li>进入应用层，应用层程序调用 Socket 接口，从内核的 Socket 接收缓冲区读取新到来的数据到应用层。</li>\n</ol>\n<h4 id=\"linux发送网络包的过程\"><a href=\"#linux发送网络包的过程\" class=\"headerlink\" title=\"linux发送网络包的过程\"></a>linux发送网络包的过程</h4><p>发送网络包的流程正好和接收流程相反：</p>\n<ol>\n<li>首先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，Socket 层会将应用层数据拷⻉到 Socket 发送缓冲区中。然后网络协议栈从 Socket 发送缓冲区中取出数据包，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。</li>\n<li>进入传输层，如果使用的是 TCP 传输协议发送数据，那么会在传输层增加 TCP 包头。</li>\n<li>进入网络层，网络层会给数据包增加 IP 包，然后通过查询路由表确认下一跳的 IP，并按照 MTU 大小进行分片。</li>\n<li>进入网络接口层，过 ARP 协议获得下一跳的 MAC 地址，然后增加帧头和帧尾，放到发包队列中。</li>\n<li>触发软中断告诉网卡驱动程序，这里有新的网络包需要发送，最后驱动程序通过 DMA，从发 包队列中读取网络包，将其放入到硬件网卡的队列中，随后物理网卡再将它发送出去。</li>\n</ol>\n<h3 id=\"IEEE-802标准\"><a href=\"#IEEE-802标准\" class=\"headerlink\" title=\"IEEE 802标准\"></a>IEEE 802标准</h3><p>IEEE 802 指IEEE标准中关于局域网和城域网的一系列标准。更确切的说，IEEE 802标准仅限定在传输可变大小数据包的网络。其中最广泛使用的有以太网、令牌环、无线局域网等。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。</p>\n<p>IEEE 802中定义的服务和协议限定在OSI模型的最低两层（即物理层和数据链路层）。事实上，IEEE 802将OSI的数据链路层分为两个子层，分别是逻辑链路控制（LLC, Logical Link Control）和介质访问控制（MAC, Media Access Control），如下所示：</p>\n<ul>\n<li>数据链路层<ul>\n<li>逻辑链路控制子层</li>\n<li>介质访问控制子层</li>\n</ul>\n</li>\n<li>物理层</li>\n</ul>\n<p>现有标准</p>\n<ul>\n<li>IEEE 802.1：高层局域网协议（Bridging (networking) and Network Management）</li>\n<li>IEEE 802.2：逻辑链路控制（Logical link control）</li>\n<li>IEEE 802.3：以太网（Ethernet）</li>\n<li>IEEE 802.4：令牌总线（Token bus）</li>\n<li>IEEE 802.5：令牌环（Token-Ring）</li>\n<li>IEEE 802.6：城域网（MAN, Metropolitan Area Network）</li>\n<li>IEEE 802.7：宽带TAG（Broadband LAN using Coaxial Cable）</li>\n<li>IEEE 802.8：光纤分布式数据接口（FDDI）</li>\n<li>IEEE 802.9：综合业务局域网（Integrated Services LAN）</li>\n<li>IEEE 802.10：局域网网络安全（Interoperable LAN Security）</li>\n<li>IEEE 802.11：无线局域网（Wireless LAN &amp; Mesh）</li>\n<li>IEEE 802.12：需求优先级（Demand priority）</li>\n<li>IEEE 802.13：（未使用）</li>\n<li>IEEE 802.14：电缆调制解调器（Cable modems）</li>\n<li>IEEE 802.15：无线个人网（Wireless PAN）</li>\n<li>IEEE 802.15.1：无线个人网络（WPAN, Wireless Personal Area Network）</li>\n<li>IEEE 802.15.4：低速无线个人网络（LR-WPAN, Low Rate Wireless Personal Area Network）</li>\n<li>IEEE 802.16：宽带无线接入（Broadband Wireless Access）</li>\n<li>IEEE 802.17：弹性封包环传输技术（Resilient packet ring）</li>\n<li>IEEE 802.18：无线电管制技术（Radio Regulatory TAG）</li>\n<li>IEEE 802.19：共存标签（Coexistence TAG）</li>\n<li>IEEE 802.20：移动宽频无线接入（Mobile Broadband Wireless Access）</li>\n<li>IEEE 802.21：媒介独立换手（Media Independent Handover）</li>\n<li>IEEE 802.22：无线区域网（Wireless Regional Area Network）</li>\n<li>IEEE 802.23：紧急服务工作组（Emergency Services Working Group），2010年3月新发布</li>\n</ul>\n","categories":["计算机网络"],"tags":["计算机网络"]},{"title":"计算机网路系列（三）：tcp篇","url":"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/","content":"<blockquote>\n<p>计算机网路系列（三）：tcp篇</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"tcp是什么\"><a href=\"#tcp是什么\" class=\"headerlink\" title=\"tcp是什么\"></a>tcp是什么</h2><p>TCP 工作在传输层，是面向连接的、可靠的、基于字节流的传输层通信协议。这次有三个重要概念：</p>\n<ul>\n<li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息。</li>\n<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端;</li>\n<li><strong>字节流</strong>：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当 「前一个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</li>\n</ul>\n<h2 id=\"tcp格式\"><a href=\"#tcp格式\" class=\"headerlink\" title=\"tcp格式\"></a>tcp格式</h2><p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230319214213819.png\" alt=\"image-20230319214213819\"></p>\n<p>重要字段解析：</p>\n<ul>\n<li><code>源端口号</code>&#x2F;<code>目标端口号</code>：注意tcp协议只指定端口号，ip地址在ip层。</li>\n<li><code>序列号</code>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就 「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。</li>\n<li><code>确认应答号</code>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决不丢包的问题。</li>\n<li><code>窗口大小</code>：服务器向客户端返回的滑动窗口大小，表示服务器当前可以接受的数据量大小，用于流量控制。</li>\n<li><code>控制位</code>:<ul>\n<li><code>ACK</code>：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必 须设置为 1 。</li>\n<li><code>RST</code>：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</li>\n<li><code>SYN</code>：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>\n<li><code>FIN</code>：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的 主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</li>\n</ul>\n</li>\n</ul>\n<p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p>\n<ul>\n<li>源地址</li>\n<li>源端口</li>\n<li>目的地址</li>\n<li>目的端口</li>\n</ul>\n<p>源地址和目的地址的字段(32位)是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。<br>源端口和目的端口的字段(16位)是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p>\n<h3 id=\"MTU和MSS\"><a href=\"#MTU和MSS\" class=\"headerlink\" title=\"MTU和MSS\"></a>MTU和MSS</h3><p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230319214229334.png\" alt=\"image-20230319214229334\"></p>\n<p><code>MTU</code>：一个网络包的最大⻓度，以太网中一般为 1500 字节;<br><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大⻓度;</p>\n<p>当 IP 层有一个超过 MTU 大小的数据要发送，那么 IP 层就要进行分片，把数据分片成 若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行􏰁新组装后，再交给上一层 TCP 传输层。但是注意 <code>IP 层没有超时重传等纠错机制</code>，如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。</p>\n<p>为了只重传丢失的数据，我们会在 TCP 层把超过 MSS 大小的数据提前进行数据分片，确保最后在 IP 层组装分片长度不会大于 MTU，自然也就不用 IP 分片了。</p>\n<p>经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。</p>\n<h3 id=\"tcp和udp的区别\"><a href=\"#tcp和udp的区别\" class=\"headerlink\" title=\"tcp和udp的区别\"></a>tcp和udp的区别</h3><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。UDP 协议真的非常简，头部只有 8 个字节( 64 位)。<br><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230319214251423.png\" alt=\"image-20230319214251423\"></p>\n<ul>\n<li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li>\n<li>包⻓度：该字段保存了 UDP 首部的⻓度跟数据的⻓度之和。</li>\n<li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计。</li>\n</ul>\n<p>TCP 和 UDP 区别：</p>\n<ol>\n<li>连接<ul>\n<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>\n<li>UDP 是不需要连接，即刻传输数据。</li>\n</ul>\n</li>\n<li>服务对象<ul>\n<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>\n<li>UDP 支持一对一、一对多、多对多的交互通信</li>\n</ul>\n</li>\n<li>可靠性<ul>\n<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。 </li>\n<li>UDP 是尽最大努力交付，不保证可靠交付数据。</li>\n</ul>\n</li>\n<li>拥塞控制、流量控制<ul>\n<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>\n<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>\n</ul>\n</li>\n<li>首部开销<ul>\n<li>TCP 首部⻓度较⻓，会有一定的开销，首部在没有使用「选项」字段时是20个字节，如果使用了「选项」字段则会变⻓的。</li>\n<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>\n</ul>\n</li>\n<li>传输方式<ul>\n<li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li>\n<li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li>\n</ul>\n</li>\n<li>分片不同<ul>\n<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>\n<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，在实现可靠传输的 UDP 时则就需要重传所有的数据包，这样 传输效率非常差，所以通常 UDP 的报文应该小于 MTU。</li>\n</ul>\n</li>\n</ol>\n<p>tcp为什么是可靠的协议？</p>\n<ul>\n<li>三次握手和四次挥手保证连接是可靠的。</li>\n<li>基于序列号的确认应答机制，保证数据包的有序性。</li>\n<li>对于没有收到数据包，提供重传机制。</li>\n<li>为了协调发送方的发送包和接收方的接收包的速度，提供流量控制机制。</li>\n<li>为了维护网络环境的稳定，提供拥塞控制机制。</li>\n</ul>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606232951407.png\" alt=\"image-20230606232951407\"></p>\n<ul>\n<li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li>\n</ul>\n<p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233026823.png\" alt=\"image-20230606233026823\"></p>\n<ul>\n<li>客户端会随机初始化序号( <code>client_isn</code> )，将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志 位置为 <code>1</code> ，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不 包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li>\n</ul>\n<p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233048027.png\" alt=\"image-20230606233048027\"></p>\n<ul>\n<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号( <code>server_isn</code> )，将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code> , 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code> 。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li>\n</ul>\n<p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233101407.png\" alt=\"image-20230606233101407\"></p>\n<ul>\n<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位 置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客 户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li>\n<li>服务器收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>\n</ul>\n<p>一旦完成三次握手，双方都处于 ESTABLISHED 状态，此时连接就已建立完成，客户端和服务端就可以相互发送 数据了。<br>注意：第三次握手是可以携带数据的，前两次握手是不可以携带数据的。</p>\n<h3 id=\"为什么握手是三次，不是两次，四次？\"><a href=\"#为什么握手是三次，不是两次，四次？\" class=\"headerlink\" title=\"为什么握手是三次，不是两次，四次？\"></a>为什么握手是三次，不是两次，四次？</h3><p>三次握手的主要原因：<code>为了防止旧的重复连接初始化造成混乱</code>。<br><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233129431.png\" alt=\"image-20230606233129431\"></p>\n<p>假如网络拥堵，客户端发送的 <code>SYN</code> 报文，或者服务器返回的 <code>SYN+ACK</code> 报文都有可能发生拥堵或者丢失，客户端特定时间内收不到报文触发超时重传，会再次发送SYN报文。</p>\n<p>假如客户端已经发送了多个 <code>SYN</code> 报文，目前收到了一个 <code>SYN+ACK</code> 报文。使用三次握手的机制，客户端有足够的上下文来判断这个报文是否属于历史连接：</p>\n<ul>\n<li>如果是历史连接(序列号过期或超时)，则第三次握手发送的报文是 <code>RST</code> 报文，以此中止历史连接。</li>\n<li>如果不是历史连接，则第三次发送的报文是 <code>ACK</code> 报文，通信双方就会成功建立连接。</li>\n</ul>\n<p>为什么不是两次？<br>两次握手连接不能判断当前连接是否是历史连接。假如双方正常通信已经完成了，过了一段时间后客户端突然收到一个 <code>SYN+ACK</code> 旧报文。如果是两次握手的话这时候双方会建立起通信，但事实上双方通信已经完成了，这个报文属于脏数据，这次通信不应该被建立。</p>\n<p>为什么不是四次？<br>在第二次握手里面，服务器已经把<code>确认客户端序列号</code>和<code>发送自己的序列号</code>合并为一个步骤，所以相当于四次握手简化为三次握手了。<br>在第三次握手之后，就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</p>\n<h3 id=\"半连接队列和全连接队列\"><a href=\"#半连接队列和全连接队列\" class=\"headerlink\" title=\"半连接队列和全连接队列\"></a>半连接队列和全连接队列</h3><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>\n<ul>\n<li>半连接队列，也称 SYN 队列</li>\n<li>全连接队列，也称 accepet 队列</li>\n</ul>\n<p>服务端收到客户端发起的 SYN 请求后，<code>内核会把该连接存储到半连接队列</code>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<code>内核会把连接从半连接队列移除，然后创建新的完全的连 接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来</code>。</p>\n<p>不管是半连接队列还是全连接队列，都有最大⻓度限制，超过限制时，内核会直接丢弃，或返回 RST 包。</p>\n<p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233247296.png\" alt=\"image-20230606233247296\"></p>\n<h3 id=\"SYN攻击\"><a href=\"#SYN攻击\" class=\"headerlink\" title=\"SYN攻击\"></a>SYN攻击</h3><p>假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到 一个 SYN 报文，就进入 SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的 SYN 接收队列，使得服务器不能为正常用户服务。</p>\n<p>避免SYN攻击的策略：启用 <code>net.ipv4.tcp_syncookies</code> 参数。</p>\n<p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233310097.png\" alt=\"image-20230606233310097\"></p>\n<ul>\n<li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」</li>\n<li>计算出一个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端，</li>\n<li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。</li>\n<li>最后应用通过调用 accpet() socket 接口，从「 Accept 队列」取出的连接。</li>\n</ul>\n<h3 id=\"tcp的保活机制\"><a href=\"#tcp的保活机制\" class=\"headerlink\" title=\"tcp的保活机制\"></a>tcp的保活机制</h3><p>已经建立好的 TCP 连接，如果长时间没有数据交互，就会触发<code>保活机制</code>。这个机制的原理是这样的：</p>\n<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>\n<p>在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：</p>\n<ul>\n<li>tcp_keepalive_time&#x3D;7200：表示保活时间是 7200 秒(2小时)，也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</li>\n<li>tcp_keepalive_intvl&#x3D;75：表示每次检测间隔 75 秒;</li>\n<li>tcp_keepalive_probes&#x3D;9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li>\n</ul>\n<p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。</p>\n<h2 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h2><p>tcp连接断开通过四次挥手完成。注意和三次挥手不同，三次挥手只能由客户端发起，而四次挥手双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。<br><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233329185.png\" alt=\"image-20230606233329185\"></p>\n<ul>\n<li>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。</li>\n<li>服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。</li>\n<li>客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。 </li>\n<li>等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。</li>\n<li>客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态。</li>\n<li>服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭。</li>\n<li>客户端在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭。</li>\n</ul>\n<h3 id=\"为什么挥手是四次？\"><a href=\"#为什么挥手是四次？\" class=\"headerlink\" title=\"为什么挥手是四次？\"></a>为什么挥手是四次？</h3><ul>\n<li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>\n<li>服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</li>\n</ul>\n<p>所以每个方向都需要一个 FIN 和一个 ACK，而服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。</p>\n<h3 id=\"为什么需要TIME-WAIT？\"><a href=\"#为什么需要TIME-WAIT？\" class=\"headerlink\" title=\"为什么需要TIME_WAIT？\"></a>为什么需要TIME_WAIT？</h3><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。<br>需要 <code>TIME-WAIT</code> 状态的原因：</p>\n<ul>\n<li>防止旧的数据包被接收。如果 TIME-WAIT 过短或者没有，假如网络拥堵，关闭本次连接再重新打开连接之后，旧连接的数据包才到达，就会造成数据混乱。而足够长的 TIME-WAIT 足以<code>让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的</code>。<br><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233417173.png\" alt=\"image-20230606233417173\"></li>\n<li>防止数据包丢失导致被动关闭方不能正常关闭。四次挥手的最后一个 ACK 报文如果在网络中被丢失了，此时如果客户端 TIME-WAIT 过短或没有，则就直接进入了 CLOSED 状态了，那么服务端则会一直处在 LASE_ACK 状态。后面客户端和服务端就不能正常建立连接。而足够长的 TIME-WAIT 可以保证<code>服务端没有收到四次挥手的最后一个 ACK 报文时，则会重发 FIN 关闭连接报文并等待新的 ACK 报文，从而帮助双方都正确关闭</code>。<br><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233436577.png\" alt=\"image-20230606233436577\"></li>\n</ul>\n<h3 id=\"为什么TIME-WAIT的时间是2MSL？\"><a href=\"#为什么TIME-WAIT的时间是2MSL？\" class=\"headerlink\" title=\"为什么TIME_WAIT的时间是2MSL？\"></a>为什么TIME_WAIT的时间是2MSL？</h3><p>MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是<code>任何报文在网络上存在的最⻓时间，超过这个时 间报文将被丢弃</code>。在 Linux 系统里 2MSL 默认是 60 秒，那么一个 MSL 也就是 30 秒。Linux 系统停留在 TIME_WAIT 的时 间为固定的 60 秒。</p>\n<p>为什么TIME_WAIT的时间是2MSL？比较合理的解释是: 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。设置2MSL的时间，可以保证发送方发出去的数据都收到响应。</p>\n<p>2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端􏰁发的 FIN 报文，那么 2MSL 时间将重新计时。</p>\n<h3 id=\"TIME-WAIT过多的危害和优化\"><a href=\"#TIME-WAIT过多的危害和优化\" class=\"headerlink\" title=\"TIME_WAIT过多的危害和优化\"></a>TIME_WAIT过多的危害和优化</h3><p>发送方过多的 TIME-WAIT 状态的 TCP 连接会占用有限的端口资源，一般可以开启的端口为 <code>32768~61000</code>。如果发起连接一方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。</p>\n<p>优化 TIME_WAIT 的方法：</p>\n<ul>\n<li>复用处于 TIME_WAIT 的 socket 为新的连接所用。客户端在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。使用 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 参数。</li>\n</ul>\n<h2 id=\"重传机制\"><a href=\"#重传机制\" class=\"headerlink\" title=\"重传机制\"></a>重传机制</h2><p>TCP 针对数据包丢失的情况，会用<code>重传机制</code>解决。<br>常⻅的重传机制:</p>\n<ul>\n<li>超时重传</li>\n<li>快速重传</li>\n<li>选择重传</li>\n</ul>\n<h3 id=\"超时重传\"><a href=\"#超时重传\" class=\"headerlink\" title=\"超时重传\"></a>超时重传</h3><p>发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，这就是<code>超时重传</code>。</p>\n<p>超时重传有两个重要概念：</p>\n<ul>\n<li><code>RTT</code> (Round-Trip Time)：往返时间，也就是从数据发出去到接收响应所需的时间。</li>\n<li><code>RTO</code> (Retransmission Timeout)：超时重传时间。</li>\n</ul>\n<p>RTO 的值会影响重传机制的效率：</p>\n<ul>\n<li>当超时时间 RTO 较大时，􏰁发就慢，丢了老半天才重发，没有效率，性能差;</li>\n<li>当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>\n</ul>\n<p>理论上<code>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</code>。</p>\n<p>实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个动态变化的值。</p>\n<h3 id=\"快速重传\"><a href=\"#快速重传\" class=\"headerlink\" title=\"快速重传\"></a>快速重传</h3><p>如果丢失的数据包都等超时时间到了才进行重传，有时候未免太慢了。所以还有另外一套重传机制：<code>快速重传</code>。<br><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233456890.png\" alt=\"image-20230606233456890\"></p>\n<p>快速重传机制的核心思想就是：<code>发送方当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段</code>。</p>\n<h3 id=\"选择重传\"><a href=\"#选择重传\" class=\"headerlink\" title=\"选择重传\"></a>选择重传</h3><p>快速重传虽然解决了重传缓慢的问题，但是面临重传什么包的问题。例如收到三个同样的ACK，只能说明这个ACK对应的包丢失了，但是并不知道这三个ACK是哪些发出去的包返回的，也就是不知道服务器已经收到了哪些包。<code>在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道哪些数据包已经到达服务器了</code>，这就是<code>选择重传</code>。</p>\n<h4 id=\"SACK机制\"><a href=\"#SACK机制\" class=\"headerlink\" title=\"SACK机制\"></a>SACK机制</h4><p>选择重传基于 <code>SACK(Selective Acknowledgment)</code> 机制。SACK 机制需要双方支持。<br>在 TCP 头部「选项」字段里加一个 SACK 的东⻄，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。</p>\n<p><img src=\"evernotecid://1A77DB63-CEBF-4C5E-B653-7DD2D90B3827/appyinxiangcom/9108333/ENResource/p6912\" alt=\"f10efb2279852cda09e3f820464f8d3e.png\"></p>\n<p>例如发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</p>\n<h4 id=\"D-SACK机制\"><a href=\"#D-SACK机制\" class=\"headerlink\" title=\"D-SACK机制\"></a>D-SACK机制</h4><p>D-SACK，即重复SACK，对SACK机制进行扩展，使得扩展后的SACK可以告知发送方有哪些数据包自己重复接收了。引入D-SACK的目的是使TCP进行更好的流控：</p>\n<ul>\n<li>让发送方知道，是发送的包丢了，还是返回的ACK包丢了；</li>\n<li>网络上是否出现了包失序；</li>\n<li>数据包是否被网络上的路由器复制并转发了</li>\n<li>是不是自己的timeout太小了，导致重传</li>\n</ul>\n<p>D-SACK的规则如下：</p>\n<ol>\n<li>第一个段将包含重复收到的报文段的序号</li>\n<li>跟在D-SACK之后的SACK将按照SACK的方式工作</li>\n<li>如果有多个被重复接收的报文段，则D-SACK只包含其中第一个</li>\n</ol>\n<p>如何判断是普通SACK还是D-SACK？D-SACK使用了<code>SACK的第一个段</code>来作为判断标准：</p>\n<ol>\n<li>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK</li>\n<li>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK</li>\n</ol>\n<p>例如：<br>1、满足第一个判断标准<br><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233541767.png\" alt=\"image-20230606233541767\"><br>由于ACK 4000大于[3000,3500]，因此[4000, SACK&#x3D;3000-3500]是D-SACK。发送端首先向接收端发送了3000-3499,3500-3999报文，接收端都收到了，但是接收端返回的ACK 3500及4000都丢失，导致发送端重传了3000-3499报文。接收端收到发送端重新发送的3000-3499报文，通过[4000，SACK&#x3D;3000-3500]告知发送端，发送端就知道第一次的3000-3499报文接收端是收到了，由于当前ACK到了4000，那么4000之前的数据也都收到了。</p>\n<p>2、满足第二个判断标准<br><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233618052.png\" alt=\"image-20230606233618052\"></p>\n<p>由于第一个段[5000-5500]被第二个段[4500-5500]所覆盖，所以[4000, SACK&#x3D;5000-5500, 4500-5500]是D-SACK，而前面的[4000, SACK&#x3D;4500-5000]及[4000, SACK&#x3D;4500-5500]都是普通的SACK。含义是4000前的包收到，5000-5499包重复收到，4500-5500的包都收到，4000-4499的包丢失。</p>\n<h2 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h2><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。<br>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>\n<p>为了解决这种现象发生，<code>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量</code>，这就是所谓的<code>流量控制</code>。</p>\n<p>流量控制基于<code>滑动窗口</code>。</p>\n<h3 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h3><p>如果 TCP 每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了，再发送下一个，这种发送效率会很低。所以我们可以<code>定义一个窗口，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值</code>，这就是<code>滑动窗口</code>。</p>\n<p>TCP 头里有一个字段叫 <code>Window</code>，也就是<code>窗口大小</code>。 这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</p>\n<p>所以，<code>通常窗口的大小是由接收方的窗口大小来决定的</code>。发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>\n<h4 id=\"滑动窗口的实现\"><a href=\"#滑动窗口的实现\" class=\"headerlink\" title=\"滑动窗口的实现\"></a>滑动窗口的实现</h4><p>发送方和接收方分别有两个缓冲区，一个是 buffer，指的是内核缓冲区，另外一个是 application，指的是应用层的缓冲区。</p>\n<p>对于发送方来说，当要发送数据的时候，需要从 application 拷贝数据到 buffer，而对于接收方来说，当接收到数据的时候，会先缓存到 buffer，然后再由应用程序从 buffer 读取数据。</p>\n<h4 id=\"发送方的滑动窗口\"><a href=\"#发送方的滑动窗口\" class=\"headerlink\" title=\"发送方的滑动窗口\"></a>发送方的滑动窗口</h4><p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233646633.png\" alt=\"image-20230606233646633\"></p>\n<p>发送方的滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针(指特定的序列号)，一个是相对指针(需要做偏移)。</p>\n<ul>\n<li><code>SND.WND</code>：表示发送窗口的大小(大小是由接收方指定的);</li>\n<li><code>SND.UNA</code>：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li>\n<li><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个 字节。</li>\n<li>指向 #4 的第一个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND 大小的偏移􏰀，就可以指向 #4 的第一个字节了。</li>\n</ul>\n<p>那么可用窗口大小的计算：<code>可用窗口大小 = SND.WND -(SND.NXT - SND.UNA)</code></p>\n<h4 id=\"接收方的滑动窗口\"><a href=\"#接收方的滑动窗口\" class=\"headerlink\" title=\"接收方的滑动窗口\"></a>接收方的滑动窗口</h4><p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233702008.png\" alt=\"image-20230606233702008\"></p>\n<p>其中三个接收部分，使用两个指针进行划分：</p>\n<ul>\n<li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li>\n<li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字 节。</li>\n<li>指向 #4 的第一个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND 大小的偏移􏰀，就可以指向 #4 的第一个字节了。</li>\n</ul>\n<blockquote>\n<p>接收窗口和发送窗口的大小是相等的吗？</p>\n<p>并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。<br>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以 很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过 程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p>\n</blockquote>\n<h3 id=\"流量控制的实现\"><a href=\"#流量控制的实现\" class=\"headerlink\" title=\"流量控制的实现\"></a>流量控制的实现</h3><ul>\n<li>客户端是接收方，服务端是发送方</li>\n<li>假设接收窗口和发送窗口相同，都为 200，整个传输过程中都保持相同的窗口大小，不受外界影响<br><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233723745.png\" alt=\"image-20230606233723745\"></li>\n</ul>\n<ol>\n<li>客户端向服务端发送请求数据报文。这里要说明下，本次例子是把服务端作为发送方，所以没有画出服务端 的接收窗口。</li>\n<li>服务端收到请求报文后，发送确认报文和 80 字节的数据，于是可用窗口 Usable 减少为 120 字节，同时 SND.NXT 指针也向右偏移 80 字节后，指向 321，这意味着下次发送数据的时候，序列号是 321。</li>\n<li>客户端收到 80 字节数据后，于是接收窗口往右移动 80 字节， RCV.NXT 也就指向 321，这意味着客户端期 望的下一个报文的序列号是 321，接着发送确认报文给服务端。</li>\n<li>服务端再次发送了 120 字节数据，于是可用窗口耗尽为 0，服务端无再继续发送数据。</li>\n<li>客户端收到 120 字节的数据后，于是接收窗口往右移动 120 字节， RCV.NXT 也就指向 441，接着发送确认报文给服务端。</li>\n<li>服务端收到对 80 字节数据的确认报文后， SND.UNA 指针往右偏移后指向 321，于是可用窗口 Usable 增大到 80。</li>\n<li>服务端收到对 120 字节数据的确认报文后， SND.UNA 指针往右偏移后指向 441，于是可用窗口 Usable 增大到 200。</li>\n<li>服务端可以继续发送了，于是发送了 160 字节的数据后， SND.NXT 指向 601，于是可用窗口 Usable 减少到 40。</li>\n<li>客户端收到 160 字节后，接收窗口往右移动了 160 字节， RCV.NXT 也就是指向了 601，接着发送确认报文给服务端。</li>\n<li>服务端收到对 160 字节数据的确认报文后，发送窗口往右移动了 160 字节，于是 SND.UNA 指针偏移了 160 后指向 601，可用窗口 Usable 也就增大至了 200。</li>\n</ol>\n<h3 id=\"零窗口和窗口探测\"><a href=\"#零窗口和窗口探测\" class=\"headerlink\" title=\"零窗口和窗口探测\"></a>零窗口和窗口探测</h3><p>当接收方的 buffer 堆积了大量数据但 application 还没来得及读取，最终导致 buffer 满了，这时<code>接收方就会给发送方通报一个接收窗口为0的报文，表示不能再接收数据</code>，这就是<code>零窗口</code>。</p>\n<p>当接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那就会造成死锁：</p>\n<ul>\n<li>发送方一直等待非 0 窗口通知。</li>\n<li>接收方一直等待发送方发送数据。</li>\n</ul>\n<p>为了解决死锁问题，TCP <code>为每个连接设有一个持续定时器，只要发送方收到对方的零窗口通知，就启动持续计时器</code>。如果持续计时器超时，就会发送<code>窗口探测</code> (Window probe) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。<br><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233742771.png\" alt=\"image-20230606233742771\"></p>\n<ul>\n<li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器。</li>\n<li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li>\n</ul>\n<h3 id=\"延迟确认和Nagle算法\"><a href=\"#延迟确认和Nagle算法\" class=\"headerlink\" title=\"延迟确认和Nagle算法\"></a>延迟确认和Nagle算法</h3><p>虽然滑动窗口可以发送多个数据包提高了通信效率，但是如果频繁的进行 TCP 小包通信, 通信效率还是是非常低下的。为了提高网络传输效率；</p>\n<ul>\n<li>对于发送方来说可以使用 <code>Nagle算法</code></li>\n<li>对于接收方来说可以使用 <code>延迟确认</code>。</li>\n</ul>\n<h4 id=\"Nagle算法\"><a href=\"#Nagle算法\" class=\"headerlink\" title=\"Nagle算法\"></a>Nagle算法</h4><p>Nagle 算法的策略:</p>\n<ul>\n<li>没有已发送未确认报文时，立刻发送数据。</li>\n<li>存在未确认报文时，直到「收到所有未确认报文的ACK报文」或「数据⻓度达到 MSS 大小」时，再发送数据。</li>\n</ul>\n<p>只有满足上面的其中一条发送方才会发送数据，否则发送方一直在囤积数据。<br><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233801771.png\" alt=\"image-20230606233801771\"></p>\n<p>右侧启用了 Nagle 算法，它的发送数据的过程：</p>\n<ul>\n<li>一开始由于没有已发送未确认的报文，所以就立刻发了 H 字符。</li>\n<li>接着，在还没收到对 H 字符的确认报文时，发送方就一直在囤积数据，直到收到了确认报文后，此时没有已发送未确认的报文，于是就把囤积后的 ELL 字符一起发给了接收方。</li>\n<li>待收到对 ELL 字符的确认报文后，于是把最后一个 O 字符发送了出去。</li>\n</ul>\n<p>可以看出，Nagle 算法一定会有一个小报文，也就是在最开始的时候。</p>\n<p>Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互 性比较强的程序，则需要关闭 Nagle 算法。在 Socket 设置 <code>TCP_NODELAY</code> 选项来关闭这个算法。</p>\n<h4 id=\"延迟确认\"><a href=\"#延迟确认\" class=\"headerlink\" title=\"延迟确认\"></a>延迟确认</h4><p>如果接收方每次一收到数据就回复没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。为了提高效率就需要接收方<code>延迟确认</code>。</p>\n<p>TCP 延迟确认的策略：</p>\n<ul>\n<li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方。</li>\n<li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li>\n<li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK<br><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233828155.png\" alt=\"image-20230606233828155\"></li>\n</ul>\n<p>注意：Nagle算法和延迟确认不能同时开启。当 TCP 延迟确认 和 Nagle 算法混合使用时，会导致时耗增⻓。</p>\n<ul>\n<li>发送方先发出一个小报文，接收方收到后，由于延迟确认机制，自己又没有要发送的数据，只能干等着发送方的下一个报文到达;</li>\n<li>而发送方由于 Nagle 算法机制，在未收到第一个报文的确认前，是不会发送后续的数据。所以接收方只能等待最大时间 200 ms 后，才回 ACK 报文，发送方收到第一个报文的确认报文后，也才可以发送后续的数据。<br><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233844756.png\" alt=\"image-20230606233844756\"></li>\n</ul>\n<h2 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h2><p><code>流量控制是避免「发送方」的数据填满「接收方」的缓存</code>。但是在实际网络传输的过程中，网络传输还会受到网络环境的影响。在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环。所以就出现了拥塞控制，<code>拥塞控制的目的就是避免「发送方」的数据填满整个网络</code>。</p>\n<p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<code>拥塞窗口</code>」的概念。拥塞窗口 <code>cwnd</code> 是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。拥塞窗口 <code>cwnd</code> 变化的规则:</p>\n<ul>\n<li>只要网络中没有出现拥塞， cwnd 就会增大。</li>\n<li>但网络中出现了拥塞， cwnd 就减少。</li>\n</ul>\n<p>拥塞窗口 <code>cwnd</code> 、发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 的关系：<code>swnd = min(cwnd, rwnd)</code>，也就是说发送窗口是拥塞窗口和接收窗口中的最小值。但是 rwnd 是由对端确定的，网络环境对其没有影响，所以在考虑拥塞的时候我们一般不考虑 <code>rwnd</code> 的值。只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞。</p>\n<p>TCP拥塞控制算法有三个版本（Tahoe&#x2F;Reno&#x2F;Newreno），Tahoe是TCP的最早版本，包含三个算法：</p>\n<ul>\n<li><code>慢启动</code>（Slow Start）</li>\n<li><code>拥塞避免</code>（Congestion Avoidance）</li>\n<li><code>快速重传</code>（Fast Retransmit）</li>\n</ul>\n<p>Reno 包含 Tahoe 的三个算法，还多了一个<code>快速恢复</code>（Fast Recovery）算法。Reno是目前使用最广泛的算法。<br>NewReno 是基于 Reno 的改进版本，主要是改进了快速恢复算法。</p>\n<h3 id=\"慢启动\"><a href=\"#慢启动\" class=\"headerlink\" title=\"慢启动\"></a>慢启动</h3><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量。慢启动的规则是：<code>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1，直到 cwnd 大小达到 ssthresh</code> 。</p>\n<p>慢启动⻔限 <code>ssthresh</code> 是拥塞控制算法定义的一个阈值变量：</p>\n<ul>\n<li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用「慢启动算法」。</li>\n<li>当 <code>cwnd</code> &gt;&#x3D; <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li>\n</ul>\n<p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233904584.png\" alt=\"image-20230606233904584\"></p>\n<ul>\n<li>连接建立完成后，一开始初始化 cwnd &#x3D; 1 ，表示可以传一个 MSS 大小的数据。</li>\n<li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li>\n<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li>\n<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li>\n</ul>\n<p>由此可以看出<code>慢启动算法发包的个数是指数性的增⻓</code>。</p>\n<h3 id=\"拥塞避免\"><a href=\"#拥塞避免\" class=\"headerlink\" title=\"拥塞避免\"></a>拥塞避免</h3><p>当拥塞窗口 <code>cwnd</code> 「超过」慢启动⻔限 <code>ssthresh</code> 就会进入拥塞避免算法。一般来说 <code>ssthresh</code> 的大小是 65535 字节。</p>\n<p>拥塞避免算法的规则是：<code>每当收到一个 ACK 时，cwnd 增加 1/cwnd</code>。换而言之，<code>当收到 cwnd 数量的 ACK 时，cwnd 的大小就会加1</code>。</p>\n<p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233919277.png\" alt=\"image-20230606233919277\"></p>\n<ul>\n<li>因为 ssthresh 为 8，当 8 个 ACK 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9个 MSS 大小的数据，变成了线性增⻓。</li>\n</ul>\n<p><code>拥塞避免算法就是将原本慢启动算法的指数增⻓变成了线性增⻓</code>。</p>\n<h3 id=\"快速重传-1\"><a href=\"#快速重传-1\" class=\"headerlink\" title=\"快速重传\"></a>快速重传</h3><p>拥塞避免算法虽然把发送包的增长速度变成了线性增长，但毕竟还在增⻓阶段。就这么一直增⻓着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>\n<p>重传机制主要有两种：</p>\n<ul>\n<li>超时重传</li>\n<li>快速重传</li>\n</ul>\n<blockquote>\n<p>选择重传只是在快速重传的基础上进行改进，本质上还是快速重传。</p>\n</blockquote>\n<p>这两种重传机制里面 <code>ssthresh</code> 和 <code>cwnd</code> 的值的变化是不同的。</p>\n<h4 id=\"超时重传对应的拥塞控制算法\"><a href=\"#超时重传对应的拥塞控制算法\" class=\"headerlink\" title=\"超时重传对应的拥塞控制算法\"></a>超时重传对应的拥塞控制算法</h4><p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233936925.png\" alt=\"image-20230606233936925\"></p>\n<p><code>ssthresh</code> 和 <code>cwnd</code> 的变化：</p>\n<ul>\n<li><code>ssthresh = cwnd/2</code>。</li>\n<li><code>cwnd</code> 重置为 1。</li>\n<li>进入慢启动算法。</li>\n</ul>\n<p>慢启动会突然减少数据流，导致网络剧烈抖动，这种方式太激进了，并不推荐日常使用。所以Reno算法提出了更温和的快速重传+快速恢复算法。</p>\n<h4 id=\"快速重传对应的拥塞发生算法\"><a href=\"#快速重传对应的拥塞发生算法\" class=\"headerlink\" title=\"快速重传对应的拥塞发生算法\"></a>快速重传对应的拥塞发生算法</h4><p>快速重传算法下，当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。快速恢复算法是认为，你还能收到 3 个重复的 ACK 说明网络也不那么糟糕，没必要像超时重传那么激烈。<code>ssthresh</code> 和 <code>cwnd</code> 的变化：</p>\n<ul>\n<li><code>ssthresh = cwnd/2</code>。</li>\n<li><code>cwnd = ssthresh + 3</code>(3 的意思是确认有 3 个数据包被收到了)。</li>\n<li>进入快速恢复算法。</li>\n</ul>\n<h3 id=\"快速恢复\"><a href=\"#快速恢复\" class=\"headerlink\" title=\"快速恢复\"></a>快速恢复</h3><p>快速重传和快速恢复算法一般同时使用</p>\n<p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606233951694.png\" alt=\"image-20230606233951694\"></p>\n<ul>\n<li>重传丢失的数据包。</li>\n<li>如果再收到重复的 ACK，那么 cwnd 增加 1。</li>\n<li>如果收到新数据的 ACK 后，把 cwnd 设置为 ssthresh 的值，然后再次进入拥塞避免状态。原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的拥塞避免状态了。</li>\n</ul>\n<h3 id=\"拥塞避免算法过程\"><a href=\"#拥塞避免算法过程\" class=\"headerlink\" title=\"拥塞避免算法过程\"></a>拥塞避免算法过程</h3><p><img src=\"/2021/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9Atcp%E7%AF%87/image-20230606234004574.png\" alt=\"image-20230606234004574\"></p>\n<ol>\n<li>当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长。</li>\n<li>当cwnd超过慢启动门限(ssthresh)后，慢启动过程结束，进入拥塞避免算法。当窗口中所有的报文段都被确认时，cwnd的大小加1。cwnd的值就随着RTT开始线性增加。</li>\n<li>当检测到拥塞状态（判断拥塞的依据是TCP对每一个报文段都有一个定时器，称为重传定时器(RTO)，当RTO超时且还没有得到ack报文，或者连续三次收到相同的ack报文，就判断出现了拥塞情况。），进入快读重传阶段，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，进入快速恢复阶段。</li>\n<li>再收到重复的ACK时，拥塞窗口增加1。当收到新的数据包的ACK时，把cwnd设置为第3步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。</li>\n</ol>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h3 id=\"解决time-wait过多的问题\"><a href=\"#解决time-wait过多的问题\" class=\"headerlink\" title=\"解决time_wait过多的问题\"></a>解决time_wait过多的问题</h3><p>解决方案很简单，通过修改&#x2F;etc&#x2F;sysctl.conf文件，服务器能够快速回收和重用那些TIME_WAIT的资源</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭</span><br><span class=\"line\">net.ipv4.tcp_tw_reuse = 1</span><br><span class=\"line\"></span><br><span class=\"line\">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭    </span><br><span class=\"line\">net.ipv4.tcp_tw_recycle = 1</span><br><span class=\"line\"></span><br><span class=\"line\">#一般需要配合上面两个参数使用</span><br><span class=\"line\">net.ipv4.tcp_timestamps = 1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解决CLOSE-WAIT过多的问题\"><a href=\"#解决CLOSE-WAIT过多的问题\" class=\"headerlink\" title=\"解决CLOSE_WAIT过多的问题\"></a>解决CLOSE_WAIT过多的问题</h3><p>CLOSE_WAIT很多，表示说要么是你的应用程序写的有问题，没有合适的关闭socket；要么是说，你的服务器CPU处理不过来（CPU太忙）或者你的应用程序一直睡眠到其它地方(锁，或者文件I&#x2F;O等等)，你的应用程序获得不到合适的调度时间，造成你的程序没法真正的执行close操作。</p>\n<h3 id=\"泛洪攻击\"><a href=\"#泛洪攻击\" class=\"headerlink\" title=\"泛洪攻击\"></a>泛洪攻击</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</span><br><span class=\"line\">net.ipv4.tcp_max_syn_backlog = 8192 </span><br><span class=\"line\"></span><br><span class=\"line\">#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭    </span><br><span class=\"line\">net.ipv4.tcp_syncookies = 1</span><br></pre></td></tr></table></figure>\n","categories":["计算机网络"],"tags":["计算机网络"]},{"title":"计算机网络系列（四）：ip篇","url":"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/","content":"<blockquote>\n<p>计算机网络系列（四）：ip篇</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h2><h3 id=\"IP基本概念\"><a href=\"#IP基本概念\" class=\"headerlink\" title=\"IP基本概念\"></a>IP基本概念</h3><p>IP 在 TCP&#x2F;IP 参考模型中处于第三层，也就是网络层。网络层的主要作用是：<code>实现主机与主机之间的通信，也叫点对点(end to end)通信</code>。</p>\n<p>那么网络层与数据链路层有什么关系呢？</p>\n<p><code>MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输</code>。</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203325252.png\" alt=\"image-20230327203325252\"></p>\n<p>MAC只负责两个直连设备间的数据传输，当数据包在两台直连的设备上从一端传输到另外一端时，这时候源MAC地址就会被赋值当前的目标MAC地址（因为数据包已经传输到当前目标MAC地址了），而目标MAC地址就会被就会被赋值下一台直连设备的MAC地址。</p>\n<p>所以数据包在两个远程主机间传输的过程中，<code>源IP地址和目标IP地址在传输过程中是不会变化的，只有源 MAC 地址和目标 MAC 一直在变化</code>。</p>\n<p>IP 地址(IPv4 地址)由 32 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。而人类为了方便记忆采用了点分十进制的标记方式，也就是将 32 位 IP 地址以每 8 位为组，共分为 4 组，每组以 「 . 」隔开，再将每组转换成十进制。</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203340895.png\" alt=\"image-20230327203340895\"></p>\n<h3 id=\"IP协议格式\"><a href=\"#IP协议格式\" class=\"headerlink\" title=\"IP协议格式\"></a>IP协议格式</h3><p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203354098.png\" alt=\"image-20230327203354098\"></p>\n<h3 id=\"IP地址的分类\"><a href=\"#IP地址的分类\" class=\"headerlink\" title=\"IP地址的分类\"></a>IP地址的分类</h3><p>最初设计互联网络时，为了便于寻址以及层次化构造网络，IP地址由 <code>网络号</code> 和 <code>主机号</code> 两部分组成。同一个物理网络上的所有主机都使用同一个网络ID。</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203412330.png\" alt=\"image-20230327203412330\"></p>\n<blockquote>\n<p>为什么要分离网络号和主机号？</p>\n</blockquote>\n<blockquote>\n</blockquote>\n<blockquote>\n<p>因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。</p>\n</blockquote>\n<blockquote>\n<p>路由器寻址工作中，也就是通过这样的方式来找到对应的网络号的，进而把数据包转发给对应的网络内。</p>\n</blockquote>\n<p>IP地址根据 <code>网络号的不同</code> 分为5种类型：<code>A类地址</code>、<code>B类地址</code>、<code>C类地址</code>、<code>D类地址</code>和<code>E类地址</code>。A类保留给政府机构，B类分配给中等规模的公司，C类分配给任何需要的人，D类用于组播，E类用于实验，各类可容纳的地址数目不同。</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203457585.png\" alt=\"image-20230327203457585\"></p>\n<ul>\n<li><p>A类IP地址：由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是 <code>0</code>。前八位取值范围是 <code>[1,126]</code>，注意没有包括0和127。</p>\n</li>\n<li><p>B类IP地址：由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是 <code>10</code>。前八位取值范围是 <code>[128,191]</code></p>\n</li>\n<li><p>C类IP地址：由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是 <code>110</code>。前八位取值范围是 <code>[192,223]</code></p>\n</li>\n<li><p>D类IP地址：不分网络地址和主机地址，网络地址的最高位必须是 <code>1110</code>，用于多播。由于广播无法穿透路由，若想给其他网段发送同样的包，就可以使用可以穿透路由的多播。多播用于将包发送给特定组内的所有主机。</p>\n</li>\n<li><p>E类IP地址：不分网络地址和主机地址，网络地址的最高位必须是 <code>11110</code>，用于保留实验。</p>\n</li>\n</ul>\n<p>各类IP地址对应的相关内容如下：</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>前缀码</th>\n<th>最高位范围</th>\n<th>网络地址位数</th>\n<th>主机地址位数</th>\n<th>主机开始地址</th>\n<th>主机结束地址</th>\n<th>对应CIDR修饰</th>\n<th>网络数</th>\n<th>每个网络的主机数</th>\n<th>默认子网掩码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>A类地址</td>\n<td>0</td>\n<td>[1,126]</td>\n<td>8</td>\n<td>24</td>\n<td>1.0.0.1</td>\n<td>126.255.255.254</td>\n<td>&#x2F;8</td>\n<td>126</td>\n<td>16,777,214</td>\n<td>255.0.0.0</td>\n</tr>\n<tr>\n<td>B类地址</td>\n<td>10</td>\n<td>[128,191]</td>\n<td>16</td>\n<td>16</td>\n<td>128.0.0.1</td>\n<td>191.255.255.254</td>\n<td>&#x2F;16</td>\n<td>16,384</td>\n<td>65,534</td>\n<td>255.255.0.0</td>\n</tr>\n<tr>\n<td>C类地址</td>\n<td>110</td>\n<td>[192,223]</td>\n<td>24</td>\n<td>8</td>\n<td>192.0.0.1</td>\n<td>223.255.255.254</td>\n<td>&#x2F;24</td>\n<td>2,097,152</td>\n<td>254</td>\n<td>255.255.255.0</td>\n</tr>\n<tr>\n<td>D类地址（群播）</td>\n<td>1110</td>\n<td>[224,239]</td>\n<td>未定义</td>\n<td>未定义</td>\n<td>224.0.0.1</td>\n<td>239.255.255.254</td>\n<td>&#x2F;4</td>\n<td>未定义</td>\n<td>未定义</td>\n<td>未定义</td>\n</tr>\n<tr>\n<td>E类地址 （保留）</td>\n<td>11110</td>\n<td>[240,255]</td>\n<td>未定义</td>\n<td>未定义</td>\n<td>240.0.0.1</td>\n<td>255.255.255.254</td>\n<td>&#x2F;4</td>\n<td>未定义</td>\n<td>未定义</td>\n<td>未定义</td>\n</tr>\n</tbody></table>\n<h4 id=\"私有地址\"><a href=\"#私有地址\" class=\"headerlink\" title=\"私有地址\"></a>私有地址</h4><p>ABC三种类型的网络有一部保留地址用来作为私有地址或内部地址，这些地址不能用于外网，因为他们不可路由。</p>\n<ul>\n<li><p>A类私有地址：<code>10.0.0.0</code> ～ <code>10.255.255.255</code></p>\n</li>\n<li><p>B类私有地址：<code>172.16.0.0</code> ～ <code>172.31.255.255</code></p>\n</li>\n<li><p>C类私有地址：<code>192.168.0.0</code> ～ <code>192.168.255.255</code></p>\n</li>\n</ul>\n<h4 id=\"本机地址\"><a href=\"#本机地址\" class=\"headerlink\" title=\"本机地址\"></a>本机地址</h4><p>IP地址 <code>0.0.0.0</code> 表示本机宿主机地址。</p>\n<h4 id=\"回环地址\"><a href=\"#回环地址\" class=\"headerlink\" title=\"回环地址\"></a>回环地址</h4><p>127开头的地址，<code>127.0.0.1</code> ～ <code>127.255.255.255</code> 属于网络测试地址，也称为 loop-back 回环地址。</p>\n<p>环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。计算机使用一个特殊的 IP 地址 <code>127.0.0.1</code> 作为环回地址，与该地址具有相同意义的是一个叫做 <code>localhost</code> 的主机名。使用这个 IP 或主机名时，数据包不会流向网络。</p>\n<h4 id=\"网络地址\"><a href=\"#网络地址\" class=\"headerlink\" title=\"网络地址\"></a>网络地址</h4><p><code>网络地址</code>是指主机号全为 0，即网段下面第一个地址，指定识别某个网络。</p>\n<h4 id=\"广播地址\"><a href=\"#广播地址\" class=\"headerlink\" title=\"广播地址\"></a>广播地址</h4><p><code>广播地址</code>是指主机号全为1的地址，即网段下面的最后一个地址，用于同一个链路中相互连接的主机之间发送数据包。发向该地址的数据包会广播到网段内的所有设备。</p>\n<blockquote>\n<p>计算分类地址最大主机个数</p>\n</blockquote>\n<blockquote>\n<p>因为每个网段下的第一个地址（网络地址）和最后一个地址（广播地址）不能用于主机地址分配，所以我们得到关系：</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>最大可容纳主机地址数 &#x3D; 2 ^ 主机位数</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>可用的主机地址数 &#x3D; 最大可容纳主机地址数 - 2</li>\n</ul>\n</blockquote>\n<h4 id=\"无分类地址-CIDR\"><a href=\"#无分类地址-CIDR\" class=\"headerlink\" title=\"无分类地址 CIDR\"></a>无分类地址 CIDR</h4><p>A、B、C类有个尴尬处境，就是不能很好的与现实网络匹配。C 类地址能包含的最大主机数量实在太少了，只有 254 个，而 B 类地址能包含的最大主机数量又太多了，一般中小企业用不到6万多台主机。所以后面提出了无分类地址的方案，即 <code>CIDR</code> 。</p>\n<p>CIDR 不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。表示形式 <code>a.b.c.d/x</code> ，其中 <code>/x</code> 表示前 x 位属于网络号，x 的范围是 <code>0 ~ 32</code> ，这就使得 IP 地址更加具有灵活性。</p>\n<p>比如 10.100.122.2&#x2F;24，这种地址表示形式就是 CIDR，&#x2F;24 表示前 24 位是网络号，剩余的 8 位是主机号。</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203634006.png\" alt=\"image-20230327203634006\"></p>\n<h3 id=\"子网划分\"><a href=\"#子网划分\" class=\"headerlink\" title=\"子网划分\"></a>子网划分</h3><h4 id=\"网段和子网\"><a href=\"#网段和子网\" class=\"headerlink\" title=\"网段和子网\"></a>网段和子网</h4><p>比如某企业被分到一个B类网络号172.10.0.0，这个企业可以使用该网络号分配6万多台主机，这6万多台主机就处于同一个<code>网段</code>。</p>\n<p>但该公司还希望在网段内不划分出多个不同的小网络，不同的小网络分给不同的部门使用，这就需要用到<code>子网划分</code>的功能。</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203716625.png\" alt=\"image-20230327203716625\"></p>\n<p>子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址。</p>\n<ul>\n<li><p>未做子网划分的 ip 地址：网络地址+主机地址</p>\n</li>\n<li><p>做子网划分后的 ip 地址：网络地址+(子网网络地址+子网主机地址)</p>\n</li>\n</ul>\n<p>子网划分需要用到<code>子网掩码</code>。</p>\n<h4 id=\"子网掩码\"><a href=\"#子网掩码\" class=\"headerlink\" title=\"子网掩码\"></a>子网掩码</h4><p><code>子网掩码</code>是连续的1和连续的0组成的32位地址。子网掩码不能单独存在，它必须结合IP地址一起使用。例如</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203728256.png\" alt=\"image-20230327203728256\"></p>\n<p>在CIDR表示法里面，以上地址也可以表示为 <code>x.x.x.x/24</code>，<code>/24</code> 表示掩码地址左边是24个1。</p>\n<p>IP默认分配的子网掩码有：</p>\n<ul>\n<li><p>A类的默认子网掩码：<code>255.0.0.0</code> 或者 <code>/8</code></p>\n</li>\n<li><p>B类的默认子网掩码：<code>255.255.0.0</code> 或者 <code>/16</code></p>\n</li>\n<li><p>C类的默认子网掩码：<code>255.255.255.0</code> 或者 <code>/24</code></p>\n</li>\n</ul>\n<p>掩码的意思就是掩盖掉主机号，剩余的就是网络号。所以子网掩码的作用是<code>将某个IP地址划分成网络地址和主机地址两部分</code>。</p>\n<p>如果给定网络地址，子网掩码划分出来的网络地址位数比给定的网络地址要多，多出来的几个位就属于子网网络地址，所以子网掩码的另外一个作用是<code>将某个IP地址划分成网络地址、子网网络地址和主机地址三部分</code>。</p>\n<h4 id=\"利用子网掩码计算网络地址\"><a href=\"#利用子网掩码计算网络地址\" class=\"headerlink\" title=\"利用子网掩码计算网络地址\"></a>利用子网掩码计算网络地址</h4><p><code>将子网掩码和 IP 地址按位计算 AND，就可得到网络地址</code>。</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203742268.png\" alt=\"image-20230327203742268\"></p>\n<h4 id=\"利用子网掩码划分子网\"><a href=\"#利用子网掩码划分子网\" class=\"headerlink\" title=\"利用子网掩码划分子网\"></a>利用子网掩码划分子网</h4><p>假设对 C 类地址进行子网划分，网络地址 192.168.1.0，使用子网掩码 255.255.255.192 对其进行子网划分。</p>\n<p>C 类地址中前 24 位是网络号，最后 8 位是主机号，子网掩码相当于 &#x2F;26。<code>根据子网掩码可知从 8 位主机号中借用 2 位作为子网号</code>。</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203757212.png\" alt=\"image-20230327203757212\"></p>\n<p>由于子网网络地址被划分成 2 位，那么子网地址就有 4 个，分别是 00、01、10、11。所以被划分为四个子网：</p>\n<ul>\n<li><p>192.168.1.<code>00</code>000000 ～ 192.168.1.<code>00</code>111111</p>\n</li>\n<li><p>192.168.1.<code>01</code>000000 ～ 192.168.1.<code>01</code>111111</p>\n</li>\n<li><p>192.168.1.<code>10</code>000000 ～ 192.168.1.<code>10</code>111111</p>\n</li>\n<li><p>192.168.1.<code>11</code>000000 ～ 192.168.1.<code>11</code>111111</p>\n</li>\n</ul>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203809601.png\" alt=\"image-20230327203809601\"></p>\n<h2 id=\"IP相关技术\"><a href=\"#IP相关技术\" class=\"headerlink\" title=\"IP相关技术\"></a>IP相关技术</h2><h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><p>我们在上网的时候，通常使用的方式是域名，而不是 IP 地址，因为域名方便人类记忆。但我们的 IP 协议里面只能用 IP，所以需要将域名转成 IP 地址，实现这个过程的技术就是 <code>DNS</code>。<code>DNS 的作用是将域名网址自动转换为具体的 IP 地址</code>。</p>\n<p>DNS的解析层级是一个树状结构</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203821252.png\" alt=\"image-20230327203821252\"></p>\n<ul>\n<li><p>根 DNS 服务器</p>\n</li>\n<li><p>顶级域 DNS 服务器(com)</p>\n</li>\n<li><p>权威 DNS 服务器(server.com)</p>\n</li>\n</ul>\n<p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。这样一来，任何 DNS 服务器就都可以找到并访问 根域 DNS 服务器了。</p>\n<p>因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到 位于下层的某台目标 DNS 服务器。</p>\n<p>DNS 的解析过程：</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203836289.png\" alt=\"image-20230327203836289\"></p>\n<h3 id=\"ARP\"><a href=\"#ARP\" class=\"headerlink\" title=\"ARP\"></a>ARP</h3><p>在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就需要确定 IP 数据包的下一跳 MAC 地址。但是我们主机的「路由表」中只能找到下一跳的 IP 地址，所以我们需要把下一跳的 IP 地址转换成下一跳的 MAC 地址。这就需要用到 ARP 协议。</p>\n<p><code>ARP</code> 协议的全称是 Address Resolution Protocol(地址解析协议)，<code>ARP 协议的作用是实现从 IP 地址到 MAC 地址的映射</code>。ARP 协议在 IPv4 中极其重要。</p>\n<h4 id=\"ARP工作原理\"><a href=\"#ARP工作原理\" class=\"headerlink\" title=\"ARP工作原理\"></a>ARP工作原理</h4><p>ARP 是借助 ARP 请求与 ARP 响应两种类型的包确定 MAC 地址的：</p>\n<ul>\n<li>主机会通过广播向同一链路的所有主机发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li>\n</ul>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203849351.png\" alt=\"image-20230327203849351\"></p>\n<ul>\n<li>当同一链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。</li>\n</ul>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203901656.png\" alt=\"image-20230327203901656\"></p>\n<ul>\n<li>如果目标主机不在同一个链路上，那么会查找下一跳路由器的 MAC 地址。</li>\n</ul>\n<h4 id=\"ARP缓存\"><a href=\"#ARP缓存\" class=\"headerlink\" title=\"ARP缓存\"></a>ARP缓存</h4><p>如果每次查找 MAC 地址都需要经过广播 -&gt; 封装 ARP 响应 -&gt; 返回给主机这一系列流程，网络传输的效率会很低。这时候就需要 <code>ARP缓存</code>。</p>\n<p>每个主机和路由器上都有一个 <code>ARP 缓存</code>(或表)。这个缓存维护着每个 IP 到 MAC 地址的映射关系。通过把第一次 ARP 获取到的 MAC 地址作为 IP 对 MAC 的映射关系到一个 ARP 缓存表中，下一次再向这个地址发送数据报时就不再需要重新发送 ARP 请求了，而是直接使用这个缓存表中的 MAC 地址进行数据报的发送。每发送一次 ARP 请求，缓存表中对应的映射关系都会被清除。</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203919505.png\" alt=\"image-20230327203919505\"></p>\n<p>通过 ARP 缓存，降低了网络流量的使用，在一定程度上防止了 ARP 的大量广播。不过 MAC 地址的缓存有一定期限，超过这个期限后，缓存的内容会被清除。</p>\n<h4 id=\"RARP\"><a href=\"#RARP\" class=\"headerlink\" title=\"RARP\"></a>RARP</h4><p>与 ARP 相对的，<code>RARP(Reverse Address Resolution Protocol) 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议</code>，将打印机服务器等小型嵌入式设备接入网络时会使用到。</p>\n<p>通常这需要架设一台 RARP 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接 入到网络，接着:</p>\n<ul>\n<li><p>该设备会发送一条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</p>\n</li>\n<li><p>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。</p>\n</li>\n</ul>\n<h3 id=\"DHCP\"><a href=\"#DHCP\" class=\"headerlink\" title=\"DHCP\"></a>DHCP</h3><p>当我们的设备连到局域网上的时候，需要被分配一个 ip 地址，如果每次都手动分配静态地址，难以保证这个 ip 地址不会和局域网内的其他设备冲突，所以我们需要一种动态管理 ip 地址的技术，而且必须要有一个服务器来集中管理，这就是 <code>DHCP</code>。<code>DHCP 的作用是在子网内对地址进行统一规划，分配和管理，以及租约，续租的动态管理</code>。</p>\n<blockquote>\n<p>上面我们提到 RARP 技术也可以将 MAC 地址转换成 IP 地址，那么 RARP 和 DHCP 的区别是什么？</p>\n</blockquote>\n<blockquote>\n</blockquote>\n<blockquote>\n<p>RARP只能实现简单的从MAC地址到IP地址的查询工作，RARP server上的MAC地址和IP地址是必须事先静态配置好的。但DHCP却可以实现除静态分配外的动态IP地址分配以及IP地址租期管理等等相对复杂的功能。</p>\n</blockquote>\n<blockquote>\n<p>RARP是在数据链路层实现的，无法穿透子网，DHCP基于UDP协议，在应用层实现的，可以穿透子网。</p>\n</blockquote>\n<h4 id=\"DHCP-工作原理\"><a href=\"#DHCP-工作原理\" class=\"headerlink\" title=\"DHCP 工作原理\"></a>DHCP 工作原理</h4><p>使用 DHCP 协议需要先搭建一个 DHCP 服务器。我们的服务器通常内置 DHCP 服务器。</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327203950762.png\" alt=\"image-20230327203950762\"></p>\n<ul>\n<li><p>客户端首先发起 <code>DHCP 发现报文(DHCP DISCOVER)</code> 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP 广播通信，其使用的广播目的地址是 255.255.255.255(端口 67) 并且使用 0.0.0.0(端口 68) 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后 将帧广播到所有的网络中设备。</p>\n</li>\n<li><p>DHCP 服务器收到 DHCP 发现报文时，用 <code>DHCP 提供报文(DHCP OFFER)</code> 向客户端做出响应。该报文仍 然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、 DNS 服务器以及 IP 地址租用期。</p>\n</li>\n<li><p>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 <code>DHCP 请求报文</code>(DHCP REQUEST进行响应，回显配置的参数。</p>\n</li>\n<li><p>最后，服务端用 <code>DHCP ACK 报文</code>对 DHCP 请求报文进行响应，应答所要求的参数。</p>\n</li>\n</ul>\n<p>一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。 如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文:</p>\n<ul>\n<li><p>服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延⻓租期。</p>\n</li>\n<li><p>服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。</p>\n</li>\n</ul>\n<p>可以发现，DHCP 交互中，全程都是使用 UDP 广播通信。</p>\n<h4 id=\"DHCP-中继代理\"><a href=\"#DHCP-中继代理\" class=\"headerlink\" title=\"DHCP 中继代理\"></a>DHCP 中继代理</h4><p>那如果 DHCP 服务器和客户端不是在同一个局域网内，路由器又不会转发广播包，那不是每个网络 都要配一个 DHCP 服务器？</p>\n<p>这种情况就需要 <code>DHCP 中继代理</code>。有了 DHCP 中继代理以后，对不同网段的 IP 地址分配也 可以由一个 DHCP 服务器统一进行管理。</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327204005303.png\" alt=\"image-20230327204005303\"></p>\n<ul>\n<li><p>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以单播的形式发给 DHCP 服务器。</p>\n</li>\n<li><p>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包广播给 DHCP 客户端 。</p>\n</li>\n</ul>\n<h3 id=\"NAT\"><a href=\"#NAT\" class=\"headerlink\" title=\"NAT\"></a>NAT</h3><p>我们的设备在局域网内使用的时候，被分配的地址都是私有 IP 地址。当我们的设备需要和局域网外的其他主机进行通信的时候，需要<code>把私有 IP 地址转换成公有 IP 地址</code>，这就是 <code>NAT</code> 技术。</p>\n<p>如果私有 IP 地址和公有 IP 地址的转换是一对一对应关系，我们现有的 ipv4 地址数量远远不能满足世界上的所有设备。由于绝大多数的网络应用都是使用传输层协议 TCP 或 UDP 来传输数据的，我们可以<code>把私有 IP 地址 + 端口号一起进行转换公有 IP 地址 + 端口号</code>，这就是 <code>NAPT</code> 技术。</p>\n<h4 id=\"NAT-x2F-NAPT工作原理\"><a href=\"#NAT-x2F-NAPT工作原理\" class=\"headerlink\" title=\"NAT&#x2F;NAPT工作原理\"></a>NAT&#x2F;NAPT工作原理</h4><p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327204019868.png\" alt=\"image-20230327204019868\"></p>\n<p>两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器 183.232.231.172 进行通信，并且这两个客户端的 本地端口都是 1025。转换之后两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。</p>\n<p>最后会生成一个 <code>NAPT 路由器的转换表</code>，就可以正确地转换地址跟端口的组合，令客户端 A、B 能同时与服务器之间进行通信。这种转换表在 NAT 路由器上自动生成。例如，在 TCP 的情况下，建立 TCP 连接首次握手时的 SYN 包一经发出，就会生成这个表。而后又随着收到关闭连接时发出 FIN 包的确认应答从表中被删除。</p>\n<h4 id=\"NAT穿透\"><a href=\"#NAT穿透\" class=\"headerlink\" title=\"NAT穿透\"></a>NAT穿透</h4><p>由于 NAT&#x2F;NAPT 都依赖于自己的转换表，因此会有以下的问题:</p>\n<ul>\n<li><p>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</p>\n</li>\n<li><p>转换表的生成与转换操作都会产生性能开销。</p>\n</li>\n<li><p>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</p>\n</li>\n</ul>\n<p>这些问题的根源是转换表。如果我们有一种技术让局域网内的设备不依赖转换表就可以把私有地址转换成公有地址，就可以解决这些问题，这就是<code>NAT穿透</code>技术。</p>\n<p>在NAT穿透技术下，客户端可以主动发现自己位于 NAT 设备之后，并且会主动获得 NAT 设 备的公有 IP，并为自己建立端口映射条目，然后用这个条目对外通信， 就不需要 NAT 设备来进行转换了。</p>\n<h3 id=\"ICMP\"><a href=\"#ICMP\" class=\"headerlink\" title=\"ICMP\"></a>ICMP</h3><p>网络包在复杂的网络传输环境里，常常会遇到各种问题。当遇到问题的时候，我们需要获得反馈报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。这就需要 <code>ICMP</code> 协议。</p>\n<p><code>ICMP</code> 全称是 Internet Control Message Protocol，也就是互联网控制报文协议。<code>ICMP 主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等</code>。例如在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知。</p>\n<h4 id=\"ICMP工作原理\"><a href=\"#ICMP工作原理\" class=\"headerlink\" title=\"ICMP工作原理\"></a>ICMP工作原理</h4><p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327204035300.png\" alt=\"image-20230327204035300\"></p>\n<p>如上图例子，主机 A 向主机 B 发送了数据包，由于某种原因，途中的路由器 2 未能发现主机 B 的存在， 这时，路由器 2 就会向主机 A 发送一个 ICMP 目标不可达数据包，说明发往主机 B 的包未能成功。</p>\n<h4 id=\"ICMP协议格式\"><a href=\"#ICMP协议格式\" class=\"headerlink\" title=\"ICMP协议格式\"></a>ICMP协议格式</h4><p>从 ICMP 的报文格式来说，ICMP 是 IP 的上层协议。但是 ICMP 分担了 IP 的一部分功能，一般我们<code>把 ICMP 当作和 IP 协议同层的网络层协议</code>。</p>\n<p>ICMP 报文被封装成 IP 数据包。<code>在 IP 数据包中如果协议类型字段的值是 1 的话，就表示 IP 数据是 ICMP 报文</code>。IP 数据包就是靠这个协议类型字段来区分不同的数据包的。</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327204049770.png\" alt=\"image-20230327204049770\"></p>\n<p>ICMP 包头的类型字段，大致可以分为两大类：</p>\n<ul>\n<li><p>一类是用于诊断的查询消息，也就是「查询报文类型」</p>\n</li>\n<li><p>另一类是通知出错原因的错误消息，也就是「差错报文类型」</p>\n</li>\n</ul>\n<h5 id=\"查询报文类型\"><a href=\"#查询报文类型\" class=\"headerlink\" title=\"查询报文类型\"></a>查询报文类型</h5><p>回送消息用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息， ping 命令 就是利用这个消息实现的。</p>\n<ul>\n<li><p>回应请求消息，类型为 <code>0</code>。</p>\n</li>\n<li><p>回应应答消息，类型为 <code>8</code>。</p>\n</li>\n</ul>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327204104877.png\" alt=\"image-20230327204104877\"></p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327204128487.png\" alt=\"image-20230327204128487\"></p>\n<p>相比原生的 ICMP，这里多了两个字段：</p>\n<ul>\n<li><p><code>标识符</code>：用以区分是哪个应用程序发 ICMP 包，比如用进程 PID 作为标识符;</p>\n</li>\n<li><p><code>序号</code>：序列号从 0 开始，每发送一次新的回送请求就会加 1，可以用来确认网络包是否有丢失。</p>\n</li>\n</ul>\n<p>在选项数据中， ping 还会存放发送请求的时间值，来计算往返时间，说明路程的⻓短。</p>\n<h5 id=\"差错报文类型\"><a href=\"#差错报文类型\" class=\"headerlink\" title=\"差错报文类型\"></a>差错报文类型</h5><p>常见的差错报文类型有：</p>\n<ul>\n<li><p>目标不可达消息，类型为 <code>3</code></p>\n</li>\n<li><p>原点抑制消息，类型为 <code>4</code></p>\n</li>\n<li><p>重定向消息，类型为 <code>5</code></p>\n</li>\n<li><p>超时消息，类型为 <code>11</code></p>\n</li>\n</ul>\n<p><strong>目标不可达消息</strong></p>\n<p>IP 路由器无法将 IP 数据包发送给目标地址时，会给发送端主机返回一个目标不可达的 ICMP 消息，并在这个消息 中显示不可达的具体原因，原因记录在 ICMP 包头的代码字段。代码类型：</p>\n<ul>\n<li><p>网络不可达代码为 0</p>\n</li>\n<li><p>主机不可达代码为 1</p>\n</li>\n<li><p>协议不可达代码为 2</p>\n</li>\n<li><p>端口不可达代码为 3</p>\n</li>\n<li><p>需要进行分片但设置了不分片位代码为 4</p>\n</li>\n</ul>\n<p><strong>原点抑制消息</strong></p>\n<p>在使用低速广域线路的情况下，连接 WAN 的路由器可能会遇到网络拥堵的问题。当路由器向低速线路发送数据时，其发送队列的缓存变为零而无法发送出去时，可以向 IP 包的源地址发送一个 ICMP 原点抑制消息。收到这个消息的主机借此了解在整个线路的某一处发生了拥堵的情况，从而增大 IP 包的传输间隔，减少网络拥堵 的情况。然而，由于这种 ICMP 可能会引起不公平的网络通信，一般不被使用。</p>\n<p><strong>重定向消息</strong></p>\n<p>如果路由器发现发送端主机使用了「不是最优」的路径发送数据，那么它会返回一个 ICMP 重定向消息给这个主机。在这个消息中包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下。路由器会通过这样的 ICMP 消息告知发送端，让它下次发给另外一个路由器。</p>\n<p><strong>超时消息</strong></p>\n<p>IP 包中有一个字段叫做 TTL ( Time To Live ，生存周期)，它的值随着每经过一次路由器就会减 1，直到减到 0 时该 IP 包会被丢弃。此时，路由器将会发送一个 ICMP 超时消息给发送端主机，并通知该包已被丢弃。设置 IP 包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免 IP 包无休止地在网络上被转发。</p>\n<h4 id=\"查询报文的应用——ping\"><a href=\"#查询报文的应用——ping\" class=\"headerlink\" title=\"查询报文的应用——ping\"></a>查询报文的应用——ping</h4><p>ping的原理就是基于 ICMP 协议的查询报文：类型为8的回送请求消息和类型为0的回送应答消息。</p>\n<p><img src=\"/2021/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Aip%E7%AF%87/image-20230327204145297.png\" alt=\"image-20230327204145297\"></p>\n<h4 id=\"差错报文的应用——traceroute\"><a href=\"#差错报文的应用——traceroute\" class=\"headerlink\" title=\"差错报文的应用——traceroute\"></a>差错报文的应用——traceroute</h4><p>有一款充分利用 ICMP 差错报文类型的应用叫做 <code>traceroute</code>。</p>\n<p>traceroute 的第一个作用是<code>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器</code>。它的原理就是<code>利用 IP 包的生存期限 从 1 开始按照顺序递增的同时发送 UDP 包，强制接收 ICMP 超时消息</code>。工作流程：</p>\n<ol>\n<li><p>将 TTL 设置 为 1 ，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是时间超 时。</p>\n</li>\n<li><p>接下来将 TTL 设置为 2 ，第一个路由器过了，遇到第二个路由器也牺牲了，也同时返回了 ICMP 差错报文数据 包，如此往复，直到到达目的主机。</p>\n</li>\n<li><p>继续重复，traceroute 就可以拿到了所有的路由器 IP。</p>\n</li>\n</ol>\n<p>traceroute 的第二个作用是<code>故意设置不分片，从而确定路径的 MTU</code>。因为有的时候我们并不知道路由器的 MTU 大小，以太网的数据链路上的 MTU 通常是 1500 字节，但是非以 外网的 MTU 值就不一样了，所以我们要知道 MTU 的大小，从而控制发送的包大小。工作流程：</p>\n<ol>\n<li><p>首先在发送端主机发送 IP 数据报时，将 IP 包首部的分片禁止标志位设置为 1。根据这个标志位，途中的路由 器不会对大数据包进行分片，而是将包丢弃。</p>\n</li>\n<li><p>随后，通过一个 ICMP 的不可达消息将数据链路上 MTU 的值一起给发送主机，不可达消息的类型为「需要进行分 片但设置了不分片位」。</p>\n</li>\n<li><p>发送主机端每次收到 ICMP 差错报文时就减少包的大小，以此来定位一个合适的 MTU 值，以便来达到目标主机。</p>\n</li>\n</ol>\n","categories":["计算机网络"],"tags":["计算机网络"]},{"title":"docker系列（一）：基础篇","url":"/2021/04/05/docker%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/","content":"<blockquote>\n<p>docker系列（一）：基础篇</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"一、基本概念\"><a href=\"#一、基本概念\" class=\"headerlink\" title=\"一、基本概念\"></a>一、基本概念</h2><h3 id=\"docker是什么\"><a href=\"#docker是什么\" class=\"headerlink\" title=\"docker是什么\"></a>docker是什么</h3><p>Docker 是 一种容器化技术。Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 版本开始，则进一步演进为使用 runC 和 containerd。<br><img src=\"/2021/04/05/docker%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/image-20230705164144837.png\" alt=\"image-20230705164144837\"></p>\n<p>docker 的本质是一个 linux 用户进程，在创建进程的过程中：</p>\n<ol>\n<li>在 clone 调用时传入 namespace 参数，实现资源隔离。</li>\n<li>对进程配置 cgroups 参数，控制资源使用。</li>\n<li>使用 chroot&#x2F;pivot_root 切换进程的根目录。</li>\n<li>使用 unionfs 技术合并文件读写层和只读层。</li>\n</ol>\n<p>所以，docker 底层的核心三大技术是：</p>\n<ul>\n<li><code>Namespaces</code></li>\n<li><code>Cgroups</code></li>\n<li><code>Unionfs</code></li>\n</ul>\n<blockquote>\n<p>docker 和虚拟机的区别？</p>\n</blockquote>\n<p><img src=\"/2021/04/05/docker%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/image-20230705164208066.png\" alt=\"image-20230705164208066\"></p>\n<p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>\n<h3 id=\"docker架构\"><a href=\"#docker架构\" class=\"headerlink\" title=\"docker架构\"></a>docker架构</h3><p><img src=\"/2021/04/05/docker%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/image-20230705164226208.png\" alt=\"image-20230705164226208\"></p>\n<ul>\n<li><code>Docker守护进程(docker daemon)</code>是运行在你的操作系统上的一个服务。目前，它只能运行在Linux上，因为它依赖于一些Linux内核特性(比如Cgroup与Namespace)。 但是，也有一些特殊的办法让Docker运行在MacOS与Windows上(运行在Linux虚拟机中)。</li>\n<li><code>Docker守护进程提供了REST API</code>。许多工具(Docker命令行，Docker Compose等)都可以通过REST API与Docker守护进程进行交互，例如创建容器，构建镜像等。</li>\n<li><code>Docker命令行(docker CLI)</code>是与Docker守护进程进行交互的主要工具。</li>\n</ul>\n<p><code>Docker是Client/Server架构</code>。其中Docker守护进程是服务端，Docker命令行是众多客户端之一。事实上，还有很多第三方的Docker客户端。对于各种流行的编程语言，它们都有对应的Docker客户端。感兴趣的话，你也可以开发一个，使用REST API与Docker守护进程进行交互就好了。</p>\n<p>docker有三个非常重要的基础概念：</p>\n<ul>\n<li><code>镜像（Image）</code></li>\n<li><code>容器（Container）</code></li>\n<li><code>仓库（Repository）</code></li>\n</ul>\n<h3 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h3><p>镜像是一个为进程提供隔离后执行环境的文件系统，也就是所谓的 <code>rootfs</code>。<code>rootfs 只是操作系统一个操作系统所包含的文件、配置和目录，并不包含操作系统内核</code>。镜像运行起来后（变成容器）依赖宿主机的操作系统内核。</p>\n<p><code>镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际而是由一组文件系统组成</code>。镜像使用了 Unionfs 技术，把多层文件系统联合在一起。</p>\n<p>镜像是一组静态的文件，不包含任何动态数据，其内容在构建之后也不会被改变。</p>\n<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><p>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>\n<p><code>容器的实质是 clone 调用的进程，该进程运行在namespace隔离的环境里，拥有自己独立的 root 文件系统、网络配置、进程空间甚至用户 ID 空间</code>。</p>\n<p>容器运行时，是以镜像为基础层，在其上增加了init层和可读写层。所以容器的 rootfs 分为三层：<br><img src=\"/2021/04/05/docker%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/image-20230705164247113.png\" alt=\"image-20230705164247113\"></p>\n<ul>\n<li><code>只读层(ro+wh)</code>：只读层是容器的 rootfs 的下五层，它们的挂载方式都是只读的，这些层都以增量的方式叠加。</li>\n<li><code>Init层(ro+wh)</code>：是 Docker 项目单独生成的一个内部层，专门用来存放 &#x2F;etc&#x2F;hosts、&#x2F;etc&#x2F;resolv.conf 这些系统文件。我们修改系统文件后只对当前的容器有效，docker commit 不会提交 Init 层的内容，只会提交可读写层。</li>\n<li><code>可读写层(rw)</code>：是容器的 rootfs 的最上面一层，用于保存对 rootfs 的增删查改。在没有写入文件之前，这个目录是空的。如果是做了增查改操作，改变产生的内容就会以增量的方式出现在这个层中；如果是删除操作，<code>会在可读写层创建一个 whiteout 文件</code>，把只读层里的文件遮挡起来。比如，你要删除只读层里一个名叫 foo 的文件，那么这个删除操作实际上是在可读写层创建了一个名叫.wh.foo 的文件。这样，当这两个层被联合挂载之后，foo 文件就会被.wh.foo 文件遮挡起来，只读层里的内容则不会有任何变化。</li>\n</ul>\n<h3 id=\"仓库\"><a href=\"#仓库\" class=\"headerlink\" title=\"仓库\"></a>仓库</h3><p>Docker Registry 提供集中存储、分发镜像的服务。</p>\n<ul>\n<li>一个 Docker Registry 中可以包含多个仓库（Repository）。</li>\n<li>一个仓库可以包含多个 Image。</li>\n<li>Image 用 GUID 表示，有一个或多个 Tag 与之关联。</li>\n</ul>\n<p>Docker Registry 中镜像的完整命名为:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DOCKER_REGISTRY/repo/name:tag</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>DOCKER_REGISTRY：公司统一的Docker Registry地址。</li>\n<li>repo：镜像仓库，用来管理一类镜像。</li>\n<li>name：镜像名称。</li>\n<li>tag：镜像标签。</li>\n</ul>\n<p>Docker Hub 是默认的官方 Registry，也可以修改 <code>/etc/docker/daemon.json</code> 文件，修改默认 Registry 地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 增加一句</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 然后重启</span><br><span class=\"line\">$ sudo service docker restart</span><br></pre></td></tr></table></figure>\n\n<p>一般情况下我们常使用的 <code>repo/name:tag</code> 这种格式，就会去默认的 Registry 地址拉取镜像。</p>\n<p>docker hub 中有两种类型的仓库：</p>\n<ul>\n<li>顶层仓库（top-leveled repository），由docker公司内部创建，命名只有 <code>repo</code>，例如<code>redis</code>。</li>\n<li>用户仓库（user repository），由docker用户创建，命名为 <code>username/repo</code>，例如<code>fedora/redis</code>。</li>\n</ul>\n<h2 id=\"二、docker原理\"><a href=\"#二、docker原理\" class=\"headerlink\" title=\"二、docker原理\"></a>二、docker原理</h2><p>上面提到 Docker 的核心三大技术：</p>\n<ul>\n<li><code>Namespaces</code>：资源隔离，保证两个进程之间的独立性。</li>\n<li><code>Cgroups</code>：资源控制，分配一个进程最大限度可以使用的硬件资源。</li>\n<li><code>Unionfs</code>：合并多层文件，合并多层文件只读层和读写层。</li>\n</ul>\n<h3 id=\"Namespace\"><a href=\"#Namespace\" class=\"headerlink\" title=\"Namespace\"></a>Namespace</h3><p>Linux Namespace 是 Linux 提供的一种内核级别环境隔离的方法。使用 Linux Namespace 创造出的进程可以充分利用宿主机的资源，宿主机有的资源容器进程都可以享有，但彼此之间是隔离的，互不干扰。</p>\n<p>Linux namespace 实现了 6 项资源隔离，基本上涵盖了一个小型操作系统的运行要素，包括主机名、用户权限、文件系统、网络、进程号、进程间通信。</p>\n<table>\n<thead>\n<tr>\n<th>namespace</th>\n<th>系统调用参数</th>\n<th>隔离内容</th>\n<th>内核版本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>UTS</td>\n<td>CLONE_NEWUTS</td>\n<td>主机名和域名</td>\n<td>2.6.19</td>\n</tr>\n<tr>\n<td>IPC</td>\n<td>CLONE_NEWIPC</td>\n<td>信号量、消息队列和共享内存</td>\n<td>2.6.19</td>\n</tr>\n<tr>\n<td>PID</td>\n<td>CLONE_NEWPID</td>\n<td>进程编号</td>\n<td>2.6.24</td>\n</tr>\n<tr>\n<td>Network</td>\n<td>CLONE_NEWNET</td>\n<td>网络设备、网络栈、端口等</td>\n<td>2.6.29</td>\n</tr>\n<tr>\n<td>Mount</td>\n<td>CLONE_NEWNS</td>\n<td>挂载点（文件系统）</td>\n<td>2.4.19</td>\n</tr>\n<tr>\n<td>User</td>\n<td>CLONE_NEWUSER</td>\n<td>用户和用户组</td>\n<td>3.8</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>User namespace的内核完成版本：3.8，这也是很多时候为什么我们说Docker只能在centos7中运行的原因</p>\n</blockquote>\n<p>Namespace的实现主要是下面三个系统调用：</p>\n<ul>\n<li><code>clone()</code> – 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。</li>\n<li><code>setns()</code> – 把某进程加入到某个namespace，在docker exec进入容器的时候使用。</li>\n<li><code>unshare()</code> – 使某进程脱离某个namespace。</li>\n</ul>\n<p>主要来看下 clone 调用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参数child_func传入子进程运行的程序主函数</li>\n<li>参数child_stack传入子进程使用的栈空间</li>\n<li>参数flags表示使用哪些CLONE_*标志位</li>\n<li>参数args则可用于传入用户参数</li>\n</ul>\n<p>在调用 clone() 在 flags 参数时候传入以上系统调用参数，就可以控制进程的隔离内容。一个容器进程也可以再 clone() 出一个容器进程，这是容器的嵌套。</p>\n<p>例如最简单的 clone() 调用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#define _GNU_SOURCE </span><br><span class=\"line\">#include &lt;sys/mount.h&gt; </span><br><span class=\"line\">#include &lt;sys/types.h&gt;</span><br><span class=\"line\">#include &lt;sys/wait.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;sched.h&gt;</span><br><span class=\"line\">#include &lt;signal.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#define STACK_SIZE (1024 * 1024)</span><br><span class=\"line\">static char container_stack[STACK_SIZE];</span><br><span class=\"line\">char* const container_args[] = &#123;</span><br><span class=\"line\">  &quot;/bin/bash&quot;,</span><br><span class=\"line\">  NULL</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">int container_main(void* arg)</span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  printf(&quot;Container - inside the container!\\n&quot;);</span><br><span class=\"line\">  execv(container_args[0], container_args);</span><br><span class=\"line\">  printf(&quot;Something&#x27;s wrong!\\n&quot;);</span><br><span class=\"line\">  return 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;Parent - start a container!\\n&quot;);</span><br><span class=\"line\">  int container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD , NULL);</span><br><span class=\"line\">  waitpid(container_pid, NULL, 0);</span><br><span class=\"line\">  printf(&quot;Parent - container stopped!\\n&quot;);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的功能非常简单：在 main 函数里，我们通过 clone() 系统调用创建了一个新的子进程 container_main 执行了一个&#x2F;bin&#x2F;bash。clone() 第二个参数指定了子进程运行的栈空间大小，第三个参数即为创建不同 namespace 隔离的关键。</p>\n<p>但是对于上面的程序，父子进程的进程空间是没有什么差别的，父进程能访问到的子进程也能。</p>\n<p>使用了 Linux Namespace 隔离技术后：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#define _GNU_SOURCE </span><br><span class=\"line\">#include &lt;sys/mount.h&gt; </span><br><span class=\"line\">#include &lt;sys/types.h&gt;</span><br><span class=\"line\">#include &lt;sys/wait.h&gt;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;sched.h&gt;</span><br><span class=\"line\">#include &lt;signal.h&gt;</span><br><span class=\"line\">#include &lt;unistd.h&gt;</span><br><span class=\"line\">#define STACK_SIZE (1024 * 1024)</span><br><span class=\"line\">static char container_stack[STACK_SIZE];</span><br><span class=\"line\">char* const container_args[] = &#123;</span><br><span class=\"line\">  &quot;/bin/bash&quot;,</span><br><span class=\"line\">  NULL</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">int container_main(void* arg)</span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">  printf(&quot;Container - inside the container!\\n&quot;);</span><br><span class=\"line\">  sethostname(&quot;test&quot;,10); /* 设置hostname */</span><br><span class=\"line\">  execv(container_args[0], container_args);</span><br><span class=\"line\">  printf(&quot;Something&#x27;s wrong!\\n&quot;);</span><br><span class=\"line\">  return 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  printf(&quot;Parent - start a container!\\n&quot;);</span><br><span class=\"line\">  int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD , NULL);</span><br><span class=\"line\">  waitpid(container_pid, NULL, 0);</span><br><span class=\"line\">  printf(&quot;Parent - container stopped!\\n&quot;);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的clone系统调用中，我们新增了2个参数：<code>CLONE_NEWUTS</code>、<code>CLONE_NEWPID</code>；也就是新增了UTS和PID两种Namespace。为了能够看出容器内和容器外主机名的变化，我们子进程执行函数中加入：<code>sethostname(&quot;test&quot;, 9);</code></p>\n<p>运行以上程序，发现子进程的hostname变成了 container，同时查看当前的进程号变成了1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ vi test.c</span><br><span class=\"line\">$ gcc -o test test.c</span><br><span class=\"line\">$ ./test</span><br><span class=\"line\">Parent - start a container!</span><br><span class=\"line\">Container - inside the container!</span><br><span class=\"line\">$ hostname</span><br><span class=\"line\">test</span><br><span class=\"line\">$ echo $$</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p>这就是 Linux Namespace 技术的隔离效果。</p>\n<p>事实上，作为一个普通用户，我们希望的情况是：每当创建一个新容器时，容器进程看到的文件系统就是一个独立的隔离环境，而不是继承自宿主机的文件系统，这里可以通过容器进程启动之前重新挂载它的整个根目录“&#x2F;”。而由于 Mount Namespace 的存在，这个挂载对宿主机不可见，所以容器进程就可以在里面随便折腾了。</p>\n<p>在 Linux 操作系统里，有一个名为 <code>chroot</code> 的命令可以帮助你在 shell 中方便地完成这个工作。它的作用就是帮你“change root file system”，即改变进程的根目录到你指定的位置。</p>\n<p><code>使用 Namespace + chroot，我们就可以创造出一个隔离的容器环境</code>。</p>\n<h3 id=\"Cgroups\"><a href=\"#Cgroups\" class=\"headerlink\" title=\"Cgroups\"></a>Cgroups</h3><p>虽然通过 Namespace 创造出隔离的容器环境，但事实上仍是所有容器进程共享宿主机上的硬件资源。如果某个进程占用资源过高，就会影响宿主机上其他进程的稳定性，所以有必要限制单个进程可以占用的最大程度的硬件资源。</p>\n<p><code>cgroups(Control Groups) 是 linux 内核提供的一种机制，用来统一将进程进行分组，并在分组的基础上对进程进行监控和资源控制管理等</code>。</p>\n<p>cgroup主要包括下面两部分结构：</p>\n<ul>\n<li>subsystem：一个 subsystem 就是一个内核模块，用来限制某一类资源的使用。目前 linux 支持 12 种 subsystem：<ul>\n<li>blkio 对块设备的 IO 进行限制。</li>\n<li>cpu 限制 CPU 时间片的分配，与 cpuacct 挂载在同一目录。</li>\n<li>cpuacct 生成 cgroup 中的任务占用 CPU 资源的报告，与 cpu 挂载在同一目录。</li>\n<li>cpuset 给 cgroup 中的任务分配独立的 CPU(多处理器系统) 和内存节点。</li>\n<li>devices 允许或禁止 cgroup 中的任务访问设备。</li>\n<li>freezer 暂停&#x2F;恢复 cgroup 中的任务。</li>\n<li>hugetlb 限制使用的内存页数量。</li>\n<li>memory 对 cgroup 中的任务的可用内存进行限制，并自动生成资源占用报告。</li>\n<li>net_cls 使用等级识别符（classid）标记网络数据包，这让 Linux 流量控制器（tc 指令）可以识别来自特定 cgroup 任务的数据包，并进行网络限制。</li>\n<li>net_prio 允许基于 cgroup 设置网络流量(netowork traffic)的优先级。</li>\n<li>perf_event 允许使用 perf 工具来监控 cgroup。</li>\n<li>pids 限制任务的数量。</li>\n</ul>\n</li>\n<li>hierarchy：一个 hierarchy 可以理解为一棵 cgroup 树，系统中可以有很多颗 cgroup 树，每棵树可以和一到多个 subsystem 关联，但一个 subsystem 只能关联到一颗 cgroup 树，一旦关联并在这颗树上创建了子 cgroup，subsystems 和这棵 cgroup 树就成了一个整体。在一颗树里面，会包含 Linux 系统中的所有进程，树的每个节点就是一个进程组。一个进程可以属于多颗树，但一个进程不能同属于同一棵树下的多个节点。</li>\n</ul>\n<p><img src=\"/2021/04/05/docker%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/image-20230705164320169.png\" alt=\"image-20230705164320169\"><br>cgroup 结构体是一个树状结构，树的每个节点是一个进程组，而每颗树又和一个或者多个subsystem关联。树的作用是将进程分组，subsystem 的作用就是对这些组进行资源限制。</p>\n<p>最下面的P代表一个进程。每一个进程的描述符中有一个指针指向了一个辅助数据结构css_set（cgroups subsystem set）。 指向某一个css_set的进程会被加入到当前css_set的进程链表中。一个进程只能隶属于一个css_set，一个css_set可以包含多个进程，隶属于同一css_set的进程受到同一个css_set所关联的资源限制。</p>\n<p>”M×N Linkage”说明的是css_set通过辅助数据结构可以与 cgroups 节点进行多对多的关联。但是 cgroups 的实现不允许css_set同时关联同一个cgroups层级结构下多个节点。 这是因为 cgroups 对同一种资源不允许有多个限制配置。</p>\n<p>cgrou p相关的所有操作都是基于内核中的 cgroup virtual filesystem。使用 cgroup 很简单，<code>使用 mount 命令挂载需要限制资源的文件系统到 /sys/fs/cgroup 目录下</code>。在 &#x2F;sys&#x2F;fs&#x2F;cgroup 目录下创建文件夹，也会自动创建好各种资源文件。</p>\n<ol>\n<li>挂载和所有subsystem关联的cgroup树到&#x2F;sys&#x2F;fs&#x2F;cgroup</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mount -t cgroup xxx /sys/fs/cgroup</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>挂载一颗和cpuset subsystem关联的cgroup树到&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mkdir /sys/fs/cgroup/cpuset</span><br><span class=\"line\">mount -t cgroup -o cpuset xxx /sys/fs/cgroup/cpuset</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>挂载一颗与cpu和cpuacct subsystem关联的cgroup树到&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mkdir /sys/fs/cgroup/cpu,cpuacct</span><br><span class=\"line\">mount -t cgroup -o cpu,cpuacct xxx /sys/fs/cgroup/cpu,cpuacct</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>查看系统上的所有cgroup</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mount | grep cgroup</span><br></pre></td></tr></table></figure>\n\n<p>创建并挂载好一颗 cgroup 树之后，就有了树的根节点，也即根cgroup，这时候就可以通过创建文件夹的方式创建子cgroup，然后再往每个子cgroup中添加进程。</p>\n<p>可以通过查看 <code>/proc/[pid]/cgroup(since Linux 2.6.24)</code> 知道指定进程属于哪些cgroup。</p>\n<h3 id=\"Unionfs\"><a href=\"#Unionfs\" class=\"headerlink\" title=\"Unionfs\"></a>Unionfs</h3><p>UnionFS（Union File System）是把其他文件系统联合到一个联合挂载点的文件系统服务。它使用 branch 把不同文件系统的文件和目录覆盖，形成一个一致的文件系统。</p>\n<p>UnionFS 使用 <code>COW</code>（copy-on-write，写时复制）的技术：如果一个资源是重复的，并且没有任何修改，这时并不需要立即创建一个新的资源，这个资源可以被新旧实例共享；当对资源进行修改后的时候，写到一个新的文件中，并没有改变原来的文件。通过这种资源共享的方式可以显著地减少未修改资源复制带来的消耗。</p>\n<p><code>AUFS</code> 是 Docker 使用的第一种存储驱动，目前 Docker 默认的存储驱动已经变为了 <code>overlay2</code>。可以使用 <code>docker info</code> 查看 docker 使用的 storage driver。</p>\n<h4 id=\"AUFS\"><a href=\"#AUFS\" class=\"headerlink\" title=\"AUFS\"></a>AUFS</h4><p>AUFS 是 Docker 最先使用的 storage driver，它技术很成熟，社区支持也很好，它的特性使得它成为 storage driver 的一个好选择。但仍有一些Linux发行版不支持AUFS，主要是它没有被并入Linux内核。AUFS通过写时复制策略来实现镜像镜像的共享和最小化磁盘开销。</p>\n<p>AUFS 的读写过程：第一次修改文件的时候，意味着它当前不在最顶层的读写层AUFS就会在下面的读写层中查找它，查找是自顶向下，逐层查找的。找到之后，就把整个文件拷贝到读写层，再对它进行修改。哪怕只是文件的一小部分被改变，也需要复制整个文件。</p>\n<p>AUFS 的删除过程：AUFS 通过在最顶层(读写层)生成一个 whiteout 文件来删除文件。whiteout 文件会掩盖下面只读层相应文件的存在，但它事实上没有被删除。</p>\n<h4 id=\"Overlay2\"><a href=\"#Overlay2\" class=\"headerlink\" title=\"Overlay2\"></a>Overlay2</h4><p>Overlay2 是 Docker 目前默认的存储驱动。Overlay2 与 AUFS 相似，但分层命名有所不同。<br><img src=\"/2021/04/05/docker%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/image-20230705164341213.png\" alt=\"image-20230705164341213\"></p>\n<p>overlay2包括 lowerdir，upperdir 和 merged 三个层次：</p>\n<ul>\n<li>lowerdir：表示较为底层的目录，修改联合挂载点不会影响到lowerdir。</li>\n<li>upperdir：表示较为上层的目录，修改联合挂载点会在upperdir同步修改。</li>\n<li>merged：是lowerdir和upperdir合并后的联合挂载点。</li>\n<li>workdir：用来存放挂载后的临时文件与间接文件。</li>\n</ul>\n<p>在运行容器后，可以通过 mount 命令查看其具体挂载信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@staight chmdocker]# mount | grep overlay</span><br><span class=\"line\">overlay on /var/lib/docker/overlay2/16361198b12618b2234306c6998cd8eb1c55f577a02144913da60dba4ca0c6e5/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/INEXQHCNWBDKYZLHC42SH33R43:/var/lib/docker/overlay2/l/H47VNXLFUBUVMHEAEGXMC6S3QJ,upperdir=/var/lib/docker/overlay2/16361198b12618b2234306c6998cd8eb1c55f577a02144913da60dba4ca0c6e5/diff,workdir=/var/lib/docker/overlay2/16361198b12618b2234306c6998cd8eb1c55f577a02144913da60dba4ca0c6e5/work)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>联合挂载点：<code>/var/lib/docker/overlay2/16361198b12618b2234306c6998cd8eb1c55f577a02144913da60dba4ca0c6e5/merged</code></li>\n<li>lowerdir：<code>/var/lib/docker/overlay2/l/INEXQHCNWBDKYZLHC42SH33R43:/var/lib/docker/overlay2/l/H47VNXLFUBUVMHEAEGXMC6S3QJ</code>，冒号分隔多个lowerdir，从左到右层次越低。</li>\n<li>upperdir：<code>/var/lib/docker/overlay2/16361198b12618b2234306c6998cd8eb1c55f577a02144913da60dba4ca0c6e5/diff</code></li>\n<li>workdir：<code>/var/lib/docker/overlay2/16361198b12618b2234306c6998cd8eb1c55f577a02144913da60dba4ca0c6e5/work</code></li>\n</ul>\n<p>overlay2 读文件的过程：</p>\n<ul>\n<li>要读的文件不在container layer中，那就从lowerdir中读。</li>\n<li>要读的文件之存在于container layer中：直接从upperdir中读。</li>\n<li>要读的文件在container layer和image layer中都存在，从upperdir中读文件。</li>\n</ul>\n<p>overlay2 写文件的过程：第一次修改时，文件不在container layer(upperdir)中，overlay driver调用 copy-up 操作将文件从 lowerdir 读到upperdir中，对文件的读写都直接在 upperdir 中进行。overlayfs 中仅有两层，这使得文件的查找效率很高(相对于aufs)。</p>\n<p>overlay2 新建文件的过程：对 merged 目录新增文件，会同步到 upper 目录，底下 lower 目录不会受影响。</p>\n<p>overlay2 删除文件的过程：删除文件和aufs一样，相应的whiteout文件被创建在upperdir。并不删除容器层(lowerdir)中的文件，whiteout文件屏蔽了它的存在。删除目录的时候，会建立一个 opaque 目录，作用同上。</p>\n<p>可以通过 <code>docker inspect CONTAINER_ID</code> 查看容器的文件系统：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker inspect 4d23ac2876e4e2c71c6789e3e</span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;Id&quot;: &quot;4d23ac2876e4e2c71c6789e3ed85359c34ee333a7edb3ff798a5e9ada4e1994a&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">        &quot;Image&quot;: &quot;sha256:0e901e68141fd02f237cf63eb842529f8a9500636a9419e3cf4fb986b8fe3d5d&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">        ......</span><br><span class=\"line\"></span><br><span class=\"line\">        &quot;GraphDriver&quot;: &#123;</span><br><span class=\"line\">            &quot;Data&quot;: &#123;</span><br><span class=\"line\">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/da23c8758079677a3c4ecf066959dfecd1ce0da6e4fcdf361aa2ecf52b399a2f-init/diff:/var/lib/docker/overlay2/2dd80634d16dfeea21deb784951b8c1ba624e87818ad8d5ac76fbd2ae8889b52/diff:/var/lib/docker/overlay2/8b812a5acf0a7f5492b3b16a7e7e8c4f24ae8f70e12edc64eb9b1aca3abd9191/diff:/var/lib/docker/overlay2/17f0ddd048f1f50a683c9c457ac211aa522b00b8401eb126ebee0aa2a5f5010b/diff:/var/lib/docker/overlay2/ff6d59331669f3d7378caf593354b57f8818987238ac0f903e10171ab2ae3b79/diff:/var/lib/docker/overlay2/0d0ca9fbfc0df2efcee37649a9da72e573b2781b10d85d52566be73588bb2033/diff:/var/lib/docker/overlay2/9731f15d91e25117bb3105fb91bd3f1dfc8b11ee2a06102288ed33b4ff2ac3ff/diff&quot;,</span><br><span class=\"line\">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/da23c8758079677a3c4ecf066959dfecd1ce0da6e4fcdf361aa2ecf52b399a2f/merged&quot;,</span><br><span class=\"line\">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/da23c8758079677a3c4ecf066959dfecd1ce0da6e4fcdf361aa2ecf52b399a2f/diff&quot;,</span><br><span class=\"line\">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/da23c8758079677a3c4ecf066959dfecd1ce0da6e4fcdf361aa2ecf52b399a2f/work&quot;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ID：容器ID，这里的容器ID是da23cxxx</li>\n<li>Image：镜像ID</li>\n<li>GraphDriver：overlay2分层信息，这里详细列出了四种目录指向的具体目录：<ul>\n<li>LowerDir：指向 da23cxxx 的 Init 目录和 LowerDir 层的 diff 目录。</li>\n<li>MergedDir：指向 da23cxxx 的 merged 目录。</li>\n<li>UpperDir：指向 da23cxxx 的 diff 目录。</li>\n<li>WorkDir：指向 da23cxxx 的 work 目录。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"三、数据卷\"><a href=\"#三、数据卷\" class=\"headerlink\" title=\"三、数据卷\"></a>三、数据卷</h2><p>在Docker中，要想实现数据的持久化（即数据不随着Container的结束而结束），需要将数据从宿主机挂载到容器中。目前Docker提供了三种不同的方式将数据从宿主机挂载到容器中：</p>\n<ul>\n<li><code>volume</code>：存于主机文件系统中的指定区域（<code>/var/lib/docker/volumes/</code>），由Docker进行管理。非Docker进程不应该修改这些数据。卷是Docker中持久化数据的最好方式。</li>\n<li><code>bind mount</code>：可以存储在宿主机系统的任意位置。非 Docker 的进程或者 Docker 容器可能随时对其进行修改，存在潜在的安全风险。bind mount在不同的宿主机系统时不可移植的，比如Windows和Linux的目录结构是不一样的，bind mount所指向的host目录也不能一样。</li>\n<li><code>tmpfs</code>：存于内存中，并不是持久化到磁盘。在容器的生命周期中，可以被容器用来存放非持久化的状态或敏感信息，比较少用。</li>\n</ul>\n<p>绑定数据卷可以使用参数<code>-v</code>或者<code>--volume</code>，Docker 17.06 之后，可以统一使用参数<code>--mount</code>。</p>\n<blockquote>\n<p>-v和–mount的区别：</p>\n<ul>\n<li>使用-v的时候，如果在 Docker Host 不存在要挂载的文件或者目录，Docker 将会自动进行创建，通常是一个目录;</li>\n<li>使用–mount的时候，如果在 Docker Host 不存在要挂载的文件或者目录，Docker 不会自动创建目录，并生成一个错误;</li>\n</ul>\n</blockquote>\n<p>-v 语法：分为三部分，使用冒号进行分割。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-v 宿主机目录地址:容器目录地址:ro</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>映射到宿主机文件的目录的地址或数据卷名称</li>\n<li>挂载到容器上的文件目录的地址</li>\n<li>可选字段，用来增加附加项目，比如ro，rw等等</li>\n</ul>\n<p>–mount语法：由一组键值对组成，用逗号进行分割。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--mount type=bind,source=宿主机目录地址,target=容器目录地址,readonly</span><br></pre></td></tr></table></figure>\n\n<p>各部分含义同上。</p>\n<h3 id=\"使用bind-mount挂载数据卷\"><a href=\"#使用bind-mount挂载数据卷\" class=\"headerlink\" title=\"使用bind mount挂载数据卷\"></a>使用bind mount挂载数据卷</h3><p>把宿主机的&#x2F;app&#x2F;wwwroot目录挂载到容器的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker run -d -it --name my_nginx -p 80:80 -v /app/wwwroot:/usr/share/nginx/html/ nginx:latest</span><br><span class=\"line\"></span><br><span class=\"line\">或者</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker run -d -it --name my_nginx -p 80:80 --mount type=bind,source=/app/wwwroot,target=/usr/share/nginx/html/ nginx:latest</span><br></pre></td></tr></table></figure>\n\n<p>也可以设置<code>只读挂载，设置后容器中无法对数据进行修改。只有宿主机可以进行数据修改</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker run -d -it --name my_nginx -p 80:80 -v /app/wwwroot:/usr/share/nginx/html/:ro nginx:latest</span><br><span class=\"line\"></span><br><span class=\"line\">或者</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker run -d -it --name my_nginx -p 80:80 --mount type=bind,source=/app/wwwroot,target=/usr/share/nginx/html/,readonly nginx:latest</span><br></pre></td></tr></table></figure>\n\n<p>注意，<code>bind mounts的方式会隐藏掉容器被挂载目录里面的内容（如果非空的话）</code>。以上&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 目录下的内容被隐藏掉了，因此我们看不到。</p>\n<h3 id=\"使用volume挂载数据卷\"><a href=\"#使用volume挂载数据卷\" class=\"headerlink\" title=\"使用volume挂载数据卷\"></a>使用volume挂载数据卷</h3><p>volume由Docker来进行管理，在打包的时候可以把volume的内容一起打包，所以有良好的迁移性。volume的默认目录为<code>/var/lib/docker/volumes</code>，所有volume的数据内容都保存在该目录下，每一个目录对应一个volume。在创建volume的时候如果没有指定名称，docker就会生成一个随机字符串命名。<br><img src=\"/2021/04/05/docker%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/image-20230705164413976.png\" alt=\"image-20230705164413976\"></p>\n<p>创建volume数据卷有三种方式：</p>\n<ul>\n<li>使用 <code>docker volume create volume_name</code> 创建，会在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes下生成一个volume_name命名的目录。</li>\n<li>在 <code>docker run</code> 中使用 <code>-v</code> 或者 <code>--mount</code> 参数进行创建。</li>\n<li>匿名创建。如果 <code>docker volume create</code> 或者 <code>docker run</code> 中都没有指定 volume 的名称，docker 就会生成一个随机字符串作为命名。</li>\n</ul>\n<p>此外volume支持使用 volume drivers，允许将数据存储挂载到远程主机上。</p>\n<p>volume 使用 -v 或者 –mount 参数挂载数据卷的用法和 bind mount 类似。<br>-v语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-v 数据卷名称:容器目录地址:ro</span><br></pre></td></tr></table></figure>\n\n<p>–mount语法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--mount type=bind,source=数据卷名称,target=容器目录地址,readonly</span><br></pre></td></tr></table></figure>\n\n<p>例如把容器的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;目录挂载到宿主机上一个名为test的卷</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker run -d -it --name my_nginx -p 80:80 -v test:/usr/share/nginx/html/ nginx:latest</span><br><span class=\"line\"></span><br><span class=\"line\">或者</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker run -d -it --name my_nginx -p 80:80 --mount type=bind,source=test,target=/usr/share/nginx/html/ nginx:latest</span><br></pre></td></tr></table></figure>\n\n<p>然后在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes目录下发现生成一个test的目录。</p>\n<h3 id=\"查看数据卷\"><a href=\"#查看数据卷\" class=\"headerlink\" title=\"查看数据卷\"></a>查看数据卷</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查看所有容器卷</span><br><span class=\"line\">$ docker volume ls</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定容器卷详情信息</span><br><span class=\"line\">$ docker volume inspect volume_name</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定容器的数据卷</span><br><span class=\"line\">$ docker inspect containerID</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">......</span><br><span class=\"line\">        &quot;Mounts&quot;: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class=\"line\">                &quot;Name&quot;: &quot;3e680b6c7eeb1965a71cb23a0032934fa5b731b57b9b02bea213c6f82819764f&quot;,</span><br><span class=\"line\">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/3e680b6c7eeb1965a71cb23a0032934fa5b731b57b9b02bea213c6f82819764f/_data&quot;,</span><br><span class=\"line\">                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class=\"line\">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class=\"line\">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class=\"line\">                &quot;RW&quot;: true,</span><br><span class=\"line\">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除数据卷\"><a href=\"#删除数据卷\" class=\"headerlink\" title=\"删除数据卷\"></a>删除数据卷</h3><p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器。所以Docker 不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。我们需要手动删除数据卷。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 删除指定数据卷</span><br><span class=\"line\">$ docker volume rm volume_name</span><br><span class=\"line\"></span><br><span class=\"line\"># 清理所有无用数据卷</span><br><span class=\"line\">$ docker volume prune</span><br></pre></td></tr></table></figure>\n\n<p>如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p>\n<h2 id=\"四、网络\"><a href=\"#四、网络\" class=\"headerlink\" title=\"四、网络\"></a>四、网络</h2><p>docker为容器间通信设置了四种网络模式：</p>\n<table>\n<thead>\n<tr>\n<th>网络模式</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bridge</td>\n<td>为每一个容器分配、设置 IP 等，并将容器连接到一个 docker0 虚拟网桥，默认为该模式。</td>\n</tr>\n<tr>\n<td>host</td>\n<td>容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</td>\n</tr>\n<tr>\n<td>none</td>\n<td>容器有独立的 Network namespace，但并没有对其进行任何网络设置，如分配 veth pair 和网桥连接，IP 等。</td>\n</tr>\n<tr>\n<td>container</td>\n<td>新创建的容器不会创建自己的网卡和配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。</td>\n</tr>\n</tbody></table>\n<p>安装 Docker 以后，会默认创建三种网络，可以通过 <code>docker network ls</code> 查看。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker network ls</span><br><span class=\"line\">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class=\"line\">688d1970f72e        bridge              bridge              local</span><br><span class=\"line\">885da101da7d        host                host                local</span><br><span class=\"line\">f4f1b3cf1b7f        none                null                local</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bridge模式\"><a href=\"#bridge模式\" class=\"headerlink\" title=\"bridge模式\"></a>bridge模式</h3><p>Docker 的默认网络模式。守护进程创建了一个虚拟以太网桥 docker0，新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包。</p>\n<p>然后守护进程会创建一对对等虚拟设备接口 veth pair，将其中一个接口设置为容器的 eth0 接口（容器的网卡），另一个接口放置在宿主机的命名空间中，以类似 vethxxx 这样的名字命名，从而将宿主机上的所有容器都连接到这个内部网络上。</p>\n<p>同时，守护进程还会从网桥 docker0 的私有地址空间中分配一个 IP 地址和子网给该容器，并设置 docker0 的 IP 地址为容器的默认网关。<br><img src=\"/2021/04/05/docker%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/image-20230705164500393.png\" alt=\"image-20230705164500393\"></p>\n<p>Bridge 桥接模式的实现步骤主要如下：</p>\n<ul>\n<li>Docker Daemon 利用 veth pair 技术，在宿主机上创建一对对等虚拟网络接口设备，假设为 veth0 和 veth1。而 veth pair 技术的特性可以保证无论哪一个 veth 接收到网络报文，都会将报文传输给另一方。</li>\n<li>Docker Daemon 将 veth0 附加到 Docker Daemon 创建的 docker0 网桥上。保证宿主机的网络报文可以发往 veth0；</li>\n<li>Docker Daemon 将 veth1 添加到 Docker Container 所属的 namespace 下，并被改名为 eth0。如此一来，宿主机的网络报文若发往 veth0，则立即会被 Container 的 eth0 接收，实现宿主机到 Docker Container 网络的联通性；同时，也保证 Docker Container 单独使用 eth0，实现容器网络环境的隔离性。</li>\n</ul>\n<p>使用 bridge 网络模式：<br>在创建容器时通过参数 <code>--net bridge</code> 或者 <code>--network bridge</code> 指定即可，当然这也是创建容器默认使用的网络模式，也就是说这个参数是可以省略的。</p>\n<p>查看 bridge 网络模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker network inspect bridge</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"host模式\"><a href=\"#host模式\" class=\"headerlink\" title=\"host模式\"></a>host模式</h3><p>采用 host 网络模式的 Docker Container，可以直接使用宿主机的 IP 地址与外界进行通信，若宿主机的 eth0 是一个公有 IP，那么容器也拥有这个公有 IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行 NAT 转换。</p>\n<p>host 网络模式可以让容器共享宿主机网络栈，这样的好处是外部主机与容器直接通信，但是容器的网络缺少隔离性。<br><img src=\"/2021/04/05/docker%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/image-20230705164517131.png\" alt=\"image-20230705164517131\"></p>\n<p>使用 host 网络模式：<br>创建容器时通过参数 <code>--net host</code> 或者 <code>--network host</code> 指定。</p>\n<p>查看 host 网络模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker network inspect host</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"none模式\"><a href=\"#none模式\" class=\"headerlink\" title=\"none模式\"></a>none模式</h3><p>none 网络模式即不为 Docker Container 创建任何的网络环境，容器内部就只能使用 loopback 网络设备，不会再有其他的网络资源。即只有 lo 接口 local 的简写，代表 127.0.0.1，即 localhost 本地环回接口。</p>\n<p>使用 none 网络模式：<br>在创建容器时通过参数 <code>--net none</code> 或者 <code>--network none</code> 指定。<br>查看 none 网络模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker network inspect none</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"container模式\"><a href=\"#container模式\" class=\"headerlink\" title=\"container模式\"></a>container模式</h3><p>处于 Container 网络模式下的 Docker 容器会共享一个网络栈，这样两个容器之间可以使用 localhost 高效快速通信。即新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样两个容器除了网络方面相同之外，其他的如文件系统、进程列表等还是隔离的。<br><img src=\"/2021/04/05/docker%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%AF%87/image-20230705164536887.png\" alt=\"image-20230705164536887\"></p>\n<p>使用 container 网络模式：<br>在创建容器时通过参数 <code>--net container:已运行的容器名称|ID</code> 或者 <code>--network container:已运行的容器名称|ID</code> 指定。</p>\n<p>处于 Container 网络模式下的容器，如果所依赖的容器停止运行了，本容器就只剩下 lo 接口了。</p>\n<h3 id=\"link\"><a href=\"#link\" class=\"headerlink\" title=\"link\"></a>link</h3><p><code>docker run --link</code> 可以用来链接两个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据，如源容器的环境变量。</p>\n<p>这种方式官方已不推荐使用，并且在未来版本可能会被移除，所以这里不作为重点讲解，感兴趣可自行了解。</p>\n<h3 id=\"自定义网络\"><a href=\"#自定义网络\" class=\"headerlink\" title=\"自定义网络\"></a>自定义网络</h3><p>处于同一网络下的两个容器可以直接通过 ip 地址进行通信。但是 IP 地址可能是不固定的，有被更改的情况发生，那容器内所有通信的 IP 地址也需要进行更改。</p>\n<p>从 Docker 1.10 版本开始，docker daemon 实现了一个内嵌的 DNS server，<code>使容器可以直接通过容器名称通信</code>。方法很简单，只要在创建容器时使用 –name 为容器命名即可。</p>\n<p>但是使用 Docker DNS 有个限制：<code>只能在 user-defined 网络中使用。也就是说，默认的 bridge 网络是无法使用 DNS 的</code>。</p>\n<p>为了启用容器名称到 IP 地址的自动 DNS 解析，以及提高容器的安全性，我们就需要自定义网络。</p>\n<h4 id=\"创建网络\"><a href=\"#创建网络\" class=\"headerlink\" title=\"创建网络\"></a>创建网络</h4><p>创建一个基于 bridge 网络模式的自定义网络模式 custom_network。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker network create custom_network</span><br></pre></td></tr></table></figure>\n\n<p>查看网络模式，确认生成 custom_network 模式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker network ls</span><br><span class=\"line\">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class=\"line\">b3634bbd8943        bridge              bridge              local</span><br><span class=\"line\">062082493d3a        custom_network      bridge              local</span><br><span class=\"line\">885da101da7d        host                host                local</span><br><span class=\"line\">f4f1b3cf1b7f        none                null                local</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用自定义网络创建容器\"><a href=\"#使用自定义网络创建容器\" class=\"headerlink\" title=\"使用自定义网络创建容器\"></a>使用自定义网络创建容器</h4><p>使用 custom_network 网络模式创建两个容器 custom_bbox01 和 custom_bbox02</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker run -di --name custom_bbox01 --net custom_network busybox</span><br><span class=\"line\">$ docker run -di --name custom_bbox02 --net custom_network busybox</span><br></pre></td></tr></table></figure>\n\n<p>这时候进入容器 custom_bbox01，直接执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ping custom_bbox02</span><br></pre></td></tr></table></figure>\n\n<p>通过容器名字已经可以 ping 通。</p>\n<h4 id=\"加入自定义网络模式\"><a href=\"#加入自定义网络模式\" class=\"headerlink\" title=\"加入自定义网络模式\"></a>加入自定义网络模式</h4><p>已经存在的容器custom_bbox03，可以加入自定义网络模式custom_network</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker network connect custom_network custom_bbox03</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"断开自定义网络模式\"><a href=\"#断开自定义网络模式\" class=\"headerlink\" title=\"断开自定义网络模式\"></a>断开自定义网络模式</h4><p>custom_bbox03也可以退出自定义网络模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker network disconnect custom_network custom_bbox03</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"删除自定义网络模式\"><a href=\"#删除自定义网络模式\" class=\"headerlink\" title=\"删除自定义网络模式\"></a>删除自定义网络模式</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker network rm custom_network</span><br></pre></td></tr></table></figure>\n\n<p>注意：如果通过某个自定义网络模式创建了容器，则该网络模式无法删除。</p>\n","categories":["docker"],"tags":["docker"]},{"title":"docker系列（二）：docker命令","url":"/2021/04/05/docker%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Adocker%E5%91%BD%E4%BB%A4/","content":"<blockquote>\n<p>docker系列（二）：docker命令</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"一、系统概况\"><a href=\"#一、系统概况\" class=\"headerlink\" title=\"一、系统概况\"></a>一、系统概况</h2><h3 id=\"查看docker信息\"><a href=\"#查看docker信息\" class=\"headerlink\" title=\"查看docker信息\"></a>查看docker信息</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker info</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker version</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看docker事件\"><a href=\"#查看docker事件\" class=\"headerlink\" title=\"查看docker事件\"></a>查看docker事件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker events [OPTIONS]</span><br></pre></td></tr></table></figure>\n<p>OPTIONS说明：</p>\n<ul>\n<li>-f ：根据条件过滤事件</li>\n<li>–since ：从指定的时间戳后显示所有事件</li>\n<li>–until ：流水时间显示到指定的时间为止</li>\n</ul>\n<h3 id=\"重启整个docker服务\"><a href=\"#重启整个docker服务\" class=\"headerlink\" title=\"重启整个docker服务\"></a>重启整个docker服务</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ service docker restart</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用代理\"><a href=\"#使用代理\" class=\"headerlink\" title=\"使用代理\"></a>使用代理</h3><p>官方默认：<code>/etc/docker/daemon.json</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 例如使用科大的加速地址</span><br><span class=\"line\">$ sudo vim /etc/default/docker</span><br><span class=\"line\"></span><br><span class=\"line\"># 增加一句</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 然后重启</span><br><span class=\"line\">$ sudo service docker restart</span><br></pre></td></tr></table></figure>\n<p>ubuntu：<code>/etc/default/docker</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 例如使用科大的加速器</span><br><span class=\"line\">$ sudo vim /etc/docker/daemon.json</span><br><span class=\"line\"></span><br><span class=\"line\"># 在最后添加一句</span><br><span class=\"line\">DOCKER_OPTS=&quot;--registry-mirror=https://docker.mirrors.ustc.edu.cn&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 然后重启</span><br><span class=\"line\">$ sudo service docker restart</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、容器\"><a href=\"#二、容器\" class=\"headerlink\" title=\"二、容器\"></a>二、容器</h2><h3 id=\"启动全新容器\"><a href=\"#启动全新容器\" class=\"headerlink\" title=\"启动全新容器\"></a>启动全新容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>\n<p>options说明：</p>\n<ul>\n<li>-d：后台运行容器，并返回容器ID；</li>\n<li>-i保证容器的STDIN是开启的，-t为容器创建一个伪tty终端，两者结合使用创建一个交互式容器</li>\n<li>-p：指定端口映射，格式为：主机(宿主)端口:容器端口</li>\n<li>–name：为容器指定一个名称</li>\n<li>-e：设置环境变量</li>\n<li>–net&#x3D;”bridge”: 指定容器的网络连接类型，支持bridge&#x2F;host&#x2F;none&#x2F;container四种类型</li>\n<li>–link&#x3D;[]：添加链接到另一个容器；</li>\n<li>–expose&#x3D;[]：开放一个端口或一组端口；</li>\n<li>-v，–volume：绑定一个卷</li>\n<li>–rm：容器退出后会自动清理，–rm 不能与 -d 同时使用（或者说同时使用没有意义）</li>\n<li>-c：容器运行起来后要执行的命令</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker run -d \\ #以后台形式运行，如果是-i -t就是以交互形式运行</span><br><span class=\"line\">--name mynginx \\ #自定义容器名字</span><br><span class=\"line\">-p 8000:80 \\ #主机端口:容器端口</span><br><span class=\"line\">-e &quot;ENV_OPTS=test&quot; \\ #环境参数</span><br><span class=\"line\">-v /test:/usr/share/nginx/html \\ #挂载目录，主机文件目录:容器文件目录</span><br><span class=\"line\">-c bash \\ #容器运行起来后要执行的命令</span><br><span class=\"line\">nginx:1.17</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"操作容器\"><a href=\"#操作容器\" class=\"headerlink\" title=\"操作容器\"></a>操作容器</h3><h4 id=\"启动已存在的容器\"><a href=\"#启动已存在的容器\" class=\"headerlink\" title=\"启动已存在的容器\"></a>启动已存在的容器</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker start [NAME]/[CONTAINER ID]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重启正在运行的容器\"><a href=\"#重启正在运行的容器\" class=\"headerlink\" title=\"重启正在运行的容器\"></a>重启正在运行的容器</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker restart [NAME]/[CONTAINER ID]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"暂停容器中所有的进程\"><a href=\"#暂停容器中所有的进程\" class=\"headerlink\" title=\"暂停容器中所有的进程\"></a>暂停容器中所有的进程</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker pause [NAME]/[CONTAINER ID]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"恢复容器中所有的进程\"><a href=\"#恢复容器中所有的进程\" class=\"headerlink\" title=\"恢复容器中所有的进程\"></a>恢复容器中所有的进程</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker unpause [NAME]/[CONTAINER ID]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"停止容器\"><a href=\"#停止容器\" class=\"headerlink\" title=\"停止容器\"></a>停止容器</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker stop [NAME]/[CONTAINER ID]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"强制停止容器\"><a href=\"#强制停止容器\" class=\"headerlink\" title=\"强制停止容器\"></a>强制停止容器</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker kill [NAME]/[CONTAINER ID]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"停止所有容器\"><a href=\"#停止所有容器\" class=\"headerlink\" title=\"停止所有容器\"></a>停止所有容器</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker stop $(docker ps -aq)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><p>有两种方式，第一种是使用 <code>docker attach</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker attach [NAME]/[CONTAINER ID]</span><br></pre></td></tr></table></figure>\n<p>第二种是使用 <code>docker exec</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker exec [OPTIONS] [NAME]/[CONTAINER ID] COMMAND [ARG...]</span><br></pre></td></tr></table></figure>\n<p>options说明：</p>\n<ul>\n<li>-d：分离模式，在后台运行</li>\n<li>-i：即使没有附加也保持STDIN 打开</li>\n<li>-t：分配一个伪终端</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it daemon_dave /bin/bash</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>attach 和 exec 的区别：</p>\n<ul>\n<li>attach把标准输出输入连接到容器内的PID1，所有的窗口都会同步显示。如果有一个窗口阻塞了，那么其他窗口也无法再进行操作；使用attach连接容器，退出的时候容器也会被关闭。所以attach太适合于生产环境。</li>\n<li>exec：不同终端连接到不同的tty，使用exec连接容器，退出的时候容器不会被关闭。</li>\n</ul>\n</blockquote>\n<h3 id=\"查看容器信息\"><a href=\"#查看容器信息\" class=\"headerlink\" title=\"查看容器信息\"></a>查看容器信息</h3><h4 id=\"查看当前运行的所有容器\"><a href=\"#查看当前运行的所有容器\" class=\"headerlink\" title=\"查看当前运行的所有容器\"></a>查看当前运行的所有容器</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker ps [options]</span><br></pre></td></tr></table></figure>\n<p>options说明：</p>\n<ul>\n<li>-a：显示所有的容器，包括未运行的。</li>\n<li>-f：根据条件过滤显示的内容。</li>\n<li>–format：指定返回值的模板文件。</li>\n<li>-l：显示最近创建的容器。</li>\n<li>-n：列出最近创建的n个容器。</li>\n<li>–no-trunc：不截断输出。</li>\n<li>-q：静默模式，只显示容器编号。</li>\n<li>-s：显示总的文件大小。</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 列出所有的容器 ID</span><br><span class=\"line\">$ docker ps -aq</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查看指定容器详细信息\"><a href=\"#查看指定容器详细信息\" class=\"headerlink\" title=\"查看指定容器详细信息\"></a>查看指定容器详细信息</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker inspect [NAME]/[CONTAINER ID]</span><br></pre></td></tr></table></figure>\n<h4 id=\"查看容器内部进程\"><a href=\"#查看容器内部进程\" class=\"headerlink\" title=\"查看容器内部进程\"></a>查看容器内部进程</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker top [NAME]/[CONTAINER ID]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"统计容器信息\"><a href=\"#统计容器信息\" class=\"headerlink\" title=\"统计容器信息\"></a>统计容器信息</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker stats [NAME]/[CONTAINER ID]</span><br></pre></td></tr></table></figure>\n<h4 id=\"查看容器日志\"><a href=\"#查看容器日志\" class=\"headerlink\" title=\"查看容器日志\"></a>查看容器日志</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker logs [OPTIONS] [NAME]/[CONTAINER ID]</span><br></pre></td></tr></table></figure>\n<p>options说明：</p>\n<ul>\n<li>-f：跟踪日志输出</li>\n<li>–since：显示某个开始时间的所有日志</li>\n<li>-t：显示时间戳</li>\n<li>–tail：仅列出最新N条容器日志</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查看容器mynginx从2016年7月1日后的最新10条日志。</span><br><span class=\"line\">$ docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h3><h4 id=\"删除未停止的容器\"><a href=\"#删除未停止的容器\" class=\"headerlink\" title=\"删除未停止的容器\"></a>删除未停止的容器</h4><p>删除一个或多个容器，在删除需要先停止容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker rm [OPTIONS] [NAME]/[CONTAINER ID]</span><br></pre></td></tr></table></figure>\n<p>OPTIONS说明：</p>\n<ul>\n<li>-f：通过 SIGKILL 信号强制删除一个运行中的容器。</li>\n<li>-l：移除容器间的网络连接，而非容器本身。</li>\n<li>-v：删除与容器关联的卷。</li>\n</ul>\n<h4 id=\"删除所有已停止容器\"><a href=\"#删除所有已停止容器\" class=\"headerlink\" title=\"删除所有已停止容器\"></a>删除所有已停止容器</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker container prune -f</span><br><span class=\"line\">或</span><br><span class=\"line\">$ docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"容器和宿主机间传递文件\"><a href=\"#容器和宿主机间传递文件\" class=\"headerlink\" title=\"容器和宿主机间传递文件\"></a>容器和宿主机间传递文件</h3><p>不管容器有没有启动，拷贝命令都会生效。</p>\n<h4 id=\"从容器拷贝文件到宿主机\"><a href=\"#从容器拷贝文件到宿主机\" class=\"headerlink\" title=\"从容器拷贝文件到宿主机\"></a>从容器拷贝文件到宿主机</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker cp mycontainer:/opt/testnew/file.txt /opt/test/</span><br></pre></td></tr></table></figure>\n<h4 id=\"从宿主机拷贝文件到容器\"><a href=\"#从宿主机拷贝文件到容器\" class=\"headerlink\" title=\"从宿主机拷贝文件到容器\"></a>从宿主机拷贝文件到容器</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker cp /opt/test/file.txt mycontainer:/opt/testnew/</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、镜像\"><a href=\"#三、镜像\" class=\"headerlink\" title=\"三、镜像\"></a>三、镜像</h2><h3 id=\"查看镜像列表\"><a href=\"#查看镜像列表\" class=\"headerlink\" title=\"查看镜像列表\"></a>查看镜像列表</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>\n<p>options说明：</p>\n<ul>\n<li>-a：列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li>\n<li>–digests：显示镜像的摘要信息；</li>\n<li>-f：显示满足条件的镜像；</li>\n<li>–format：指定返回值的模板文件；</li>\n<li>–no-trunc：显示完整的镜像信息；</li>\n<li>-q：只显示镜像ID。</li>\n</ul>\n<h3 id=\"创建镜像\"><a href=\"#创建镜像\" class=\"headerlink\" title=\"创建镜像\"></a>创建镜像</h3><h4 id=\"使用-docker-commit-创建镜像\"><a href=\"#使用-docker-commit-创建镜像\" class=\"headerlink\" title=\"使用 docker commit 创建镜像\"></a>使用 <code>docker commit</code> 创建镜像</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker commit [OPTIONS] [NAME]/[CONTAINER ID] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>\n<p>options说明：</p>\n<ul>\n<li>-a：提交的镜像作者</li>\n<li>-c：使用Dockerfile指令来创建镜像</li>\n<li>-m：提交时的说明文字</li>\n<li>-p：在commit时，将容器暂停</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 基于当前运行的容器 my_ubuntu 创建镜像 ubuntu:v1.0</span><br><span class=\"line\">$ docker commit my_ubuntu ubuntu:v1.0</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用-docker-build-创建镜像\"><a href=\"#使用-docker-build-创建镜像\" class=\"headerlink\" title=\"使用 docker build 创建镜像\"></a>使用 <code>docker build</code> 创建镜像</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure>\n<p>可以使用本地或者远程 Dockerfile 文件来创建镜像：</p>\n<ul>\n<li>PATH：本地路径，包括<code>.</code>表示当前目录。例如基于当前目录上下文：<code>docker build .</code></li>\n<li>URL：远程路径。例如使用github仓库地址：<code>docker build github.com/creack/docker-firefox</code></li>\n<li>-：不使用指定上下文，从 STDIN 读取 Dockerfile，也可以把 Dockerfile 通过 STDIN 传入：<code>docker build - &lt; Dockerfile</code>。</li>\n</ul>\n<p>options说明：</p>\n<ul>\n<li>–build-arg&#x3D;[]\t设置镜像创建时的变量</li>\n<li>–cpu-shares\t设置 cpu 使用权重</li>\n<li>–cpu-period\t限制 CPU CFS周期</li>\n<li>–cpu-quota\t限制 CPU CFS配额</li>\n<li>–cpuset-cpus\t指定使用的CPU id</li>\n<li>–cpuset-mems\t指定使用的内存 id</li>\n<li>–disable-content-trust\t忽略校验，默认开启</li>\n<li>-f\t指定要使用的Dockerfile路径</li>\n<li>–force-rm\t设置镜像过程中删除中间容器</li>\n<li>–isolation\t使用容器隔离技术</li>\n<li>–label&#x3D;[]\t设置镜像使用的元数据</li>\n<li>-m\t设置内存最大值</li>\n<li>–memory-swap\t设置 Swap 的最大值为内存 +swap，”-1”表示不限 swap</li>\n<li>–no-cache\t创建镜像的过程不使用缓存</li>\n<li>–pull\t尝试去更新镜像的新版本</li>\n<li>-q\t安静模式，成功后只输出镜像ID</li>\n<li>–rm\t设置镜像成功后删除中间容器</li>\n<li>–shm-size\t设置&#x2F;dev&#x2F;shm的大小，默认值是64M</li>\n<li>–ulimit\tUlimit配置</li>\n<li>–tag, -t 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li>\n</ul>\n<p>示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。</span><br><span class=\"line\">$ docker build -t runoob/ubuntu:v1 .</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定Dockerfile 文件的位置，但还是基于当前目录上下文</span><br><span class=\"line\">$ docker build -f /path/to/a/Dockerfile .</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像</span><br><span class=\"line\">$ docker build github.com/creack/docker-firefox</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重命名镜像\"><a href=\"#重命名镜像\" class=\"headerlink\" title=\"重命名镜像\"></a>重命名镜像</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker tag IMAGE[:TAG] [REGISTORY/][USERNAME/]NAME[:TAG]</span><br></pre></td></tr></table></figure>\n<p>示例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像</span><br><span class=\"line\">$ docker tag ubuntu:15.10 runoob/ubuntu:v3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看镜像历史\"><a href=\"#查看镜像历史\" class=\"headerlink\" title=\"查看镜像历史\"></a>查看镜像历史</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker history [OPTIONS] REPOSITORY[:TAG]</span><br></pre></td></tr></table></figure>\n<p>OPTIONS说明：</p>\n<ul>\n<li>-H：以可读的格式打印镜像大小和日期，默认为true；</li>\n<li>–no-trunc：显示完整的提交记录；</li>\n<li>-q：仅列出提交记录ID。</li>\n</ul>\n<h3 id=\"删除镜像\"><a href=\"#删除镜像\" class=\"headerlink\" title=\"删除镜像\"></a>删除镜像</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker rmi [OPTIONS] REPOSITORY[:TAG]</span><br></pre></td></tr></table></figure>\n<p>options说明：</p>\n<ul>\n<li>-f：强制删除</li>\n<li>–no-prune：不移除该镜像的过程镜像，默认移除</li>\n</ul>\n<h4 id=\"删除所有镜像\"><a href=\"#删除所有镜像\" class=\"headerlink\" title=\"删除所有镜像\"></a>删除所有镜像</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker rmi $(docker images -q)</span><br><span class=\"line\">或</span><br><span class=\"line\">$ docker image prune -af</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、仓库\"><a href=\"#四、仓库\" class=\"headerlink\" title=\"四、仓库\"></a>四、仓库</h2><h3 id=\"登陆远程仓库\"><a href=\"#登陆远程仓库\" class=\"headerlink\" title=\"登陆远程仓库\"></a>登陆远程仓库</h3><p>登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker login [OPTIONS] [SERVER]</span><br></pre></td></tr></table></figure>\n<p>OPTIONS说明：</p>\n<ul>\n<li>-u：登陆的用户名</li>\n<li>-p：登陆的密码</li>\n</ul>\n<h3 id=\"登出远程仓库\"><a href=\"#登出远程仓库\" class=\"headerlink\" title=\"登出远程仓库\"></a>登出远程仓库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker logout</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在仓库中查找镜像\"><a href=\"#在仓库中查找镜像\" class=\"headerlink\" title=\"在仓库中查找镜像\"></a>在仓库中查找镜像</h3><p>默认从Docker Hub查找镜像</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure>\n<ul>\n<li>–automated：只列出 automated build类型的镜像；</li>\n<li>–no-trunc：显示完整的镜像描述；</li>\n<li>-f &lt;过滤条件&gt;：列出收藏数不小于指定值的镜像。</li>\n</ul>\n<h3 id=\"从仓库拉取镜像\"><a href=\"#从仓库拉取镜像\" class=\"headerlink\" title=\"从仓库拉取镜像\"></a>从仓库拉取镜像</h3><p>从镜像仓库拉取镜像，如果不加 tag 默认拉取 latest 镜像。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker pull [OPTIONS] REPOSITORY[:TAG]</span><br></pre></td></tr></table></figure>\n<p>options说明：</p>\n<ul>\n<li>-a：拉取所有 tagged 镜像</li>\n<li>–disable-content-trust：忽略镜像的校验,默认开启</li>\n</ul>\n<h3 id=\"上传镜像到仓库\"><a href=\"#上传镜像到仓库\" class=\"headerlink\" title=\"上传镜像到仓库\"></a>上传镜像到仓库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker push REPOSITORY[:TAG]</span><br></pre></td></tr></table></figure>\n","categories":["docker"],"tags":["docker"]},{"title":"docker系列（三）：Dockerfile","url":"/2021/04/06/docker%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ADockerfile/","content":"<blockquote>\n<p>docker系列（二）：Dockerfile</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"一、Dockerfile是什么\"><a href=\"#一、Dockerfile是什么\" class=\"headerlink\" title=\"一、Dockerfile是什么\"></a>一、Dockerfile是什么</h2><p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明，通过 <code>docker build</code> 命令执行 Dockerfile 文件，可以构建一个Docker镜像。</p>\n<p>Dockerfile 的文件命名就为 <code>Dockerfile</code>，文本格式是一行行指令，每个指令有一个命令和参数组成，类似于命令行可执行文件。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># FROM指令指定基础镜像</span><br><span class=\"line\">FROM ubuntu:latest</span><br><span class=\"line\"></span><br><span class=\"line\"># COPY指令用于复制文件</span><br><span class=\"line\">COPY /myapp/target/myapp.jar /myapp/myapp.jar</span><br><span class=\"line\"></span><br><span class=\"line\"># CMD指令指定容器启动时执行的命令</span><br><span class=\"line\">CMD echo Starting Docker Container</span><br></pre></td></tr></table></figure>\n\n<p>一般会把 Dockerfile 放在一个空目录里面，这个目录里面的文件就称为 build 的上下文。移动到 Dockerfile 所在的目录，然后执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker build -t REPOSITORY/IMAGE:TAG .</span><br></pre></td></tr></table></figure>\n<p>指定自定义镜像名称，生成新的镜像。</p>\n<h2 id=\"二、Dockerfile原理\"><a href=\"#二、Dockerfile原理\" class=\"headerlink\" title=\"二、Dockerfile原理\"></a>二、Dockerfile原理</h2><h3 id=\"Dockerfile上下文\"><a href=\"#Dockerfile上下文\" class=\"headerlink\" title=\"Dockerfile上下文\"></a>Dockerfile上下文</h3><p>在使用 docker build 命令通过 Dockerfile 创建镜像时，会产生一个 <code>build 上下文(context)</code>。所谓的 build 上下文就是 docker build 命令的 PATH 或 URL 指定的路径中的文件的集合。<code>在镜像 build 过程中可以引用上下文中的任何文件，但不能引用上下文以外的文件</code>。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker build .</span><br></pre></td></tr></table></figure>\n<p><code>.</code>就指定了当前目录为上下文环境。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure>\n<p>指定了 Dockerfile 文件的位置，但上下文环境还是当前目录。也就是 <code>Dockerfile 文件和上下文环境可以不在同一个目录</code>。</p>\n<p>对于 COPY 和 ADD 命令来说，如果要把本地的文件拷贝到镜像中，那么本地的文件必须是在上下文目录中的文件。因为在执行 build 命令时，docker 客户端会把上下文中的所有文件发送给 docker daemon。考虑 docker 客户端和 docker daemon 不在同一台机器上的情况，build 命令只能从上下文中获取文件。如果我们在 Dockerfile 的 COPY 和 ADD 命令中引用了上下文中没有的文件，就会收到类似下面的错误：<br><img src=\"/2021/04/06/docker%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ADockerfile/image-20230705175422573.png\" alt=\"image-20230705175422573\"></p>\n<p><code>一般情况下 build 上下文应该为一个空文件夹</code>。因为 docker 客户端会将上下文的全部内容挂载到 docker daemon。如果使用包含很多内容的目录例如根目录 <code>/</code> 作为 PATH，会将硬盘驱动器的全部内容全部暴露，增加系统风险。</p>\n<h3 id=\"Dockerfile缓存\"><a href=\"#Dockerfile缓存\" class=\"headerlink\" title=\"Dockerfile缓存\"></a>Dockerfile缓存</h3><p>Dockerfile 是由一行行指令组成的，每一行指令都会产生一行<code>镜像缓存</code>。如下 Dockerfile 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">FROM busybox:latest</span><br><span class=\"line\">COPY a.txt /usr/a.txt</span><br><span class=\"line\">CMD echo &quot;hello busybox&quot;</span><br></pre></td></tr></table></figure>\n<p>执行 docker build，输出内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo docker build -t test_busybox:v1.0 .</span><br><span class=\"line\">[sudo] password for mcb: </span><br><span class=\"line\">Sending build context to Docker daemon   2.56kB</span><br><span class=\"line\">Step 1/3 : FROM busybox:latest</span><br><span class=\"line\"> ---&gt; 62aedd01bd85</span><br><span class=\"line\">Step 2/3 : COPY a.txt /usr/a.txt</span><br><span class=\"line\"> ---&gt; c0dcd0ba7521</span><br><span class=\"line\">Step 3/3 : CMD echo &quot;hello busybox&quot;</span><br><span class=\"line\"> ---&gt; Running in ee7acd2e64f4</span><br><span class=\"line\">Removing intermediate container ee7acd2e64f4</span><br><span class=\"line\"> ---&gt; 8bf7d58518fb</span><br><span class=\"line\">Successfully built 8bf7d58518fb</span><br><span class=\"line\">Successfully tagged test_busybox:v1.0</span><br></pre></td></tr></table></figure>\n<p>生成镜像 <code>test_busybox:v1.0</code>，Dockerfile 的三条指令分别对应 Step 1-3，生成了三层镜像缓存。如果我们再修改一下 Dockerfile，增加一条指令 <code>ENV MY_VAR 123</code>，变成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">FROM busybox:latest</span><br><span class=\"line\">COPY a.txt /usr/a.txt</span><br><span class=\"line\">ENV MY_VAR 123</span><br><span class=\"line\">CMD echo &quot;hello busybox&quot;</span><br></pre></td></tr></table></figure>\n<p>再执行 docker build，输出内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo docker build -t test_busybox:v2.0 .</span><br><span class=\"line\">Sending build context to Docker daemon   2.56kB</span><br><span class=\"line\">Step 1/4 : FROM busybox:latest</span><br><span class=\"line\"> ---&gt; 62aedd01bd85</span><br><span class=\"line\">Step 2/4 : COPY a.txt /usr/a.txt</span><br><span class=\"line\"> ---&gt; Using cache</span><br><span class=\"line\"> ---&gt; c0dcd0ba7521</span><br><span class=\"line\">Step 3/4 : ENV MY_VAR 123</span><br><span class=\"line\"> ---&gt; Running in 4397c65fbca8</span><br><span class=\"line\">Removing intermediate container 4397c65fbca8</span><br><span class=\"line\"> ---&gt; 3f24a6cb1c21</span><br><span class=\"line\">Step 4/4 : CMD echo &quot;hello busybox&quot;</span><br><span class=\"line\"> ---&gt; Running in ec8f2c77bb95</span><br><span class=\"line\">Removing intermediate container ec8f2c77bb95</span><br><span class=\"line\"> ---&gt; ab7efbf4edfd</span><br><span class=\"line\">Successfully built ab7efbf4edfd</span><br><span class=\"line\">Successfully tagged test_busybox:v2.0</span><br></pre></td></tr></table></figure>\n<p>生成镜像 <code>test_busybox:v2.0</code>，Step 也变成 4 步，注意 Step 2&#x2F;4 里面，有一句 <code>Using cache</code>，这里使用了上一步构建产生的缓存层 <code>c0dcd0ba7521</code>。所以每次 docker build 都会尽量去复用已经存在的镜像缓冲层，这样可以节省磁盘空间和提高构建速度。我们也可以指定 <code>--no-cache</code> 参数，表示不使用已有的镜像缓存，这样每步 Step 都会生成新的镜像缓存。</p>\n<p>如果我们对同一个 Dockerfile 执行多次 docker build，如果文件内容不变，只是修改生成镜像的名称，不会生成多个镜像，只会保留一个镜像，镜像名称是最后执行 docker build 指定的命名。</p>\n<p>注意，<code>这里的镜像缓冲层和 overlay2 里面的 layer 不是同一个概念</code>。overlay2 的 layer 保存在 <code>/var/lib/docker/overlay2</code> 目录，而镜像缓冲层保存 <code>/var/lib/docker/image/overlay2/imagedb/</code> 目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">root:/var/lib/docker$ find . -name &quot;c0dcd0ba7521*&quot;</span><br><span class=\"line\">./image/overlay2/imagedb/metadata/sha256/c0dcd0ba752121cf93931167a9e75e5dcc59a0dd5f0e249083ac9ba6856e0679</span><br><span class=\"line\">./image/overlay2/imagedb/content/sha256/c0dcd0ba752121cf93931167a9e75e5dcc59a0dd5f0e249083ac9ba6856e0679</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"docker-build和docker-commit的区别\"><a href=\"#docker-build和docker-commit的区别\" class=\"headerlink\" title=\"docker build和docker commit的区别\"></a>docker build和docker commit的区别</h4><p>docker build 和 docker commit 都可以生成新的镜像，两者的区别是：</p>\n<ul>\n<li>使用 docker commit 方式创造的镜像，使用 docker history 看不到构建镜像过程中执行的命令。这意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知，后期极难维护。</li>\n<li>使用 docker build 方式创造的镜像，可以使用 docker history 清楚看到镜像构建过程中执行了哪些命令；能够自由灵活的与宿主机联系（docker commit因为在容器里面，无法做复制拷贝宿主机文件等动作）；后期可扩展性强，有一个 Dockerfile 文件就可以随时运行镜像了。</li>\n</ul>\n<p>例如使用 Dockerfile 生成镜像 test_busybox:v1.0</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">FROM busybox:latest</span><br><span class=\"line\">COPY a.txt /usr/a.txt</span><br><span class=\"line\">CMD echo &quot;hello busybox&quot;</span><br></pre></td></tr></table></figure>\n<p>使用 docker history 查看镜像，每一行都跟 Dockerfile 一一对应</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker history test_busybox:v1.0</span><br><span class=\"line\">IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT</span><br><span class=\"line\">8bf7d58518fb   36 minutes ago   /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo…   0B        </span><br><span class=\"line\">c0dcd0ba7521   36 minutes ago   /bin/sh -c #(nop) COPY file:39435c5f19162403…   0B        </span><br><span class=\"line\">62aedd01bd85   13 days ago      /bin/sh -c #(nop)  CMD [&quot;sh&quot;]                   0B        </span><br><span class=\"line\">&lt;missing&gt;      13 days ago      /bin/sh -c #(nop) ADD file:7edb4d0af355de4ed…   1.24MB </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"dockerignore\"><a href=\"#dockerignore\" class=\"headerlink\" title=\".dockerignore\"></a>.dockerignore</h4><p><code>.dockerignore</code> 文件的作用类似于 git 工程中的 <code>.gitignore</code> 。不同的是 <code>.dockerignore</code> 应用于 docker 镜像的构建，它存在于 docker 构建上下文的根目录，用来排除不需要上传到 docker 服务端的文件或目录。</p>\n<p>docker 在构建镜像时首先从构建上下文找有没有 <code>.dockerignore</code> 文件，如果有的话则在上传上下文到 docker 服务端时忽略掉 <code>.dockerignore</code> 里面的文件列表。这么做显然带来的好处是：</p>\n<ul>\n<li>构建镜像时能避免不需要的大文件上传到服务端，从而拖慢构建的速度、网络带宽的消耗；</li>\n<li>可以避免构建镜像时将一些敏感文件及其他不需要的文件打包到镜像中，从而提高镜像的安全性；</li>\n</ul>\n<p><code>.dockerignore</code> 文件的写法和 <code>.gitignore</code> 类似，支持正则和通配符，具体规则如下：</p>\n<ul>\n<li>每行为一个条目；</li>\n<li>以 <code>#</code> 开头的行为注释；</li>\n<li>空行被忽略；</li>\n<li>构建上下文路径为所有文件的根路径；</li>\n</ul>\n<p>文件匹配规则具体语法如下：</p>\n<table>\n<thead>\n<tr>\n<th>规则</th>\n<th>行为</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>*/temp*</code></td>\n<td>匹配根路径下一级目录下所有以 temp 开头的文件或目录</td>\n</tr>\n<tr>\n<td><code>*/*/temp*</code></td>\n<td>匹配根路径下两级目录下所有以 temp 开头的文件或目录</td>\n</tr>\n<tr>\n<td><code>temp?</code></td>\n<td>匹配根路径下以 temp 开头，任意一个字符结尾的文件或目录</td>\n</tr>\n<tr>\n<td><code>**/*.go</code></td>\n<td>匹配所有路径下以 .go 结尾的文件或目录，即递归搜索所有路径</td>\n</tr>\n<tr>\n<td><code>*.md !README.md</code></td>\n<td>匹配根路径下所有以 .md 结尾的文件或目录，但 README.md 除外</td>\n</tr>\n</tbody></table>\n<p>如果两个匹配语法规则有包含或者重叠关系，那么以后面的匹配规则为准。</p>\n<h2 id=\"三、Dockerfile指令\"><a href=\"#三、Dockerfile指令\" class=\"headerlink\" title=\"三、Dockerfile指令\"></a>三、Dockerfile指令</h2><h3 id=\"FROM\"><a href=\"#FROM\" class=\"headerlink\" title=\"FROM\"></a>FROM</h3><p>指定基础镜像，后续的操作都是基于基础镜像。一般 Dockerfile 文件都是以 FROM 开始，FROM 后面只跟一个基础镜像。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">FROM ubuntu:latest</span><br></pre></td></tr></table></figure>\n<p>在17.05版本之前的 Docker，只允许 Dockerfile 中出现一个 FROM 指令；Docker 17.05 版本以后允许 Dockerfile支持多个 FROM 指令，但是仍以最后一条 FROM 为准。</p>\n<p>多个 FROM 指令的意义是：每一条 FROM 指令都是一个构建阶段，多条 FROM 就是多阶段构建。虽然最后生成的镜像只能是最后一个阶段的结果，但是能够将前置阶段中的文件拷贝到后边的阶段中。</p>\n<h3 id=\"ARG\"><a href=\"#ARG\" class=\"headerlink\" title=\"ARG\"></a>ARG</h3><p>ARG 是唯一一个可以放在 FROM 语句之前的指令。ARG 指定可以定义变量，它的规则是：</p>\n<ul>\n<li>在 FROM 之前声明的 ARG 在构建阶段之外，所以只可以在 FROM 语句中使用，一般设置默认值。</li>\n<li>在 FROM 之后声明的 ARG 可以在声明后全局使用。</li>\n<li>构建 Docker 镜像时，必须为所有 ARG 提供值。如果没有设置默认值，必须在执行 docker build 命令通过 –build-arg 参数传进来；如果设置了默认值，可以通过 –build-arg 参数传入新的值，也可以不传参数使用默认值。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ARG VERSION=latest</span><br><span class=\"line\">FROM busybox:$VERSION</span><br><span class=\"line\"></span><br><span class=\"line\">ARG VERSION</span><br><span class=\"line\">RUN echo $VERSION &gt; image_version</span><br></pre></td></tr></table></figure>\n<p>第一个 VERSION 设置了默认值，但只能在 FROM 里面使用。第二个 VERSION 没有默认值，必须通过参数传进来。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker build --build-arg VERSION=v1.0 .</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MAINTAINER\"><a href=\"#MAINTAINER\" class=\"headerlink\" title=\"MAINTAINER\"></a>MAINTAINER</h3><p>MAINTAINER命令用于说明谁在维护这个Dockerfile文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">MAINTAINER Joe Blocks &lt;joe@blocks.com&gt;</span><br></pre></td></tr></table></figure>\n<p>MAINTAINER命令并不常用，因为这类信息在Git存储或其他地方有了。</p>\n<h3 id=\"USER\"><a href=\"#USER\" class=\"headerlink\" title=\"USER\"></a>USER</h3><p>USER 可以用来指定 USER 指令声明之后之后 RUN , CMD 和 ENTRYPOINT 运行容器和程序时的用户及用户组（如果不指定用户组，默认为root）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">USER mcb</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RUN\"><a href=\"#RUN\" class=\"headerlink\" title=\"RUN\"></a>RUN</h3><p>RUN 指令用于 在 Docker 镜像 build 过程中执行命令行指令，运行时会在当前镜像上创建一个新的文件层用来保存修改的数据。RUN 指令有 shell 和 exec 两种格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">RUN  (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)</span><br><span class=\"line\">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)</span><br></pre></td></tr></table></figure>\n<p>executable是一个可执行的文件，如果是 <code>/bin</code> 目录下的文件就不需要指定路径，否则就需要指定完整路径或者先通过 WORKDIR 切换到可执行文件所在的目录。<br>例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">RUN apt-get update -y &amp;&amp; apt-get install -y htop</span><br><span class=\"line\">或者</span><br><span class=\"line\">RUN [&quot;apt-get&quot;, &quot;update&quot;, &quot;-y&quot;]</span><br><span class=\"line\">RUN [&quot;apt-get&quot;, &quot;install&quot;, &quot;-y&quot;, &quot;htop&quot;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h3><p>CMD 命令用于指定启动 Docker 容器时需要执行的命令。也可以在 docker run 启动容器的时候通过命令行指定其他命令，命令行命令会覆盖 Dockerfile 里面的 CMD 命令。</p>\n<p>CMD 指令只能出现一次。如果 Dockerfile 中出现多个 CMD 指令，则另外的都会忽略，只有最后一个有效。</p>\n<p>CMD 指令也可以使用 shell 或 exec 格式，有三种形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, 首选方式)</span><br><span class=\"line\">CMD [&quot;param1&quot;,&quot;param2&quot;] (作为默认参数传递给ENTRYPOINT)</span><br><span class=\"line\">CMD command param1 param2 (shell form)</span><br></pre></td></tr></table></figure>\n\n<p>例如传递默认参数给ENTRYPOINT：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">FROM busybox</span><br><span class=\"line\">ENTRYPOINT [&quot;/bin/ping&quot;]</span><br><span class=\"line\">CMD [&quot;localhost&quot;]</span><br></pre></td></tr></table></figure>\n<p>最后在容器启动的时候执行的完整命令为：<code>/bin/ping localhost</code>。</p>\n<h3 id=\"ENTRYPOINT\"><a href=\"#ENTRYPOINT\" class=\"headerlink\" title=\"ENTRYPOINT\"></a>ENTRYPOINT</h3><p>ENTRYPOINT 指令也可以指定在容器启动时要执行的命令，他和 CMD 指令的区别是：ENTRYPOINT 不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。除非使用 –entrypoint 选项强行覆盖 ENTRYPOINT 指令。</p>\n<p>ENTRYPOINT 指令也只能出现一次。Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p>\n<p>ENTRYPOINT 也包含 shell 或 exec 两种格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form, 首选方式)</span><br><span class=\"line\">ENTRYPOINT command param1 param2 (shell form)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>RUN、CMD 和 ENTRYPOINT 的区别？</p>\n</blockquote>\n<ul>\n<li>RUN：在容器 build 阶段执行，可以有多个 RUN 命令。</li>\n<li>CMD：在容器 run 阶段启动的时候执行，提供默认命令及参数 (不一定会执行，只是默认) ，有可能会被 docker run 后面命令参数替换。CMD 指令也只能出现一次，如果存在多个 CMD 指令，仅最后一个生效。</li>\n<li>ENTRYPOINT：和 CMD 一样，在容器 run 阶段启动的时候执行，而且一定会执行。ENTRYPOINT 指令也只能出现一次，如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</li>\n</ul>\n<blockquote>\n<p>shell 和 exec 格式的区别？</p>\n</blockquote>\n<ul>\n<li>shell 格式：底层会调用 <code>/bin/sh -c</code> 来执行命令，可以解析变量。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ENV name Docker</span><br><span class=\"line\"></span><br><span class=\"line\"># 输出hello Docker</span><br><span class=\"line\">CMD echo &quot;hello $name&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># 上面等价于</span><br><span class=\"line\">CMD [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo hello $name&quot;]</span><br></pre></td></tr></table></figure></li>\n<li>exec 格式：需要指定使用什么脚本来执行，默认不能解析变量。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ENV name Docker</span><br><span class=\"line\"></span><br><span class=\"line\"># 这里会输出字符串hello $name，而不是hello Docker，因为$name没有被解析，直接被当作字符串输出了</span><br><span class=\"line\">ENTRYPOINT [&quot;echo&quot;, &quot;hello $name&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果要解析变量，需要指定bash脚本来执行</span><br><span class=\"line\">ENTRYPOINT [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello $name&quot;]</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"COPY\"><a href=\"#COPY\" class=\"headerlink\" title=\"COPY\"></a>COPY</h3><p>从上下文目录中复制文件或者目录到容器里指定路径。<br>例如复制文件：把主机的&#x2F;myapp&#x2F;target&#x2F;myapp.jar文件复制到Docker进行中的&#x2F;myapp&#x2F;myapp.jar文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPY /myapp/target/myapp.jar /myapp/myapp.jar</span><br></pre></td></tr></table></figure>\n<p>复制目录：把主机的&#x2F;myapp&#x2F;config&#x2F;prod目录复制到Docker镜像中的&#x2F;myapp&#x2F;config目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPY /myapp/config/prod /myapp/config</span><br></pre></td></tr></table></figure>\n<p>复制多个文件到Docker镜像中的一个目录中：将主机的&#x2F;myapp&#x2F;config&#x2F;prod&#x2F;conf1.cfg文件和&#x2F;myapp&#x2F;conig&#x2F;prod&#x2F;conf2.cfg文件复制到Docker镜像中的&#x2F;myapp&#x2F;config&#x2F;目录中。注意，目标目录必须以&#x2F;（斜杠）结束。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">COPY /myapp/config/prod/conf1.cfg /myapp/config/prod/conf2.cfg /myapp/config/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ADD\"><a href=\"#ADD\" class=\"headerlink\" title=\"ADD\"></a>ADD</h3><p>类似于 COPY，区别在于：</p>\n<ul>\n<li>可以添加远程服务器上的文件。这里下载远程地址的 myapp.jar 到 Docker 镜像的 &#x2F;myapp&#x2F; 目录中。如果是添加一个远程的压缩 tar 包，Docker 并不会解压这个文件。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ADD http://jenkov.com/myapp.jar /myapp/</span><br></pre></td></tr></table></figure></li>\n<li>添加的文件如果为打包文件 tar 格式或者压缩文件 gzip、bzip2、xz 格式，会自动复制并解压到。这里会解压 myapp.tar 到 Docker 镜像的 &#x2F;myapp&#x2F; 目录中。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ADD myapp.tar /myapp/</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"ENV\"><a href=\"#ENV\" class=\"headerlink\" title=\"ENV\"></a>ENV</h3><p>设置环境变量，在后续的指令或者在容器内部，通过 <code>$</code> 符号就可以使用这个环境变量。有两种格式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ENV &lt;key&gt; &lt;value&gt;</span><br><span class=\"line\">ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure>\n<p>例如设置变量BASE_URL</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ENV BASE_URL www.songpangpang.com</span><br><span class=\"line\">RUN curl -SLO &quot;https://$BASE_URL/&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"VOLUME\"><a href=\"#VOLUME\" class=\"headerlink\" title=\"VOLUME\"></a>VOLUME</h3><p>定义匿名数据卷。在启动容器时没有没有使用 <code>-v</code> 参数显式挂载数据卷，会自动挂载到匿名卷。挂载的意义是持久化保存在宿主机上，避免容器重启后数据丢失。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">VOLUME [&quot;/path1&quot;, &quot;/path2&quot;]</span><br><span class=\"line\">VOLUME /path</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WORKDIR\"><a href=\"#WORKDIR\" class=\"headerlink\" title=\"WORKDIR\"></a>WORKDIR</h3><p>用于设置 Dockerfile 中的 RUN、CMD 和 ENTRYPOINT 指令执行命令的工作目录（默认为根目录）。WORKDIR 指定的工作目录，必须是提前创建好的。</p>\n<p>WORKDIR 可以在一个 Dockerfile 中出现多次，如果使用相对路径，那它会相对于前面一个 WORKDIR 指令对应的目录。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">WORKDIR /a</span><br><span class=\"line\">WORKDIR b</span><br><span class=\"line\">WORKDIR c</span><br><span class=\"line\">RUN pwd</span><br></pre></td></tr></table></figure>\n<p>最后输出的路径为：<code>/a/b/c</code>。</p>\n<h3 id=\"EXPOSE\"><a href=\"#EXPOSE\" class=\"headerlink\" title=\"EXPOSE\"></a>EXPOSE</h3><p>暴露端口。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"LABEL\"><a href=\"#LABEL\" class=\"headerlink\" title=\"LABEL\"></a>LABEL</h3><p>LABEL 可以为镜像添加元数据，元数据以键值对的形式出现。推荐将所有的元数据放在同一条 label 指令。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>\n<p>可以通过 <code>docker inspect</code> 查看容器定义的 label。</p>\n<h3 id=\"HEALTHCHECK\"><a href=\"#HEALTHCHECK\" class=\"headerlink\" title=\"HEALTHCHECK\"></a>HEALTHCHECK</h3><p>定期执行健康检查，监视 Docker 容器中运行的应用程序的运行状况。如果命令返回 0，Docker 将认为应用程序和容器正常；如果命令返回 1，Docker 会认为应用程序和容器不正常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">HEALTHCHECK [options] &lt;命令&gt;</span><br></pre></td></tr></table></figure>\n<p>options说明：</p>\n<ul>\n<li>–interval：健康检查间隔时间，默认为30s</li>\n<li>–start-period：健康检查开始时间。有些应用程序可能需要一段时间启动，因此，只有经过某段时间后再进行健康检查才有意义。默认情况下，Docker会立即检查Docker容器的监控状况。</li>\n<li>–timeout：健康检查最大超时时间，如果健康检查超时，Docker也会认为容器不健康。</li>\n<li>–retries：监控检查最大重试次数。</li>\n</ul>\n<p>例如使用了java应用程序的com.jenkov.myapp.HealthCheck作为健康检查的命令，每60s执行一次。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">HEALTHCHECK --interval=60s java -cp com.jenkov.myapp.HealthCheck</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ONBUILD\"><a href=\"#ONBUILD\" class=\"headerlink\" title=\"ONBUILD\"></a>ONBUILD</h3><p>ONBUILD 是一个特殊的指令，后面跟的是其它指令。ONBUILD 指定的命令，在本次构建镜像的过程中不会执行；只有当以当前镜像为基础镜像（通过  FROM 引用），去构建下一级镜像的时候才会被执行。</p>\n<p>例如使用以下 Dockerfile 构建镜像 my-node，三行 ONBUILD 指令不会执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">FROM node:slim</span><br><span class=\"line\">RUN mkdir /app</span><br><span class=\"line\">WORKDIR /app</span><br><span class=\"line\">ONBUILD COPY ./package.json /app</span><br><span class=\"line\">ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]</span><br><span class=\"line\">ONBUILD COPY . /app/</span><br><span class=\"line\">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure>\n<p>新的 Dockerfile 以 my-node 作为基础镜像引入时，之前基础镜像的那三行 ONBUILD 就会开始执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">FROM my-node</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、Dockerfile实战\"><a href=\"#四、Dockerfile实战\" class=\"headerlink\" title=\"四、Dockerfile实战\"></a>四、Dockerfile实战</h2><p>通过基础镜像 centos:7，在该镜像中安装 jdk 和 tomcat 以后将其制作为一个新的镜像 mycentos:7。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 指明构建的新镜像是来自于 centos:7 基础镜像</span><br><span class=\"line\">FROM centos:7</span><br><span class=\"line\"># 通过镜像标签声明了作者信息</span><br><span class=\"line\">LABEL maintainer=&quot;mrhelloworld.com&quot;</span><br><span class=\"line\"># 设置工作目录</span><br><span class=\"line\">WORKDIR /usr/local</span><br><span class=\"line\"># 新镜像构建成功以后创建指定目录</span><br><span class=\"line\">RUN mkdir -p /usr/local/java &amp;&amp; mkdir -p /usr/local/tomcat</span><br><span class=\"line\"># 拷贝文件到镜像中并解压</span><br><span class=\"line\">ADD jdk-11.0.6_linux-x64_bin.tar.gz /usr/local/java</span><br><span class=\"line\">ADD apache-tomcat-9.0.37.tar.gz /usr/local/tomcat</span><br><span class=\"line\"># 暴露容器运行时的 8080 监听端口给外部</span><br><span class=\"line\">EXPOSE 8080</span><br><span class=\"line\"># 设置容器内 JAVA_HOME 环境变量</span><br><span class=\"line\">ENV JAVA_HOME /usr/local/java/jdk-11.0.6/</span><br><span class=\"line\">ENV PATH $PATH:$JAVA_HOME/bin</span><br><span class=\"line\"># 启动容器时启动 tomcat 并查看 tomcat 日志信息</span><br><span class=\"line\">ENTRYPOINT /usr/local/tomcat/apache-tomcat-9.0.37/bin/startup.sh &amp;&amp; tail -f /usr/local/tomcat/apache-tomcat-9.0.37/logs/catalina.out</span><br></pre></td></tr></table></figure>\n","categories":["docker"],"tags":["docker"]},{"title":"docker系列（四）：Docker Compose","url":"/2021/04/08/docker%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ADocker-Compose/","content":"<blockquote>\n<p>docker系列（四）：Docker Compose</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"一、Docker-Compose-基础\"><a href=\"#一、Docker-Compose-基础\" class=\"headerlink\" title=\"一、Docker Compose 基础\"></a>一、Docker Compose 基础</h2><h3 id=\"Docker-Compose是什么\"><a href=\"#Docker-Compose是什么\" class=\"headerlink\" title=\"Docker Compose是什么\"></a>Docker Compose是什么</h3><p>Docker Compose 是单个宿主机上快速编排多个容器的工具。使用 Docker Compose 不再需要使用 shell 脚本来启动容器。 </p>\n<p>Compose 通过一个配置文件来管理多个 Docker 容器，在配置文件中，所有的容器通过 services 来定义，然后使用 docker-compose 脚本来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器，非常适合组合使用多个容器进行开发的场景。</p>\n<p>使用 Docker Compose 的步骤如下：</p>\n<ul>\n<li>新建空目录作为 Docker Compose 的根目录。</li>\n<li>定义容器资源，新建 <code>Dockerfile</code> 文件定义容器启动需要的资源，并把容器需要的所有资源移动到根目录下。</li>\n<li>编排服务，新建 <code>docker-compose.yml</code> 配置文件，编排服务启动顺序和依赖关系。</li>\n<li>在根目录下执行 <code>docker-compose up</code> 启动所有容器。</li>\n</ul>\n<p><code>docker-compose.yml</code> 典型示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># yaml 配置实例</span><br><span class=\"line\">version: &#x27;3&#x27;</span><br><span class=\"line\">services:</span><br><span class=\"line\">  web:</span><br><span class=\"line\">    build: .</span><br><span class=\"line\">    ports:</span><br><span class=\"line\">   - &quot;5000:5000&quot;</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">   - .:/code</span><br><span class=\"line\">    - logvolume01:/var/log</span><br><span class=\"line\">    links:</span><br><span class=\"line\">   - redis</span><br><span class=\"line\">  redis:</span><br><span class=\"line\">    image: redis</span><br><span class=\"line\">volumes:</span><br><span class=\"line\">  logvolume01: &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Docker-Compose安装\"><a href=\"#Docker-Compose安装\" class=\"headerlink\" title=\"Docker Compose安装\"></a>Docker Compose安装</h3><p>安装可能需要 root 权限。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo pip install -U docker-compose</span><br></pre></td></tr></table></figure>\n\n<p>查看是否安装成功</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-compose --version</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、-Docker-Compose-配置文件\"><a href=\"#二、-Docker-Compose-配置文件\" class=\"headerlink\" title=\"二、 Docker Compose 配置文件\"></a>二、 Docker Compose 配置文件</h2><p>Docker Compose 使用 YAML 文件来定义多服务的应用。文件可以命名为：</p>\n<ul>\n<li><code>compose.yaml</code>（官方推荐）</li>\n<li><code>compose.yml</code></li>\n<li><code>docker-compose.yaml</code></li>\n<li><code>docker-compose.yml</code></li>\n</ul>\n<p>一个完整的 docker-compose.yml 使用示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">services:</span><br><span class=\"line\">  frontend:</span><br><span class=\"line\">    image: awesome/webapp</span><br><span class=\"line\">    ports:</span><br><span class=\"line\">      - &quot;443:8043&quot;</span><br><span class=\"line\">    networks:</span><br><span class=\"line\">      - front-tier</span><br><span class=\"line\">      - back-tier</span><br><span class=\"line\">    configs:</span><br><span class=\"line\">      - httpd-config</span><br><span class=\"line\">    secrets:</span><br><span class=\"line\">      - server-certificate</span><br><span class=\"line\"></span><br><span class=\"line\">  backend:</span><br><span class=\"line\">    image: awesome/database</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - db-data:/etc/data</span><br><span class=\"line\">    networks:</span><br><span class=\"line\">      - back-tier</span><br><span class=\"line\"></span><br><span class=\"line\">volumes:</span><br><span class=\"line\">  db-data:</span><br><span class=\"line\">    driver: flocker</span><br><span class=\"line\">    driver_opts:</span><br><span class=\"line\">      size: &quot;10GiB&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">configs:</span><br><span class=\"line\">  httpd-config:</span><br><span class=\"line\">    external: true</span><br><span class=\"line\"></span><br><span class=\"line\">secrets:</span><br><span class=\"line\">  server-certificate:</span><br><span class=\"line\">    external: true</span><br><span class=\"line\"></span><br><span class=\"line\">networks:</span><br><span class=\"line\">  # The presence of these objects is sufficient to define them</span><br><span class=\"line\">  front-tier: &#123;&#125;</span><br><span class=\"line\">  back-tier: &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>启动一个前端服务 webapp 和一个后端服务 database</li>\n<li>为 webapp 配置 front-tier 网络、back-tier 网络和 sercret 验证</li>\n<li>为 database 配置持久化卷。</li>\n<li>webapp 和 database 通过 back-tier 网络进行通讯。</li>\n</ul>\n<p>整体架构如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">(External user) --&gt; 443 [frontend network]</span><br><span class=\"line\">                            |</span><br><span class=\"line\">                  +--------------------+</span><br><span class=\"line\">                  |  frontend service  |...ro...&lt;HTTP configuration&gt;</span><br><span class=\"line\">                  |      &quot;webapp&quot;      |...ro...&lt;server certificate&gt; #secured</span><br><span class=\"line\">                  +--------------------+</span><br><span class=\"line\">                            |</span><br><span class=\"line\">                        [backend network]</span><br><span class=\"line\">                            |</span><br><span class=\"line\">                  +--------------------+</span><br><span class=\"line\">                  |  backend service   |  r+w   ___________________</span><br><span class=\"line\">                  |     &quot;database&quot;     |=======( persistent volume )</span><br><span class=\"line\">                  +--------------------+        \\_________________/</span><br></pre></td></tr></table></figure>\n\n<p>下面是配置文件常用的一级标签：</p>\n<ul>\n<li><p><code>version</code> ：版本，已废弃。Compose 文件格式有 3 个版本，分别为 <code>1</code>、<code>2.x</code> 和 <code>3.x</code>。目前主流的为 3.x，支持 docker 1.13.0 以上的版本。官方的态度来说，version 字段即将被废弃。如果不加 version 字段启动失败，可以加个 <code>version: &quot;3.9&quot;</code>。</p>\n</li>\n<li><p><code>services</code> ：必须字段，定义所有的容器服务。</p>\n</li>\n<li><p><code>networks</code>：配置容器连接的网络，用于容器间的通讯。</p>\n</li>\n<li><p><code>volumes</code>：挂载一个目录或者一个已存在的数据卷容器。</p>\n</li>\n<li><p><code>secrets</code>：存储敏感数据，例如服务密码。</p>\n</li>\n<li><p>2 services, backed by Docker images: webapp and database</p>\n</li>\n<li><p>1 secret (HTTPS certificate), injected into the frontend</p>\n</li>\n<li><p>1 configuration (HTTP), injected into the frontend</p>\n</li>\n<li><p>1 persistent volume, attached to the backend</p>\n</li>\n<li><p>2 networks</p>\n</li>\n</ul>\n<h3 id=\"services\"><a href=\"#services\" class=\"headerlink\" title=\"services\"></a>services</h3><p>services 标签是使用最频繁的字段，而且是必须字段。用来定义所有的容器服务</p>\n<h4 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"build\"></a>build</h4><p>指定构建镜像的上下文路径。该路径可以使用绝对路径，也可以使用相对路径（根目录为 Compose 文件所在目录），该路径里面必须包含 Dockerfile 文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">services:</span><br><span class=\"line\">  webapp:</span><br><span class=\"line\">    build: ./dir</span><br></pre></td></tr></table></figure>\n<p>build 字段也可以使用子字段进行更加详细的配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">services:</span><br><span class=\"line\">  webapp:</span><br><span class=\"line\">    build:</span><br><span class=\"line\">      context: ./dir</span><br><span class=\"line\">      dockerfile: Dockerfile-alternate</span><br><span class=\"line\">      args:</span><br><span class=\"line\">        buildno: 1</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        - &quot;com.example.description=Accounting webapp&quot;</span><br><span class=\"line\">        - &quot;com.example.department=Finance&quot;</span><br><span class=\"line\">        - &quot;com.example.label-with-empty-value&quot;</span><br><span class=\"line\">      target: prod</span><br></pre></td></tr></table></figure>\n<ul>\n<li>context：必须字段，上下文路径。</li>\n<li>dockerfile：指定构建镜像的 Dockerfile 文件名。</li>\n<li>args：添加构建参数，这是只能在构建过程中访问的环境变量。</li>\n<li>labels：设置构建镜像的标签。</li>\n<li>target：多层构建，可以指定构建哪一层。</li>\n</ul>\n<h4 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a>image</h4><p>指定容器运行的镜像。以下格式都可以：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">image: redis</span><br><span class=\"line\">image: ubuntu:14.04</span><br><span class=\"line\">image: tutum/influxdb</span><br><span class=\"line\">image: example-registry.com:4000/postgresql</span><br><span class=\"line\">image: a4bc65fd # 镜像id</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"container-name\"><a href=\"#container-name\" class=\"headerlink\" title=\"container_name\"></a>container_name</h4><p>指定一个自定义容器名称。如果不指定，容器名称默认以 Compose 文件所在目录名称为前缀。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">container_name: my-web-container</span><br></pre></td></tr></table></figure>\n<p>由于Docker容器名称必须是唯一的，因此如果指定了自定义名称，则无法将服务扩展到多个容器。</p>\n<h4 id=\"volumes\"><a href=\"#volumes\" class=\"headerlink\" title=\"volumes\"></a>volumes</h4><p>卷挂载路径设置。设置格式有：</p>\n<ul>\n<li><code>宿主机路径:容器路径</code></li>\n<li><code>宿主机路径:容器路径:访问模式</code><br>例如：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">volumes:</span><br><span class=\"line\">  # 只需指定一个路径，让引擎创建一个卷</span><br><span class=\"line\">  - /var/lib/mysql</span><br><span class=\"line\"> </span><br><span class=\"line\">  # 指定绝对路径映射</span><br><span class=\"line\">  - /opt/data:/var/lib/mysql</span><br><span class=\"line\"> </span><br><span class=\"line\">  # 相对于当前compose文件的相对路径</span><br><span class=\"line\">  - ./cache:/tmp/cache</span><br><span class=\"line\"> </span><br><span class=\"line\">  # 用户家目录相对路径，而且使用只读模式</span><br><span class=\"line\">  - ~/configs:/etc/configs/:ro</span><br><span class=\"line\"> </span><br><span class=\"line\">  # 命名卷</span><br><span class=\"line\">  - datavolume:/var/lib/mysql</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"command\"><a href=\"#command\" class=\"headerlink\" title=\"command\"></a>command</h4><p>覆盖容器启动后默认执行的命令。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">command: bundle exec thin -p 3000</span><br><span class=\"line\">command: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"entrypoint\"><a href=\"#entrypoint\" class=\"headerlink\" title=\"entrypoint\"></a>entrypoint</h4><p>覆盖容器默认的 entrypoint。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">entrypoint: /code/entrypoint.sh</span><br></pre></td></tr></table></figure>\n<p>也可以是以下格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">entrypoint:</span><br><span class=\"line\">    - php</span><br><span class=\"line\">    - -d</span><br><span class=\"line\">    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</span><br><span class=\"line\">    - -d</span><br><span class=\"line\">    - memory_limit=-1</span><br><span class=\"line\">    - vendor/bin/phpunit</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"depends-on\"><a href=\"#depends-on\" class=\"headerlink\" title=\"depends_on\"></a>depends_on</h4><p>设置依赖关系。</p>\n<ul>\n<li>docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。</li>\n<li>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。</li>\n<li>docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">version: &quot;3.7&quot;</span><br><span class=\"line\">services:</span><br><span class=\"line\">  web:</span><br><span class=\"line\">    build: .</span><br><span class=\"line\">    depends_on:</span><br><span class=\"line\">      - db</span><br><span class=\"line\">      - redis</span><br><span class=\"line\">  redis:</span><br><span class=\"line\">    image: redis</span><br><span class=\"line\">  db:</span><br><span class=\"line\">    image: postgres</span><br></pre></td></tr></table></figure>\n注意：web 服务不会等待 redis db 完全启动 之后才启动。</li>\n</ul>\n<h4 id=\"environment\"><a href=\"#environment\" class=\"headerlink\" title=\"environment\"></a>environment</h4><p>添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">environment:</span><br><span class=\"line\">  RACK_ENV: development</span><br><span class=\"line\">  SHOW: &#x27;true&#x27;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ports\"><a href=\"#ports\" class=\"headerlink\" title=\"ports\"></a>ports</h4><p>映射端口到宿主机上，格式为 <code>宿主机端口:容器端口</code> 或者仅仅指定容器的端口（宿主将会随机选择端口）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ports:</span><br><span class=\"line\"> - &quot;3000&quot;</span><br><span class=\"line\"> - &quot;3000-3005&quot;</span><br><span class=\"line\"> - &quot;8000:8000&quot;</span><br><span class=\"line\"> - &quot;9090-9091:8080-8081&quot;</span><br><span class=\"line\"> - &quot;49100:22&quot;</span><br><span class=\"line\"> - &quot;127.0.0.1:8001:8001&quot;</span><br><span class=\"line\"> - &quot;127.0.0.1:5000-5010:5000-5010&quot;</span><br><span class=\"line\"> - &quot;6060:6060/udp&quot;</span><br></pre></td></tr></table></figure>\n<p>当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 你可能会得到错误得结果，因为 YAML 将会解析 xx:yy 这种数字格式为 60 进制。所以建议采用字符串格式。</p>\n<h4 id=\"expose\"><a href=\"#expose\" class=\"headerlink\" title=\"expose\"></a>expose</h4><p>暴露端口，但不映射到宿主机，只被连接的服务访问。 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">expose:</span><br><span class=\"line\"> - &quot;3000&quot;</span><br><span class=\"line\"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"healthcheck\"><a href=\"#healthcheck\" class=\"headerlink\" title=\"healthcheck\"></a>healthcheck</h4><p>用于检测 docker 服务是否健康运行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">healthcheck:</span><br><span class=\"line\">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;] # 设置检测程序</span><br><span class=\"line\">  interval: 1m30s # 设置检测间隔</span><br><span class=\"line\">  timeout: 10s # 设置检测超时时间</span><br><span class=\"line\">  retries: 3 # 设置重试次数</span><br><span class=\"line\">  start_period: 40s # 启动后，多少秒开始启动检测程序</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"network-mode\"><a href=\"#network-mode\" class=\"headerlink\" title=\"network_mode\"></a>network_mode</h4><p>设置网络模式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">network_mode: &quot;bridge&quot;</span><br><span class=\"line\">network_mode: &quot;host&quot;</span><br><span class=\"line\">network_mode: &quot;none&quot;</span><br><span class=\"line\">network_mode: &quot;service:[service name]&quot;</span><br><span class=\"line\">network_mode: &quot;container:[container name/id]&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"restart\"><a href=\"#restart\" class=\"headerlink\" title=\"restart\"></a>restart</h4><ul>\n<li>no：是默认的重启策略，在任何情况下都不会重启容器。</li>\n<li>always：容器总是重新启动。</li>\n<li>on-failure：在容器非正常退出时（退出状态非0），才会重启容器。</li>\n<li>unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">restart: &quot;no&quot;</span><br><span class=\"line\">restart: always</span><br><span class=\"line\">restart: on-failure</span><br><span class=\"line\">restart: unless-stopped</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"volumes-1\"><a href=\"#volumes-1\" class=\"headerlink\" title=\"volumes\"></a>volumes</h3><p>挂载一个目录或者一个已存在的数据卷容器，作用是：</p>\n<ul>\n<li><p>重用数据卷。可以将主机路径挂载为单个服务定义的一部分，无需在一级<code>volumes</code>键中定义它。但是想在多个服务中重用一个卷，则需要在一级volumes 中定义一个命名卷。</p>\n</li>\n<li><p>保护宿主机文件。可以直接使用<code>HOST:CONTAINER</code>这样的格式，或者使用<code>HOST:CONTAINER:ro</code>这样的格式，后者对于容器来说，数据卷是只读的，这样可以有效保护宿主机的文件系统。</p>\n</li>\n</ul>\n<p>如下实例，web 服务使用命名卷 (<code>mydata</code>)，以及为单个服务定义的绑定安装（<code>db</code>service下的第一个路径<code>volumes</code>）。<code>db</code>服务还使用名为<code>dbdata</code>（<code>db</code>service下的第二个路径<code>volumes</code>）的命名卷，使用了旧字符串格式定义它以安装命名卷。命名卷必须列在顶级<code>volumes</code>键下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">version: &quot;3.9&quot;</span><br><span class=\"line\">services:</span><br><span class=\"line\">  web:</span><br><span class=\"line\">    image: nginx:alpine</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - type: volume</span><br><span class=\"line\">        source: mydata</span><br><span class=\"line\">        target: /data</span><br><span class=\"line\">        volume:</span><br><span class=\"line\">          nocopy: true</span><br><span class=\"line\">      - type: bind</span><br><span class=\"line\">        source: ./static</span><br><span class=\"line\">        target: /opt/app/static</span><br><span class=\"line\"></span><br><span class=\"line\">  db:</span><br><span class=\"line\">    image: postgres:latest</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - &quot;/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock&quot;</span><br><span class=\"line\">      - &quot;dbdata:/var/lib/postgresql/data&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">volumes:</span><br><span class=\"line\">  mydata:</span><br><span class=\"line\">  dbdata:</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"简短语法\"><a href=\"#简短语法\" class=\"headerlink\" title=\"简短语法\"></a>简短语法</h4><p>简短语法使用通用<code>[SOURCE:]TARGET[:MODE]</code>格式，其中 <code>SOURCE</code>可以是主机路径或卷名。<code>TARGET</code>是安装卷的容器路径。标准模式<code>ro</code>用于只读和<code>rw</code>读写（默认）。</p>\n<p>您可以在主机上挂载一个相对路径，该路径相对于正在使用的 Compose 配置文件的目录展开。相对路径应始终以<code>.</code>或开头<code>..</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">volumes:</span><br><span class=\"line\">  # Just specify a path and let the Engine create a volume</span><br><span class=\"line\">  - /var/lib/mysql</span><br><span class=\"line\"></span><br><span class=\"line\">  # Specify an absolute path mapping</span><br><span class=\"line\">  - /opt/data:/var/lib/mysql</span><br><span class=\"line\"></span><br><span class=\"line\">  # Path on the host, relative to the Compose file</span><br><span class=\"line\">  - ./cache:/tmp/cache</span><br><span class=\"line\"></span><br><span class=\"line\">  # User-relative path</span><br><span class=\"line\">  - ~/configs:/etc/configs/:ro</span><br><span class=\"line\"></span><br><span class=\"line\">  # 命名卷</span><br><span class=\"line\">  - datavolume:/var/lib/mysql</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"长语法\"><a href=\"#长语法\" class=\"headerlink\" title=\"长语法\"></a>长语法</h4><ul>\n<li><code>type</code>: 安装类型， <code>bind</code>,<code>tmpfs</code>或<code>npipe</code></li>\n<li><code>source</code>: 安装源、主机上用于绑定安装的路径或在顶级volumes 中定义的卷的名称 。不适用于 tmpfs 挂载。</li>\n<li><code>target</code>：安装卷的容器中的路径</li>\n<li><code>read_only</code>: 将卷设置为只读的标志</li>\n<li><code>bind</code>: 配置额外的绑定选项</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">version: &quot;3.9&quot;</span><br><span class=\"line\">services:</span><br><span class=\"line\">  web:</span><br><span class=\"line\">    image: nginx:alpine</span><br><span class=\"line\">    ports:</span><br><span class=\"line\">      - &quot;80:80&quot;</span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - type: volume</span><br><span class=\"line\">        source: mydata</span><br><span class=\"line\">        target: /data</span><br><span class=\"line\">        volume:</span><br><span class=\"line\">          nocopy: true</span><br><span class=\"line\">      - type: bind</span><br><span class=\"line\">        source: ./static</span><br><span class=\"line\">        target: /opt/app/static</span><br><span class=\"line\"></span><br><span class=\"line\">networks:</span><br><span class=\"line\">  webnet:</span><br><span class=\"line\"></span><br><span class=\"line\">volumes:</span><br><span class=\"line\">  mydata:</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"networks\"><a href=\"#networks\" class=\"headerlink\" title=\"networks\"></a>networks</h3><p>默认情况下，Compose 会创建一个默认网络，<code>services</code> 服务的所有容器都加入默认网络，并且可以被该网络上的其他容器访问。我们可以创建通过 <code>networks</code> 自定义更复杂的网络，在相同网络下的容器可以进行通讯。例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">version: &quot;3&quot;</span><br><span class=\"line\">services:</span><br><span class=\"line\"></span><br><span class=\"line\">  proxy:</span><br><span class=\"line\">    build: ./proxy</span><br><span class=\"line\">    networks:</span><br><span class=\"line\">      - frontend</span><br><span class=\"line\">  app:</span><br><span class=\"line\">    build: ./app</span><br><span class=\"line\">    networks:</span><br><span class=\"line\">      - frontend</span><br><span class=\"line\">      - backend</span><br><span class=\"line\">  db:</span><br><span class=\"line\">    image: postgres</span><br><span class=\"line\">    networks:</span><br><span class=\"line\">      - backend</span><br><span class=\"line\"></span><br><span class=\"line\">networks:</span><br><span class=\"line\">  frontend:</span><br><span class=\"line\">    # Use a custom driver</span><br><span class=\"line\">    driver: custom-driver-1</span><br><span class=\"line\">  backend:</span><br><span class=\"line\">    # Use a custom driver which takes special options</span><br><span class=\"line\">    driver: custom-driver-2</span><br><span class=\"line\">    driver_opts:</span><br><span class=\"line\">      foo: &quot;1&quot;</span><br><span class=\"line\">      bar: &quot;2&quot;</span><br></pre></td></tr></table></figure>\n\n<p>一级配置<code>networks</code> 创建了自定义的网络 。这里配置了两个<code>frontend</code>和<code>backend</code> ，且自定义了网络类型。每一个services下，<code>proxy</code> , <code>app</code> , <code>db</code>都定义了<code>networks</code>配置。</p>\n<ol>\n<li><code>proxy</code> 只加入到 <code>frontend</code>网络。</li>\n<li><code>db</code> 只加入到<code>backend</code>网络。</li>\n<li><code>app</code>同时加入到 <code>frontend</code>和<code>backend</code> 。</li>\n<li><code>db</code>和<code>proxy</code>不能通讯，因为不在一个网络中。</li>\n<li><code>app</code>和两个都能通讯，因为<code>app</code>在两个网络中都有配置。</li>\n<li><code>db</code>和<code>proxy</code>要通讯，只能通过<code>app</code>这个应用来连接。</li>\n</ol>\n<h3 id=\"secrets\"><a href=\"#secrets\" class=\"headerlink\" title=\"secrets\"></a>secrets</h3><h4 id=\"简短语法-1\"><a href=\"#简短语法-1\" class=\"headerlink\" title=\"简短语法\"></a>简短语法</h4><p>简短的语法仅指定机密名称。以下示例授予<code>redis</code>服务对<code>my_secret</code>和<code>my_other_secret</code>机密的访问权限。<code>./my_secret.txt</code>文件的内容被设置为 my_secret，<code>my_other_secret</code>被定义为外部机密，这意味着它已经在Docker中定义，无论是通过运行<code>docker secret create</code>命令还是通过另一个堆栈部署，都不会重新创建。如果外部机密不存在，堆栈部署将失败并显示<code>secret not found</code>错误。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">version: &quot;3.9&quot;</span><br><span class=\"line\">services:</span><br><span class=\"line\">  redis:</span><br><span class=\"line\">    image: redis:latest</span><br><span class=\"line\">    deploy:</span><br><span class=\"line\">      replicas: 1</span><br><span class=\"line\">    secrets:</span><br><span class=\"line\">      - my_secret</span><br><span class=\"line\">      - my_other_secret</span><br><span class=\"line\">secrets:</span><br><span class=\"line\">  my_secret:</span><br><span class=\"line\">    file: ./my_secret.txt</span><br><span class=\"line\">  my_other_secret:</span><br><span class=\"line\">    external: true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"长语法-1\"><a href=\"#长语法-1\" class=\"headerlink\" title=\"长语法\"></a>长语法</h4><ul>\n<li><code>source</code>：定义机密标识符。</li>\n<li><code>target</code>：要挂载在<code>/run/secrets/</code>服务的任务容器中的文件的名称，默认是 source。</li>\n<li><code>uid</code>和<code>gid</code>：<code>/run/secrets/</code>在服务的任务容器中拥有文件的数字 UID 或 GID 。</li>\n<li><code>mode</code>：要挂载在<code>/run/secrets/</code> 服务的任务容器中的文件的权限，以八进制表示法。例如，<code>0444</code> 代表可读。</li>\n</ul>\n<p>下面的示例表示将my_secret 命名为<code>redis_secret</code>，模式为<code>0440</code>（组可读），和用户组为<code>103</code>。该<code>redis</code>服务无权访问该<code>my_other_secret</code>机密。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">version: &quot;3.9&quot;</span><br><span class=\"line\">services:</span><br><span class=\"line\">  redis:</span><br><span class=\"line\">    image: redis:latest</span><br><span class=\"line\">    deploy:</span><br><span class=\"line\">      replicas: 1</span><br><span class=\"line\">    secrets:</span><br><span class=\"line\">      - source: my_secret</span><br><span class=\"line\">        target: redis_secret</span><br><span class=\"line\">        uid: &#x27;103&#x27;</span><br><span class=\"line\">        gid: &#x27;103&#x27;</span><br><span class=\"line\">        mode: 0440</span><br><span class=\"line\">secrets:</span><br><span class=\"line\">  my_secret:</span><br><span class=\"line\">    file: ./my_secret.txt</span><br><span class=\"line\">  my_other_secret:</span><br><span class=\"line\">    external: true</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、Docker-Compose-命令\"><a href=\"#三、Docker-Compose-命令\" class=\"headerlink\" title=\"三、Docker Compose 命令\"></a>三、Docker Compose 命令</h2><p>docker-compose 命令需要在 Compose 文件所在目录下执行的，基本格式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-compose [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure>\n<p>options说明</p>\n<ul>\n<li>-f, –file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。</li>\n<li>-p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。</li>\n<li>–verbose 输出更多调试信息。</li>\n<li>-v, –version 打印版本并退出。</li>\n</ul>\n<p>详细参考 <a href=\"https://yeasy.gitbook.io/docker_practice/compose/commands\">这里</a></p>\n<h3 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-compose up [options] [SERVICE...]</span><br></pre></td></tr></table></figure>\n<p>options说明：</p>\n<ul>\n<li>-d 在后台运行服务容器。</li>\n<li>–no-color 不使用颜色来区分不同的服务的控制台输出。</li>\n<li>–no-deps 不启动服务所链接的容器。</li>\n<li>–force-recreate 强制重新创建容器，不能与 –no-recreate 同时使用。</li>\n<li>–no-recreate 如果容器已经存在了，则不重新创建，不能与 –force-recreate 同时使用。</li>\n<li>–no-build 不自动构建缺失的服务镜像。</li>\n<li>-t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</li>\n</ul>\n<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。链接的服务都将会被自动启动，除非已经处于运行状态。可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>\n<p>常用的有两种格式：</p>\n<ul>\n<li><code>docker-compose up</code>：默认情况，启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。当通过 Ctrl-C 停止命令时，所有容器将会停止。</li>\n<li><code>docker-compose up -d</code>，后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</li>\n</ul>\n<p>默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 docker-compose up –no-recreate。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 docker-compose up –no-deps -d <SERVICE_NAME> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>\n<h3 id=\"列出所有服务\"><a href=\"#列出所有服务\" class=\"headerlink\" title=\"列出所有服务\"></a>列出所有服务</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-compose ps</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重新构建服务\"><a href=\"#重新构建服务\" class=\"headerlink\" title=\"重新构建服务\"></a>重新构建服务</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-compose build</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"停止服务\"><a href=\"#停止服务\" class=\"headerlink\" title=\"停止服务\"></a>停止服务</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-compose down</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"查看服务日志\"><a href=\"#查看服务日志\" class=\"headerlink\" title=\"查看服务日志\"></a>查看服务日志</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-compose logs</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动已存在的服务\"><a href=\"#启动已存在的服务\" class=\"headerlink\" title=\"启动已存在的服务\"></a>启动已存在的服务</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-compose start</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"停止已运行的服务\"><a href=\"#停止已运行的服务\" class=\"headerlink\" title=\"停止已运行的服务\"></a>停止已运行的服务</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-compose stop</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"重启服务\"><a href=\"#重启服务\" class=\"headerlink\" title=\"重启服务\"></a>重启服务</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker-compose restart</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h2><p><a href=\"https://zhuanlan.zhihu.com/p/387840381\">docker compose 配置文件 .yml 全面指南</a></p>\n","categories":["docker"],"tags":["docker"]},{"title":"docker系列：安装常用软件","url":"/2021/04/10/docker%E7%B3%BB%E5%88%97%EF%BC%9A%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/","content":"<blockquote>\n<p>docker系列：安装常用软件</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h3 id=\"使用原则\"><a href=\"#使用原则\" class=\"headerlink\" title=\"使用原则\"></a>使用原则</h3><ol>\n<li>要明确版本，不能用latest，方便后期管理</li>\n<li>尽量把目录挂在出来，下面的操作有都有一个预启动的过程，把目录挂载出来后，再把预启动的容器删掉，再使用挂载目录的启动命令。</li>\n<li>尽量不要使用默认的网络，而是使用本地网桥进行通讯</li>\n</ol>\n<h3 id=\"本地网桥\"><a href=\"#本地网桥\" class=\"headerlink\" title=\"本地网桥\"></a>本地网桥</h3><p>本地网桥用于本地容器间可以通过127.0.0.1的地址进行通信。</p>\n<h4 id=\"创建网桥\"><a href=\"#创建网桥\" class=\"headerlink\" title=\"创建网桥\"></a>创建网桥</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker network create local-bridge</span><br></pre></td></tr></table></figure>\n<h4 id=\"查看网桥\"><a href=\"#查看网桥\" class=\"headerlink\" title=\"查看网桥\"></a>查看网桥</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker network inspect local-bridge</span><br></pre></td></tr></table></figure>\n<p>local-bridge的地址为172.19.0.2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;Containers&quot;: &#123;</span><br><span class=\"line\">    &quot;93cc041fd02115e6ac0d380974c24b3cd8283a6be27cbdbd6619555ce24f0afe&quot;: &#123;</span><br><span class=\"line\">        &quot;Name&quot;: &quot;zookeeper&quot;,</span><br><span class=\"line\">        &quot;EndpointID&quot;: &quot;cd362e7c273845977994c176c2bca47a8055eee0420236d489f6957b3bccd116&quot;,</span><br><span class=\"line\">        &quot;MacAddress&quot;: &quot;02:42:ac:13:00:02&quot;,</span><br><span class=\"line\">        &quot;IPv4Address&quot;: &quot;172.19.0.2/16&quot;,</span><br><span class=\"line\">        &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull zookeeper:3.6.3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"首次启动\"><a href=\"#首次启动\" class=\"headerlink\" title=\"首次启动\"></a>首次启动</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">--net=local-bridge \\</span><br><span class=\"line\">-p 2181:2181 \\</span><br><span class=\"line\">-v ~/docker/zookeeper/data:/data \\</span><br><span class=\"line\">-v ~/docker/zookeeper/config:/conf \\</span><br><span class=\"line\">--name zookeeper zookeeper:3.6.3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it zookeeper /bin/bash</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><h3 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull redis:6.0.6</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"首次启动-1\"><a href=\"#首次启动-1\" class=\"headerlink\" title=\"首次启动\"></a>首次启动</h3><p>redis默认是没有配置的，需要手动加配置，外面挂载data目录和配置文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">-p 6379:6379 \\</span><br><span class=\"line\">-v ~/docker/redis/data:/data \\</span><br><span class=\"line\">-v ~/docker/redis/config/redis.conf:/etc/redis/redis.conf \\</span><br><span class=\"line\">--name redis redis:6.0.6 \\</span><br><span class=\"line\">redis-server /etc/redis/redis.conf \\</span><br><span class=\"line\">--appendonly yes</span><br></pre></td></tr></table></figure>\n<p>然后修改redis.conf</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#把这行注释掉，否则只能本机访问</span><br><span class=\"line\"># bin 127.0.0.1</span><br><span class=\"line\"></span><br><span class=\"line\">#把yes改为no</span><br><span class=\"line\">protected-mode no</span><br><span class=\"line\"></span><br><span class=\"line\">#默认是没有密码的，如果需要密码就把前面的#去掉</span><br><span class=\"line\"># requirepass root</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进入容器-1\"><a href=\"#进入容器-1\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it redis /bin/bash</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h2><h3 id=\"安装-2\"><a href=\"#安装-2\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull bitnami/kafka:2.8.1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"首次启动-2\"><a href=\"#首次启动-2\" class=\"headerlink\" title=\"首次启动\"></a>首次启动</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">--net=local-bridge \\</span><br><span class=\"line\">-p 9092:9092 \\</span><br><span class=\"line\">-e KAFKA_BROKER_ID=0 \\</span><br><span class=\"line\">-e KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \\</span><br><span class=\"line\">-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://localhost:9092 \\</span><br><span class=\"line\">-e ALLOW_PLAINTEXT_LISTENER=yes \\</span><br><span class=\"line\">-v ~/docker/kafka/data:/bitnami/kafka/data \\</span><br><span class=\"line\">-v ~/docker/kafka/config:/opt/bitnami/kafka/config \\</span><br><span class=\"line\">-v ~/docker/kafka/logs:/opt/bitnami/kafka/logs \\</span><br><span class=\"line\">--name kafka bitnami/kafka:2.8.1</span><br></pre></td></tr></table></figure>\n<p>主目录是<code>/opt/bitnami/kafka</code>，数据目录是<code>/bitnami/kafka/data</code>，数据目录是在server.properties中配置的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log.dirs=/bitnami/kafka/data</span><br></pre></td></tr></table></figure>\n<p>如果因为找不到配置文件启动失败，可以使用不带挂载目录参数的命令启动，把&#x2F;opt&#x2F;bitnami&#x2F;kafka&#x2F;config下的文件全部拷贝到宿主机上</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker cp kafka:/opt/bitnami/kafka/config/ ~/docker/config/kafka/</span><br></pre></td></tr></table></figure>\n<p>删除容器，再使用带挂载目录参数的命令启动新容器</p>\n<h3 id=\"进入容器-2\"><a href=\"#进入容器-2\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it kafka /bin/bash</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Rocketmq\"><a href=\"#Rocketmq\" class=\"headerlink\" title=\"Rocketmq\"></a>Rocketmq</h2><h3 id=\"安装-3\"><a href=\"#安装-3\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull apache/rocketmq:4.9.4</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"首次启动-3\"><a href=\"#首次启动-3\" class=\"headerlink\" title=\"首次启动\"></a>首次启动</h3><p>主目录是<code>/home/rocketmq/rocketmq-4.9.4/</code>。挂载目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker cp rmqnamesrv:/home/rocketmq/rocketmq-4.9.4/conf/ /Users/mochuangbiao/docker/rocketmq/config/</span><br></pre></td></tr></table></figure>\n<p>启动nameserver</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">--net=local-bridge \\</span><br><span class=\"line\">-p 9876:9876 \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/rocketmq/logs/nameserver:/home/rocketmq/logs \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/rocketmq/data/nameserver:/home/rocketmq/store \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/rocketmq/config:/home/rocketmq/rocketmq-4.9.4/conf \\</span><br><span class=\"line\">--name rmqnamesrv apache/rocketmq:4.9.4 \\</span><br><span class=\"line\">sh mqnamesrv </span><br></pre></td></tr></table></figure>\n<p>启动broker</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">--net=local-bridge \\</span><br><span class=\"line\">-p 10911:10911 \\</span><br><span class=\"line\">-p 10909:10909 \\</span><br><span class=\"line\">-e &quot;NAMESRV_ADDR=rmqnamesrv:9876&quot; \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/rocketmq/logs/broker:/home/rocketmq/logs \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/rocketmq/data/broker:/home/rocketmq/store \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/rocketmq/config:/home/rocketmq/rocketmq-4.9.4/conf \\</span><br><span class=\"line\">--name rmqbroker apache/rocketmq:4.9.4 \\</span><br><span class=\"line\">sh mqbroker -c /home/rocketmq/rocketmq-4.9.4/conf/broker.conf </span><br></pre></td></tr></table></figure>\n<p>启动console</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">--net=local-bridge \\</span><br><span class=\"line\">-p 8080:8080 \\</span><br><span class=\"line\">-e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=rmqnamesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot; \\</span><br><span class=\"line\">--name rmqconsole styletang/rocketmq-console-ng</span><br></pre></td></tr></table></figure>\n<p>访问地址 <a href=\"http://locahost:8080，注意broker和console的-e参数要么使用nameserver的容器昵称`rmqnamesrv`，要么使用本地的ip\">http://locahost:8080，注意broker和console的-e参数要么使用nameserver的容器昵称`rmqnamesrv`，要么使用本地的ip</a> <code>192.168.50.105</code>。如果使用本地IP，另外还要修改 <code>broker.conf</code>，增加</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">namesrvAddr=192.168.50.105:9876</span><br><span class=\"line\">brokerIP1=192.168.50.105</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进入容器-3\"><a href=\"#进入容器-3\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><p>进入nameserver</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it rmqnamesrv /bin/bash</span><br></pre></td></tr></table></figure>\n<p>进入broker</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it rmqbroker /bin/bash</span><br></pre></td></tr></table></figure>\n<p>进入console</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it rmqconsole /bin/bash</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h2><h3 id=\"安装-4\"><a href=\"#安装-4\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull nginx:1.22.0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"首次启动-4\"><a href=\"#首次启动-4\" class=\"headerlink\" title=\"首次启动\"></a>首次启动</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">-p 9001:80 \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/nginx/config/nginx.conf:/etc/nginx/nginx.conf \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/nginx/config/conf.d:/etc/nginx/conf.d \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/nginx/logs:/var/log/nginx \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/nginx/data:/usr/share/nginx/html \\</span><br><span class=\"line\">--name nginx nginx:1.22.0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进入容器-4\"><a href=\"#进入容器-4\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it nginx /bin/bash</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Apache\"><a href=\"#Apache\" class=\"headerlink\" title=\"Apache\"></a>Apache</h2><h3 id=\"安装-5\"><a href=\"#安装-5\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull httpd:2.4.54</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"首次启动-5\"><a href=\"#首次启动-5\" class=\"headerlink\" title=\"首次启动\"></a>首次启动</h3><p>挂载文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker cp apache:/usr/local/apache2/conf/httpd.conf /Users/mochuangbiao/docker/apache/conf</span><br></pre></td></tr></table></figure>\n<p>启动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">-p 8004:80 \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/apache/www/:/usr/local/apache2/htdocs/ \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/apache/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/apache/logs:/usr/local/apache2/logs/ \\</span><br><span class=\"line\">--name apache httpd:2.4.54</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进入容器-5\"><a href=\"#进入容器-5\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it apache /bin/bash</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Elasticsearch\"><a href=\"#Elasticsearch\" class=\"headerlink\" title=\"Elasticsearch\"></a>Elasticsearch</h2><h3 id=\"安装-6\"><a href=\"#安装-6\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull elasticsearch:8.4.3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"临时启动\"><a href=\"#临时启动\" class=\"headerlink\" title=\"临时启动\"></a>临时启动</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d --name elasticsearch  -p 9200:9200 -p 9300:9300 -e  &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms256m -Xmx256m&quot; elasticsearch:8.4.3</span><br></pre></td></tr></table></figure>\n<p>挂载文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -p /Users/mochuangbiao/docker/elasticsearch/&#123;config,data,logs,plugins&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">docker cp elasticsearch:/usr/share/elasticsearch/config /Users/mochuangbiao/docker/elasticsearch</span><br><span class=\"line\">docker cp elasticsearch:/usr/share/elasticsearch/logs /Users/mochuangbiao/docker/elasticsearch</span><br><span class=\"line\">docker cp elasticsearch:/usr/share/elasticsearch/data /Users/mochuangbiao/docker/elasticsearch</span><br><span class=\"line\">docker cp elasticsearch:/usr/share/elasticsearch/plugins /Users/mochuangbiao/docker/elasticsearch</span><br></pre></td></tr></table></figure>\n<p>v8之后默认开启关闭x-pack的安全功能，需要手动关闭。修改 &#x2F;data&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 关闭账号密码登陆</span><br><span class=\"line\">xpack.security.enabled: false</span><br><span class=\"line\"></span><br><span class=\"line\"># 关闭enrollment token登陆</span><br><span class=\"line\">xpack.security.enrollment.enabled: false</span><br><span class=\"line\"></span><br><span class=\"line\"># 关闭ssl登陆</span><br><span class=\"line\">xpack.security.http.ssl:</span><br><span class=\"line\">  enabled: false</span><br><span class=\"line\">  keystore.path: certs/http.p12</span><br></pre></td></tr></table></figure>\n<h3 id=\"首次启动-6\"><a href=\"#首次启动-6\" class=\"headerlink\" title=\"首次启动\"></a>首次启动</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">-p 9200:9200 \\</span><br><span class=\"line\">-p 9300:9300 \\</span><br><span class=\"line\">--net=local-bridge \\</span><br><span class=\"line\">-e &quot;discovery.type=single-node&quot; \\</span><br><span class=\"line\">-e ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot; \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/elasticsearch/logs:/usr/share/elasticsearch/logs \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/elasticsearch/data:/usr/share/elasticsearch/data \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/elasticsearch/plugins:/usr/share/elasticsearch/plugins \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/elasticsearch/config:/usr/share/elasticsearch/config \\</span><br><span class=\"line\">--name elasticsearch elasticsearch:8.4.3</span><br></pre></td></tr></table></figure>\n<p>访问地址 <a href=\"http://localhost:9200，正常返回即为成功\">http://localhost:9200，正常返回即为成功</a></p>\n<p>开机自启动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker update elasticsearch --restart=always</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进入容器-6\"><a href=\"#进入容器-6\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it elasticsearch /bin/bash</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Kibana\"><a href=\"#Kibana\" class=\"headerlink\" title=\"Kibana\"></a>Kibana</h2><h3 id=\"安装-7\"><a href=\"#安装-7\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull kibana:8.4.3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"临时启动-1\"><a href=\"#临时启动-1\" class=\"headerlink\" title=\"临时启动\"></a>临时启动</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d --name kibana -p 5601:5601 kibana:8.4.3</span><br></pre></td></tr></table></figure>\n<p>挂载文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -p /Users/mochuangbiao/docker/kibana/config</span><br><span class=\"line\"></span><br><span class=\"line\">docker cp kibana:/usr/share/kibana/config /Users/mochuangbiao/docker/kibana</span><br></pre></td></tr></table></figure>\n<h3 id=\"首次启动-7\"><a href=\"#首次启动-7\" class=\"headerlink\" title=\"首次启动\"></a>首次启动</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">-p 5601:5601 \\</span><br><span class=\"line\">--net=local-bridge \\</span><br><span class=\"line\">-v /Users/mochuangbiao/docker/kibana/config:/usr/share/kibana/config \\</span><br><span class=\"line\">--name kibana kibana:8.4.3</span><br></pre></td></tr></table></figure>\n<p>访问地址：<a href=\"http://localhost:5601/\">http://localhost:5601</a><br>注意如果没有关闭 es 的安全性校验，在第一次登录的时候会提示输入 enrollment token。<br>enrollment token 在第一个 Elasticsearch 启动后的有效时间为30分钟。超过30分钟的时间上述 token 将会无效。enrollment token分两个，一个是kibana连接es使用的，另一个是es加入集群使用的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 先进入已经启动的es集群中路径或者容器中</span><br><span class=\"line\">$ docker exec -it es-node1 </span><br><span class=\"line\">$ /bin/bash cd /usr/share/elasticsearch </span><br><span class=\"line\"></span><br><span class=\"line\"># kibana使用的 </span><br><span class=\"line\">$ bin/elasticsearch-create-enrollment-token -s kibana --url &quot;https://localhost:9200&quot; </span><br><span class=\"line\"></span><br><span class=\"line\"># node节点使用的</span><br><span class=\"line\">$ bin/elasticsearch-create-enrollment-token -s node</span><br></pre></td></tr></table></figure>\n<p>开机自启动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ docker update kibana  --restart=always</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进入容器-7\"><a href=\"#进入容器-7\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it kibana /bin/bash</span><br></pre></td></tr></table></figure>\n\n","categories":["docker"],"tags":["docker"]}]