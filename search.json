[{"title":"Hexo+GitHub搭建个人博客教程","url":"/2018/06/13/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"<blockquote>\n<p><a href=\"https://hexo.io/\">Hexo</a> 是一款基于 Node.js 的支持 Markdown 的静态站点生成框架，利用 Hexo+GitHub 可以轻松打造属于个人的免费博客。经过本人一番摸索最终搭建成功。本人的博客地址为 <a href=\"https://18814122746.github.io/\">飙戈的博客</a>，欢迎大家前来指导，转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"一、环境配置\"><a href=\"#一、环境配置\" class=\"headerlink\" title=\"一、环境配置\"></a>一、环境配置</h1><p>在搭建之前电脑需要的环境配置如下：</p>\n<ul>\n<li><a href=\"https://git-scm.com/\">git</a></li>\n<li><a href=\"https://nodejs.org/en/\">node.js</a></li>\n<li><a href=\"https://pages.github.com/\">github pages</a> 仓库</li>\n</ul>\n<p>我们可以在控制台中输入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ node -v</span><br><span class=\"line\">$ git --version</span><br></pre></td></tr></table></figure>\n\n<p>如果没有报错则说明git和node.js已经安装成功，可直接跳过安装教程，如果报错则需要重新安装</p>\n<h3 id=\"1、安装git\"><a href=\"#1、安装git\" class=\"headerlink\" title=\"1、安装git\"></a><strong>1、安装git</strong></h3><ul>\n<li>windows 用户：直接下载<a href=\"https://git-scm.com/downloads\">git安装程序</a>根据提示进行安装</li>\n<li>mac 用户：通过homebrew进行安装，没有安装的需要先安装<a href=\"https://brew.sh/\">homebrew</a>，可以通过命令 <code>$ brew install git</code> 安装，也可通过下载 <a href=\"https://git-scm.com/downloads\">git安装程序</a> 进行安装</li>\n<li>linux 用户：通过命令行安装 <code>$ sudo apt-get install git-core</code></li>\n</ul>\n<p>安装完成后再在控制台输入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git --version</span><br></pre></td></tr></table></figure>\n\n<p>如果没有报错则说明安装成功</p>\n<h3 id=\"2、安装node-js\"><a href=\"#2、安装node-js\" class=\"headerlink\" title=\"2、安装node.js\"></a><strong>2、安装node.js</strong></h3><h3 id=\"1）下载安装程序（推荐）\"><a href=\"#1）下载安装程序（推荐）\" class=\"headerlink\" title=\"1）下载安装程序（推荐）\"></a>1）下载安装程序（推荐）</h3><p>直接下载 <a href=\"https://nodejs.org/en/\">node.js安装程序</a> 进行安装，比较快捷省事，适用于 mac 和 windows 用户</p>\n<h3 id=\"2）使用nvm安装\"><a href=\"#2）使用nvm安装\" class=\"headerlink\" title=\"2）使用nvm安装\"></a>2）使用nvm安装</h3><p>cURL:  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure>\n\n<p>Wget:  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nvm install stable</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后再在控制台输入 <code>$ node -v</code> 如果没有报错则说明安装成功</p>\n<h3 id=\"3、github-pages\"><a href=\"#3、github-pages\" class=\"headerlink\" title=\"3、github pages\"></a><strong>3、github pages</strong></h3><p>我们用来托管博客的服务叫做 <a href=\"https://pages.github.com/\">Github Pages</a>，它是 Github 用来提供给个人&#x2F;组织或者项目的网页服务，只需要部署到你的 Github Repository，推送代码，便可以实时呈现。</p>\n<h3 id=\"1）申请github账号\"><a href=\"#1）申请github账号\" class=\"headerlink\" title=\"1）申请github账号\"></a>1）申请github账号</h3><p>首先你需要申请注册一个 <a href=\"https://github.com/\">github</a> 账号</p>\n<h3 id=\"2）创建托管仓库\"><a href=\"#2）创建托管仓库\" class=\"headerlink\" title=\"2）创建托管仓库\"></a>2）创建托管仓库</h3><p>点击右上角 New Repository 新建一个仓库来作为托管仓库，注意命名为 <strong>username.github.io</strong>（username是你的账号名)。</p>\n<blockquote>\n<p>GitHub Pages 有两种类型：User&#x2F;Organization Pages 和 Project Pages，两者的区别是：</p>\n<ol>\n<li>User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。</li>\n<li>用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。</li>\n<li>User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。</li>\n<li>User Pages 通过 http(s):&#x2F;&#x2F;username.github.io 进行访问，而 Projects Pages通过 http(s):&#x2F;&#x2F;username.github.io&#x2F;projectname 进行访问。</li>\n</ol>\n</blockquote>\n<p>一般搭建个人博客都是用 User Pages，所以命名需要按照规范命名。</p>\n<h3 id=\"3）配置SSH（可跳过）\"><a href=\"#3）配置SSH（可跳过）\" class=\"headerlink\" title=\"3）配置SSH（可跳过）\"></a>3）配置SSH（可跳过）</h3><p>SSH实现本地 git 项目和远程 github 的连接，github 通过 <em><strong>SSH 密钥识别特定的可信任电脑</strong></em>，该部分电脑在向 github 推送的时候不需要输入用户名和密码</p>\n<ul>\n<li>查看电脑是否已经配置 ssh key</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>默认情况下，public keys的文件名是以下的格式之一：<strong>id_dsa.pub、id_ecdsa.pub、id_ed25519.pub、id_rsa.pub</strong>。因此，如果列出的文件有public和private钥匙对（例如id_ras.pub和id_rsa），证明已存在SSH keys。如果提示 <code>No such file or directory</code> 则说明未安装</p>\n</blockquote>\n<ul>\n<li>第一次安装完 git 需要先 <em>初始化配置 git</em>（可跳过）</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config –global user.name &quot;yourusername&quot;</span><br><span class=\"line\">git config --global user.email &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>生成新的 SSH Key，输入密码之类的可以省略，一路回车就行</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>复制执行命令后显示的 key 内容</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>点击右上角的 Settings –&gt; SSH and GPG keys –&gt; New SSH key ，Title 自由填写，Key 粘贴刚才复制的那段代码，点击 Add SSH Key</p>\n</li>\n<li><p>测试连接</p>\n</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<p> 如果看到</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">The authenticity of host &#x27;github.com (207.97.227.239)&#x27; can&#x27;t be established.</span><br><span class=\"line\">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>\n\n<p> 输入<code>yes</code>，回车看到</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hi username! You&#x27;ve successfully authenticated, but GitHub does not</span><br><span class=\"line\">provide shell access.</span><br></pre></td></tr></table></figure>\n\n<p> 表示连接成功，ssh的配置至此完成</p>\n<h1 id=\"二、安装Hexo\"><a href=\"#二、安装Hexo\" class=\"headerlink\" title=\"二、安装Hexo\"></a>二、安装Hexo</h1><p>hexo的安装相当简单，在确保以上环境已经配置好的情况下</p>\n<h2 id=\"1、下载Hexo\"><a href=\"#1、下载Hexo\" class=\"headerlink\" title=\"1、下载Hexo\"></a>1、下载Hexo</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>有些教程会用命令 <code>$ npm install -g hexo</code>，作用同上，均为下载Hexo的安装包</p>\n<h2 id=\"2、初始化安装\"><a href=\"#2、初始化安装\" class=\"headerlink\" title=\"2、初始化安装\"></a>2、初始化安装</h2><p>执行以下命令Hexo可把文件安装到指定文件夹</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo init &lt;folder&gt;</span><br><span class=\"line\">$ cd &lt;folder&gt;</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<p>新建一个名为<folder>的文件夹（可带路径），通过 <code>hexo init</code> 初始化该文件夹，然后切换到该文件夹中，执行 <code>npm install</code> 进行安装</folder></p>\n<h2 id=\"3、目录\"><a href=\"#3、目录\" class=\"headerlink\" title=\"3、目录\"></a>3、目录</h2><p>如果以上的安装成功，在安装目录下将会出现以下的文件结构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── _config.yml</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>_config.yml：网站的全局配置文件</li>\n<li>package.json：应用程序的信息</li>\n<li>scaffolds：模版文件夹，Hexo的模板是指在新建的markdown文件中默认填充的内容。当您新建文章时，Hexo 会根据 scaffold 来建立文件。例如，如果您修改scaffold&#x2F;post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</li>\n<li>source：资源文件夹，除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。例如用于域名解析的 CNAME 文件就可以放到该文件夹中，每次部署的时候都会自动添加该文件。</li>\n<li>themes：主题文件夹，Hexo 会根据主题来生成静态页面。</li>\n</ul>\n<h1 id=\"三、使用Hexo\"><a href=\"#三、使用Hexo\" class=\"headerlink\" title=\"三、使用Hexo\"></a>三、使用Hexo</h1><h2 id=\"1、启动\"><a href=\"#1、启动\" class=\"headerlink\" title=\"1、启动\"></a>1、启动</h2><p>进入hexo的安装目录，输入命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>进行启动，可简化为 <code>$ hexo s</code> ，也可启动调试模式 <code>$ hexo server --debug</code></p>\n<p>启动完成后访问地址：<a href=\"http://localhost:4000/\">http://localhost:4000/</a></p>\n<h2 id=\"2、创建文章\"><a href=\"#2、创建文章\" class=\"headerlink\" title=\"2、创建文章\"></a>2、创建文章</h2><p>执行以下命令可新建文章</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<p> <code>layout</code> 叫做布局，不同的 <code>layout</code> 选项会创建不同类型的文章。</p>\n<p>hexo有三种默认布局，用户也可以自定义布局，不同布局对应不同的存储路径</p>\n<ul>\n<li>post：一般文章布局，自定义布局和post的对应的存储路径为 <code>source/_posts</code></li>\n<li>page：页面布局，例如可以用于生成标签（tags）或分类（categories）等主页面，就是点击菜单直接显示的页面，对应的存储路径为 <code>source</code></li>\n<li>draft：草稿布局，草稿默认不会显示在页面上，已完成的草稿可用 <code>$ hexo publish &lt;title&gt;</code> 来发布，对应的存储路径为 <code>source/_drafts</code></li>\n</ul>\n<p>Hexo 默认以标题做为文件名称，可以修改<code>_config.yml</code>的 <code>new_post_name</code> 参数来修改新生成的文件名称，例如设置为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">:year-:month-:day-:title.md</span><br></pre></td></tr></table></figure>\n\n<p>文件名会带上年月日，<code>:title</code> 表示转为小写，空格将会被替换为短杠。这个时候创建文章</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new post &quot;hello world&quot;</span><br></pre></td></tr></table></figure>\n\n<p>source&#x2F;_posts下面会自动生成一个名为 2019-08-02-hello-world.md 文件。</p>\n<h2 id=\"3、编辑文章\"><a href=\"#3、编辑文章\" class=\"headerlink\" title=\"3、编辑文章\"></a>3、编辑文章</h2><p>文章编辑可以用普通的markdown编辑器，例如经典的typora编辑器。</p>\n<p>文章内容分为<strong>前页</strong>和<strong>正文</strong></p>\n<h3 id=\"1）前页\"><a href=\"#1）前页\" class=\"headerlink\" title=\"1）前页\"></a>1）前页</h3><p>Front-matter 是文章头部 <code>—</code> 分隔符上方的区域，可以设置的变量有：</p>\n<ul>\n<li>layout：布局</li>\n<li>title：标题</li>\n<li>date：建立日期，默认为文件建立日期</li>\n<li>updated：更新日期，默认为文件更新日期</li>\n<li>comments：开启文章的评论功能，默认为true</li>\n<li>tags：标签，不适用于布局为 <code>page</code> 的的页面</li>\n<li>categories：分类，不适用于布局为 <code>page</code> 的的页面</li>\n<li>permalink：覆盖文章网址</li>\n</ul>\n<blockquote>\n<p>categories和tags的区别：categories具有顺序性和层次性，例如</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">categories:</span><br><span class=\"line\"> - Diary</span><br><span class=\"line\"> - Life</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>会使 Life 成为 Diary 的子类，而不是并列分类。<br>tags没有顺序和层次。</p>\n</blockquote>\n<p>实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: hello-world</span><br><span class=\"line\">date: 2018-06-10 16:15:04</span><br><span class=\"line\">categories:</span><br><span class=\"line\">- Diary</span><br><span class=\"line\">- Life</span><br><span class=\"line\">tags:</span><br><span class=\"line\">- happy</span><br><span class=\"line\">- friend</span><br><span class=\"line\">comments: false</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>创建一篇文章题目为hello-world，文章创建时间是2018-06-10 16:15:04，分类归为Diary的子分类Life，贴上happy和friend两个标签，最后禁止评论</p>\n<h3 id=\"2）正文\"><a href=\"#2）正文\" class=\"headerlink\" title=\"2）正文\"></a>2）正文</h3><p>正文和普通的markdown编辑相同，在这里有一些使用技巧。</p>\n<ul>\n<li><p>首页显示部分内容。首页默认会显示全部文章的全部内容，很多情况下我们只想在首页显示每篇文章的序言等部分内容，这样有利于读者总览。我们只需要在文章添加一句 <code>&lt;!--more--&gt;</code> ，例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">文章内容1</span><br><span class=\"line\">&lt;!--more--&gt;</span><br><span class=\"line\">文章内容2</span><br></pre></td></tr></table></figure>\n\n<p><code>&lt;!--more--&gt;</code> 以上的内容1会在首页正常显示，以下的内容2会隐藏，并显示 <code>阅读全文</code> 等链接。</p>\n</li>\n<li><p>编辑字体颜色。Hexo 通过 <code>&lt;font&gt;</code> 标签可实现自定义字体颜色和大小，<code>color</code> 属性定义字体颜色（不带引号），<code>size</code> 定义字体大小，例如<font color=\"#BF3EFF\" size=\"3\">粉色字体</font></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;font color=#BF3EFF size=3&gt;粉色字体&lt;/font&gt; </span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"4、发布文章\"><a href=\"#4、发布文章\" class=\"headerlink\" title=\"4、发布文章\"></a>4、发布文章</h2><p>我们在本地编辑的文章只能在本地查看，如果想把文章发布到网上，我们需要把文章上传到上面配置好的 github pages 中。在发布文章前我们需要进行一些配置。</p>\n<h3 id=\"1）配置-config-yml文件\"><a href=\"#1）配置-config-yml文件\" class=\"headerlink\" title=\"1）配置_config.yml文件\"></a>1）配置_config.yml文件</h3><p>编辑安装目录下的 _config.yml 文件，找到 <code>deploy</code> 参数，把 <code>type</code> 改成 <code>git</code>，<code>repo</code> 改成你自己的仓库地址，该地址可以直接上 github 上获取。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\"> type: git</span><br><span class=\"line\"> repo: https://github.com/18814122746/18814122746.github.io.git</span><br></pre></td></tr></table></figure>\n\n<p>注意：***<code>type:</code> 和 <code>git</code>之间必须带一个空格***</p>\n<h3 id=\"2）安装deployer工具\"><a href=\"#2）安装deployer工具\" class=\"headerlink\" title=\"2）安装deployer工具\"></a>2）安装deployer工具</h3><p><a href=\"https://github.com/hexojs/hexo-deployer-git\">hexo-deployer-git</a> 为hexo自动部署安装工具，可通过命令安装</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git  --save</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3）开始发布\"><a href=\"#3）开始发布\" class=\"headerlink\" title=\"3）开始发布\"></a>3）开始发布</h3><p>发布文章可分为 <strong>清空</strong>、<strong>生成</strong> 和 <strong>部署</strong> 三部分</p>\n<ol>\n<li>清空。清除缓存文件 (db.json) 和已生成的静态文件 (public)</li>\n</ol>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>生成。生成public静态文件夹</li>\n</ol>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p> 也可简化成 <code>$ hexo g</code></p>\n<ol start=\"3\">\n<li>部署。部署到 github 上面</li>\n</ol>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p> 也可简化成 <code>$ hexo d</code></p>\n<p>执行完以上命令后，在浏览器输入 <a href=\"https://username.github.io/\">https://username.github.io</a> 就可以浏览你的刚才发布的博客，例如本人的博客网址为 <a href=\"https://18814122746.github.io/\">https://18814122746.github.io/</a> ，至此 Hexo + Github 的个人博客<em><strong>搭建已经完成</strong></em>。</p>\n<h2 id=\"5、Hexo常用命令汇总\"><a href=\"#5、Hexo常用命令汇总\" class=\"headerlink\" title=\"5、Hexo常用命令汇总\"></a>5、Hexo常用命令汇总</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo init [folder] #初始化 folder 文件夹为网站根目录，如果没有 folder 默认在目前的文件夹初始化</span><br><span class=\"line\">$ hexo new &lt;title&gt; #新建文章</span><br><span class=\"line\">$ hexo new page &lt;title&gt; #新建页面</span><br><span class=\"line\">$ hexo server #启动服务器，默认情况下，访问网址为： http://localhost:4000/</span><br><span class=\"line\">$ hexo clean #清空静态文件和缓存文件</span><br><span class=\"line\">$ hexo generate #生成静态文件到public目录，可简写为 hexo -g</span><br><span class=\"line\">$ hexo deploy #部署文件到远程服务器，可简写为 hexo -d</span><br><span class=\"line\">$ hexo help  #查看帮助</span><br><span class=\"line\">$ hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>\n\n<p>上述命令行可指定模式运行，有三种模式：</p>\n<ul>\n<li>安全模式。在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo --safe</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>调试模式。在终端中显示调试信息并记录到 debug.log。</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo --debug</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>简洁模式</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo --silent</span><br></pre></td></tr></table></figure>\n\n<p>例如以调试模式启动服务器： <code>$ hexo s --debug</code></p>\n<p>为了快速执行命令，我们可以修改 hexo 根目录下的<code>package.json</code>文件，增加</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;start&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;,</span><br><span class=\"line\">  &quot;debug&quot;: &quot;hexo clean &amp;&amp; hexo g&quot;,</span><br><span class=\"line\">  &quot;deploy&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 hexo 根目录下执行 <code>npm run</code> + 脚本命令名称，例如部署到服务器，输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm run deploy</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://hexo.io/zh-cn/docs/\">Hexo官方中文文档</a><br><a href=\"http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/\">HEXO搭建个人博客</a><br><a href=\"https://www.jianshu.com/p/189fd945f38f\">搭建个人博客-hexo+github详细完整步骤</a><br><a href=\"https://www.jianshu.com/p/05289a4bc8b2\">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><br><a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\">GitHub Pages + Hexo搭建博客</a><br><a href=\"https://www.jianshu.com/p/70f3cfae1ef4\">使用Hexo搭建个人静态博客</a></p>\n","categories":["工具","Hexo"],"tags":["Hexo"]},{"title":"Hexo主题配置","url":"/2018/06/17/Hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","content":"<blockquote>\n<p>Hexo 支持多种主题，NexT 是 Hexo 下最热门的主题之一，下面简单简介 NextT 主题的配置。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 <font color=\"#5CACEE\" size=\"3\">站点配置文件</font>，后者称为 <font color=\"#BF3EFF\" size=\"3\">主题配置文件</font>。转载请说明出处。</p>\n<h2 id=\"一、安装NextT\"><a href=\"#一、安装NextT\" class=\"headerlink\" title=\"一、安装NextT\"></a>一、安装NextT</h2><h3 id=\"1、下载主题\"><a href=\"#1、下载主题\" class=\"headerlink\" title=\"1、下载主题\"></a>1、下载主题</h3><p>切换到hexo 的安装目录，把主题文件下载到安装目录的 <code>theme/next</code> 目录下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、启用主题\"><a href=\"#2、启用主题\" class=\"headerlink\" title=\"2、启用主题\"></a>2、启用主题</h3><p>打开 <font color=\"#5CACEE\" size=\"3\">站点配置文件</font>， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">theme: next</span><br></pre></td></tr></table></figure>\n<p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p>\n<blockquote>\n<p>注意：修改 <font color=\"#5CACEE\" size=\"3\">站点配置文件</font> 需求重启服务器才能生效，修改 <font color=\"#BF3EFF\" size=\"3\">主题配置文件</font> 不需要重启服务器。重启步骤为在服务器启动控制台 <code>ctrl + c</code>，然后 <code>$ hexo server [--debug]</code></p>\n</blockquote>\n<h2 id=\"二、主题设置\"><a href=\"#二、主题设置\" class=\"headerlink\" title=\"二、主题设置\"></a>二、主题设置</h2><h3 id=\"1、外观-scheme-设置\"><a href=\"#1、外观-scheme-设置\" class=\"headerlink\" title=\"1、外观 scheme 设置\"></a>1、外观 scheme 设置</h3><p>修改 <font color=\"#BF3EFF\" size=\"3\">主题配置文件</font>，查找 <code>scheme</code> 关键字，将你需用启用的 <code>scheme</code> 前面注释 <code>#</code> 去除即可</p>\n<ul>\n<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白  </li>\n<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观  </li>\n<li>Pisces - 双栏 Scheme，小家碧玉似的清新  </li>\n<li>Gemini - 紧凑集中版双栏 Scheme，本网站采用的主题</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Schemes</span><br><span class=\"line\">#scheme: Muse</span><br><span class=\"line\">#scheme: Mist</span><br><span class=\"line\">#scheme: Pisces</span><br><span class=\"line\">scheme: Gemini</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、语言-language-设置\"><a href=\"#2、语言-language-设置\" class=\"headerlink\" title=\"2、语言 language 设置\"></a>2、语言 language 设置</h3><p>编辑 <font color=\"#5CACEE\" size=\"3\">站点配置文件</font> （针对所有主题下的文件）或 <font color=\"#BF3EFF\" size=\"3\">主题配置文件</font> (针对本主题下的文件)下的 <code>language</code>，例如启用简体中文就改成 <code>zh-Hans</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">language: zh-Hans</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、设置菜单\"><a href=\"#3、设置菜单\" class=\"headerlink\" title=\"3、设置菜单\"></a>3、设置菜单</h3><h4 id=\"启用-x2F-禁用菜单\"><a href=\"#启用-x2F-禁用菜单\" class=\"headerlink\" title=\"启用&#x2F;禁用菜单\"></a>启用&#x2F;禁用菜单</h4><p>编辑 <font color=\"#BF3EFF\" size=\"3\">主题配置文件</font>，设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：<code>item name: link</code>。其中 <code>item name</code> 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。把需要启动的菜单项前面的 <code>#</code> 去掉。也可以新增自定义菜单项。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: / || home</span><br><span class=\"line\">  #  about: /about/ || user</span><br><span class=\"line\">  tags: /tags/ || tags</span><br><span class=\"line\">  categories: /categories/ || th</span><br><span class=\"line\">  # archives: /archives/ || archive</span><br><span class=\"line\">  # schedule: /schedule/ || calendar</span><br><span class=\"line\">  # sitemap: /sitemap.xml || sitemap</span><br><span class=\"line\">  # commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>\n\n<p>默认的菜单项如下：</p>\n<table>\n<thead>\n<tr>\n<th>键值</th>\n<th>设定值</th>\n<th>显示文本（简体中文）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>home</td>\n<td>home: &#x2F;</td>\n<td>主页</td>\n</tr>\n<tr>\n<td>archives</td>\n<td>archives: &#x2F;archives</td>\n<td>归档页</td>\n</tr>\n<tr>\n<td>categories</td>\n<td>categories: &#x2F;categories</td>\n<td>分类页</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>tags: &#x2F;tags</td>\n<td>标签页</td>\n</tr>\n<tr>\n<td>schedule</td>\n<td>schedule: &#x2F;schedule</td>\n<td>日程表</td>\n</tr>\n<tr>\n<td>about</td>\n<td>about: &#x2F;about</td>\n<td>关于</td>\n</tr>\n<tr>\n<td>sitemap</td>\n<td>sitemap: &#x2F;sitemap</td>\n<td>站点地图</td>\n</tr>\n<tr>\n<td>commonweal</td>\n<td>commonweal: &#x2F;404.html</td>\n<td>公益 404</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>其中除了 home 和 archives 页面，其他页面都需要手动创建，例如新建 tags 页面</p>\n</blockquote>\n<ol>\n<li>切换到 Hexo 根目录下，使用 <code>hexo new page tags</code> 新建 tags 页面</li>\n<li>编辑 <code>/source/tags/index.md</code> 文件，在头文件部分 front-matter 添加 <code>type: &quot;tags&quot;</code>，如需要关闭评论添加 <code>comments: false</code></li>\n</ol>\n<h4 id=\"设置菜单显示文字\"><a href=\"#设置菜单显示文字\" class=\"headerlink\" title=\"设置菜单显示文字\"></a>设置菜单显示文字</h4><p>修改 <code>languages/&#123;language&#125;.yml</code> 文件，如果简体中文对应 <code>languages/zh-Hans.yml</code> 文件下的 <code>menu</code> 字段</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">menu:</span><br><span class=\"line\">  home: 首页</span><br><span class=\"line\">  archives: 归档</span><br><span class=\"line\">  categories: 分类</span><br><span class=\"line\">  tags: 标签</span><br><span class=\"line\">  about: 关于</span><br><span class=\"line\">  search: 搜索</span><br><span class=\"line\">  schedule: 日程表</span><br><span class=\"line\">  sitemap: 站点地图</span><br><span class=\"line\">  commonweal: 公益404</span><br></pre></td></tr></table></figure>\n\n<p>修改字段值直接影响页面上菜单文字显示，或者新增字段值，字段名要与上面第一步设置的自定义菜单名称对应。</p>\n<h3 id=\"4、设置侧栏\"><a href=\"#4、设置侧栏\" class=\"headerlink\" title=\"4、设置侧栏\"></a>4、设置侧栏</h3><p>修改 <font color=\"#BF3EFF\" size=\"3\">主题配置文件</font> 文件中的 <code>sidebar</code> 字段</p>\n<h4 id=\"设置侧栏位置\"><a href=\"#设置侧栏位置\" class=\"headerlink\" title=\"设置侧栏位置\"></a>设置侧栏位置</h4><ul>\n<li>left - 靠左放置</li>\n<li>right - 靠右放置</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sidebar:</span><br><span class=\"line\">  position: left</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设置侧栏显示的时机\"><a href=\"#设置侧栏显示的时机\" class=\"headerlink\" title=\"设置侧栏显示的时机\"></a>设置侧栏显示的时机</h4><ul>\n<li>post - 默认行为，在文章页面（拥有目录列表）时显示</li>\n<li>always - 在所有页面中都显示</li>\n<li>hide - 在所有页面中都隐藏（可以手动展开）</li>\n<li>remove - 完全移除</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sidebar:</span><br><span class=\"line\">  display: post</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、设置头像\"><a href=\"#5、设置头像\" class=\"headerlink\" title=\"5、设置头像\"></a>5、设置头像</h3><p>修改 <font color=\"#BF3EFF\" size=\"3\">主题配置文件</font> 下的 <code>avatar</code> 字段，设成头像的链接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">avatar: images/avatar.png</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、设置作者昵称\"><a href=\"#6、设置作者昵称\" class=\"headerlink\" title=\"6、设置作者昵称\"></a>6、设置作者昵称</h3><p>编辑 <font color=\"#5CACEE\" size=\"3\">站点配置文件</font>，设置 <code>author</code> 字段</p>\n<h3 id=\"7、设置站点名称\"><a href=\"#7、设置站点名称\" class=\"headerlink\" title=\"7、设置站点名称\"></a>7、设置站点名称</h3><p>编辑 <font color=\"#5CACEE\" size=\"3\">站点配置文件</font>，设置 <code>description</code> 字段</p>\n<h3 id=\"8、设置社交\"><a href=\"#8、设置社交\" class=\"headerlink\" title=\"8、设置社交\"></a>8、设置社交</h3><p>编辑 <font color=\"#BF3EFF\" size=\"3\">主题配置文件</font></p>\n<h4 id=\"设置社交链接\"><a href=\"#设置社交链接\" class=\"headerlink\" title=\"设置社交链接\"></a>设置社交链接</h4><p>修改 <code>social</code> 字段，其键值格式是 <code>显示文本: 链接地址</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">social:</span><br><span class=\"line\">  GitHub: https://github.com/18814122746 || github</span><br><span class=\"line\">  #E-Mail: mailto:yourname@gmail.com || envelope</span><br><span class=\"line\">  #Google: https://plus.google.com/yourname || google</span><br><span class=\"line\">  #Twitter: https://twitter.com/yourname || twitter</span><br><span class=\"line\">  #FB Page: https://www.facebook.com/yourname || facebook</span><br><span class=\"line\">  #VK Group: https://vk.com/yourname || vk</span><br><span class=\"line\">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span><br><span class=\"line\">  #YouTube: https://youtube.com/yourname || youtube</span><br><span class=\"line\">  #Instagram: https://instagram.com/yourname || instagram</span><br><span class=\"line\">  #Skype: skype:yourname?call|chat || skype</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设置链接图标\"><a href=\"#设置链接图标\" class=\"headerlink\" title=\"设置链接图标\"></a>设置链接图标</h4><p>修改 <code>social_icons:</code> 字段，其键值格式是 <code>匹配键: Font Awesome 图标名称</code>，<code>匹配键</code> 与上一步所配置的链接的 <code>显示文本</code> 相同（大小写严格匹配）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Social Icons</span><br><span class=\"line\">social_icons:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  # Icon Mappings</span><br><span class=\"line\">  GitHub: github</span><br><span class=\"line\">  Twitter: twitter</span><br><span class=\"line\">  微博: weibo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9、设置背景动画\"><a href=\"#9、设置背景动画\" class=\"headerlink\" title=\"9、设置背景动画\"></a>9、设置背景动画</h3><p>NexT 自带 <code>canvas_nest</code> 和 <code>three_waves</code> 两种背景动画效果，编辑 <font color=\"#BF3EFF\" size=\"3\">主题配置文件</font> 将对应的字段改成 <code>true</code> 或 <code>false</code> 即可，只能同时开启一种背景动画效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">canvas_nest: true</span><br><span class=\"line\">#three_waves : false</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三、第三方插件\"><a href=\"#三、第三方插件\" class=\"headerlink\" title=\"三、第三方插件\"></a>三、第三方插件</h2><h3 id=\"1、安装评论系统\"><a href=\"#1、安装评论系统\" class=\"headerlink\" title=\"1、安装评论系统\"></a>1、安装评论系统</h3><p>理论上 Hexo 支持 DISQUS、Facebook Comments、HyperComments、Gitment、网易云跟帖、搜狐畅言、友言和来必力等评论插件，其中 DISQUS、Facebook Comments 需要翻墙才能评论，Hypercomments 目前只剩下收费版本，Gitment 需要用 GitHub 账号登陆才能评论，搜狐畅言需要网站备案才能使用，网易云跟帖、友言已经停止服务。综合考虑选择 <strong>来必力</strong> 作为我们的评论系统。</p>\n<ul>\n<li>登陆 <a href=\"https://livere.com/\">来必力官网</a> 注册账号</li>\n<li>点击 <strong>右上角头像</strong> &gt; <strong>管理页面</strong>，安装 <strong>City</strong> 免费版</li>\n<li>打开 <strong>管理页面</strong> 中的 <strong>代码管理</strong>，复制 <code>data-uid</code> 中的值</li>\n<li>编辑 <font color=\"#BF3EFF\" size=\"3\">主题配置文件</font> 中的 <code>livere_uid</code> 字段，把刚才复制的 <code>data-uid</code> 的值粘贴进去</li>\n</ul>\n<h3 id=\"2、统计访问次数\"><a href=\"#2、统计访问次数\" class=\"headerlink\" title=\"2、统计访问次数\"></a>2、统计访问次数</h3><p>有 <strong>百度统计</strong> 和 <strong>不蒜子</strong> 统计两种方式。两者的区别是：前者可以用来后台统计，数据比较准确可靠；后者用来在页面上显示，根据访问 ip 进行粗略统计。</p>\n<h4 id=\"百度统计\"><a href=\"#百度统计\" class=\"headerlink\" title=\"百度统计\"></a>百度统计</h4><ul>\n<li>登陆 <a href=\"https://tongji.baidu.com/web/welcome/login\">百度统计官网</a>，注册账号</li>\n<li>获取代码<br>点击 <strong>管理</strong> &gt; <strong>代码管理</strong> &gt; <strong>代码获取</strong>，找到类似于 <code>hm.src = &quot;https://hm.baidu.com/hm.js?xxx&quot;;</code> 的代码，复制 <code>.js?</code> 后面的统计脚本id</li>\n<li>编辑 <font color=\"#BF3EFF\" size=\"3\">主题配置文件</font> 中的 <code>baidu_analytics</code> 字段，把刚才粘贴的值粘贴进去</li>\n</ul>\n<h4 id=\"不蒜子统计\"><a href=\"#不蒜子统计\" class=\"headerlink\" title=\"不蒜子统计\"></a>不蒜子统计</h4><p>编辑 <font color=\"#BF3EFF\" size=\"3\">主题配置文件</font> 中的 <code>busuanzi_count</code> 参数，如下所示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Show PV/UV of the website/page with busuanzi.</span><br><span class=\"line\"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span><br><span class=\"line\">busuanzi_count:</span><br><span class=\"line\">  # count values only if the other configs are false</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  # custom uv span for the whole site</span><br><span class=\"line\">  site_uv: true</span><br><span class=\"line\">  site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 总访问人数</span><br><span class=\"line\">  site_uv_footer: 人</span><br><span class=\"line\">  # custom pv span for the whole site</span><br><span class=\"line\">  site_pv: true</span><br><span class=\"line\">  site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 总访问量</span><br><span class=\"line\">  site_pv_footer: 次</span><br><span class=\"line\">  # custom pv span for one page only</span><br><span class=\"line\">  page_pv: true</span><br><span class=\"line\">  page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 本文阅读量</span><br><span class=\"line\">  page_pv_footer: 次</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当 <code>site_uv: true</code> 时，代表在页面底部显示站点的UV值。</li>\n<li>当 <code>site_pv: true</code> 时，代表在页面底部显示站点的PV值。</li>\n<li>当 <code>page_pv: true</code> 时，代表在文章页面的标题下显示该页面的PV值（阅读数）。<blockquote>\n<p>pv的方式，单个用户连续点击n篇文章，记录n次访问量。<br>uv的方式，单个用户连续点击n篇文章，只记录1次访客数。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"3、百度分享\"><a href=\"#3、百度分享\" class=\"headerlink\" title=\"3、百度分享\"></a>3、百度分享</h3><p>编辑 <font color=\"#BF3EFF\" size=\"3\">主题配置文件</font> 中的<code> baidushare</code> 字段，改成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">baidushare:</span><br><span class=\"line\">  type: button</span><br><span class=\"line\">  baidushare: true</span><br></pre></td></tr></table></figure>\n\n<p>注意：<em>百度分享不支持 Https</em>，打开开发工具控制台可能会看到 <code>Failed to load resource</code> 的错误信息，原因是通过 Https 请求百度分享的 Http 资源时候被拒绝了。解决办法是直接把这些百度分享的资源文件放到自己的目录下，参考大佬的解决方案 <a href=\"https://www.hrwhisper.me/baidu-share-not-support-https-solution/\">百度分享不支持https的解决方案</a></p>\n<ul>\n<li>下载资源文件，GitHub地址为 <a href=\"https://github.com/hrwhisper/baiduShare\">https://github.com/hrwhisper/baiduShare</a></li>\n<li>把里面的 <code>static</code> 文件夹放在安装目录下的 <code>source</code> 文件夹里面</li>\n<li>修改 你的安装目录&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;share&#x2F;baidushare.swig 文件如下 <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.src=&#x27;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&#x27;+~(-new Date()/36e5)];&lt;/script&gt;</span><br><span class=\"line\">改为</span><br><span class=\"line\">.src=&#x27;/static/api/js/share.js?v=89860593.js?cdnversion=&#x27;+~(-new Date()/36e5)];&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>\n<li>编辑 <font color=\"#5CACEE\" size=\"3\">站点配置文件</font> 中的 <code>skip_render</code> 字段，Hexo会禁止编译 <code>skip_render</code> 定义的文件&#x2F;文件夹 <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">skip_render: static/**</span><br></pre></td></tr></table></figure></li>\n<li>重启服务器，最好执行一下 <code>hexo clean</code></li>\n</ul>\n<h3 id=\"4、本地搜索-Local-Search\"><a href=\"#4、本地搜索-Local-Search\" class=\"headerlink\" title=\"4、本地搜索 Local Search\"></a>4、本地搜索 Local Search</h3><ul>\n<li>安装 <a href=\"https://www.npmjs.com/package/hexo-generator-searchdb\">hexo-generator-searchdb</a>，在安装目录下执行</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>编辑 <font color=\"#5CACEE\" size=\"3\">站点配置文件</font>，新增以下内容到任意位置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">  path: search.json</span><br><span class=\"line\">  field: post</span><br><span class=\"line\">  format: html</span><br><span class=\"line\">  limit: 10000</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编辑 <font color=\"#BF3EFF\" size=\"3\">主题配置文件</font>，查找 <code>local_search</code> 字段，把值改为 <code>true</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">local_search:</span><br><span class=\"line\">  enable: true</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"四、参考\"><a href=\"#四、参考\" class=\"headerlink\" title=\"四、参考\"></a>四、参考</h2><p><a href=\"http://theme-next.iissnan.com/getting-started.html\">Hexo中文使用文档</a><br><a href=\"https://www.jianshu.com/p/3a05351a37dc\">Hexo的Next主题详细配置</a><br><a href=\"https://blog.csdn.net/qq_33699981/article/details/72716951\">hexo的next主题个性化教程：打造炫酷网站</a><br><a href=\"https://blog.csdn.net/ganzhilin520/article/details/79048010\">hexo添加评论功能</a><br><a href=\"https://blog.csdn.net/lanuage/article/details/78991798\">hexo next主题为博客添加分享功能\n</a><br><a href=\"https://blog.csdn.net/cl534854121/article/details/76121105\">Hexo+Github搭建个人博客(三)——百度分享集成</a><br><a href=\"https://blog.csdn.net/time888/article/details/74203939\">为NexT主题添加文章阅读量统计功能</a></p>\n","categories":["工具","Hexo"],"tags":["Hexo"]},{"title":"Hexo插入图片和设置图片大小","url":"/2018/06/21/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F/","content":"<blockquote>\n<p>Hexo 插入图片有两种方式，第一种是网络引用，第二种是本地插入，本文主要介绍本地插入图片方式。另外由于 Hexo 是静态博客框架，所插入的图片默认会按照本身大小自动铺满，如果要设置图片大小需要另外写 css 来进行控制。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Hexo 插入图片有 <strong>网络图片插入</strong> 和 <strong>本地图片插入</strong> 两种方式。</p>\n<p>网络图片插入的做法是先把图片上传到 <a href=\"https://www.qiniu.com/\">七牛云</a> 等云服务商提供的图床，然后通过 <code>![img-title](img-url)</code> 的方式，把 img-url 的地址替换成图片在图床的 url 地址即可。使用网络图片的好处是七牛云的cdn加速效果会大大提高图片的打开速度，缺点是多图片博客的编辑过程会比较繁琐，图片管理比较麻烦。</p>\n<p>本地图片插入把图片和博客保存在一起，方便图片管理，但是图片的网络打开速度会很慢。下面重点介绍本地图片插入。</p>\n<h2 id=\"常规本地图片插入\"><a href=\"#常规本地图片插入\" class=\"headerlink\" title=\"常规本地图片插入\"></a>常规本地图片插入</h2><h3 id=\"1、修改配置文件\"><a href=\"#1、修改配置文件\" class=\"headerlink\" title=\"1、修改配置文件\"></a>1、修改配置文件</h3><p>编辑 <strong>hexo安装目录下的_config.yml</strong> 文件，找到 <code>post_asset_folder</code>，把值改成 <code>true</code>。</p>\n<blockquote>\n<p>通过将 config.yml 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开资源文件管理功能。当资源文件管理功能打开后，Hexo 将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p>\n</blockquote>\n<p>在建立文件时，Hexo会自动建立一个<strong>与文章同名的文件夹</strong>，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。</p>\n<h3 id=\"2、安装插件\"><a href=\"#2、安装插件\" class=\"headerlink\" title=\"2、安装插件\"></a>2、安装插件</h3><p>安装插件 <a href=\"https://github.com/CodeFalling/hexo-asset-image\">hexo-asset-image</a>，在 hexo 安装目录下运行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后需要重启一下服务器</p>\n<h3 id=\"3、使用插入图片\"><a href=\"#3、使用插入图片\" class=\"headerlink\" title=\"3、使用插入图片\"></a>3、使用插入图片</h3><p>使用 <code>hexo new post &quot;xxxx&quot;</code> 来新建博客时，会发现在 <code>/source/_posts</code> 文件夹下会有一个同名的 <code>xxxx</code> 文件夹，对于已存在的博客可以新建一个同名文件夹。</p>\n<p>先把图片复制到同名文件夹中，然后在文章中使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">![图片替代文字](img.jpg)</span><br></pre></td></tr></table></figure>\n\n<p>注意 img.jpg 前面的路径只需要同名文件夹的名称即可，不需要写什么绝对路径、相对路径。如我要引用 example.jpeg 图片，只需要把 example.jpeg 复制到同名文件夹，然后在文章中使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">![赵霁](example.jpeg)</span><br></pre></td></tr></table></figure>\n\n<p>效果图如下：</p>\n<p><img src=\"/.com//example.jpeg\" alt=\"赵霁\"></p>\n<h2 id=\"设置图片大小\"><a href=\"#设置图片大小\" class=\"headerlink\" title=\"设置图片大小\"></a>设置图片大小</h2><p>图片默认会显示原本的图片大小并居中显示，如果需要对图片大小进行设置，需要另外写 css 样式进行控制。注意：该方法可能会覆盖原来的一些图片样式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div style=&quot;width: 200px; margin: auto&quot;&gt;![赵霁](example.jpeg)&lt;/div&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>设置宽度为200px并设置居中（高度会自动缩放），效果图如下：</p>\n<div style=\"width: 200px; margin: auto\">![赵霁](example.jpeg)</div>\n## 参考\n[Hexo 官方文档资源文件夹](https://hexo.io/zh-cn/docs/asset-folders.html)  \n[hexo博客图片问题](https://www.jianshu.com/p/c2ba9533088a)  \n[hexo生成博文插入图片](https://blog.csdn.net/sugar_rainbow/article/details/57415705)\n","categories":["工具","Hexo"],"tags":["Hexo"]},{"title":"Hexo多台电脑更新博客","url":"/2018/06/22/Hexo%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/","content":"<blockquote>\n<p>通过 Hexo 和 GitHub 搭建的博客，静态文件会上传到 GitHub 仓库的 master 分支，但是 Hexo 的安装目录还是保存在本地的。如果更换了电脑需要更新博客，我们需要 Hexo 的安装目录来生成&#x2F;编辑&#x2F;上传博客，并且这个安装目录需要随着博客的更新而更新。在这里提供一种便捷的办法来实现不同电脑之间同步更新博客。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><p>在 Github 用于存放博客的仓库 yourname.github.io 下面建立 <strong><code>master</code></strong> 和 <strong><code>hexo</code></strong> 两个分支</p>\n<ul>\n<li><code>master</code> 分支（默认创建），<em>通过 Hexo 命令提交</em>，用于存放上传的 Hexo 静态文件（例如 public 文件夹里面的内容），这个分支用于显示 <a href=\"https://yourname.github.io/\">https://yourname.github.io</a> 打开的内容。</li>\n<li><code>hexo</code> 分支（手动创建），<em>通过 Git 命令提交&#x2F;拉取</em>，用于存放 Hexo 的安装目录，该分支可设为 <strong>默认分支</strong> 。</li>\n</ul>\n<p>这样我们写博客的大概流程就是 <em>在 <code>hexo</code> 分支上写上博客，并把写好的博客内容上传到 <code>master</code> 分支</em>，两个分支都通过 git 进行管理，所有的修改一目了然，非常方便。</p>\n<h2 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h2><h3 id=\"本地电脑\"><a href=\"#本地电脑\" class=\"headerlink\" title=\"本地电脑\"></a>本地电脑</h3><p>如果你的电脑还没配置好 Hexo，请参考以前的教程 <a href=\"https://18814122746.github.io/2018/06/13/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/\">Hexo+GitHub搭建个人博客教程</a><br>当你本地电脑的 Hexo 目录已经安装配置完毕之后，该目录可以 <em>通过 Hexo 命令向 GitHub 仓库的 <code>master</code> 分支提交内容</em>，但是该目录还不是 git 管理的目录，需要把该目录初始化为 git 管理的目录。</p>\n<h4 id=\"1、删除非默认主题文件的-git-目录（可跳过）\"><a href=\"#1、删除非默认主题文件的-git-目录（可跳过）\" class=\"headerlink\" title=\"1、删除非默认主题文件的 .git 目录（可跳过）\"></a>1、删除非默认主题文件的 .git 目录（可跳过）</h4><p>如果你使用的是非默认主题 landscape 的其他主题，而该主题的目录也是在通过 <code>git clone</code> 方式拉取下来的话，需要先取消该目录的 git 管理追踪，否则到时候提交 Hexo 安装目录的时候该文件夹会报类似于 <code>XXX目录: git modified content untracked content</code> 的错误。例如本人使用的是 next 主题，在 Hexo 安装目录下输入命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cd themes/next</span><br><span class=\"line\">$ ls -la # 显示 .git 的隐藏目录</span><br><span class=\"line\">$ rm -rf .git</span><br><span class=\"line\">$ ls -la # 确认 .git 目录是否成功删除 </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、把-Hexo-命令提交的分支改成-master-分支\"><a href=\"#2、把-Hexo-命令提交的分支改成-master-分支\" class=\"headerlink\" title=\"2、把 Hexo 命令提交的分支改成 master 分支\"></a>2、把 Hexo 命令提交的分支改成 <code>master</code> 分支</h4><p>编辑 Hexo 安装目录下的 _config.yaml 文件，在 <code>deploy</code> 参数里面添加 <code>branch: master</code>，如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\"> type: git</span><br><span class=\"line\"> repo: https://github.com/yourusername/yourusername.github.io.git</span><br><span class=\"line\"> branch: master</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、初始化-git-仓库\"><a href=\"#3、初始化-git-仓库\" class=\"headerlink\" title=\"3、初始化 git 仓库\"></a>3、初始化 git 仓库</h4><p>在 Hexo 安装目录下输入命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git init</span><br><span class=\"line\">$ git checkout -b hexo</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m &#x27;init&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>初始化为 git 目录并创建 <code>hexo</code> 分支</p>\n<h4 id=\"4、提交到远端服务器\"><a href=\"#4、提交到远端服务器\" class=\"headerlink\" title=\"4、提交到远端服务器\"></a>4、提交到远端服务器</h4><p>在 Hexo 安装目录下输入命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git remote add origin git@github.com:yourusername/yourusername.github.io.git</span><br><span class=\"line\">$ git push -u origin hexo:hexo</span><br></pre></td></tr></table></figure>\n\n<p>与远端主机关联并提交 <code>hexo</code> 分支</p>\n<h3 id=\"另外一台电脑\"><a href=\"#另外一台电脑\" class=\"headerlink\" title=\"另外一台电脑\"></a>另外一台电脑</h3><p>当你在一台新电脑上需要写博客的时候，需要先把 <code>hexo</code> 分支拉取下来，再进行 Hexo 初始化。<em>前提是该电脑需要先安装 git 和 node.js，并与 GitHub 进行 ssh 关联（可选）</em>。如果这些工作还没完成请参考 <a href=\"https://18814122746.github.io/2018/06/13/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/\">Hexo+GitHub搭建个人博客教程</a>  </p>\n<h4 id=\"1、拉取-hexo-分支\"><a href=\"#1、拉取-hexo-分支\" class=\"headerlink\" title=\"1、拉取 hexo 分支\"></a>1、拉取 <code>hexo</code> 分支</h4><p>在任意目录里面输入命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git clone -b hexo git@github.com: yourusername/yourusername.github.io.git</span><br></pre></td></tr></table></figure>\n\n<p>执行完之后你的目录下应该会出现一个 <code>yourusername.github.io</code> 的目录。</p>\n<h4 id=\"2、初始化为-Hexo-目录\"><a href=\"#2、初始化为-Hexo-目录\" class=\"headerlink\" title=\"2、初始化为 Hexo 目录\"></a>2、初始化为 Hexo 目录</h4><p><code>yourusername.github.io</code> 目录只是一个普通的 git 管理目录，需要把该目录初始化为 Hexo 目录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cd yourusername.github.io</span><br><span class=\"line\">$ npm install hexo</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ npm install hexo-deployer-git</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、安装插件（可跳过）\"><a href=\"#3、安装插件（可跳过）\" class=\"headerlink\" title=\"3、安装插件（可跳过）\"></a>3、安装插件（可跳过）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-searchdb --save # 本地搜索插件</span><br><span class=\"line\">$ npm install hexo-asset-image --save # 图片插件</span><br><span class=\"line\">$ npm install hexo-generator-sitemap --save # 谷歌站点地图插件</span><br><span class=\"line\">$ npm install hexo-generator-baidu-sitemap --save # 百度站点地图插件</span><br></pre></td></tr></table></figure>\n\n<p>至此这台新电脑的初始化工作也已经完成，可以开始写博客了。</p>\n<h3 id=\"写博客步骤\"><a href=\"#写博客步骤\" class=\"headerlink\" title=\"写博客步骤\"></a>写博客步骤</h3><p>以后我们写博客都在 <code>hexo</code> 分支下进行，<code>master</code> 分支只是用来存放生成的静态文件。确认目前在 <code>hexo</code> 分支下，步骤如下：</p>\n<ol>\n<li><code>git pull</code> 每次写博客前拉取最新的 <code>hexo</code> 分支代码</li>\n<li><code>hexo new post &#39;新文章&#39;</code> 开始写博客</li>\n<li><code>hexo clean &amp;&amp; hexo g</code> 清空并生成新的静态文件和缓存文件</li>\n<li><code>git add .</code></li>\n<li><code>git commit -m &#39;备注&#39;</code></li>\n<li><code>git push</code> 提交到 <code>hexo</code> 分支</li>\n<li><code>hexo d</code> 提交到 <code>master</code> 分支</li>\n</ol>\n<p>至此我们就可以实现在多台电脑上同步更新博客</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://www.ruanyifeng.com/blog/2014/06/git_remote.html\">Git远程操作详解</a><br><a href=\"http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/#more\">GitHub Pages + Hexo搭建博客</a><br><a href=\"https://blog.csdn.net/mydo/article/details/51588008\">原git中status指令总是提示内容被修改的解决</a><br><a href=\"https://www.zhihu.com/question/38781463?sort=created\">hexo本地测试运行重启后页面空白</a></p>\n","categories":["工具","Hexo"],"tags":["Hexo"]},{"title":"小程序自定义Modal组件","url":"/2018/06/21/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89Modal%E7%BB%84%E4%BB%B6/","content":"<blockquote>\n<p>在小程序 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/\">官方文档</a> 中可以使用 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/api-react.html#wxshowmodalobject\">wx.showModal()</a> 方法来生成 Modal 蒙层弹框，但是其显示的内容只能为文本格式且由传入参数限定，显示方式比较单一，不能满足日常多样化的需求。本人查阅了相关资料完成一些自定义Modal组件，可以满足个性化需求。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><p>在这里的实现思路主要是通过微信小程序的原生 Modal 组件来实现，这个组件在最新版的官方文档中已经找不到，估计官方是想用 <code>wx.showModal()</code> 方法来代替使用，但是仍然可以向下兼容使用。通过原生的 Modal 组件我们可以自定义自己的内容界面，Modal 组件的 api 文档如下</p>\n<p><img src=\"/.com//docs.png\" alt=\"原生Modal官方文档\"></p>\n<p>再对比 <code>wx.showModal()</code> 的 api 文档不难看出其只是对 Modal 组件的进一步封装。</p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><h3 id=\"wxml\"><a href=\"#wxml\" class=\"headerlink\" title=\"wxml\"></a>wxml</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--打印发货单蒙层--&gt;</span><br><span class=\"line\">  &lt;modal hidden=&quot;&#123;&#123;hideModal&#125;&#125;&quot; class=&#x27;modal&#x27; cancel-text=&#x27;返回&#x27; confirm-text=&#x27;下一步&#x27; bindcancel=&quot;cancelPrint&quot; bindconfirm=&quot;confirmPrint&quot; catchtouchmove=&#x27;preventTouchMove&#x27;&gt;</span><br><span class=\"line\">    &lt;view class=&#x27;modal-box&#x27;&gt;</span><br><span class=\"line\">      &lt;radio-group bindchange=&#x27;radioChange&#x27;&gt;</span><br><span class=\"line\">        &lt;label class=&#x27;radio modal-item&#x27;&gt;</span><br><span class=\"line\">          &lt;view class=&#x27;modal-item-hd&#x27;&gt;</span><br><span class=\"line\">            &lt;radio value=&#x27;1&#x27; checked=&#x27;&#123;&#123;radioIndex == 1&#125;&#125;&#x27;&gt;&lt;/radio&gt;</span><br><span class=\"line\">            &lt;view&gt;根据手机号和提货码发货&lt;/view&gt;</span><br><span class=\"line\">          &lt;/view&gt;</span><br><span class=\"line\">          &lt;view class=&#x27;modal-item-bd&#x27;&gt;</span><br><span class=\"line\">            &lt;view&gt;手机号：&#123;&#123;phone&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">            &lt;view&gt;提货码：&#123;&#123;detail.ladingCode&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">          &lt;/view&gt;</span><br><span class=\"line\">        &lt;/label&gt;</span><br><span class=\"line\">        &lt;label class=&#x27;radio modal-item&#x27;&gt;</span><br><span class=\"line\">          &lt;view class=&#x27;modal-item-hd&#x27;&gt;</span><br><span class=\"line\">            &lt;radio value=&#x27;2&#x27;&gt;&lt;/radio&gt;</span><br><span class=\"line\">            &lt;view&gt;扫描二维码&lt;/view&gt;</span><br><span class=\"line\">          &lt;/view&gt;</span><br><span class=\"line\">          &lt;view class=&#x27;modal-item-bd&#x27;&gt;</span><br><span class=\"line\">            &lt;view&gt;请点击下一步&lt;/view&gt;</span><br><span class=\"line\">          &lt;/view&gt;</span><br><span class=\"line\">        &lt;/label&gt;</span><br><span class=\"line\">      &lt;/radio-group&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">  &lt;/modal&gt;</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>wxml文件最关键部分是 <code>&lt;modal&gt;&lt;/modal&gt;</code> 组件的调用，参数解析如下</p>\n<ul>\n<li>通过 <code>hidden</code> 属性来控制蒙层的显示和隐藏</li>\n<li><code>bindcancel</code> 属性绑定返回时间</li>\n<li><code>bindconfirm</code> 属性绑定确认事件</li>\n<li><code>catchtouchmove</code> 防止触摸滑动穿透，即当 modal 弹层下的页面有滚动条，在 modal 弹层上触摸滑动时下面的页面仍跟着滚动的情况。</li>\n</ul>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">data: &#123;</span><br><span class=\"line\">  phone: null,</span><br><span class=\"line\">  detail: null,</span><br><span class=\"line\">  hideModal: true,</span><br><span class=\"line\">  radioIndex: 1</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 显示modal组件</span><br><span class=\"line\"> */</span><br><span class=\"line\">printDel: function() &#123;</span><br><span class=\"line\">  this.setData(&#123;</span><br><span class=\"line\">    hideModal: false</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 隐藏modal组件</span><br><span class=\"line\"> */</span><br><span class=\"line\">cancelPrint: function() &#123;</span><br><span class=\"line\">  this.setData(&#123;</span><br><span class=\"line\">    hideModal: true</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 阻断蒙层事件向下传递</span><br><span class=\"line\"> */</span><br><span class=\"line\">preventTouchMove: function() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 选择打印发货单方式</span><br><span class=\"line\"> */</span><br><span class=\"line\">radioChange: function(e) &#123;</span><br><span class=\"line\">  this.setData(&#123;</span><br><span class=\"line\">    radioIndex: e.detail.value</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 确认打印</span><br><span class=\"line\"> */</span><br><span class=\"line\">confirmPrint: function() &#123;</span><br><span class=\"line\">  var radioIndex = this.data.radioIndex</span><br><span class=\"line\">  if(radioIndex == 1) &#123;</span><br><span class=\"line\">    //根据手机号和提货码发货</span><br><span class=\"line\">    wx.showToast(&#123;</span><br><span class=\"line\">      title: &#x27;请在终端屏幕上输入手机号和提货码&#x27;,</span><br><span class=\"line\">      icon: &#x27;none&#x27;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;else &#123;</span><br><span class=\"line\">    //扫描二维码</span><br><span class=\"line\">    /** code */</span><br><span class=\"line\">    this.setData(&#123;</span><br><span class=\"line\">      hideModal: true</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure>\n<p>js 文件中最关键的是 <code>this.setData(&#123; hideModal: true / false &#125;)</code> 来控制 Modal 组件的隐藏&#x2F;显示，以及空方法 <code>preventTouchMove()</code> 阻止事件向父节点传递。</p>\n<blockquote>\n<p>以bind或catch开头，然后跟上事件的类型，bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。</p>\n</blockquote>\n<p>详见 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html\">小程序事件</a></p>\n<h3 id=\"wxss\"><a href=\"#wxss\" class=\"headerlink\" title=\"wxss\"></a>wxss</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">.modal-item-hd &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  align-items: center</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.modal-item-hd view &#123;</span><br><span class=\"line\">  font-size: 32rpx;</span><br><span class=\"line\">  color: #000;</span><br><span class=\"line\">  padding-top: 5rpx</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.modal-item-bd &#123;</span><br><span class=\"line\">  margin: 10rpx 0 20rpx 60rpx;</span><br><span class=\"line\">  font-size: 36rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>wxss比较简单，在这里不做详细解析。</p>\n<h2 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h2><div style=\"width: 50%\">![最终效果图](rs.jpeg)<div>\n\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><p><a href=\"https://blog.csdn.net/zhuyb829/article/details/73349295\">自定义模态对话框实例</a><br><a href=\"https://www.cnblogs.com/liululin/p/6001437.html\">微信小程序之—-弹框组件modal</a><br><a href=\"https://blog.csdn.net/u011072139/article/details/54016575\">小程序 实现遮罩层</a></p>\n</div></div>","categories":["平台开发","微信小程序"],"tags":["微信小程序"]},{"title":"Hexo个人博客绑定域名","url":"/2018/06/24/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/","content":"<blockquote>\n<p>Hexo + Github 搭建的个人博客访问地址默认为 <code>yourname.github.io</code>，这种地址一方面由于太长不容易被人记住，另一方面也难以被谷歌、百度等搜索引擎收录。所以我们可以申请独立的域名指向我们的博客地址，转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"域名\"><a href=\"#域名\" class=\"headerlink\" title=\"域名\"></a>域名</h2><p>目前国内有万网、新网等域名服务商，下面以 万网 为例子说明</p>\n<h3 id=\"购买域名\"><a href=\"#购买域名\" class=\"headerlink\" title=\"购买域名\"></a>购买域名</h3><p>登陆 <a href=\"https://wanwang.aliyun.com/\">万网官网</a>，申请阿里云账号，然后在 <a href=\"https://wanwang.aliyun.com/domain/\">域名注册</a> 页面购买自己的域名</p>\n<p><img src=\"/.com//shenqing.jpeg\" alt=\"购买域名\"></p>\n<blockquote>\n<p>按照工信部 2017 年全面域名实名认证的要求,若域名在规定时间内未通过实名审核，会被注册局暂停解析（Serverhold），无法正常访问，待实名认证通过后方可恢复正常使用。实名认证流程为：</p>\n</blockquote>\n<ol>\n<li>登录 <a href=\"https://dc.console.aliyun.com/next/index#/domain/list/all-domain\">阿里云域名控制台</a>，单击 域名列表 页面的 <strong>未实名认证域名</strong> &gt; <strong>提交资料</strong> 。</li>\n<li>填写实名认证资料，单击 <strong>提交</strong> 。</li>\n</ol>\n<h3 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h3><p>在 <strong>域名列表</strong> 里面找到你注册成功且通过实名认证可正常使用的域名，点击 <strong>解析</strong> 按钮（未实名认证状态异常的域名可能没有该按钮）</p>\n<p><img src=\"/.com//jiexi1.jpeg\" alt=\"解析1\"></p>\n<p>在 <strong>解析设置</strong> 界面点击右上角 <strong>添加记录</strong>，填写内容</p>\n<div style=\"width: 50%\">![解析2](jiexi2.jpeg)</div>\n* 记录类型：`CNAME` 类型将该域名指向你的 yourname.github.io，也可以用 `A类型`指向 ip 地址：*先 ping 你的 yourusername.github.io，用 `A` 类型指向 ping 得到的 ip 地址*。\n* 主机记录：`www` 解析后的域名为 www.aliyun.com, `@` 直接解析主域名 aliyun.com。一般写这两个就行。\n* 记录值：`CNAME` 解析对应 yourname.github.io，`A` 解析对应 ip 地址。\n\n<p>添加成功后如下图所示：<br><img src=\"/.com//jiexi3.jpeg\" alt=\"jiexi3\"></p>\n<h2 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h2><p>我们要在上传到 GitHub 的静态文件夹里面添加 <code>CNAME</code> 解析文件，对应上面添加的 <code>CNAME</code> 解析记录。</p>\n<h3 id=\"创建-CNAME-文件\"><a href=\"#创建-CNAME-文件\" class=\"headerlink\" title=\"创建 CNAME 文件\"></a>创建 <code>CNAME</code> 文件</h3><p>我们在站点目录的 <code>source</code> 文件夹下面创建 <code>CNAME</code> 文件，这样每次我们生成静态文件的时候都会自动把该文件添加到 <code>public</code> 文件夹。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cd source</span><br><span class=\"line\">$ vim CNAME</span><br></pre></td></tr></table></figure>\n\n<p><em>注意文件名就是 <code>CNAME</code>，不能写错</em>，在文件中添加你注册的域名如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mcbill.cn</span><br></pre></td></tr></table></figure>\n\n<p>注意域名前面不用加任何前缀，保存退出。</p>\n<h3 id=\"发布部署\"><a href=\"#发布部署\" class=\"headerlink\" title=\"发布部署\"></a>发布部署</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>\n\n<p>部署成功再过几分钟访问你的域名，如 <code>mcbill.cn</code> 解析成功就会跳转到你的博客。以后就算是直接访问 <code>yourname.github.io</code> 也会直接解析为你的域名。至此 <em>绑定域名已经完成</em>。</p>\n","categories":["工具","Hexo"],"tags":["Hexo"]},{"title":"Hexo问题及解决办法汇总","url":"/2018/06/25/Hexo%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E6%B1%87%E6%80%BB/","content":"<blockquote>\n<p>对通过 Hexo 搭建博客过程中遇到的问题进行了汇总，以后再遇到相同的问题可以迅速定位解决问题。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"搜索问题\"><a href=\"#搜索问题\" class=\"headerlink\" title=\"搜索问题\"></a>搜索问题</h2><h3 id=\"点击-Local-Search-本地搜索页面卡住\"><a href=\"#点击-Local-Search-本地搜索页面卡住\" class=\"headerlink\" title=\"点击 Local Search 本地搜索页面卡住\"></a>点击 Local Search 本地搜索页面卡住</h3><p>问题描述：安装教程配置好 Local Search 本地搜索之后，点击 <strong>搜索</strong> 按钮页面一直卡在转圈圈的地方，F12进入开发者工具没有看到错误提示，以 <code>debug</code> 模式启动的服务器也没有错误输出？</p>\n<p>问题解决：出现这种情况是因为你的某一篇文章中出现了非 UTF-8 编码的字符，解决办法是 <em>找到把该异常字符并删除</em>。</p>\n<ul>\n<li>打开 <code>http://localhost:4000/search.xml</code>，确认错误字符所在的位置。如下图所示就在 <em>第6行第35列</em></li>\n</ul>\n<div style=\"width: 80%; margin: auto\">![localsearch1](localsearch1.jpeg)</div>\n* 通过 `$ vim public/search.xml` 打开 `search.xml` 文件，根据刚才的位置定位到出现问题的文章的该行该列。该位置一般会出现一个异常字符，例如 `^H` 或者 `^M` 等字符。*注意不用直接修改 `search.xml` 文件*。\n* 编辑出现问题的文章的 `md` 文件，找到出现问题的行列，把该位置的特殊字符删掉。该字符有可能是一个隐藏的字符如 `^H`，一般的 markdown 编辑工具可能看不到该字符，可以通过 `vim` 编辑删除该字符。\n* 执行 `$ hexo clean && hexo g` 后重启服务器，然后再打开 `http://localhost:4000/search.xml`，看到下图所示表示可以正常使用本地搜索功能。\n\n<div style=\"width: 80%; margin: auto\">![localsearch2](localsearch2.jpeg)</div>\n## 部署问题\n\n<h3 id=\"在执行-hexo-d-部署到-GitHub-上的时候总是卡住\"><a href=\"#在执行-hexo-d-部署到-GitHub-上的时候总是卡住\" class=\"headerlink\" title=\"在执行 hexo d 部署到 GitHub 上的时候总是卡住\"></a>在执行 <code>hexo d</code> 部署到 GitHub 上的时候总是卡住</h3><p>问题描述：在执行 <code>hexo d</code> 部署到 GitHub 上的时候总是卡住没有往下面执行，这时候只能 <code>ctrl + c</code> 中断或等待很久一段时间后才执行完毕。</p>\n<p>问题解决：这是由于国内墙对 GitHub 的阻挡影响，导致国内用户在向 GitHub 仓库 <code>pull</code> 或者 <code>push</code> 的时候速度都会受到不同程度的影响。解决办法是 <em>买或者自己搭建个 vpn，然后设置 git 代理</em>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 查看当前代理设置</span><br><span class=\"line\">git config --global http.proxy</span><br><span class=\"line\">git config --global https.proxy</span><br><span class=\"line\"></span><br><span class=\"line\">// 设置当前代理为 http://127.0.0.1:1080 或 socket5://127.0.0.1:1080</span><br><span class=\"line\">git config --global http.proxy &#x27;http://127.0.0.1:1080&#x27;</span><br><span class=\"line\">git config --global https.proxy &#x27;http://127.0.0.1:1080&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">git config --global http.proxy &#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class=\"line\">git config --global https.proxy &#x27;socks5://127.0.0.1:1080&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除 proxy</span><br><span class=\"line\">git config --global --unset http.proxy</span><br><span class=\"line\">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>","categories":["工具","Hexo"],"tags":["Hexo","问题汇总"]},{"title":"小程序自定义tabBar","url":"/2018/06/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89tabBar/","content":"<blockquote>\n<p>tabBar 是指小程序底部的导航栏，微信小程序官方提供了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/config.html?search-key=tabbar\">多 tabBar 设置</a>，但是官方提供的 tabBar 最多支持 5 个 tab，而且是全局共用的，这意味着并不支持 <em>有时候我们想跳到不同的页面显示不同的 tabBar 导航栏</em> 这样的功能。所以本人尝试着手实现自定义的 tabBar 导航栏。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h2><p>参考过网上自定义 tabBar 的一些资料，例如这位仁兄的 <a href=\"https://blog.csdn.net/qq_29729735/article/details/78933721\">微信小程序自定义tabBar组件开发</a>，发现大部分资料都是 <em>通过 <code>navigateTo</code> 的方式进行 tab 切换</em>。这种实现方式有一个很明显的缺点：在 tab 切换的时候整个页面都会刷新一次，这意味着页面底下的 tabBar 导航栏也会跟着刷新，这样会很影响用户体验。官网的 tabBar 导航栏是在底层实现，所以不会出现这种刷新情况。</p>\n<p>因为没有办法解决这种通过 <code>navigateTo </code> 实现 tabBar 的刷新问题，本人转换了一种思路。<em>这种办法适合于每个 tab 页面数据量不是很大的情况</em>，如果你每个页面的数据量都非常大而且需要实时刷新的话可能不太适合这种方法。</p>\n<ol>\n<li>所有的 tab 页面和底下 tabBar 导航栏都写在同一个 wxml 页面里面，每个 tab 页面跟导航栏的一个按钮对应。</li>\n<li>在打开页面时所有 tab 页面的数据通过一个路由取回，然后渲染到各个 tab 页面里面。然后只把第一个 tab 页面的内容显示出来，其他 tab 页面都隐藏。</li>\n<li>每次点击下面的 tabBar 导航栏，只把点击按钮对应的 tab 页面显示出来，其他的 tab 页面都隐藏。</li>\n</ol>\n<p>这样实现的好处是 tab 切换时底部导航栏不会刷新，而且切换非常流畅，缺点是切换时 tab 页面不能实现实时刷新。如果你觉得这种实现方法能满足你的需求，请继续往下看。</p>\n<h2 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h2><p>下面显示每部分的核心代码。</p>\n<h3 id=\"wxml\"><a href=\"#wxml\" class=\"headerlink\" title=\"wxml\"></a>wxml</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;view class=&#x27;container&#x27;&gt;</span><br><span class=\"line\">  &lt;view class=&#x27;del-list&#x27;&gt;</span><br><span class=\"line\">    &lt;view class=&quot;page__bd&quot;&gt;</span><br><span class=\"line\">      &lt;block wx:if=&#x27;&#123;&#123;tabbarIndex == 0&#125;&#125;&#x27;&gt;</span><br><span class=\"line\">      // tab 页面1代码</span><br><span class=\"line\">      &lt;/block&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &lt;block wx:if=&#x27;&#123;&#123;tabbarIndex == 1&#125;&#125;&#x27;&gt;</span><br><span class=\"line\">      // tab 页面2代码</span><br><span class=\"line\">      &lt;/block&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">  &lt;!--自定义导航栏--&gt;</span><br><span class=\"line\">  &lt;view class=&#x27;tabbar&#x27;&gt;</span><br><span class=\"line\">    &lt;view class=&#x27;tabbar-box&#x27;&gt;</span><br><span class=\"line\">      &lt;view class=&#x27;tabbar-item&#x27; wx:for=&quot;&#123;&#123;tabbarList&#125;&#125;&quot; bindtap=&#x27;tapTabbar&#x27; id=&quot;&#123;&#123;item.index&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;view class=&#x27;tabbar-item-icon&#x27;&gt;</span><br><span class=\"line\">          &lt;image src=&#x27;&#123;&#123;item.icon&#125;&#125;&#x27;&gt;&lt;/image&gt;</span><br><span class=\"line\">        &lt;/view&gt;</span><br><span class=\"line\">        &lt;view class=&#x27;tabbar-item-text&#x27;&gt;&#123;&#123;item.text&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">      &lt;/view&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">  &lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n<p><em>底部导航栏为 <code>tabbarList </code> 的一个 list 数组，每个 tab 页面的 <code>tabbarIndex</code> 跟 list 数组的 <code>index</code> 对应</em>。这样就可以根据 <code>index</code> 来显示对应的 tab 页面。</p>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Page(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">\t</span><br><span class=\"line\">  tabbarList: [&#123;</span><br><span class=\"line\">    index: 0,</span><br><span class=\"line\">    icon: &#x27;/images/driver/deliver-select.png&#x27;,</span><br><span class=\"line\">    text: &#x27;发货单&#x27;</span><br><span class=\"line\">  &#125;, &#123;</span><br><span class=\"line\">    index: 1,</span><br><span class=\"line\">    icon: &#x27;/images/driver/my.png&#x27;,</span><br><span class=\"line\">    text: &#x27;我的&#x27;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\">    tabbarIndex: 0,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * 点击tabbar导航栏</span><br><span class=\"line\">   */</span><br><span class=\"line\">  tapTabbar: function(e) &#123;</span><br><span class=\"line\">    var index = e.currentTarget.id</span><br><span class=\"line\">    var tabbarList = this.data.tabbarList</span><br><span class=\"line\">    for (var item in tabbarList) &#123;</span><br><span class=\"line\">      if (tabbarList[item].index == index) &#123;</span><br><span class=\"line\">        var icon = tabbarList[item].icon</span><br><span class=\"line\">        var iconList = icon.split(&#x27;.&#x27;)</span><br><span class=\"line\">        if(iconList[0].indexOf(&#x27;select&#x27;) &lt; 0) &#123;</span><br><span class=\"line\">          tabbarList[item].icon = iconList[0] + &#x27;-select.&#x27; + iconList[1]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;else &#123;</span><br><span class=\"line\">        var icon = tabbarList[item].icon</span><br><span class=\"line\">        var iconList = icon.split(&#x27;.&#x27;)</span><br><span class=\"line\">        if (iconList[0].indexOf(&#x27;select&#x27;) &gt; 0) &#123;</span><br><span class=\"line\">          var temp = iconList[0].replace(/-select/g, &#x27;&#x27;)</span><br><span class=\"line\">          tabbarList[item].icon = temp + &#x27;.&#x27; + iconList[1]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.setData(&#123;</span><br><span class=\"line\">      tabbarList: tabbarList,</span><br><span class=\"line\">      tabbarIndex: index</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  </span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>点击 tabBar 导航栏时，把当前点击按钮的图片更新为带 <code>-select</code> 后缀表示选中的图片，其他的按钮图片更新为无后缀图片，然后重新渲染 <code>tabbarList</code> 和 <code>tabbarIndex </code>。</p>\n<h3 id=\"wxss\"><a href=\"#wxss\" class=\"headerlink\" title=\"wxss\"></a>wxss</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">.tabbar &#123;</span><br><span class=\"line\">  position: fixed;</span><br><span class=\"line\">  z-index: 999;</span><br><span class=\"line\">  bottom: 0;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 120rpx;</span><br><span class=\"line\">  background-color: #f8f8f8;</span><br><span class=\"line\">  border-top: 1rpx solid #d9d9d9</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.tabbar-box &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  align-items: center;</span><br><span class=\"line\">  justify-content: center</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.tabbar-item &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-direction: column;</span><br><span class=\"line\">  text-align: center;</span><br><span class=\"line\">  justify-content: center;</span><br><span class=\"line\">  margin-top: 10rpx;</span><br><span class=\"line\">  width: 50%</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.tabbar-item image &#123;</span><br><span class=\"line\">  width: 65rpx;</span><br><span class=\"line\">  height: 65rpx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.tabbar-item-icon &#123;</span><br><span class=\"line\">  height: 65rpx</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.tabbar-item-text &#123;</span><br><span class=\"line\">  font-size: 28rpx;</span><br><span class=\"line\">  color: #999</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.del-list-logout &#123;</span><br><span class=\"line\">  width: 90%;</span><br><span class=\"line\">  margin: 50rpx auto 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"tabBar-图片\"><a href=\"#tabBar-图片\" class=\"headerlink\" title=\"tabBar 图片\"></a>tabBar 图片</h3><div style=\"width: 50%\">![tabbar](tabbar.jpeg)</div>\n## 实现效果\n\n<div style=\"width: 45%; display: inline-block; margin-right: 5%\">![rs1](rs1.jpeg)</div>\n<div style=\"width: 45%; display: inline-block\">![rs2](rs2.jpeg)</div>","categories":["平台开发","微信小程序"],"tags":["微信小程序"]},{"title":"Hexo博客SEO优化","url":"/2018/06/29/Hexo%E5%8D%9A%E5%AE%A2SEO%E4%BC%98%E5%8C%96/","content":"<blockquote>\n<p>SEO（Search Engine Optimization）即搜索引擎优化，利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名，即让搜索引擎更加容易搜索到我们的网站且结果更加靠前。当我们在网上搭建好自己的博客之后，百度、谷歌等搜索引擎并不能立即搜索到我们的博客。我们需要做一些工作来让搜索引擎更加容易搜到我们的博客。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>为了让搜索引擎更加容易搜索到我们的博客，我们需要做的工作有：</p>\n<ol>\n<li>在搜索引擎收录入口添加我们的网站（同时添加带 www 前缀的和不带 www 前缀的）</li>\n<li>向搜索引擎推送我们的网站，谷歌可以推送 sitemap 文档，百度有主动推送、自动推送和 sitemap 文档等多种方式。</li>\n<li>等待搜索引擎的收录。</li>\n</ol>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p><a href=\"https://www.cnblogs.com/tengj/p/5357879.html\">hexo干货系列：（六）hexo提交搜索引擎（百度+谷歌</a> 这篇文章已经介绍得很详细，在这里只做部分补充。</p>\n<h3 id=\"通过-CNAME-方式验证网站\"><a href=\"#通过-CNAME-方式验证网站\" class=\"headerlink\" title=\"通过 CNAME 方式验证网站\"></a>通过 CNAME 方式验证网站</h3><p>上面的教程中是通过在网站根目录里面添加验证文件的方式来验证网站持有者的身份，如果你拥有独立的域名，通过 CNAME 的方法来验证会更加方便。</p>\n<h4 id=\"1、添加网站\"><a href=\"#1、添加网站\" class=\"headerlink\" title=\"1、添加网站\"></a>1、添加网站</h4><p><a href=\"https://ziyuan.baidu.com/site/index\">百度添加网站入口</a><br><a href=\"https://www.google.com/webmasters/tools/home\">谷歌添加网站入口</a></p>\n<p>添加你的域名地址，<em>注意：最好每个搜索引擎都添加带 www 前缀和不带 www 前缀的两条记录</em>，百度需要添加一些介绍信息之类，最后到验证网站所有权。</p>\n<h4 id=\"2、验证网站\"><a href=\"#2、验证网站\" class=\"headerlink\" title=\"2、验证网站\"></a>2、验证网站</h4><p>谷歌：<strong>备用方法</strong> &gt; <strong>域名提供商</strong> &gt; <strong>添加 CNAME 记录</strong></p>\n<p><img src=\"/.com//cname1.jpeg\" alt=\"cname1\"></p>\n<p>百度：<strong>CNAME 验证</strong></p>\n<p><img src=\"/.com//cname2.jpeg\" alt=\"cname2\"></p>\n<p>选择 CNAME 验证会得到两个网址 <code>xxx.你的域名</code> 和 搜索引擎验证网址（百度：<code>ziyuan.baidu.com</code> &#x2F; 谷歌：<code>xxx.dv.googlehosted.com</code>），这两个网址下面需要用到。</p>\n<h4 id=\"3、域名解析添加-CNAME-记录\"><a href=\"#3、域名解析添加-CNAME-记录\" class=\"headerlink\" title=\"3、域名解析添加 CNAME 记录\"></a>3、域名解析添加 CNAME 记录</h4><p>以万网为例，进入 <a href=\"https://dc.console.aliyun.com/next/index#/domain/list/all-domain\">域名列表</a>，点击 <strong>解析</strong> &gt; <strong>添加记录</strong>，记录类型选择 <code>CNAME</code>，主机记录前缀填写上面 <code>xxx.你的域名</code> 中的 <code>xxx</code> 前缀，解析线路默认即可，记录值填写搜索引擎验证网址，以添加谷歌验证为例：</p>\n<div style=\"width: 70%\">![cname3](cname3.jpeg)</div>\n#### 4、完成\n返回刚才搜索引擎的站点管理网址，点击 **验证**，验证成功，如果失败过一段时间再来点击验证。\n\n<h3 id=\"生成站点地图文件补充\"><a href=\"#生成站点地图文件补充\" class=\"headerlink\" title=\"生成站点地图文件补充\"></a>生成站点地图文件补充</h3><p>按照上面教程成功生成 sitemap.xml 和baidusitemap.xml 文件之后，这两个文件里面的域名默认为 <code>http://yoursite.com</code>，这个域名并不会自动转换成你的域名地址，直接提交给搜索引擎解析会报错，因此需要手动改成我们的域名地址，详细参考 <a href=\"https://blog.csdn.net/qiuchengjia/article/details/52923170\">hexo做SEO（添加sitemap和baidusitemap）</a></p>\n<h3 id=\"百度收录失败问题\"><a href=\"#百度收录失败问题\" class=\"headerlink\" title=\"百度收录失败问题\"></a>百度收录失败问题</h3><p>谷歌收录按照步骤完成之后一般都能正确收录，而且收录速度也很快。但是百度收录就比较难。<strong>注意：如果你的网站是搭建在 GitHub 上面，就不能被百度收录</strong>。</p>\n<blockquote>\n<p>百度爬取 GitHub 太频繁了，甚至引起了 GitHub 的服务不稳定，最后 GitHub 直接把百度屏蔽了，百度爬虫访问直接报 403 错误。也就是说，所有托管到 GitHub Pages 上的静态博客都是无法被百度搜索到。</p>\n</blockquote>\n<p>如果你希望你的博客能被百度收录，可以参考 <a href=\"http://guochenglai.com/2016/09/26/baidu-crow-github-page/\">百度无法爬取Github Pages静态网站解决方案</a></p>\n","categories":["工具","Hexo"],"tags":["Hexo","SEO"]},{"title":"Hadoop入门及安装","url":"/2018/07/01/Hadoop%E5%85%A5%E9%97%A8%E5%8F%8A%E5%AE%89%E8%A3%85/","content":"<blockquote>\n<p>当我们需要从 TB 甚至 PB 级别以上的数据中分析获取我们需要的信息时，如果使用传统的系统架构进行处理速度将会非常慢并且对服务器造成巨大压力。Hadoop 就是用来存储并处理这种巨大数据量的分布式架构平台。用户在该平台上可以在不需要了解底层实现细节的情况下开发高效处理大数据的程序。下面介绍 Hadoop 的一些入门知识和安装配置。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"入门知识\"><a href=\"#入门知识\" class=\"headerlink\" title=\"入门知识\"></a>入门知识</h2><h3 id=\"Hadoop-是什么\"><a href=\"#Hadoop-是什么\" class=\"headerlink\" title=\"Hadoop 是什么\"></a>Hadoop 是什么</h3><p>Hadoop 是一个用来处理大数据的分布式存储和计算平台。简单来说这个平台最重要的两个作用是 <strong>存储</strong> 和 <strong>计算</strong>：</p>\n<ul>\n<li>存储：分布式存储，数据被分散到多台机器上存储，由至少一台机器进行分配管理。该过程对开发人员是透明，也就是说开发人员对数据的存取过程感受不到数据是分散存储的。</li>\n<li>计算：分布式计算，用户请求被分解成多个任务在多台机器上运行，运行结果集汇总成最终结果再返回给用户。该过程对开发人员同样是透明的。</li>\n</ul>\n<p>基于以上分布式的特点 Hadoop 可以在大量廉价的机器上搭建一个分布式集群系统架构。开发人员只要先把巨大数据存储在 Hadoop 平台上，然后根据统计分析需求编写简单的处理程序。<em>Hadoop 平台会自动把数据进行分割存储，把处理程序分解映射成多个任务分配到多台机器上进行并行计算，然后把结果集汇总返回给用户</em>。</p>\n<h3 id=\"Hadoop-生态系统\"><a href=\"#Hadoop-生态系统\" class=\"headerlink\" title=\"Hadoop 生态系统\"></a>Hadoop 生态系统</h3><p>Hadoop 平台和基于该平台的相关模块框架形成一套完善的 <strong>Hadoop生态系统</strong>。该生态系统包含的组件大概如下：</p>\n<p><img src=\"/.com//shengtai.png\" alt=\"shengtai\"></p>\n<p>在该系统中最核心的两大组件是 <strong>HDFS</strong> 和 <strong>MapReduce</strong>，这两个组件是 Hadoop 平台最早推出的体现分布式处理数据思想的组件。此外还有 <strong>YARN</strong> 资源组件。</p>\n<ul>\n<li><strong>HDFS</strong>：Hadoop Distributed File System，分布式文件存储系统。该系统把数据分割成多个部分分别存储到多台机器 (DataNode) 上，然后由一台机器 (NameNode) 进行统一组织管理。该系统只是用来管理数据的存储方式，并不存储数据。详细可参考 <a href=\"http://www.cnblogs.com/edisonchou/p/3485135.html\">基本介绍</a></li>\n</ul>\n<blockquote>\n<p>HDFS 架构采用主从架构（master&#x2F;slave）。一个典型的 HDFS 集群包含一个 NameNode 节点和多个 DataNode 节点。NameNode 节点负责整个 HDFS 文件系统中的文件的元数据保管和管理，集群中通常只有一台机器上运行 NameNode 实例，DataNode 节点保存文件中的数据，集群中的机器分别运行一个 DataNode 实例。在 HDFS 中，NameNode 节点被称为名称节点，DataNode 节点被称为数据节点。DataNode 节点通过心跳机制与 NameNode 节点进行定时的通信。</p>\n</blockquote>\n<ul>\n<li><strong>MapReduce</strong>：一种用于大规模数据集并行计算的编程模型，包含两项重要函数：Map 和 Reduce。简单来说就是先通过 Map 计算把任务分发到集群多个节点上，并行计算，然后再通过 Reduce 计算把计算结果合并，从而得到最终计算结果。详细可参考 <a href=\"http://www.cnblogs.com/edisonchou/p/3485135.html\">基本介绍</a> 和 <a href=\"https://blog.csdn.net/q739404976/article/details/73188645\">MapReduce详解</a></li>\n</ul>\n<blockquote>\n<p>MapReduce由以下四个部分组成：</p>\n<ol>\n<li>Client：面向用户的接口。</li>\n</ol>\n<ul>\n<li>用户编写的 MapReduce 程序通过 Client 提交到 JobTracker 端</li>\n<li>用户可通过 Client 提供的一些接口查看作业运行状态</li>\n</ul>\n<ol start=\"2\">\n<li>JobTracker：负责所有节点的资源监控和作业调度。主节点只有一个 JobTracker。</li>\n</ol>\n<ul>\n<li>监控所有 TaskTracker 与 Job 的健康状况，一旦发现失败，就将相应的任务转移到其他节点。</li>\n<li>跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器（TaskScheduler），而调度器会在资源出现空闲时，选择合适的任务去使用这些资源。</li>\n</ul>\n<ol start=\"3\">\n<li>TaskTracker：负责本节点的资源监控和作业调度。从节点有多个 TaskTracker。</li>\n</ol>\n<ul>\n<li>TaskTracker 会周期性地通过“心跳”将本节点上资源的使用情况和任务的运行进度汇报给 JobTracker，同时接收 JobTracker 发送过来的命令并执行相应的操作（如启动新任务、杀死任务等）</li>\n<li>TaskTracker 使用 slot等量划分本节点上的资源量（CPU、内存等）。一个 Task 获取到一个 slot 后才有机会运行，而 Hadoop 调度器的作用就是将各个 TaskTracker 上的空闲 slot 分配给 Task 使用。slot 分为 Map slot 和 Reduce slot 两种，分别供 MapTask 和 Reduce Task 使用</li>\n</ul>\n<ol start=\"4\">\n<li>Task：分为 Map Task 和 Reduce Task 两种，均由 TaskTracker 启动</li>\n</ol>\n</blockquote>\n<ul>\n<li><p><strong>YARN</strong>：一个通用的资源管理系统，可为各类计算框架提供资源的管理和调度。它的基本设计思想是将 MRv1 中的 JobTracker 拆分成了两个独立的服务：一个全局的资源管理器 ResourceManager 和每个应用程序特有的 ApplicationMaster。其中 ResourceManager 负责整个系统的资源管理和分配，而 ApplicationMaster 负责单个应用程序的管理。详细可参考 <a href=\"https://www.cnblogs.com/chushiyaoyue/p/5784871.html\">Hadoop-Yarn-框架原理及运作机制（原理篇）</a> 和 <a href=\"https://blog.csdn.net/bingduanlbd/article/details/51880019\">理解Hadoop YARN架构</a></p>\n</li>\n<li><p><strong>Hbase</strong>：一个开源的非关系型分布式数据库，可以通过廉价的机器构建集群来处理庞大的数据表，例如超过10亿行数据和数百万列元素组成的数据表。</p>\n<blockquote>\n<p>HDFS 缺乏随机读写操作，HBase 可以用来弥补这种缺陷，其提供可以实时访问一些数据的随机读写功能。HBase 以 Google BigTable 为蓝本，以键值对的形式存储。项目的目标就是快速在主机内数十亿行数据中定位所需的数据并访问它。<br>你可以用 Hadoop 作为静态数据仓库，HBase 作为数据存储，可以放一些需要实时访问和操作的数据。</p>\n</blockquote>\n</li>\n<li><p><strong>Hive</strong>：一个数据仓库工具。可以把用户的 HiveQL（类 SQL）语句自动转换成 MapReduce 任务，这样用户就不用理解 MapReduce API 的接口内容和编写复杂的 MapReduce 程序，只需要编写简单的类 SQL 语句就可以进行数据分析。</p>\n</li>\n<li><p><strong>Pig</strong>：一种数据流语言，用来快速轻松的处理巨大的数据。包含 Pig Interface 和 Pig Latin 两部分。Pig可以非常方便的处理 HDFS 和 HBase 的数据，和 Hive 类似，通过编写简单的 Pig 脚本就可以自动转换成 MapReduce 作业来处理数据。当你想做一些数据处理但又不想编写 MapReduce jobs 就可以用 Pig。</p>\n<blockquote>\n<p>Hive 和 Pig 的区别：</p>\n<ul>\n<li>Hive 更适合于数据仓库的任务，Hive 主要用于静态的结构以及需要经常分析的工作。Hive 与 SQL 相似促使 其成为 Hadoop 与其他 BI 工具结合的理想交集。  </li>\n<li>Pig 赋予开发人员在大数据集领域更多的灵活性，并允许开发简洁的脚本用于转换数据流以便嵌入到较大的应用程序。  </li>\n<li>Pig 相比 Hive 相对轻量，它主要的优势是相比于直接使用Hadoop Java APIs可大幅削减代码量。正因为如此，Pig 仍然是吸引大量的软件开发人员。  </li>\n<li>Hive 和 Pig 都可以与HBase组合使用，Hive 和 Pig 还为 HBase 提供了高层语言支持，使得在 HBase 上进行数据统计处理变的非常简单</li>\n</ul>\n</blockquote>\n</li>\n<li><p><strong>Mahout</strong>：Hadoop 平台上的数据挖掘算法库</p>\n</li>\n<li><p><strong>Zookeeper</strong>：一种分布式的应用程序协调服务。随着计算节点的增多，集群成员需要彼此同步并了解去哪里访问服务和如何配置，ZooKeeper正是为此而生的。</p>\n</li>\n<li><p><strong>Sqoop</strong>：Sqoop 一种数据同步和传输工具，主要用于在 Hadoop(Hive) 与传统的数据库 (mysql、postgresql…) 间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL, Oracle, Postgres等）中的数据导进到 Hadoop 的 HDFS 中，也可以将 HDFS 的数据导进到关系型数据库中。</p>\n</li>\n<li><p><strong>Flume</strong>：一种日志收集工具</p>\n</li>\n<li><p><strong>Ambari</strong>：一个集群的安装和管理工具</p>\n</li>\n</ul>\n<h2 id=\"Hadoop-安装\"><a href=\"#Hadoop-安装\" class=\"headerlink\" title=\"Hadoop 安装\"></a>Hadoop 安装</h2><p>以下配置环境</p>\n<ul>\n<li>Mac OS X 10.13.2</li>\n<li>Java 1.8.0_131</li>\n<li>Hadoop 2.8.4</li>\n</ul>\n<h3 id=\"1、Java-环境\"><a href=\"#1、Java-环境\" class=\"headerlink\" title=\"1、Java 环境\"></a>1、Java 环境</h3><p>在终端输入下面命令进行查看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ java -version</span><br></pre></td></tr></table></figure>\n\n<p>如果没有报错表示 Java 环境配置成功，否则请自行安装 Java<br>环境，在这里不做详细介绍</p>\n<h3 id=\"2、SSH-配置\"><a href=\"#2、SSH-配置\" class=\"headerlink\" title=\"2、SSH 配置\"></a>2、SSH 配置</h3><p>在终端输入下面命令进行查看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh localhost</span><br></pre></td></tr></table></figure>\n\n<p>如果没有报错直接显示登录时间则已经配置成功，一般来说可能会有下面两种异常情况。</p>\n<h4 id=\"用户没有权限\"><a href=\"#用户没有权限\" class=\"headerlink\" title=\"用户没有权限\"></a>用户没有权限</h4><p>进入 <strong>系统偏好设置</strong> &gt; <strong>共享</strong> &gt; <strong>勾选远程登录</strong>，并设置允许访问：所有用户。</p>\n<div style=\"width: 60%\">![ssh](ssh.jpeg)</div>\n#### 还没生成 ssh 密钥\n可以选择 rsa 或者 dsa 协议来生成，以 rsa 协议为例\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>\n\n<p>一路回车后会在 ~&#x2F;.ssh 目录下生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件，然后执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat ~/.ssh/id_rsa.pub &gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、下载-Hadoop\"><a href=\"#3、下载-Hadoop\" class=\"headerlink\" title=\"3、下载 Hadoop\"></a>3、下载 Hadoop</h3><p>点击 <a href=\"http://hadoop.apache.org/releases.html\">Hadoop 官方下载地址</a>，选择所需版本的 <code>binary</code> 包进行下载（<code>source</code> 包是源代码，<code>binary</code> 包是编译后的文件，一般来说我们直接使用后者即可）。以 2.8.4 版本为例，点击下载后进行解压。我的解压后安装路径为 <code>/Users/mochuangbiao/hadoop-2.8.4</code></p>\n<div style=\"width: 80%\">![xiazai](xiazai.jpeg)</div>\n### 4、配置 Hadoop\n\n<h4 id=\"配置-Java-环境\"><a href=\"#配置-Java-环境\" class=\"headerlink\" title=\"配置 Java 环境\"></a>配置 Java 环境</h4><p>如果还没有配置 Java 环境，查看 JDK 安装目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ /usr/libexec/java_home -V</span><br></pre></td></tr></table></figure>\n\n<p>添加该目录到环境配置文件 <code>~/.bash_profile</code> 中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置-Hadoop-环境\"><a href=\"#配置-Hadoop-环境\" class=\"headerlink\" title=\"配置 Hadoop 环境\"></a>配置 Hadoop 环境</h4><p>添加你的 Hadoop 安装目录路径到环境配置文件 <code>~/.bash_profile</code> 中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export HADOOP_HOME=/Users/mochuangbiao/hadoop-2.8.4</span><br><span class=\"line\">export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>修改 <code>~/.bash_profile</code> 文件后记得执行 <code>$ source ~/.bash_profile</code> 使其生效</p>\n</blockquote>\n<h4 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h4><p>需要修改的配置文件一共有四个：<strong>core-site.xml</strong>、<strong>hdfs-site.xml</strong>、<strong>mapred-site.xml</strong> 和 <strong>yarn-site.xml</strong>，所有文件均位于 <code>etc/hadoop</code> 目录下。文件的修改均为最简单化，如需要详细配置请参考官方文档。</p>\n<ul>\n<li>core-site.xml</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">   &lt;property&gt;</span><br><span class=\"line\">       &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class=\"line\">       &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class=\"line\">   &lt;/property&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>hdfs-site.xml</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">   &lt;property&gt;</span><br><span class=\"line\">       &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class=\"line\">       &lt;value&gt;1&lt;/value&gt;</span><br><span class=\"line\">   &lt;/property&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>mapred-site.xml</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">   &lt;property&gt;</span><br><span class=\"line\">       &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class=\"line\">       &lt;value&gt;yarn&lt;/value&gt;</span><br><span class=\"line\">   &lt;/property&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>yarn-site.xml <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;configuration&gt;</span><br><span class=\"line\">   &lt;property&gt;</span><br><span class=\"line\">       &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class=\"line\">       &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class=\"line\">   &lt;/property&gt;</span><br><span class=\"line\">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"5、启动\"><a href=\"#5、启动\" class=\"headerlink\" title=\"5、启动\"></a>5、启动</h3><h4 id=\"格式化-HDFS\"><a href=\"#格式化-HDFS\" class=\"headerlink\" title=\"格式化 HDFS\"></a>格式化 HDFS</h4><p>切换到 Hadoop 安装目录，输入命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hdfs namenode -format</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"启动-HDFS\"><a href=\"#启动-HDFS\" class=\"headerlink\" title=\"启动 HDFS\"></a>启动 HDFS</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ start-dfs.sh</span><br></pre></td></tr></table></figure>\n\n<p>可能需要输入三次密码，分别用来启动 NameNode、DataNode 和 SecondaryNameNode 三个线程，访问 <a href=\"http://localhost:50070/\">http://localhost:50070</a>，能看到以下界面表示启动成功</p>\n<p><img src=\"/.com//hdfs.jpeg\" alt=\"hdfs\"></p>\n<h4 id=\"启动-YARN\"><a href=\"#启动-YARN\" class=\"headerlink\" title=\"启动 YARN\"></a>启动 YARN</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ start-yarn.sh</span><br></pre></td></tr></table></figure>\n\n<p>可能需要输入一次到多次密码用来启动 ResourceManager 线程和 Nodemanager 线程，访问 <a href=\"http://localhost:8088/\">http://localhost:8088</a>，能看到以下界面表示启动成功</p>\n<p><img src=\"/.com//yarn.jpeg\" alt=\"yarn\"></p>\n<p>输入命令 <code>$ jps</code>，可以查看到以下节点信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">12963 DataNode</span><br><span class=\"line\">13076 SecondaryNameNode</span><br><span class=\"line\">12651 ResourceManager</span><br><span class=\"line\">12876 NameNode</span><br><span class=\"line\">20844 Jps</span><br><span class=\"line\">12748 NodeManager</span><br><span class=\"line\">19885 Launcher</span><br><span class=\"line\">19886 B2BApplication</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"停止\"><a href=\"#停止\" class=\"headerlink\" title=\"停止\"></a>停止</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ stop-yarn.sh</span><br><span class=\"line\">$ stop-dfs.sh</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Hadoop-常用-Shell-命令\"><a href=\"#Hadoop-常用-Shell-命令\" class=\"headerlink\" title=\"Hadoop 常用 Shell 命令\"></a>Hadoop 常用 Shell 命令</h2><p>调用 Hadoop Shell 命令在可使用 <code>$ hadoop fs &lt;args&gt;</code> 的形式（使用面最广，可以操作任何文件系统）或 <code>$ hdfs dfs &lt;args&gt;</code> 的形式（只能操作HDFS文件系统相关），区别可见 <a href=\"https://blog.csdn.net/jediael_lu/article/details/37649609\">何时使用hadoop fs、hadoop dfs与hdfs dfs命令</a>。常用 <code>&lt;args&gt;</code> 参数有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-ls #表示对hdfs下一级目录的查看 </span><br><span class=\"line\">-lsr #表示对hdfs目录的递归查看 </span><br><span class=\"line\">-mkdir #创建目录 </span><br><span class=\"line\">-put #从linux上传文件到hdfs </span><br><span class=\"line\">-get #从hdfs下载文件到linux </span><br><span class=\"line\">-text #查看文件内容 </span><br><span class=\"line\">-rm #表示删除文件 </span><br><span class=\"line\">-rmr #表示递归删除文件</span><br></pre></td></tr></table></figure>\n\n<p>详细的可参考 <a href=\"http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html\">Hadoop Shell 命令</a></p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>通过 HDFS 创建的目录和存储的文件以特殊的编码方式存放在机器上，不能在文件夹界面直接查看这些文件和目录，只能通过 Shell 命令来查看和操作这些文件</li>\n<li>HDFS的根目录是 <code>/</code>，这个是在 HDFS 系统上的目录，与系统目录无关。默认的工作目录是 <code>/user/$USER</code>，<code>USER</code> 是你的登录用户名。使用命令 <code>$ hdfs dfs -ls</code> 会直接显示工作目录 <code>/user/$USER</code> 下的内容</li>\n<li>使用 <code>-mkdir</code> 参数创建目录的时候，如果父目录不存在会报 <code>No such file or directory</code> 的错误。可以加上 <code>-p</code> 参数，如 <code>hdfs dfs -mkdir -p /user/Hadoop/twitter_data</code>，当路径中的某个目录不存在时会自动创建。</li>\n</ul>\n<h2 id=\"Hadoop-样例\"><a href=\"#Hadoop-样例\" class=\"headerlink\" title=\"Hadoop 样例\"></a>Hadoop 样例</h2><p>在这里使用 Hadoop 的 exmaple jar 包进行样例测试，该 jar 包的 wordCount 功能可用来统计一系列文本文件中每个单词出现的次数。该 jar 包的存放路径为 <code>/Users/mochuangbiao/hadoop-2.8.4/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.4.jar</code></p>\n<ol>\n<li>准备样本数据。在网上下载一些英文内容保存为 txt 格式，保存路径为 <code>/Users/mochuangbiao/test</code>。</li>\n<li>创建目录。执行命令 <code>$ hdfs dfs -mkdir input</code>，在默认工作目录下创建 <code>input</code> 目录，该目录路径为 <code>/user/mochuangbiao/input</code>。</li>\n<li>上传文件到 hdfs 系统。执行 <code>$ hdfs dfs -put /Users/mochuangbiao/test/*.txt input</code>，上传刚才的 txt 文件到 <code>input</code> 目录。</li>\n<li>运行样例。执行 <code>$ hdfs dfs /Users/mochuangbiao/hadoop-2.8.4/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.4.jar wordcount input output</code>。调用 example jar 包里面的 wordcount 统计 <code>input</code> 目录里面的文档，统计结果自动输出到 <code>output</code> 文件夹。</li>\n<li>查看结果。执行 <code>$ hdfs dfs -ls output</code>，一般里面会有一个类似于 <code>part-r-00000</code> 的文件，执行 <code>hdfs dfs -cat output/part-r-00000</code> 查看结果。</li>\n</ol>\n<p>详细可参考 <a href=\"https://www.cnblogs.com/CherishFX/p/4239959.html\">Hadoop例子——运行example中的wordCount例子</a></p>\n<h2 id=\"其他参考\"><a href=\"#其他参考\" class=\"headerlink\" title=\"其他参考\"></a>其他参考</h2><p><a href=\"https://www.jianshu.com/p/34ec406eb40d\">大数据学习 第一篇——基础知识</a><br><a href=\"https://www.csdn.net/article/a/2016-07-28/3775\">Hadoop大数据生态系统及常用组件简介\n</a><br><a href=\"https://blog.csdn.net/dashujuedu/article/details/53538609\">数据分析：Hive、Pig和Impala</a><br><a href=\"http://zhongyaonan.com/hadoop-tutorial/setting-up-hadoop-2-6-on-mac-osx-yosemite.html\">Setting up Hadoop 2.6 on Mac OS X Yosemite</a><br><a href=\"https://www.jianshu.com/p/de7eb61c983a\">Mac 系统安装Hadoop 2.7.3</a></p>\n","categories":["大数据","Hadoop"],"tags":["Hadoop"]},{"title":"Maven入门","url":"/2018/06/26/Maven%E5%85%A5%E9%97%A8%E5%8F%8APOM%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/","content":"<blockquote>\n<p>Maven 是基于项目对象模型 POM(project object model) 概念的的 <strong>软件项目管理工具</strong>。Maven 提供统一标准的开发项目结构，并使用简单的标签描述来配置项目相关信息和管理项目依赖包，可以使开发人员在非常短的时间内完成配置工作，大大提高开发效率。下面介绍 Maven 的一些入门知识。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"Maven\"><a href=\"#Maven\" class=\"headerlink\" title=\"Maven\"></a>Maven</h2><h3 id=\"Maven-是什么\"><a href=\"#Maven-是什么\" class=\"headerlink\" title=\"Maven 是什么\"></a>Maven 是什么</h3><p>在不借助项目管理工具的开发过程中我们通常会遇到这样的问题：</p>\n<ul>\n<li>在开发中，为了保证编译通过，我们会到处去寻找 jar 包，当编译通过了，运行的时候，却发现 “ClassNotFoundException” ，我们想到的是，难道还差 jar 包？例如在 spring 框架上开发的过程中我们至少要把 spring 的常用 jar 包和依赖包 common-logging 包下载下来，然后还要加入类路径和输出目录，工作显得非常累赘。</li>\n<li>每个 Java 项目的目录结构都没有一个统一的标准，配置文件到处都是，单元测试代码到底应该放在那里也没有一个权威的规范。</li>\n</ul>\n<p>这时候就需要一个项目管理工具来对项目进行管理。Maven 是一个跨平台的项目管理工具，用于管理项目依赖，项目构建和项目生命周期的全过程。Maven 的作用有：</p>\n<ul>\n<li>统一项目开发目录。例如所有的项目目录结构统一划分成 <code> src/main/java</code> (源代码目录)、<code>src/main/resources</code> (资源目录)、<code>src/test/java</code> (测试代码目录)、 <code>src/test/resources</code> (测试资源目录)、 <code>target</code> (生成文件目录)等目录。</li>\n<li>统一项目的生命周期，规范项目从开始构建到部署的建设过程。</li>\n<li>统一管理项目依赖，开发人员只需要定义所需要的依赖包，Maven 会自动搜索依赖包所依赖的其他包，不需要开发人员关心。</li>\n<li>测试和构建流程自动化和简单化。</li>\n</ul>\n<h3 id=\"Maven-目录\"><a href=\"#Maven-目录\" class=\"headerlink\" title=\"Maven 目录\"></a>Maven 目录</h3><p>参考 <a href=\"http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html\">Maven 标准目录布局</a>，根据 Maven 管理工具构建的项目是有一定的目录结构标准的，这样就很好解决了文件不知道放哪里、文件目录结构杂乱无章的问题。Maven 标准的目录如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">|── pom.xml</span><br><span class=\"line\">|── src</span><br><span class=\"line\">|   ├── main</span><br><span class=\"line\">|   |   ├── java</span><br><span class=\"line\">|   |   ├── resources</span><br><span class=\"line\">|   |   └── filters</span><br><span class=\"line\">|   ├── test</span><br><span class=\"line\">|   |   ├── java</span><br><span class=\"line\">|   |   ├── resources</span><br><span class=\"line\">|   |   └── filters</span><br><span class=\"line\">|   ├── it</span><br><span class=\"line\">|   ├── assembly</span><br><span class=\"line\">|   └── site</span><br><span class=\"line\">├── LICENSE.txt</span><br><span class=\"line\">├── NOTICE.txt</span><br><span class=\"line\">└── README.txt</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>pom.xml</code>：Maven 的核心配置文件</li>\n<li><code>src/main/java</code>：项目的源代码所在的目录</li>\n<li><code>src/main/resources</code>：项目的资源文件所在的目录</li>\n<li><code>src/main/filters</code>：项目的资源过滤文件所在的目录</li>\n<li><code>src/main/webapp</code>：如果是web项目，则该目录是web应用源代码所在的目录，比如html文件和web.xml等都在该目录下。</li>\n<li><code>src/test/java</code>：测试代码所在的目录</li>\n<li><code>src/test/resources</code>：测试相关的资源文件所在的目录</li>\n<li><code>src/test/filters</code>：测试相关的资源过滤文件所在的目录</li>\n</ul>\n<p>下面这些目录平时用的不是很多</p>\n<ul>\n<li><code>src/it</code>：集成测试代码所在的目录，主要是供别的插件使用的。</li>\n<li><code>src/assembly</code>：组件（Assembly）描述符所在的目录</li>\n<li><code>src/site</code>：站点描述文件</li>\n<li><code>LICENSE.txt</code>：项目的许可文件</li>\n<li><code>NOTICE.txt</code>：该项目依赖的库的注意事项</li>\n<li><code>README.txt</code>：项目的readme文件</li>\n</ul>\n<h3 id=\"Maven-插件\"><a href=\"#Maven-插件\" class=\"headerlink\" title=\"Maven 插件\"></a>Maven 插件</h3><h4 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h4><p>参考 <a href=\"http://maven.apache.org/plugins/index.html\">Maven Plugins</a>。Maven 实际上是一个<strong>插件</strong>(plugin)的集成框架，它的核心并不执行任何具体的构建任务，所有这些任务都交给插件来完成。</p>\n<p>每个插件对应一到多个<strong>目标</strong>(global)，每个目标完成一个任务。Maven 的所有任务都是通过插件及其对应的目标来完成的。使用的插件语法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mvn [plugin-name]:[goal-name]</span><br></pre></td></tr></table></figure>\n\n<p>例如使用编译插件 (maven-compiler-plugin) 下的 compile 目标用来编译 <code>src/main/java/</code> 目录下的代码，testCompile 目标用来编译 <code>src/test/java/</code> 下的测试代码，命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mvn compiler:compile</span><br><span class=\"line\">$ mvn compiler:testCompile</span><br></pre></td></tr></table></figure>\n\n<p>参考 <a href=\"https://www.cnblogs.com/avivaye/p/5341341.html\">常用插件分析</a> ，在命令行输入常用的插件有：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">插件</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">maven-archetype-plugin</td>\n<td align=\"left\">生成简单的 Maven 项目骨架，例如初学者常用的 <code>mvn archetype:generate</code></td>\n</tr>\n<tr>\n<td align=\"left\">maven-compiler-plugin</td>\n<td align=\"left\">编译 java 源文件，包括 main&#x2F;java 和 test&#x2F;java&#x2F; 目录下的 java 文件</td>\n</tr>\n<tr>\n<td align=\"left\">maven-resources-plugin</td>\n<td align=\"left\">处理资源文件，例如复制 main&#x2F;resources 和 test&#x2F;resources 下的资源文件</td>\n</tr>\n<tr>\n<td align=\"left\">maven-surefire-plugin</td>\n<td align=\"left\">运行 JUnit 单元测试，其实大部分时间内，只要你的测试类遵循通用的命令约定（以Test结尾、以TestCase结尾、或者以Test开头），就几乎不用知晓该插件的存在</td>\n</tr>\n<tr>\n<td align=\"left\">maven-dependency-plugin</td>\n<td align=\"left\">分析项目依赖并打包项目依赖到指定文件夹等</td>\n</tr>\n</tbody></table>\n<p>命令行输入的插件是可以在 pom.xml 文件里面配置的。pom.xml 文件里面的 &lt; build &gt; 元素对应项目的构建阶段，其中的 &lt; plugin &gt; 元素对应项目会用到的一些插件。例如下面是 pom.xml 文件常定义的的一些插件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">    &lt;finalName&gt;MavenTest&lt;/finalName&gt;</span><br><span class=\"line\">    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span><br><span class=\"line\">        &lt;plugins&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;3.0.0&lt;/version&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;3.0.2&lt;/version&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.20.1&lt;/version&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;3.2.0&lt;/version&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.5.2&lt;/version&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.8.2&lt;/version&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;/plugins&gt;</span><br><span class=\"line\">    &lt;/pluginManagement&gt;</span><br><span class=\"line\">&lt;/build&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"插件参数\"><a href=\"#插件参数\" class=\"headerlink\" title=\"插件参数\"></a>插件参数</h4><p>在使用命令行执行 Maven 命令的时候可以加入参数执行，**-D** 表示配置 &lt; properties &gt; 属性，**-P** 表示配置 &lt; profiles &gt; 属性。</p>\n<p>使用命令行 -D 设置 &lt; properties &gt; 属性的方式是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn -DpropertyName=propertyValue clean package</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果 propertyName 原来在 pom.xml 里面不存在，它将被设置为一个新值。</li>\n<li>如果 propertyName 已经存在 pom.xml，例如 <code>maven.compiler.source</code> 这种有默认值的属性，传递的参数值会覆盖原来的属性值。</li>\n</ul>\n<p>多个 -D 属性之间通过空格分开</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn -DpropA=valueA -DpropB=valueB -DpropC=valueC clean package</span><br></pre></td></tr></table></figure>\n\n<p>也可以在 pom.xml 文件里面通过设置 &lt; configuration &gt; 属性来设置插件属性，例如设置 JDK 的编译版本为 1.8</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;plugin&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class=\"line\">    &lt;configuration&gt;</span><br><span class=\"line\">        &lt;source&gt;1.8&lt;/source&gt;</span><br><span class=\"line\">        &lt;target&gt;1.8&lt;/target&gt;</span><br><span class=\"line\">    &lt;/configuration&gt;</span><br><span class=\"line\">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>\n\n<p>总的来说，用户调用 Maven 插件目标有两种方式：</p>\n<ol>\n<li><p>输入生命周期调用插件目标。生命周期阶段是与插件目标绑定的，这样用户只需要输入生命周期阶段就可以调用对应的插件目标，如果绑定了多个插件目标将会顺序执行。例如 Maven 默认将 maven-compiler-plugin 的 compile 目标与 compile 生命周期阶段绑定，因此命令 <code>mvn compile</code> 实际上是先定位到 compile 这一生命周期阶段，然后再根据绑定关系调用 maven-compiler-plugin 的 compile 目标。</p>\n</li>\n<li><p>直接在命令行指定要执行的插件目标。例如 mvn archetype:generate 就表示调用 maven-archetype-plugin 的 generate 目标，这种带冒号的调用方式与生命周期无关。</p>\n</li>\n</ol>\n<p>而 Maven 的插件参数的配置也有两种方式：</p>\n<ol>\n<li><p>直接在命令行通过 -D 属性设置。这种相当于修改了 &lt; properties &gt; 元素的属性值。</p>\n</li>\n<li><p>在 pom.xml 文件的 &lt; plugin &gt; 元素里面通过 &lt; configuration &gt; 元素设置。</p>\n</li>\n</ol>\n<p>具体怎么配置插件参数可以参考 <a href=\"https://www.cnblogs.com/EasonJim/p/6865150.html\">这里</a></p>\n<!--Maven 包含核心插件和其他插件，其中两种类型的插件可以在 `pom.xml` 文件配置相关信息：\n\n* Build 插件：在构建过程中执行，并在 `pom.xml` 中的 `<build/>` 元素进行配置\n* Reporting 插件：在生成项目描述网站期间执行，在 `pom.xml` 中的 `<reporting/>` 元素进行配置-->\n\n<h3 id=\"Maven-生命周期\"><a href=\"#Maven-生命周期\" class=\"headerlink\" title=\"Maven 生命周期\"></a>Maven 生命周期</h3><p>参考 <a href=\"http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html\">Maven Lifecycle</a>，Maven 一共有三套<strong>生命周期</strong> (build lifecycle)。每套生命周期会有对应的<strong>构建阶段</strong>(build phases)。运行命令执行某一个构建阶段，该阶段前面的所有阶段都会自动执行。</p>\n<p>Maven 构建阶段和插件目标绑定。一个插件目标可以对应零到多个构建阶段，一个构建阶段可以对应零到多个插件目标，一个构建阶段如果没有绑定插件目标就不会执行。</p>\n<ul>\n<li>default：构建生命周期，包括项目从验证到部署的整体流程。default 生命周期根据打包 (packaging) 类型不同（例如可以打包成 jar, war 和 pom 等），具有不同的构建阶段。下面的 jar 包的生命周期阶段：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">阶段</th>\n<th align=\"left\">插件:目标</th>\n<th align=\"left\">目标作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">process-resources</td>\n<td align=\"left\">resources:resources</td>\n<td align=\"left\">默认处理 src&#x2F;main&#x2F;resources&#x2F; 下的文件，将其输出到测试的 classpath 目录中</td>\n</tr>\n<tr>\n<td align=\"left\">compile</td>\n<td align=\"left\">compiler:compile</td>\n<td align=\"left\">编译 src&#x2F;main&#x2F;java 下的 java 文件，产生对应的class</td>\n</tr>\n<tr>\n<td align=\"left\">process-test-resources</td>\n<td align=\"left\">resources:testResources</td>\n<td align=\"left\">默认处理 src&#x2F;test&#x2F;resources&#x2F; 下的文件，将其输出到测试的 classpath 目录中</td>\n</tr>\n<tr>\n<td align=\"left\">test-compile</td>\n<td align=\"left\">compiler:testCompile</td>\n<td align=\"left\">编译 src&#x2F;test&#x2F;java 下的 java 文件，产生对应的 class</td>\n</tr>\n<tr>\n<td align=\"left\">test</td>\n<td align=\"left\">surefire:test</td>\n<td align=\"left\">运行测试用例</td>\n</tr>\n<tr>\n<td align=\"left\">package</td>\n<td align=\"left\">jar:jar</td>\n<td align=\"left\">打包构件，即生成对应的 jar, war 等</td>\n</tr>\n<tr>\n<td align=\"left\">install</td>\n<td align=\"left\">install:install</td>\n<td align=\"left\">将构件部署到本地仓库</td>\n</tr>\n<tr>\n<td align=\"left\">deploy</td>\n<td align=\"left\">deploy:deploy</td>\n<td align=\"left\">部署构件到远程仓库</td>\n</tr>\n</tbody></table>\n<ul>\n<li>clean：清理生命周期，清空目标文件，也就是清空 target 文件夹。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">阶段</th>\n<th align=\"left\">插件:目标</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">clean</td>\n<td align=\"left\">clean:clean</td>\n</tr>\n</tbody></table>\n<ul>\n<li>site：生成项目描述网站周期，产生项目的站点描述文件。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">阶段</th>\n<th align=\"left\">插件:目标</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">site</td>\n<td align=\"left\">site:site</td>\n<td align=\"left\">产生项目的站点文档</td>\n</tr>\n<tr>\n<td align=\"left\">site-deploy</td>\n<td align=\"left\">site:deploy</td>\n<td align=\"left\">将项目的站点文档部署到服务器</td>\n</tr>\n</tbody></table>\n<h2 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h2><p><code>pom.xml</code> 文件是整个 Maven 项目的核心配置文件。<code>pom.xml</code> 文件记录了整个项目的基础配置信息、相关依赖插件、构建配置和远程库等信息。</p>\n<h3 id=\"整体结构\"><a href=\"#整体结构\" class=\"headerlink\" title=\"整体结构\"></a>整体结构</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class=\"line\">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0</span><br><span class=\"line\">            http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 基本设置 --&gt;</span><br><span class=\"line\">    &lt;groupId&gt;...&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;...&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;...&lt;/version&gt;</span><br><span class=\"line\">    &lt;packaging&gt;...&lt;/packaging&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;...&lt;/dependencies&gt;</span><br><span class=\"line\">    &lt;parent&gt;...&lt;/parent&gt;</span><br><span class=\"line\">    &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt;</span><br><span class=\"line\">    &lt;modules&gt;...&lt;/modules&gt;</span><br><span class=\"line\">    &lt;properties&gt;...&lt;/properties&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 构建过程的设置 --&gt;</span><br><span class=\"line\">    &lt;build&gt;...&lt;/build&gt;</span><br><span class=\"line\">    &lt;reporting&gt;...&lt;/reporting&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 项目信息设置 --&gt;</span><br><span class=\"line\">    &lt;name&gt;...&lt;/name&gt;</span><br><span class=\"line\">    &lt;description&gt;...&lt;/description&gt;</span><br><span class=\"line\">    &lt;url&gt;...&lt;/url&gt;</span><br><span class=\"line\">    &lt;inceptionYear&gt;...&lt;/inceptionYear&gt;</span><br><span class=\"line\">    &lt;licenses&gt;...&lt;/licenses&gt;</span><br><span class=\"line\">    &lt;organization&gt;...&lt;/organization&gt;</span><br><span class=\"line\">    &lt;developers&gt;...&lt;/developers&gt;</span><br><span class=\"line\">    &lt;contributors&gt;...&lt;/contributors&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 环境设置 --&gt;</span><br><span class=\"line\">    &lt;issueManagement&gt;...&lt;/issueManagement&gt;</span><br><span class=\"line\">    &lt;ciManagement&gt;...&lt;/ciManagement&gt;</span><br><span class=\"line\">    &lt;mailingLists&gt;...&lt;/mailingLists&gt;</span><br><span class=\"line\">    &lt;scm&gt;...&lt;/scm&gt;</span><br><span class=\"line\">    &lt;prerequisites&gt;...&lt;/prerequisites&gt;</span><br><span class=\"line\">    &lt;repositories&gt;...&lt;/repositories&gt;</span><br><span class=\"line\">    &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt;</span><br><span class=\"line\">    &lt;distributionManagement&gt;...&lt;/distributionManagement&gt;</span><br><span class=\"line\">    &lt;profiles&gt;...&lt;/profiles&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常用标签\"><a href=\"#常用标签\" class=\"headerlink\" title=\"常用标签\"></a>常用标签</h3><h4 id=\"modelVersion\"><a href=\"#modelVersion\" class=\"headerlink\" title=\"modelVersion\"></a>modelVersion</h4><p>必须，POM 模型版本，一般写 <code>4.0.0</code> 版本，该版本是同时被 Maven2 和 Maven3 支持的版本。</p>\n<h4 id=\"groupId\"><a href=\"#groupId\" class=\"headerlink\" title=\"groupId\"></a>groupId</h4><p>必须，组织唯一标识，通常写法是 <code>com.mycompany.app</code>，同时定义了构建时生成的相对路径为 <code>/com/mycompany/app</code>。</p>\n<h4 id=\"artifactId\"><a href=\"#artifactId\" class=\"headerlink\" title=\"artifactId\"></a>artifactId</h4><p>必须，项目名称唯一标识，写法如 <code>consumer-banking</code></p>\n<h4 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h4><p>必须，项目版本，写法如 <code>2.3.4</code></p>\n<blockquote>\n<ul>\n<li>groupId、artifactId 和 version 是所有 POM 文件根节点 <code>&lt;project&gt;</code> 里面必须包含的三个字段，共同定义了该项目在仓库里面的坐标位置，这意味着特定的 groupId 下，artifactId 也必须是唯一的。</li>\n<li>version 定义为 <code>1.0.0</code> 和 <code>1.0.0-SNAPSHOT</code> 的区别：<code>1.0.0</code>是指稳定版本，只要版本号不变，就算远程库中该版本号的项目进行了更新，也不会去远程库中拉取最新版本的项目，除非把版本号改成 <code>1.1.0</code> 等不同版本号；<code>1.0.0-SNAPSHOT</code> 是指开发版本，每次建立项目时都会去远程库中查看是否有最新版本。</li>\n</ul>\n</blockquote>\n<h4 id=\"packaging\"><a href=\"#packaging\" class=\"headerlink\" title=\"packaging\"></a>packaging</h4><p>项目的打包类型，可以为 <code>jar</code>、<code>war</code>、<code>ear</code>、<code>pom</code> 等。</p>\n<h4 id=\"dependencies\"><a href=\"#dependencies\" class=\"headerlink\" title=\"dependencies\"></a>dependencies</h4><p>定义了项目相关的所有依赖，每一个依赖包由 <code>&lt;dependency&gt;</code> 包围，<code>&lt;groupId&gt;</code>、<code>&lt;artifactId&gt;</code>、<code>&lt;version&gt;</code> 标签定义了依赖包在仓库中的唯一坐标，Maven 根据该坐标按照 <strong>本地仓库</strong> &gt; <strong>中央仓库</strong> &gt; <strong>远程仓库</strong> 的查找顺序去查找依赖包。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">      &lt;dependency&gt;</span><br><span class=\"line\">          &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class=\"line\">          &lt;artifactId&gt;httpmime&lt;/artifactId&gt;</span><br><span class=\"line\">          &lt;version&gt;4.5.5&lt;/version&gt;</span><br><span class=\"line\">      &lt;/dependency&gt;</span><br><span class=\"line\">      &lt;dependency&gt;</span><br><span class=\"line\">          &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class=\"line\">          &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class=\"line\">          &lt;version&gt;3.6&lt;/version&gt;</span><br><span class=\"line\">      &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent\"></a>parent</h4><p>父项目坐标，类似于 java 的集成，将继承父项目的依赖和插件等。在这里继承父项目的依赖有两种方式：</p>\n<p>第一种：完全继承父项目的所有依赖。子项目将引入父项目的所有依赖。</p>\n<p>父项目使用 <dependencies> 元素引入依赖，如</dependencies></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependencies&gt; &lt;!-- 配置共有依赖 --&gt;</span><br><span class=\"line\">    &lt;!-- spring 依赖 --&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- junit 依赖 --&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;4.7&lt;/version&gt;</span><br><span class=\"line\">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n\n<p>子项目通过设置 <parent> 为父项目的坐标即可继承父项目的所有依赖</parent></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.youzhibing.account&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;account-aggregator&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">    &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;!-- 与不配置一样，默认就是寻找上级目录下得pom.xml --&gt;</span><br><span class=\"line\">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>\n\n<p>第二种：继承父类的依赖，但是只是作为一个范围约束，只有子项目通过 &lt; dependency &gt; 显示引入该范围内的依赖才算真正引入。这种继承方式更加灵活，而且子项目的 &lt; dependency &gt; 里面不需要说明 version 版本号，可以在父项目里面统一管理版本号。</p>\n<p>父项目通过 &lt; dependencyManagement &gt; 限制依赖范围。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependencyManagement&gt;</span><br><span class=\"line\">    &lt;dependencies&gt; &lt;!-- 配置共有依赖 --&gt;</span><br><span class=\"line\">        &lt;!-- spring 依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- junit 依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;4.7&lt;/version&gt;</span><br><span class=\"line\">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>\n\n<p>子类引入父项目的依赖范围，通过 &lt; dependency &gt; 真正引入依赖，不用添加版本号。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;parent&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.youzhibing.account&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;account-aggregator&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">&lt;/parent&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependencies&gt;</span><br><span class=\"line\">    &lt;!--真正引入 spring 依赖 --&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"bulid\"><a href=\"#bulid\" class=\"headerlink\" title=\"bulid\"></a>bulid</h4><p>项目的构建信息</p>\n<ul>\n<li>finalName：构建产生的项目名称，默认为 <code>$&#123;artifactId&#125;-$&#123;version&#125;</code>。</li>\n<li>directory：构建产生的文件的存放目录，默认为 <code>$(basedir&#125;/target</code> ，即项目根目录下的 <code>target</code> 目录。</li>\n<li>plugins：插件列表，如下面第一个插件指定 Maven 插件编译版本，使用 java8 语言，JVM1.8 编译，编译时使用UTF-8编码。</li>\n<li>resources：项目资源列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。如下面就把文件 version.txt、banner.txt 和 templates&#x2F;index.html 打包到 <code>target</code> 目录</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">    &lt;finalName&gt;sale-api&lt;/finalName&gt;</span><br><span class=\"line\">    &lt;plugins&gt;</span><br><span class=\"line\">        &lt;plugin&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;2.3.2&lt;/version&gt;</span><br><span class=\"line\">            &lt;configuration&gt;</span><br><span class=\"line\">                &lt;source&gt;1.8&lt;/source&gt;</span><br><span class=\"line\">                &lt;target&gt;1.8&lt;/target&gt;</span><br><span class=\"line\">                &lt;encoding&gt;UTF8&lt;/encoding&gt;</span><br><span class=\"line\">            &lt;/configuration&gt;</span><br><span class=\"line\">        &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;plugin&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;configuration&gt;</span><br><span class=\"line\">                &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;</span><br><span class=\"line\">            &lt;/configuration&gt;</span><br><span class=\"line\">        &lt;/plugin&gt;</span><br><span class=\"line\">    &lt;/plugins&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;resources&gt;</span><br><span class=\"line\">        &lt;resource&gt;</span><br><span class=\"line\">            &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt;</span><br><span class=\"line\">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class=\"line\">            &lt;includes&gt;</span><br><span class=\"line\">                &lt;include&gt;version.txt&lt;/include&gt;</span><br><span class=\"line\">                &lt;include&gt;banner.txt&lt;/include&gt;</span><br><span class=\"line\">                &lt;include&gt;templates/index.html&lt;/include&gt;</span><br><span class=\"line\">            &lt;/includes&gt;</span><br><span class=\"line\">        &lt;/resource&gt;</span><br><span class=\"line\">    &lt;/resources&gt;</span><br><span class=\"line\">&lt;/build&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"properties\"><a href=\"#properties\" class=\"headerlink\" title=\"properties\"></a>properties</h4><p>POM 定义的常量，可供 POM 文件的其他地方引用，格式是 <code>&lt;name&gt;value&lt;/name&gt;</code>，引用时通过 <code>$&#123;name&#125;</code> 来获取 <code>value</code> 的值。</p>\n<p>Maven 总共有 6 类属性，内置属性、POM 属性、settings 属性、java 系统属性、env 环境变量属性和自定义属性。</p>\n<ul>\n<li>内置属性：两个常用内置属性 ${basedir} 表示项目根目录，即包含 pom.xml 文件的目录；${version} 表示项目版本。</li>\n<li>POM 属性：用户可以使用该类属性引用 POM 文件中对应元素的值。如 ${project.artifactId} 就对应了 <project><artifactId>xxx</artifactId></project> 元素的值，常用的POM属性包括：<br>${project.build.sourceDirectory}:项目的主源码目录，默认为src&#x2F;main&#x2F;java&#x2F;</li>\n</ul>\n<p>　　　　${project.build.testSourceDirectory}:项目的测试源码目录，默认为src&#x2F;test&#x2F;java&#x2F;</p>\n<p>　　　　${project.build.directory} ： 项目构建输出目录，默认为target&#x2F;</p>\n<p>　　　　${project.outputDirectory} : 项目主代码编译输出目录，默认为target&#x2F;classes&#x2F;</p>\n<p>　　　　${project.testOutputDirectory}：项目测试主代码输出目录，默认为target&#x2F;testclasses&#x2F;</p>\n<p>　　　　${project.groupId}：项目的groupId</p>\n<p>　　　　${project.artifactId}：项目的artifactId</p>\n<p>　　　　${project.version}：项目的version,与${version} 等价</p>\n<p>　　　　${project.build.finalName}：项目打包输出文件的名称，默认为${project.artifactId}-${project.version}</p>\n<ul>\n<li>settings 属性：以 settings. 开头的属性，引用 settings.xml 文件中的 XML 元素的值。</li>\n<li>java 属性：以 java. 开头的属性，可引用java 系统属性，如${java.home}指向了 java 根目录。</li>\n<li>env 属性：以 env. 开头的属性，可使用所有环境变量属性，如 ${env.JAVA_HOME} 指代了 JAVA_HOME 环境变量的的值。</li>\n<li>自定义属性。可在其他地方通过 <code>$&#123;&#125;</code> 来引用该属性。</li>\n</ul>\n<p>例如下面就定义了 java 属性的版本号，并自定义了一个 file.encoding 属性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;properties&gt;  </span><br><span class=\"line\">    &lt;file.encoding&gt;UTF-8&lt;/file_encoding&gt;  </span><br><span class=\"line\">    &lt;java.source.version&gt;1.5&lt;/java_source_version&gt;  </span><br><span class=\"line\">    &lt;java.target.version&gt;1.5&lt;/java_target_version&gt;  </span><br><span class=\"line\">&lt;/properties&gt;  </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"repositories\"><a href=\"#repositories\" class=\"headerlink\" title=\"repositories\"></a>repositories</h4><p>远程仓库列表，当 Maven 在本地仓库和中央仓库中找不到所需要的依赖包时就会去远程仓库查找，可通过 <code>&lt;repository&gt;</code> 定义多个远程仓库。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;repositories&gt;</span><br><span class=\"line\">     &lt;repository&gt;</span><br><span class=\"line\">           &lt;id&gt;spring-releases&lt;/id&gt;</span><br><span class=\"line\">           &lt;name&gt;Spring Releases&lt;/name&gt;</span><br><span class=\"line\">           &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt;</span><br><span class=\"line\">     &lt;/repository&gt;</span><br><span class=\"line\">     &lt;repository&gt;</span><br><span class=\"line\">           &lt;id&gt;org.jboss.repository.releases&lt;/id&gt;</span><br><span class=\"line\">           &lt;name&gt;JBoss Maven Release Repository&lt;/name&gt;</span><br><span class=\"line\">           &lt;url&gt;https://repository.jboss.org/nexus/content/repositories/releases&lt;/url&gt;</span><br><span class=\"line\">     &lt;/repository&gt;</span><br><span class=\"line\">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"根-pom-xml\"><a href=\"#根-pom-xml\" class=\"headerlink\" title=\"根 pom.xml\"></a>根 pom.xml</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">\txsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和</span><br><span class=\"line\">\t\tversion。 --&gt;</span><br><span class=\"line\">\t&lt;parent&gt;</span><br><span class=\"line\">\t\t&lt;!--被继承的父项目的构件标识符 --&gt;</span><br><span class=\"line\">\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t&lt;!--被继承的父项目的全球唯一标识符 --&gt;</span><br><span class=\"line\">\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t&lt;!--被继承的父项目的版本 --&gt;</span><br><span class=\"line\">\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项</span><br><span class=\"line\">\t\t\t目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span><br><span class=\"line\">\t\t&lt;relativePath /&gt;</span><br><span class=\"line\">\t&lt;/parent&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span><br><span class=\"line\">\t&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;asia.banseon&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个</span><br><span class=\"line\">\t\t特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span><br><span class=\"line\">\t&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;</span><br><span class=\"line\">\t&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class=\"line\">\t&lt;!--项目的名称, Maven产生的文档用 --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;name&gt;banseon-maven&lt;/name&gt;</span><br><span class=\"line\">\t&lt;!--项目主页的URL, Maven产生的文档用 --&gt;</span><br><span class=\"line\">\t&lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;</span><br><span class=\"line\">\t&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标</span><br><span class=\"line\">\t\t签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;</span><br><span class=\"line\">\t&lt;description&gt;A maven project to study maven.&lt;/description&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--描述了这个项目构建环境中的前提条件。 --&gt;</span><br><span class=\"line\">\t&lt;prerequisites&gt;</span><br><span class=\"line\">\t\t&lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span><br><span class=\"line\">\t\t&lt;maven&gt;&lt;/maven&gt;</span><br><span class=\"line\">\t&lt;/prerequisites&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span><br><span class=\"line\">\t&lt;issueManagement&gt;</span><br><span class=\"line\">\t\t&lt;!--问题管理系统（例如jira）的名字， --&gt;</span><br><span class=\"line\">\t\t&lt;system&gt;jira&lt;/system&gt;</span><br><span class=\"line\">\t\t&lt;!--该项目使用的问题管理系统的URL --&gt;</span><br><span class=\"line\">\t\t&lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt;</span><br><span class=\"line\">\t&lt;/issueManagement&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目持续集成信息 --&gt;</span><br><span class=\"line\">\t&lt;ciManagement&gt;</span><br><span class=\"line\">\t\t&lt;!--持续集成系统的名字，例如continuum --&gt;</span><br><span class=\"line\">\t\t&lt;system /&gt;</span><br><span class=\"line\">\t\t&lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span><br><span class=\"line\">\t\t&lt;url /&gt;</span><br><span class=\"line\">\t\t&lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span><br><span class=\"line\">\t\t&lt;notifiers&gt;</span><br><span class=\"line\">\t\t\t&lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span><br><span class=\"line\">\t\t\t&lt;notifier&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--传送通知的途径 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;type /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--发生错误时是否通知 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;sendOnError /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--构建失败时是否通知 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;sendOnFailure /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--构建成功时是否通知 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;sendOnSuccess /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--发生警告时是否通知 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;sendOnWarning /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--不赞成使用。通知发送到哪里 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;address /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--扩展配置项 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t&lt;/notifier&gt;</span><br><span class=\"line\">\t\t&lt;/notifiers&gt;</span><br><span class=\"line\">\t&lt;/ciManagement&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span><br><span class=\"line\">\t&lt;inceptionYear /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目相关邮件列表信息 --&gt;</span><br><span class=\"line\">\t&lt;mailingLists&gt;</span><br><span class=\"line\">\t\t&lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span><br><span class=\"line\">\t\t&lt;mailingList&gt;</span><br><span class=\"line\">\t\t\t&lt;!--邮件的名称 --&gt;</span><br><span class=\"line\">\t\t\t&lt;name&gt;Demo&lt;/name&gt;</span><br><span class=\"line\">\t\t\t&lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span><br><span class=\"line\">\t\t\t&lt;post&gt;banseon@126.com&lt;/post&gt;</span><br><span class=\"line\">\t\t\t&lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span><br><span class=\"line\">\t\t\t&lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt;</span><br><span class=\"line\">\t\t\t&lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span><br><span class=\"line\">\t\t\t&lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt;</span><br><span class=\"line\">\t\t\t&lt;!--你可以浏览邮件信息的URL --&gt;</span><br><span class=\"line\">\t\t\t&lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt;</span><br><span class=\"line\">\t\t&lt;/mailingList&gt;</span><br><span class=\"line\">\t&lt;/mailingLists&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目开发者列表 --&gt;</span><br><span class=\"line\">\t&lt;developers&gt;</span><br><span class=\"line\">\t\t&lt;!--某个项目开发者的信息 --&gt;</span><br><span class=\"line\">\t\t&lt;developer&gt;</span><br><span class=\"line\">\t\t\t&lt;!--SCM里项目开发者的唯一标识符 --&gt;</span><br><span class=\"line\">\t\t\t&lt;id&gt;HELLO WORLD&lt;/id&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者的全名 --&gt;</span><br><span class=\"line\">\t\t\t&lt;name&gt;banseon&lt;/name&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者的email --&gt;</span><br><span class=\"line\">\t\t\t&lt;email&gt;banseon@126.com&lt;/email&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者的主页的URL --&gt;</span><br><span class=\"line\">\t\t\t&lt;url /&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span><br><span class=\"line\">\t\t\t&lt;roles&gt;</span><br><span class=\"line\">\t\t\t\t&lt;role&gt;Project Manager&lt;/role&gt;</span><br><span class=\"line\">\t\t\t\t&lt;role&gt;Architect&lt;/role&gt;</span><br><span class=\"line\">\t\t\t&lt;/roles&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者所属组织 --&gt;</span><br><span class=\"line\">\t\t\t&lt;organization&gt;demo&lt;/organization&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者所属组织的URL --&gt;</span><br><span class=\"line\">\t\t\t&lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者属性，如即时消息如何处理等 --&gt;</span><br><span class=\"line\">\t\t\t&lt;properties&gt;</span><br><span class=\"line\">\t\t\t\t&lt;dept&gt;No&lt;/dept&gt;</span><br><span class=\"line\">\t\t\t&lt;/properties&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;timezone&gt;-5&lt;/timezone&gt;</span><br><span class=\"line\">\t\t&lt;/developer&gt;</span><br><span class=\"line\">\t&lt;/developers&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目的其他贡献者列表 --&gt;</span><br><span class=\"line\">\t&lt;contributors&gt;</span><br><span class=\"line\">\t\t&lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;</span><br><span class=\"line\">\t\t&lt;contributor&gt;</span><br><span class=\"line\">\t\t\t&lt;name /&gt;</span><br><span class=\"line\">\t\t\t&lt;email /&gt;</span><br><span class=\"line\">\t\t\t&lt;url /&gt;</span><br><span class=\"line\">\t\t\t&lt;organization /&gt;</span><br><span class=\"line\">\t\t\t&lt;organizationUrl /&gt;</span><br><span class=\"line\">\t\t\t&lt;roles /&gt;</span><br><span class=\"line\">\t\t\t&lt;timezone /&gt;</span><br><span class=\"line\">\t\t\t&lt;properties /&gt;</span><br><span class=\"line\">\t\t&lt;/contributor&gt;</span><br><span class=\"line\">\t&lt;/contributors&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span><br><span class=\"line\">\t&lt;licenses&gt;</span><br><span class=\"line\">\t\t&lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span><br><span class=\"line\">\t\t&lt;license&gt;</span><br><span class=\"line\">\t\t\t&lt;!--license用于法律上的名称 --&gt;</span><br><span class=\"line\">\t\t\t&lt;name&gt;Apache 2&lt;/name&gt;</span><br><span class=\"line\">\t\t\t&lt;!--官方的license正文页面的URL --&gt;</span><br><span class=\"line\">\t\t\t&lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt;</span><br><span class=\"line\">\t\t\t&lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;</span><br><span class=\"line\">\t\t\t&lt;distribution&gt;repo&lt;/distribution&gt;</span><br><span class=\"line\">\t\t\t&lt;!--关于license的补充信息 --&gt;</span><br><span class=\"line\">\t\t\t&lt;comments&gt;A business-friendly OSS license&lt;/comments&gt;</span><br><span class=\"line\">\t\t&lt;/license&gt;</span><br><span class=\"line\">\t&lt;/licenses&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span><br><span class=\"line\">\t&lt;scm&gt;</span><br><span class=\"line\">\t\t&lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span><br><span class=\"line\">\t\t&lt;connection&gt;</span><br><span class=\"line\">\t\t\tscm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)</span><br><span class=\"line\">\t\t&lt;/connection&gt;</span><br><span class=\"line\">\t\t&lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span><br><span class=\"line\">\t\t&lt;developerConnection&gt;</span><br><span class=\"line\">\t\t\tscm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk</span><br><span class=\"line\">\t\t&lt;/developerConnection&gt;</span><br><span class=\"line\">\t\t&lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;</span><br><span class=\"line\">\t\t&lt;tag /&gt;</span><br><span class=\"line\">\t\t&lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span><br><span class=\"line\">\t\t&lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt;</span><br><span class=\"line\">\t&lt;/scm&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span><br><span class=\"line\">\t&lt;organization&gt;</span><br><span class=\"line\">\t\t&lt;!--组织的全名 --&gt;</span><br><span class=\"line\">\t\t&lt;name&gt;demo&lt;/name&gt;</span><br><span class=\"line\">\t\t&lt;!--组织主页的URL --&gt;</span><br><span class=\"line\">\t\t&lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;</span><br><span class=\"line\">\t&lt;/organization&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--构建项目需要的信息 --&gt;</span><br><span class=\"line\">\t&lt;build&gt;</span><br><span class=\"line\">\t\t&lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span><br><span class=\"line\">\t\t&lt;sourceDirectory /&gt;</span><br><span class=\"line\">\t\t&lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span><br><span class=\"line\">\t\t&lt;scriptSourceDirectory /&gt;</span><br><span class=\"line\">\t\t&lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span><br><span class=\"line\">\t\t&lt;testSourceDirectory /&gt;</span><br><span class=\"line\">\t\t&lt;!--被编译过的应用程序class文件存放的目录。 --&gt;</span><br><span class=\"line\">\t\t&lt;outputDirectory /&gt;</span><br><span class=\"line\">\t\t&lt;!--被编译过的测试class文件存放的目录。 --&gt;</span><br><span class=\"line\">\t\t&lt;testOutputDirectory /&gt;</span><br><span class=\"line\">\t\t&lt;!--使用来自该项目的一系列构建扩展 --&gt;</span><br><span class=\"line\">\t\t&lt;extensions&gt;</span><br><span class=\"line\">\t\t\t&lt;!--描述使用到的构建扩展。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;extension&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--构建扩展的groupId --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--构建扩展的artifactId --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--构建扩展的版本 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t\t&lt;/extension&gt;</span><br><span class=\"line\">\t\t&lt;/extensions&gt;</span><br><span class=\"line\">\t\t&lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span><br><span class=\"line\">\t\t&lt;defaultGoal /&gt;</span><br><span class=\"line\">\t\t&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span><br><span class=\"line\">\t\t&lt;resources&gt;</span><br><span class=\"line\">\t\t\t&lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span><br><span class=\"line\">\t\t\t&lt;resource&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例</span><br><span class=\"line\">\t\t\t\t\t子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;targetPath /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;filtering /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;directory /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--包含的模式列表，例如**/*.xml. --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;includes /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--排除的模式列表，例如**/*.xml --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;excludes /&gt;</span><br><span class=\"line\">\t\t\t&lt;/resource&gt;</span><br><span class=\"line\">\t\t&lt;/resources&gt;</span><br><span class=\"line\">\t\t&lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;</span><br><span class=\"line\">\t\t&lt;testResources&gt;</span><br><span class=\"line\">\t\t\t&lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;</span><br><span class=\"line\">\t\t\t&lt;testResource&gt;</span><br><span class=\"line\">\t\t\t\t&lt;targetPath /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;filtering /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;directory /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;includes /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;excludes /&gt;</span><br><span class=\"line\">\t\t\t&lt;/testResource&gt;</span><br><span class=\"line\">\t\t&lt;/testResources&gt;</span><br><span class=\"line\">\t\t&lt;!--构建产生的所有文件存放的目录 --&gt;</span><br><span class=\"line\">\t\t&lt;directory /&gt;</span><br><span class=\"line\">\t\t&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;</span><br><span class=\"line\">\t\t&lt;finalName /&gt;</span><br><span class=\"line\">\t\t&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;</span><br><span class=\"line\">\t\t&lt;filters /&gt;</span><br><span class=\"line\">\t\t&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span><br><span class=\"line\">\t\t&lt;pluginManagement&gt;</span><br><span class=\"line\">\t\t\t&lt;!--使用的插件列表 。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;plugins&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--plugin元素包含描述插件所需要的信息。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--插件在仓库里的group ID --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--插件在仓库里的artifact ID --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--被使用的插件的版本（或版本范围） --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;extensions /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;executions&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;!--execution元素包含了插件执行需要的信息 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;execution&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;phase /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;!--配置的执行目标 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;goals /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;!--配置是否被传播到子POM --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;!--作为DOM对象的配置 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;/execution&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/executions&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--项目引入插件所需要的额外依赖 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;!--参见dependencies/dependency元素 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t......</span><br><span class=\"line\">\t\t\t\t\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--任何配置是否被传播到子项目 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--作为DOM对象的配置 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/plugin&gt;</span><br><span class=\"line\">\t\t\t&lt;/plugins&gt;</span><br><span class=\"line\">\t\t&lt;/pluginManagement&gt;</span><br><span class=\"line\">\t\t&lt;!--使用的插件列表 --&gt;</span><br><span class=\"line\">\t\t&lt;plugins&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;extensions /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;executions&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;execution&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;phase /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;goals /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/execution&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/executions&gt;</span><br><span class=\"line\">\t\t\t\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--参见dependencies/dependency元素 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t\t......</span><br><span class=\"line\">\t\t\t\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/dependencies&gt;</span><br><span class=\"line\">\t\t\t\t&lt;goals /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t&lt;/plugin&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&lt;!-- 以下为插件示例 --&gt;</span><br><span class=\"line\">\t\t\t&lt;!-- 指定maven插件编译版本，使用java8语言，JVM1.8编译，编译时使用UTF-8编码 --&gt;</span><br><span class=\"line\">\t\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t\t&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t\t&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t\t&lt;version&gt;2.3.2&lt;/version&gt;</span><br><span class=\"line\">\t\t\t\t&lt;configuration&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;source&gt;1.8&lt;/source&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;target&gt;1.8&lt;/target&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;encoding&gt;UTF8&lt;/encoding&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\t&lt;/configuration&gt;</span><br><span class=\"line\">\t\t\t&lt;/plugin&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t&lt;!-- 启动jar插件 --&gt;</span><br><span class=\"line\">\t\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t\t&lt;version&gt;1.4.0.RELEASE&lt;/version&gt;</span><br><span class=\"line\">\t\t\t\t&lt;executions&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;execution&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;goals&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;/goals&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;configuration&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;classifier&gt;server&lt;/classifier&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;mainClass&gt;com.xx.xxxx.server.startup.StmsStartup&lt;/mainClass&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;/configuration&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/execution&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/executions&gt;</span><br><span class=\"line\">\t\t\t&lt;/plugin&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;/plugins&gt;</span><br><span class=\"line\">\t&lt;/build&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span><br><span class=\"line\">\t&lt;profiles&gt;</span><br><span class=\"line\">\t\t&lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;</span><br><span class=\"line\">\t\t&lt;profile&gt;</span><br><span class=\"line\">\t\t\t&lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t&lt;!-- 声明变量，当该profile被激活时，可以用$&#123;env&#125;引入值 --&gt;</span><br><span class=\"line\">\t\t\t&lt;properties&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!-- env为key（自定义的），相当于声明变量:env=dev --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;env&gt;dev&lt;/env&gt;</span><br><span class=\"line\">\t\t\t&lt;/properties&gt;</span><br><span class=\"line\">\t\t\t&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;activation&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--profile默认是否激活的标志 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;activeByDefault /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;jdk /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;os&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--激活profile的操作系统的名字 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;name&gt;Windows XP&lt;/name&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--激活profile的操作系统所属家族(如 &#x27;windows&#x27;) --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;family&gt;Windows&lt;/family&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--激活profile的操作系统体系结构 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;arch&gt;x86&lt;/arch&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--激活profile的操作系统版本 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;version&gt;5.1.2600&lt;/version&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/os&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;property&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--激活profile的属性的名称 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;name&gt;mavenVersion&lt;/name&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--激活profile的属性的值 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;value&gt;2.0.3&lt;/value&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/property&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;file&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class=\"line\">\t\t\t\t\t&lt;/exists&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class=\"line\">\t\t\t\t\t&lt;/missing&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/file&gt;</span><br><span class=\"line\">\t\t\t&lt;/activation&gt;</span><br><span class=\"line\">\t\t\t&lt;!--构建项目所需要的信息。参见build元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;build&gt;</span><br><span class=\"line\">\t\t\t\t&lt;defaultGoal /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;resources&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;resource&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;targetPath /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;filtering /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;directory /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;includes /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;excludes /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/resource&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/resources&gt;</span><br><span class=\"line\">\t\t\t\t&lt;testResources&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;testResource&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;targetPath /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;filtering /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;directory /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;includes /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;excludes /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/testResource&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/testResources&gt;</span><br><span class=\"line\">\t\t\t\t&lt;directory /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;finalName /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;filters /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;pluginManagement&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;plugins&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;extensions /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;executions&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;execution&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&lt;phase /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&lt;goals /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;/execution&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;/executions&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;!--参见dependencies/dependency元素 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t......</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;/dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;goals /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;/plugin&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/plugins&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/pluginManagement&gt;</span><br><span class=\"line\">\t\t\t\t&lt;plugins&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;extensions /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;executions&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;execution&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;phase /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;goals /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;/execution&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;/executions&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;!--参见dependencies/dependency元素 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t......</span><br><span class=\"line\">\t\t\t\t\t\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;/dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;goals /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/plugin&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/plugins&gt;</span><br><span class=\"line\">\t\t\t&lt;/build&gt;</span><br><span class=\"line\">\t\t\t&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span><br><span class=\"line\">\t\t\t&lt;modules /&gt;</span><br><span class=\"line\">\t\t\t&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;repositories&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--参见repositories/repository元素 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;repository&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;releases&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;enabled /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;updatePolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;checksumPolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/releases&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;snapshots&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;enabled /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;updatePolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;checksumPolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/snapshots&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;name /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;url /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;layout /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/repository&gt;</span><br><span class=\"line\">\t\t\t&lt;/repositories&gt;</span><br><span class=\"line\">\t\t\t&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span><br><span class=\"line\">\t\t\t&lt;pluginRepositories&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;pluginRepository&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;releases&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;enabled /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;updatePolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;checksumPolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/releases&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;snapshots&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;enabled /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;updatePolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;checksumPolicy /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/snapshots&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;name /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;url /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;layout /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/pluginRepository&gt;</span><br><span class=\"line\">\t\t\t&lt;/pluginRepositories&gt;</span><br><span class=\"line\">\t\t\t&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--参见dependencies/dependency元素 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t......</span><br><span class=\"line\">\t\t\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;/dependencies&gt;</span><br><span class=\"line\">\t\t\t&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span><br><span class=\"line\">\t\t\t&lt;reports /&gt;</span><br><span class=\"line\">\t\t\t&lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;reporting&gt;</span><br><span class=\"line\">\t\t\t\t......</span><br><span class=\"line\">\t\t\t&lt;/reporting&gt;</span><br><span class=\"line\">\t\t\t&lt;!--参见dependencyManagement元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;dependencyManagement&gt;</span><br><span class=\"line\">\t\t\t\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--参见dependencies/dependency元素 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t\t\t......</span><br><span class=\"line\">\t\t\t\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/dependencies&gt;</span><br><span class=\"line\">\t\t\t&lt;/dependencyManagement&gt;</span><br><span class=\"line\">\t\t\t&lt;!--参见distributionManagement元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;distributionManagement&gt;</span><br><span class=\"line\">\t\t\t\t......</span><br><span class=\"line\">\t\t\t&lt;/distributionManagement&gt;</span><br><span class=\"line\">\t\t\t&lt;!--参见properties元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;properties /&gt;</span><br><span class=\"line\">\t\t&lt;/profile&gt;</span><br><span class=\"line\">\t&lt;/profiles&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span><br><span class=\"line\">\t&lt;modules&gt;&lt;/modules&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span><br><span class=\"line\">\t&lt;repositories&gt;</span><br><span class=\"line\">\t\t&lt;!--包含需要连接到远程仓库的信息 --&gt;</span><br><span class=\"line\">\t\t&lt;repository&gt;</span><br><span class=\"line\">\t\t\t&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span><br><span class=\"line\">\t\t\t&lt;releases&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;enabled /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;updatePolicy /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;checksumPolicy /&gt;</span><br><span class=\"line\">\t\t\t&lt;/releases&gt;</span><br><span class=\"line\">\t\t\t&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的</span><br><span class=\"line\">\t\t\t\t策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;snapshots&gt;</span><br><span class=\"line\">\t\t\t\t&lt;enabled /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;updatePolicy /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;checksumPolicy /&gt;</span><br><span class=\"line\">\t\t\t&lt;/snapshots&gt;</span><br><span class=\"line\">\t\t\t&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span><br><span class=\"line\">\t\t\t&lt;id&gt;banseon-repository-proxy&lt;/id&gt;</span><br><span class=\"line\">\t\t\t&lt;!--远程仓库名称 --&gt;</span><br><span class=\"line\">\t\t\t&lt;name&gt;banseon-repository-proxy&lt;/name&gt;</span><br><span class=\"line\">\t\t\t&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span><br><span class=\"line\">\t\t\t&lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt;</span><br><span class=\"line\">\t\t\t&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然</span><br><span class=\"line\">\t\t\t\t而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;layout&gt;default&lt;/layout&gt;</span><br><span class=\"line\">\t\t&lt;/repository&gt;</span><br><span class=\"line\">\t&lt;/repositories&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span><br><span class=\"line\">\t&lt;pluginRepositories&gt;</span><br><span class=\"line\">\t\t&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span><br><span class=\"line\">\t\t&lt;pluginRepository&gt;</span><br><span class=\"line\">\t\t\t......</span><br><span class=\"line\">\t\t&lt;/pluginRepository&gt;</span><br><span class=\"line\">\t&lt;/pluginRepositories&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span><br><span class=\"line\">\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;!--依赖的group ID --&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;org.apache.maven&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;!--依赖的artifact ID --&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;maven-artifact&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class=\"line\">\t\t\t&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应，</span><br><span class=\"line\">\t\t\t\t尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;type&gt;jar&lt;/type&gt;</span><br><span class=\"line\">\t\t\t&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成</span><br><span class=\"line\">\t\t\t\tJAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;classifier&gt;&lt;/classifier&gt;</span><br><span class=\"line\">\t\t\t&lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath</span><br><span class=\"line\">\t\t\t\t- runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得</span><br><span class=\"line\">\t\t\t\t- systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span><br><span class=\"line\">\t\t\t&lt;scope&gt;test&lt;/scope&gt;</span><br><span class=\"line\">\t\t\t&lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;systemPath&gt;&lt;/systemPath&gt;</span><br><span class=\"line\">\t\t\t&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span><br><span class=\"line\">\t\t\t&lt;exclusions&gt;</span><br><span class=\"line\">\t\t\t\t&lt;exclusion&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/exclusion&gt;</span><br><span class=\"line\">\t\t\t&lt;/exclusions&gt;</span><br><span class=\"line\">\t\t\t&lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;optional&gt;true&lt;/optional&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t&lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span><br><span class=\"line\">\t&lt;reports&gt;&lt;/reports&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;</span><br><span class=\"line\">\t&lt;reporting&gt;</span><br><span class=\"line\">\t\t&lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt;</span><br><span class=\"line\">\t\t&lt;excludeDefaults /&gt;</span><br><span class=\"line\">\t\t&lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt;</span><br><span class=\"line\">\t\t&lt;outputDirectory /&gt;</span><br><span class=\"line\">\t\t&lt;!--使用的报表插件和他们的配置。 --&gt;</span><br><span class=\"line\">\t\t&lt;plugins&gt;</span><br><span class=\"line\">\t\t\t&lt;!--plugin元素包含描述报表插件需要的信息 --&gt;</span><br><span class=\"line\">\t\t\t&lt;plugin&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--报表插件在仓库里的group ID --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--报表插件在仓库里的artifact ID --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--被使用的报表插件的版本（或版本范围） --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--任何配置是否被传播到子项目 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--报表插件的配置 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span><br><span class=\"line\">\t\t\t\t&lt;reportSets&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;reportSet&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;id /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;!--产生报表集合时，被使用的报表的配置 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;configuration /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;!--配置是否被继承到子POMs --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;inherited /&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;!--这个集合里使用到哪些报表 --&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;reports /&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;/reportSet&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/reportSets&gt;</span><br><span class=\"line\">\t\t\t&lt;/plugin&gt;</span><br><span class=\"line\">\t\t&lt;/plugins&gt;</span><br><span class=\"line\">\t&lt;/reporting&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact</span><br><span class=\"line\">\t\tID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span><br><span class=\"line\">\t&lt;dependencyManagement&gt;</span><br><span class=\"line\">\t\t&lt;dependencies&gt;</span><br><span class=\"line\">\t\t\t&lt;!--参见dependencies/dependency元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t\t......</span><br><span class=\"line\">\t\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;/dependencies&gt;</span><br><span class=\"line\">\t&lt;/dependencyManagement&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span><br><span class=\"line\">\t&lt;distributionManagement&gt;</span><br><span class=\"line\">\t\t&lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;</span><br><span class=\"line\">\t\t&lt;repository&gt;</span><br><span class=\"line\">\t\t\t&lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;</span><br><span class=\"line\">\t\t\t&lt;uniqueVersion /&gt;</span><br><span class=\"line\">\t\t\t&lt;id&gt;banseon-maven2&lt;/id&gt;</span><br><span class=\"line\">\t\t\t&lt;name&gt;banseon maven2&lt;/name&gt;</span><br><span class=\"line\">\t\t\t&lt;url&gt;file://$&#123;basedir&#125;/target/deploy&lt;/url&gt;</span><br><span class=\"line\">\t\t\t&lt;layout /&gt;</span><br><span class=\"line\">\t\t&lt;/repository&gt;</span><br><span class=\"line\">\t\t&lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;</span><br><span class=\"line\">\t\t&lt;snapshotRepository&gt;</span><br><span class=\"line\">\t\t\t&lt;uniqueVersion /&gt;</span><br><span class=\"line\">\t\t\t&lt;id&gt;banseon-maven2&lt;/id&gt;</span><br><span class=\"line\">\t\t\t&lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt;</span><br><span class=\"line\">\t\t\t&lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt;</span><br><span class=\"line\">\t\t\t&lt;layout /&gt;</span><br><span class=\"line\">\t\t&lt;/snapshotRepository&gt;</span><br><span class=\"line\">\t\t&lt;!--部署项目的网站需要的信息 --&gt;</span><br><span class=\"line\">\t\t&lt;site&gt;</span><br><span class=\"line\">\t\t\t&lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span><br><span class=\"line\">\t\t\t&lt;id&gt;banseon-site&lt;/id&gt;</span><br><span class=\"line\">\t\t\t&lt;!--部署位置的名称 --&gt;</span><br><span class=\"line\">\t\t\t&lt;name&gt;business api website&lt;/name&gt;</span><br><span class=\"line\">\t\t\t&lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;</span><br><span class=\"line\">\t\t\t&lt;url&gt;</span><br><span class=\"line\">\t\t\t\tscp://svn.baidu.com/banseon:/var/www/localhost/banseon-web</span><br><span class=\"line\">\t\t\t&lt;/url&gt;</span><br><span class=\"line\">\t\t&lt;/site&gt;</span><br><span class=\"line\">\t\t&lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span><br><span class=\"line\">\t\t&lt;downloadUrl /&gt;</span><br><span class=\"line\">\t\t&lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span><br><span class=\"line\">\t\t&lt;relocation&gt;</span><br><span class=\"line\">\t\t\t&lt;!--构件新的group ID --&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId /&gt;</span><br><span class=\"line\">\t\t\t&lt;!--构件新的artifact ID --&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId /&gt;</span><br><span class=\"line\">\t\t\t&lt;!--构件新的版本号 --&gt;</span><br><span class=\"line\">\t\t\t&lt;version /&gt;</span><br><span class=\"line\">\t\t\t&lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span><br><span class=\"line\">\t\t\t&lt;message /&gt;</span><br><span class=\"line\">\t\t&lt;/relocation&gt;</span><br><span class=\"line\">\t\t&lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从</span><br><span class=\"line\">\t\t\tMaven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt;</span><br><span class=\"line\">\t\t&lt;status /&gt;</span><br><span class=\"line\">\t&lt;/distributionManagement&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;</span><br><span class=\"line\">\t&lt;properties&gt;&lt;/properties&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/project&gt;  </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://maven.apache.org/index.html\">Maven 官方文档</a><br><a href=\"https://www.cnblogs.com/hongwz/p/5456578.html\">Maven 详解</a><br><a href=\"http://www.cnblogs.com/now-fighting/p/4858982.html\">Maven学习-目录结构</a><br><a href=\"https://blog.csdn.net/wdx1121/article/details/79664385\">Maven 的 pom 文件详细解析</a><br><a href=\"https://blog.csdn.net/tanga842428/article/details/54574590\">Maven 中 pom 文件详解</a><br><a href=\"https://blog.csdn.net/HaosCoder/article/details/79524629\">maven常用插件解析</a></p>\n","categories":["工具","Maven"],"tags":["Maven"]},{"title":"小程序获取openid、session_key和access_token","url":"/2018/07/06/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%B0%83%E6%95%B4/","content":"<blockquote>\n<p>openid、session_key 和 access_token 是微信小程序常用到的信息，需要通过官方提供的 api 接口来获取。</p>\n<ul>\n<li>openid 是微信用户在公众号 appid 下的唯一用户标识（appid 不同，则获取到的 openid 就不同），可用于永久标记一个用户。</li>\n<li>session_key 用于校验用户信息（例如 wx.getUserInfo(OBJECT) 返回的 signature）和解密（例如 wx.getUserInfo(OBJECT) 返回的 encryptedData）。</li>\n<li>access_token 是全局唯一接口调用凭据，开发者调用各接口时都需使用。access_token 的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的 access_token 失效，所以需要妥善保存。</li>\n</ul>\n<p>转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"获取-openid-和-session-key\"><a href=\"#获取-openid-和-session-key\" class=\"headerlink\" title=\"获取 openid 和 session_key\"></a>获取 openid 和 session_key</h2><h3 id=\"获取用户信息接口调整\"><a href=\"#获取用户信息接口调整\" class=\"headerlink\" title=\"获取用户信息接口调整\"></a>获取用户信息接口调整</h3><p>根究官方公告 <a href=\"https://developers.weixin.qq.com/blogdetail?action=get_post_info&lang=zh_CN&token=384460955&docid=000aee01f98fc0cbd4b6ce43b56c01\">获取用户信息接口优化调整</a>，<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open.html#wxgetuserinfoobject\">wx.getUserInfo()</a> 进行调整，2018年05月10日以后小程序需要通过 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/component/button.html\">button</a> 按钮授权来引导用户主动进行授权操作才能获取用户信息。</p>\n<p>简单来说，在旧接口里面，开发人员可以随时调用 wx.getUserInfo()。在第一次调用的时候会弹出授权窗口，需要用户进行授权操作才能获取信息。</p>\n<p>在新接口里面，不能随时调用 wx.getUserInfo()，需要在 button 按钮里面添加属性 <code>open-type=“getUserInfo”</code>，通过点击 button 按钮来弹出授权窗口，用户授权之后两种方法获取用户信息：</p>\n<ol>\n<li>button 按钮绑定事件 <code>bindgetuserinfo=&quot;methodName&quot;</code>，通过 methodName 事件回调数据来获取用户信息。回调数据 e.detail 数据与 wx.getUserInfo() 返回的一致</li>\n</ol>\n<ul>\n<li>xml <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button open-type=“getUserInfo&quot; bindgetuserinfo=&quot;pageGetUserInfo&quot;&gt;下一步&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>\n<li>js <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pageGetUserInfo: function (e) &#123;</span><br><span class=\"line\">  console.log(e.detail) #detail数据与wx.getUserInfo()返回的一致</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>button 按钮绑定普通点击事件 <code>bindtap=&quot;methodName&quot;</code>，在 methodName 方法里面调用 wx.getUserInfo() 来获取用户信息。这时候 button 按钮只是起到弹出授权窗口的作用。</li>\n</ol>\n<ul>\n<li>xml <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button open-type=“getUserInfo&quot; bindtap=&quot;pageGetUserInfo&quot;&gt;下一步&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>\n<li>js <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pageGetUserInfo: function (e) &#123;</span><br><span class=\"line\">  var that = this</span><br><span class=\"line\">  app.getUserInfo(function (userInfo) &#123;</span><br><span class=\"line\">    that.setData(&#123;</span><br><span class=\"line\">      userInfo: userInfo</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n<li>app.js <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">getUserInfo: function (cb) &#123;</span><br><span class=\"line\">  var that = this</span><br><span class=\"line\">  if (this.globalData.userInfo) &#123;</span><br><span class=\"line\">    typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    wx.login(&#123;</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        var code = res.code; //获取code</span><br><span class=\"line\">        wx.getUserInfo(&#123;</span><br><span class=\"line\">          success: function (res) &#123; //用户授权登录</span><br><span class=\"line\">            that.globalData.userInfo = res.userInfo</span><br><span class=\"line\">            typeof cb == &quot;function&quot; &amp;&amp; cb(that.globalData.userInfo)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"获取-openid-和-session-key-1\"><a href=\"#获取-openid-和-session-key-1\" class=\"headerlink\" title=\"获取 openid 和 session_key\"></a>获取 openid 和 session_key</h3><p>根据官方提供的 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/api-login.html\">小程序登录</a> 流程，流程图如下：</p>\n<div style=\"width: 80%\">![liucheng](liucheng.jpg)</div>\n获取 openid 和 session_key 的步骤可以分为：\n\n<ol>\n<li><code>wx.login()</code> 获取登录临时凭证 code</li>\n<li>把 code 通过 <code>wx.request()</code> 发送到我们的开发服务器</li>\n<li>在开发服务器上把 code、appid 和 appsecret 发送到微信api <code>https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code</code>。appid 和 appsecret 从 <a href=\"https://mp.weixin.qq.com/\">微信公众平台</a> 上获取，然后在开发服务器上定义为配置变量来调用</li>\n<li>获取 openid 和 seesion_key 返回</li>\n</ol>\n<p>一般来说会在 app.js 里面定义获取用户信息的方法 <code>getUserInfo()</code> 方法，该方法里面再分别调用 <code>wx.login()</code> （返回的 code 用于获取 openid）和 <code>wx.getUserInfo()</code> （返回用户信息，其中 userInfo 可以保存在全局变量 app.globalData.userInfo 里面）。这样全局都可以通过调用 <code>getUserInfo()</code> 来进行获取 openid 和用户信息。</p>\n<blockquote>\n<p>wx.getUserInfo() 返回的数据 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/open.html#wxgetuserinfoobject\">encryptedData</a> 包括 openid 等敏感数据的完整用户信息的加密数据，如果只需要 openid 而不需要 session_key 的话可以直接解密 encryptedData 来获取 openid，详见 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/signature.html#wxchecksessionobject\">加密数据解密算法</a></p>\n</blockquote>\n<p>下面贴出核心代码（并不是完整代码）</p>\n<h4 id=\"app-js\"><a href=\"#app-js\" class=\"headerlink\" title=\"app.js\"></a>app.js</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">getUserInfo: function (cb) &#123;</span><br><span class=\"line\">  var that = this</span><br><span class=\"line\">  if (this.globalData.userInfo) &#123;</span><br><span class=\"line\">    typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    wx.login(&#123;</span><br><span class=\"line\">      success: function (res) &#123;</span><br><span class=\"line\">        var code = res.code;</span><br><span class=\"line\">        wx.getUserInfo(&#123;</span><br><span class=\"line\">          success: function (res) &#123; //用户授权登录</span><br><span class=\"line\">            that.globalData.userInfo = res.userInfo</span><br><span class=\"line\">            var encryptedData = encodeURIComponent(res.encryptedData);</span><br><span class=\"line\">            var iv = res.iv;</span><br><span class=\"line\">            that.wxLogin(code, encryptedData, iv); //调用后台接口登录</span><br><span class=\"line\">            typeof cb == &quot;function&quot; &amp;&amp; cb(that.globalData.userInfo)</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          fail: function (res) &#123; //用户没有授权登录</span><br><span class=\"line\">           //todo</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">wxLogin: function (code, encryptedData, iv) &#123;</span><br><span class=\"line\">  var that = this</span><br><span class=\"line\">  var data = &#123;</span><br><span class=\"line\">    code: code,</span><br><span class=\"line\">    encryptedData: encryptedData,</span><br><span class=\"line\">    iv: iv</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  that.api(&#x27;get&#x27;, &#x27;/index/decodeUserInfo&#x27;, data, function(res)&#123; //该方法是自定义对wx.request()进一步封装的request请求方法，添加了异常处理等</span><br><span class=\"line\">    that.globalData.openid = res.openid</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">globalData: &#123;</span><br><span class=\"line\">  userInfo: null,</span><br><span class=\"line\">  openid: null,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"UserController-java\"><a href=\"#UserController-java\" class=\"headerlink\" title=\"UserController.java\"></a>UserController.java</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class UserController &#123;</span><br><span class=\"line\">    @ResponseBody</span><br><span class=\"line\">    @RequestMapping(&quot;/index/decodeUserInfo&quot;)</span><br><span class=\"line\">    public Map decodeUserInfo(@RequestParam Map&lt;String, String&gt; params) &#123;</span><br><span class=\"line\">        String encryptedData = params.get(&quot;encryptedData&quot;);</span><br><span class=\"line\">        String iv = params.get(&quot;iv&quot;);</span><br><span class=\"line\">        String code = params.get(&quot;code&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            String rs = userService.getWxjscode2session(appIdVersion, code);</span><br><span class=\"line\">            JSONObject obj = JSONObject.parseObject(rs);</span><br><span class=\"line\">            String session_key = obj.get(&quot;session_key&quot;).toString();</span><br><span class=\"line\">            String openid = obj.get(&quot;openid&quot;).toString();</span><br><span class=\"line\">            </span><br><span class=\"line\">            Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">            map.put(&quot;openid&quot;, openid);</span><br><span class=\"line\">            map.put(&quot;session_key&quot;, session_key);</span><br><span class=\"line\"></span><br><span class=\"line\">            return ApiResponse.ok(map);</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            log.error(e.getMessage());</span><br><span class=\"line\">            return ApiResponse.response(ApiResponse.Code.ERROR, &quot;内部错误。&quot;, e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"UserService-java\"><a href=\"#UserService-java\" class=\"headerlink\" title=\"UserService.java\"></a>UserService.java</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class UserService &#123;</span><br><span class=\"line\">\tprivate final static String wxjscode2sessionURL= &quot;https://api.weixin.qq.com/sns/jscode2session&quot;;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    private final static String appId = &quot;xxx&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final static String secret = &quot;xxx&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private final static String grantType = &quot;authorization_code&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public String getWxjscode2session (String appIdVersion, String code)&#123;</span><br><span class=\"line\">        String rs = &quot;&quot;;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            Map&lt;String, String&gt; parameters = new HashMap&lt;String, String&gt;();</span><br><span class=\"line\">            parameters.put(&quot;js_code&quot;, code);</span><br><span class=\"line\">            parameters.put(&quot;appid&quot;, appId);</span><br><span class=\"line\">            parameters.put(&quot;secret&quot;, secret);</span><br><span class=\"line\">            parameters.put(&quot;grant_type&quot;, grantType);</span><br><span class=\"line\">            rs = HttpClientUtils.doPost(UserService.wxjscode2sessionURL, parameters); //向微信api发送请求</span><br><span class=\"line\">        &#125;catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return rs;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HttpClientUtils-java\"><a href=\"#HttpClientUtils-java\" class=\"headerlink\" title=\"HttpClientUtils.java\"></a>HttpClientUtils.java</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class HttpClientUtils &#123;</span><br><span class=\"line\">    private static final String CHARSET = &quot;utf-8&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public static String doPost(String url, Map&lt;String, String&gt; map) &#123;</span><br><span class=\"line\">        CloseableHttpClient httpClient = null;</span><br><span class=\"line\">        HttpPost httpPost = null;</span><br><span class=\"line\">        String result = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            httpClient = HttpClients.createDefault();</span><br><span class=\"line\">            RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(30000).setConnectionRequestTimeout(10000).setSocketTimeout(30000).build();</span><br><span class=\"line\">            httpPost = new HttpPost(url);</span><br><span class=\"line\">            httpPost.setConfig(requestConfig);</span><br><span class=\"line\">            // 设置参数</span><br><span class=\"line\">            List&lt;NameValuePair&gt; list = null;</span><br><span class=\"line\">            if (null != map) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                list = new ArrayList&lt;NameValuePair&gt;();</span><br><span class=\"line\">                Iterator&lt;Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class=\"line\">                while (iterator.hasNext()) &#123;</span><br><span class=\"line\">                    Entry&lt;String, String&gt; elem = iterator.next();</span><br><span class=\"line\">                    list.add(new BasicNameValuePair(elem.getKey(), elem.getValue()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (null != list &amp;&amp; list.size() &gt; 0) &#123;</span><br><span class=\"line\">                UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list, CHARSET);</span><br><span class=\"line\">                httpPost.setEntity(entity);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            CloseableHttpResponse response = httpClient.execute(httpPost);</span><br><span class=\"line\">            int statusCode = response.getStatusLine().getStatusCode();</span><br><span class=\"line\">            if (statusCode == 200) &#123;</span><br><span class=\"line\">                if (response != null) &#123;</span><br><span class=\"line\">                    HttpEntity resEntity = response.getEntity();</span><br><span class=\"line\">                    if (resEntity != null) &#123;</span><br><span class=\"line\">                        result = EntityUtils.toString(resEntity, CHARSET);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    EntityUtils.consume(resEntity);</span><br><span class=\"line\">                    response.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                System.err.println(&quot;HTTP POST ERROR: statusCode:&quot; + statusCode);</span><br><span class=\"line\">                if (response != null) &#123;</span><br><span class=\"line\">                    HttpEntity resEntity = response.getEntity();</span><br><span class=\"line\">                    if (resEntity != null) &#123;</span><br><span class=\"line\">                        String errMsg = EntityUtils.toString(resEntity, CHARSET);</span><br><span class=\"line\">                        System.err.println(errMsg);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    EntityUtils.consume(resEntity);</span><br><span class=\"line\">                    response.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Exception ex) &#123;</span><br><span class=\"line\">            System.err.println(&quot;HTTP POST 请求错误：&quot; + ex.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (StringUtils.isNotBlank(result)) &#123;</span><br><span class=\"line\">            if (result.indexOf(&quot;Token_b已失效&quot;) &gt; -1) &#123;</span><br><span class=\"line\">                throw new RuntimeException(&quot;Token已失效,请重新登录系统！&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"获取-access-token\"><a href=\"#获取-access-token\" class=\"headerlink\" title=\"获取 access_token\"></a>获取 access_token</h2><p>参考 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/token.html\">官方获取 access_token</a>，获取 access_token 的方法较为简单，通过 get 请求发送到 <code>https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET </code> 即可返回 access_token</p>\n<h4 id=\"UtilService-java\"><a href=\"#UtilService-java\" class=\"headerlink\" title=\"UtilService.java\"></a>UtilService.java</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class UtilService &#123;</span><br><span class=\"line\">    private final static String wxAccessTokenURL = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=%s&amp;secret=%s&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public void getAccessToken (String orderFid, int type, String reason) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            String url = String.format(TradeService.wxAccessTokenURL, UserService.getAppIdv2(), UserService.getSecretv2());</span><br><span class=\"line\">            String rs = HttpClientUtils.doGet(url1); //获取access_token</span><br><span class=\"line\">            JSONObject obj = JSONObject.parseObject(rs1);</span><br><span class=\"line\">            String access_token = obj1.get(&quot;access_token&quot;).toString();</span><br><span class=\"line\">        &#125;catch (NullPointerException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HttpClientUtils-java-1\"><a href=\"#HttpClientUtils-java-1\" class=\"headerlink\" title=\"HttpClientUtils.java\"></a>HttpClientUtils.java</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class HttpClientUtils &#123;</span><br><span class=\"line\">    private static final String CHARSET = &quot;utf-8&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static String doGet(String url) &#123;</span><br><span class=\"line\">        String result = null;</span><br><span class=\"line\">        CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class=\"line\">        RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(3000).setConnectionRequestTimeout(1000).setSocketTimeout(3000).build();</span><br><span class=\"line\">        HttpGet httpGet = new HttpGet(url);</span><br><span class=\"line\">        httpGet.setConfig(requestConfig);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            CloseableHttpResponse response = httpclient.execute(httpGet);</span><br><span class=\"line\">            int statusCode = response.getStatusLine().getStatusCode();</span><br><span class=\"line\">            if (statusCode == 200) &#123;</span><br><span class=\"line\">                HttpEntity entity1 = response.getEntity();</span><br><span class=\"line\">                if (entity1 != null) &#123;</span><br><span class=\"line\">                    result = EntityUtils.toString(entity1, CHARSET);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                EntityUtils.consume(entity1);</span><br><span class=\"line\">                response.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            System.err.println(&quot;HTTP GET 请求错误：&quot; + e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["平台开发","微信小程序"],"tags":["微信小程序"]},{"title":"Java异常处理中throw和throws的区别和用法","url":"/2018/07/10/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%ADthrow%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95/","content":"<blockquote>\n<p>前一篇文章已经详细介绍了 Java 的异常处理机制，在这里做一些补充，探讨异常处理关键字 throw 和 throws 的区别和用法。转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"抛出异常的三种形式\"><a href=\"#抛出异常的三种形式\" class=\"headerlink\" title=\"抛出异常的三种形式\"></a>抛出异常的三种形式</h2><p>Java 抛出异常有三种形式：</p>\n<ul>\n<li>系统自动抛出异常</li>\n<li>方法名通过 throws 抛出异常</li>\n<li>方法体通过 throw 抛出异常</li>\n</ul>\n<h3 id=\"系统自动抛出异常\"><a href=\"#系统自动抛出异常\" class=\"headerlink\" title=\"系统自动抛出异常\"></a>系统自动抛出异常</h3><p>当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常。发生异常后线程停止运行，后面的语句执行不到，会在包含它的所有 try 块中（可能在上层调用函数中）从里向外寻找含有与其匹配的 catch 子句的 try 块。如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tint a = 5, b =0;</span><br><span class=\"line\">\tSystem.out.println(5/b);</span><br><span class=\"line\">\t//function();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>系统会自动抛出ArithmeticException异常：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class=\"line\"></span><br><span class=\"line\">at test.ExceptionTest.main(ExceptionTest.java:62)</span><br></pre></td></tr></table></figure>\n\n<p>再如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tString s = &quot;abc&quot;;</span><br><span class=\"line\">\tSystem.out.println(Double.parseDouble(s));</span><br><span class=\"line\">\t//function();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>系统会自动抛出NumberFormatException异常：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1224)</span><br><span class=\"line\"></span><br><span class=\"line\">at java.lang.Double.parseDouble(Double.java:510)</span><br><span class=\"line\"></span><br><span class=\"line\">at test.ExceptionTest.main(ExceptionTest.java:62)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"throw-抛出异常\"><a href=\"#throw-抛出异常\" class=\"headerlink\" title=\"throw 抛出异常\"></a>throw 抛出异常</h3><p>throw 出现在方法体中，用于程序员主动抛出某种特定类型的异常。通过 throw 抛出的异常和系统自动抛出的异常有相同的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\tString s = &quot;abc&quot;;</span><br><span class=\"line\">\tif(s.equals(&quot;abc&quot;)) &#123;</span><br><span class=\"line\">\t\tthrow new NumberFormatException();</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tSystem.out.println(s);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t//function();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>会抛出异常：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.NumberFormatException</span><br><span class=\"line\"></span><br><span class=\"line\">at test.ExceptionTest.main(ExceptionTest.java:67)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"throws-抛出异常\"><a href=\"#throws-抛出异常\" class=\"headerlink\" title=\"throws 抛出异常\"></a>throws 抛出异常</h3><p>throws 出现方法头中，用来声明该方法可能抛出的异常类型，然后把异常交给调用它的上级程序来处理。</p>\n<p>对于 Error 和 RuntimeException 类型的及其子类的异常，不需要在方法头通过 throws 明确声明，因为这是不期待出现的异常。对于其他类型的异常 Java 编译器强制要求在方法头 通过 throws 明确声明，否则编译不通过。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void function() throws NumberFormatException&#123;</span><br><span class=\"line\">\tString s = &quot;abc&quot;;</span><br><span class=\"line\">\tSystem.out.println(Double.parseDouble(s));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">\ttry &#123;</span><br><span class=\"line\">\t\tfunction();</span><br><span class=\"line\">\t&#125; catch (NumberFormatException e) &#123;</span><br><span class=\"line\">\t\tSystem.err.println(&quot;非数据类型不能转换。&quot;);</span><br><span class=\"line\">\t\t//e.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">非数据类型不能转换。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"throw-和-throws-的区别和用法\"><a href=\"#throw-和-throws-的区别和用法\" class=\"headerlink\" title=\"throw 和 throws 的区别和用法\"></a>throw 和 throws 的区别和用法</h2><h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ul>\n<li>throws 用于方法头，throw 用于方法内部</li>\n<li>throws 后跟异常类型，表示可能会出现这些类型的异常，但是不一定抛出；throw 后跟异常对象，如果执行到 throw 就一定会抛出这种类型的异常。</li>\n<li>throw 后只能跟一个异常对象，throws 后可以一次声明多种异常类型。</li>\n</ul>\n<h3 id=\"使用场合\"><a href=\"#使用场合\" class=\"headerlink\" title=\"使用场合\"></a>使用场合</h3><p>Java 将派生于 Error 类和 RuntimeException 类的异常称为 <strong>非检查异常</strong> (unchecked exception)，将其他异常称为 <strong>检查异常</strong> (checked exception)。</p>\n<p>一般来说，系统在编译阶段检查的是检查异常和 throws 声明的异常，在运行阶段自动抛出的是非检查异常。</p>\n<p>对于检查异常，如果通过 throw 主动抛出，或者调用了可能会产生异常的方法但是又没有进行处理，必须在方法头上用 throws 显式声明该异常类型，否则编译器会报错。如下面 IOException 为检查异常</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//通过throw主动抛出</span><br><span class=\"line\">public void throwEx1() throws IOException &#123; //正常编译</span><br><span class=\"line\">    throw new IOException(&quot;.&quot;); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void throwEx2() &#123; //编译报错 unhandled exception java.io.ioexeption</span><br><span class=\"line\">    throw new IOException(&quot;.&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//调用可能会产生异常的方法但是没有进行处理</span><br><span class=\"line\">public void throwEx3() throws IOException&#123; //正常编译</span><br><span class=\"line\">    FileInputStream input = new FileInputStream(&quot;xxx&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void throwEx4() &#123; //编译报错 unhandled exception java.io.ioexeption</span><br><span class=\"line\">    FileInputStream input = new FileInputStream(&quot;xxx&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于非检查异常，如果通过 throw 主动抛出，可自行选择是否在方法头用 throws 显式声明，不声明编译也不会报错。如下面 SQLException 为非检查异常</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void throwEx5() throws SQLException&#123; //正常编译</span><br><span class=\"line\">    throw new IllegalStateException(&quot;.&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void throwEx6() &#123; //正常编译</span><br><span class=\"line\">    throw new IllegalStateException(&quot;.&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果调用方法名包含 throws 异常类型的方法，必须<em>在方法内通过 <code>try...catch</code> 捕获，或者继续在方法名上用 throws 声明继续往上抛</em>。例如调用上面的方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void throwEx7() &#123;</span><br><span class=\"line\">    throwEx1(); //编译报错 unhandled exception java.io.ioexeption</span><br><span class=\"line\">    throwEx5(); //编译报错 unhandled exception java.sql.sqlexeption</span><br><span class=\"line\">    throwEx6(); //正常编译</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void throwEx8() throws IOException, SQLException&#123;</span><br><span class=\"line\">    throwEx1(); //正常编译</span><br><span class=\"line\">    throwEx5(); //正常编译</span><br><span class=\"line\">    throwEx6(); //正常编译</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编程总结\"><a href=\"#编程总结\" class=\"headerlink\" title=\"编程总结\"></a>编程总结</h3><ol>\n<li>在写程序时，对可能会出现异常的部分通常要用 <code>try&#123;...&#125;catch&#123;...&#125;</code> 去捕捉它并对它进行处理</li>\n<li>用 <code>try&#123;...&#125;catch&#123;...&#125;</code> 捕捉了异常之后一定要对在 <code>catch&#123;...&#125;</code> 中对其进行处理，那怕是最简单的一句输出语句，或栈输入 <code>e.printStackTrace()</code></li>\n<li>如果是捕捉 IO 输入输出流中的异常，一定要在 <code>try&#123;...&#125;catch&#123;...&#125;</code> 后加 <code>finally&#123;...&#125;</code> 把输入输出流关闭；</li>\n<li>如果在函数体内用 throw 抛出了某种异常，最好要在函数名中加 throws 抛异常声明，然后交给调用它的上层函数进行处理。</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/luoweifu/article/details/10721543\">再探java基础——throw与throws</a><br><a href=\"https://zhidao.baidu.com/question/519014936.html?si=2&qbpn=1_2&tx=&wtp=wk&word=Java%EF%BC%9Athrow%E5%92%8Cthrows%E6%9C%89%E5%BF%85%E8%A6%81%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F&fr=solved&from=qb&ssid=&uid=bd_1492636518_230&pu=sz@224_240,os@&step=2&bd_page_type=1&init=middle\">百度问答</a></p>\n","categories":["Java","Java异常"],"tags":["Java","异常处理"]},{"title":"Java异常处理详解","url":"/2018/07/10/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3/","content":"<blockquote>\n<p>之前在学习工作中虽然一直在用 Java 的异常处理，但一直都处于仅仅了解简单用法的表面基础上。最近趁有空进一步深入学习了 Java 的异常处理机制，发现一些写得很好的博客，转载过来学习。本文转载自: <a href=\"https://www.cnblogs.com/lulipro/p/7504267.html\">https://www.cnblogs.com/lulipro/p/7504267.html</a></p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"什么是异常\"><a href=\"#什么是异常\" class=\"headerlink\" title=\"什么是异常\"></a>什么是异常</h2><p><em><strong>异常就是程序运行时，发生的不被期望的事件，阻止了程序按照程序员的预期正常执行</strong></em>。Java 为异常提供了优秀的解决办法：异常处理机制。</p>\n<p>异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。</p>\n<p>Java 中的异常可以是函数中的语句执行时引发的，也可以是程序员通过 throw 语句手动抛出的，只要在 Java 程序中产生了异常，就会用一个对应类型的异常对象来封装异常，JRE就会试图寻找异常处理程序来处理异常。</p>\n<h2 id=\"Java异常的分类和类结构图\"><a href=\"#Java异常的分类和类结构图\" class=\"headerlink\" title=\"Java异常的分类和类结构图\"></a>Java异常的分类和类结构图</h2><p>Throwable 类是 Java 异常类型的顶层父类，一个对象只有是 Throwable 类的（直接或者间接）实例，他才是一个异常对象，才能被异常处理机制识别。JDK中内建了一些常用的异常类，我们也可以自定义异常。</p>\n<p>Throwable 又派生出 Error 类和 Exception 类。</p>\n<ul>\n<li><p><strong>Error</strong>：Error 类以及他的子类的实例，代表了 JVM 本身的错误。错误不能被程序员通过代码处理，Error 很少出现。因此，程序员应该关注 Exception 为父类的分支下的各种异常类。</p>\n</li>\n<li><p><strong>Exception</strong>：Exception 以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被 Java 异常处理机制使用，是异常处理的核心。</p>\n</li>\n</ul>\n<p><img src=\"/.com//exception.png\" alt=\"exception\"></p>\n<p>根据编译器 Javac 对异常的处理要求（注意是分类是给 javac 识别的），将异常类分为2类。</p>\n<ul>\n<li><p><strong>非检查异常</strong>（unckecked exception）：<em><strong>Error 和 RuntimeException 以及他们的子类</strong></em>。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。<em><strong>对于这些异常，我们应该修正代码，而不是去通过异常处理器处理</strong></em>。这样的异常发生的原因多半是代码写的有问题。如除0错误 ArithmeticException，错误的强制类型转换错误 ClassCastException，数组索引越界 ArrayIndexOutOfBoundsException，使用了空对象 NullPointerException等等。</p>\n</li>\n<li><p><strong>检查异常</strong>（checked exception）：<em><strong>除了 Error 和 RuntimeException的其它异常</strong></em>。javac强制要求程序员为这样的异常做预备处理工作。<em><strong>在方法中要么用 try-catch 语句捕获它并处理，要么用 throws 子句声明抛出它，否则编译不会通过</strong></em>。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。</p>\n</li>\n</ul>\n<p>下面的代码会演示2个异常类型：ArithmeticException 和 InputMismatchException。前者由于整数除0引发，后者是输入的数据不能被转换为int类型引发。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package com.example;</span><br><span class=\"line\">import java. util .Scanner ;</span><br><span class=\"line\">public class AllDemo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">      public static void main (String [] args )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">            System . out. println( &quot;----欢迎使用命令行除法计算器----&quot; ) ;</span><br><span class=\"line\">            CMDCalculate ();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      public static void CMDCalculate ()</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">            Scanner scan = new Scanner ( System. in );</span><br><span class=\"line\">            int num1 = scan .nextInt () ;</span><br><span class=\"line\">            int num2 = scan .nextInt () ;</span><br><span class=\"line\">            int result = devide (num1 , num2 ) ;</span><br><span class=\"line\">            System . out. println( &quot;result:&quot; + result) ;</span><br><span class=\"line\">            scan .close () ;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      public static int devide (int num1, int num2 )&#123;</span><br><span class=\"line\">            return num1 / num2 ;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*****************************************</span><br><span class=\"line\"></span><br><span class=\"line\">----欢迎使用命令行除法计算器----</span><br><span class=\"line\">0</span><br><span class=\"line\">Exception in thread &quot;main&quot; java.lang.ArithmeticException : / by zero</span><br><span class=\"line\">     at com.example.AllDemo.devide( AllDemo.java:30 )</span><br><span class=\"line\">     at com.example.AllDemo.CMDCalculate( AllDemo.java:22 )</span><br><span class=\"line\">     at com.example.AllDemo.main( AllDemo.java:12 )</span><br><span class=\"line\"></span><br><span class=\"line\">----欢迎使用命令行除法计算器----</span><br><span class=\"line\">r</span><br><span class=\"line\">Exception in thread &quot;main&quot; java.util.InputMismatchException</span><br><span class=\"line\">     at java.util.Scanner.throwFor( Scanner.java:864 )</span><br><span class=\"line\">     at java.util.Scanner.next( Scanner.java:1485 )</span><br><span class=\"line\">     at java.util.Scanner.nextInt( Scanner.java:2117 )</span><br><span class=\"line\">     at java.util.Scanner.nextInt( Scanner.java:2076 )</span><br><span class=\"line\">     at com.example.AllDemo.CMDCalculate( AllDemo.java:20 )</span><br><span class=\"line\">     at com.example.AllDemo.main( AllDemo.java:12 )</span><br><span class=\"line\">*****************************************/</span><br></pre></td></tr></table></figure>\n\n<p>异常是在执行某个函数时引发的，而函数又是层级调用，形成调用栈的，因为，只要一个函数发生了异常，那么他的所有的caller都会被异常影响。当这些被影响的函数以异常信息输出时，就形成的了 <strong>异常追踪栈</strong>。</p>\n<p>异常最先发生的地方，叫做 <strong>异常抛出点</strong>。</p>\n<p><img src=\"/.com//stack.png\" alt=\"stack\"></p>\n<p>从上面的例子可以看出，当devide函数发生除0异常时，devide函数将抛出ArithmeticException异常，因此调用他的CMDCalculate函数也无法正常完成，因此也发送异常，而CMDCalculate的caller——main 因为CMDCalculate抛出异常，也发生了异常，这样一直向调用栈的栈底回溯。这种行为叫做 <strong>异常的冒泡</strong>，异常的冒泡是为了在当前发生异常的函数或者这个函数的caller中找到最近的异常处理程序。由于这个例子中没有使用任何异常处理机制，因此异常最终由main函数抛给JRE，导致程序终止。</p>\n<p>上面的代码不使用异常处理机制，也可以顺利编译，因为2个异常都是非检查异常。但是下面的例子就必须使用异常处理机制，因为异常是检查异常。</p>\n<p>代码中我选择使用throws声明异常，让函数的调用者去处理可能发生的异常。但是为什么只throws了IOException呢？因为FileNotFoundException是IOException的子类，在处理范围内。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testException() throws IOException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //FileInputStream的构造函数会抛出FileNotFoundException</span><br><span class=\"line\">    FileInputStream fileIn = new FileInputStream(&quot;E:\\\\a.txt&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    int word;</span><br><span class=\"line\">    //read方法会抛出IOException</span><br><span class=\"line\">    while((word =  fileIn.read())!=-1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.print((char)word);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //close方法会抛出IOException</span><br><span class=\"line\">    fileIn.clos</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"怎么处理异常\"><a href=\"#怎么处理异常\" class=\"headerlink\" title=\"怎么处理异常\"></a>怎么处理异常</h2><p>在编写代码处理异常时，对于检查异常，有2种不同的处理方式：</p>\n<ol>\n<li>使用 <strong>try…catch…finally</strong> 语句块处理它。</li>\n<li>在函数签名中使用 <strong>throws 声明</strong> 交给函数调用者 caller 去解决。</li>\n</ol>\n<h3 id=\"try…catch…finally语句块\"><a href=\"#try…catch…finally语句块\" class=\"headerlink\" title=\"try…catch…finally语句块\"></a>try…catch…finally语句块</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try&#123;</span><br><span class=\"line\">     //try块中放可能发生异常的代码。</span><br><span class=\"line\">     //如果执行完try且不发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。</span><br><span class=\"line\">     //如果发生异常，则尝试去匹配catch块。</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;catch(SQLException SQLexception)&#123;</span><br><span class=\"line\">    //每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java7中可以将多个异常声明在一个catch中。</span><br><span class=\"line\">    //catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。</span><br><span class=\"line\">    //在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。</span><br><span class=\"line\">    //如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。</span><br><span class=\"line\">    //如果try中没有发生异常，则所有的catch块将被忽略。</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;catch(Exception exception)&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;finally&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //finally块通常是可选的。</span><br><span class=\"line\">   //无论异常是否发生，异常是否匹配被处理，finally都会执行。</span><br><span class=\"line\">   //一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。</span><br><span class=\"line\">  //finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的地方：</p>\n<ol>\n<li><p>try块中的局部变量和catch块中的局部变量（包括异常变量），以及finally中的局部变量，他们之间不可共享使用。</p>\n</li>\n<li><p>每一个catch块用于处理一个异常。异常匹配是按照catch块的顺序从上往下寻找的，只有第一个匹配的catch会得到执行。匹配时，不仅运行精确匹配，也支持父类匹配，因此，<em><strong>如果同一个try块下的多个catch异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面</strong></em>，这样保证每个catch块都有存在的意义。</p>\n</li>\n<li><p>java中，异常处理的任务就是将执行控制流从异常发生的地方转移到能够处理这种异常的地方去。也就是说：当一个函数的某条语句发生异常时，这条语句的后面的语句不会再执行，它失去了焦点。执行流跳转到最近的匹配的异常处理catch代码块去执行，异常被处理完后，执行流会接着在“处理了这个异常的catch代码块”后面接着执行。</p>\n</li>\n</ol>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args)&#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            foo();</span><br><span class=\"line\">        &#125;catch(ArithmeticException ae) &#123;</span><br><span class=\"line\">            System.out.println(&quot;处理异常&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public static void foo()&#123;</span><br><span class=\"line\">        int a = 5/0;  //异常抛出点</span><br><span class=\"line\">        System.out.println(&quot;为什么还不给我涨工资!!!&quot;);  //这里后面不会执行</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>有的编程语言当异常被处理后，控制流会恢复到异常抛出点接着执行，这种策略叫做：恢复式异常处理模式（resumption model of exception handling）<br> 而Java则是让执行流恢复到处理了异常的catch块后接着执行，这种策略叫做：终结式异常处理模式（termination model of exception handling）</p>\n</blockquote>\n<h3 id=\"throws-函数声明\"><a href=\"#throws-函数声明\" class=\"headerlink\" title=\"throws 函数声明\"></a>throws 函数声明</h3><p>throws声明：如果一个方法内部的代码会抛出检查异常（checked exception），而方法自己又没有完全处理掉，则javac保证你必须在方法的签名上使用throws关键字声明这些可能抛出的异常，否则编译不通过。</p>\n<p>throws是另一种处理异常的方式，它不同于try…catch…finally，throws仅仅是将函数中可能出现的异常向调用者声明，而自己则不具体处理。</p>\n<p>采取这种异常处理的原因可能是：方法本身不知道如何处理这样的异常，或者说让调用者处理更好，调用者需要为可能发生的异常负责。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void foo() throws ExceptionType1 , ExceptionType2 ,ExceptionTypeN</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     //foo内部可以抛出 ExceptionType1 , ExceptionType2 ,ExceptionTypeN 类的异常，或者他们的子类的异常对象。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"异常的链化\"><a href=\"#异常的链化\" class=\"headerlink\" title=\"异常的链化\"></a>异常的链化</h2><p>在一些大型的，模块化的软件开发中，一旦一个地方发生异常，则如骨牌效应一样，将导致一连串的异常。假设B模块完成自己的逻辑需要调用A模块的方法，如果A模块发生异常，则B也将不能完成而发生异常，但是B在抛出异常时，会将A的异常信息掩盖掉，这将使得异常的根源信息丢失。异常的链化可以将多个模块的异常串联起来，使得异常信息不会丢失。</p>\n<p>异常链化: <em>以一个异常对象为参数构造新的异常对象。新的异对象将包含先前异常的信息</em>。这项技术主要是异常类的一个带Throwable参数的函数来实现的。这个当做参数的异常，我们叫他根源异常（cause）。</p>\n<p>查看Throwable类源码，可以发现里面有一个Throwable字段cause，就是它保存了构造时传递的根源异常参数。<em>这种设计和链表的结点类设计如出一辙</em>，因此形成链也是自然的了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Throwable implements Serializable &#123;</span><br><span class=\"line\">    private Throwable cause = this;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Throwable(String message, Throwable cause) &#123;</span><br><span class=\"line\">        fillInStackTrace();</span><br><span class=\"line\">        detailMessage = message;</span><br><span class=\"line\">        this.cause = cause;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     public Throwable(Throwable cause) &#123;</span><br><span class=\"line\">        fillInStackTrace();</span><br><span class=\"line\">        detailMessage = (cause==null ? null : cause.toString());</span><br><span class=\"line\">        this.cause = cause;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //........</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一个例子，演示了异常的链化：从命令行输入2个int，将他们相加，输出。输入的数不是int，则导致getInputNumbers异常，从而导致add函数异常，则可以在add函数中抛出</p>\n<p>一个链化的异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(&quot;请输入2个加数&quot;);</span><br><span class=\"line\">    int result;</span><br><span class=\"line\">    try</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        result = add();</span><br><span class=\"line\">        System.out.println(&quot;结果:&quot;+result);</span><br><span class=\"line\">    &#125; catch (Exception e)&#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//获取输入的2个整数返回</span><br><span class=\"line\">private static List&lt;Integer&gt; getInputNumbers()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();</span><br><span class=\"line\">    Scanner scan = new Scanner(System.in);</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        int num1 = scan.nextInt();</span><br><span class=\"line\">        int num2 = scan.nextInt();</span><br><span class=\"line\">        nums.add(new Integer(num1));</span><br><span class=\"line\">        nums.add(new Integer(num2));</span><br><span class=\"line\">    &#125;catch(InputMismatchException immExp)&#123;</span><br><span class=\"line\">        throw immExp;</span><br><span class=\"line\">    &#125;finally &#123;</span><br><span class=\"line\">        scan.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return nums;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//执行加法计算</span><br><span class=\"line\">private static int add() throws Exception</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int result;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; nums =getInputNumbers();</span><br><span class=\"line\">        result = nums.get(0)  + nums.get(1);</span><br><span class=\"line\">    &#125;catch(InputMismatchException immExp)&#123;</span><br><span class=\"line\">        throw new Exception(&quot;计算失败&quot;,immExp);  /////////////////////////////链化:以一个异常对象为参数构造新的异常对象。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return  result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">请输入2个加数</span><br><span class=\"line\">r 1</span><br><span class=\"line\">java.lang.Exception: 计算失败</span><br><span class=\"line\">    at practise.ExceptionTest.add(ExceptionTest.java:53)</span><br><span class=\"line\">    at practise.ExceptionTest.main(ExceptionTest.java:18)</span><br><span class=\"line\">Caused by: java.util.InputMismatchException</span><br><span class=\"line\">    at java.util.Scanner.throwFor(Scanner.java:864)</span><br><span class=\"line\">    at java.util.Scanner.next(Scanner.java:1485)</span><br><span class=\"line\">    at java.util.Scanner.nextInt(Scanner.java:2117)</span><br><span class=\"line\">    at java.util.Scanner.nextInt(Scanner.java:2076)</span><br><span class=\"line\">    at practise.ExceptionTest.getInputNumbers(ExceptionTest.java:30)</span><br><span class=\"line\">    at practise.ExceptionTest.add(ExceptionTest.java:48)</span><br><span class=\"line\">    ... 1 more</span><br><span class=\"line\"></span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/.com//lianshi.png\" alt=\"lianshi\"></p>\n<h2 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h2><p>如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展自RuntimeException。</p>\n<p>按照国际惯例，自定义的异常应该总是包含如下的构造函数：</p>\n<ul>\n<li>一个无参构造函数</li>\n<li>一个带有String参数的构造函数，并传递给父类的构造函数。</li>\n<li>一个带有String参数和Throwable参数，并都传递给父类构造函数</li>\n<li>一个带有Throwable 参数的构造函数，并传递给父类的构造函数。</li>\n</ul>\n<p>下面是IOException类的完整源代码，可以借鉴。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class IOException extends Exception</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static final long serialVersionUID = 7818375828146090155L;</span><br><span class=\"line\"></span><br><span class=\"line\">    public IOException()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        super();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public IOException(String message)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        super(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public IOException(String message, Throwable cause)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        super(message, cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public IOException(Throwable cause)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        super(cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"异常的注意事项\"><a href=\"#异常的注意事项\" class=\"headerlink\" title=\"异常的注意事项\"></a>异常的注意事项</h2><h3 id=\"重写带-throws-声明的父类方法\"><a href=\"#重写带-throws-声明的父类方法\" class=\"headerlink\" title=\"重写带 throws 声明的父类方法\"></a>重写带 throws 声明的父类方法</h3><p>当子类重写父类的带有 throws 声明的函数时，其 throws 声明的异常必须在父类异常的可控范围内。意思是说</p>\n<ul>\n<li>子类 throws 的异常数量不能多于父类</li>\n<li>子类 throws 的类型必须是父类异常类型或其子类</li>\n</ul>\n<p>例如，父类方法 throws 2 个异常，子类就不能 throws 3 个及以上的异常。父类 throws IOException，子类就必须 throws IOException 或者 IOException 的子类。</p>\n<p>这是为了支持多态。看下面这个例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Father</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public void start() throws IOException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        throw new IOException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Son extends Father</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public void start() throws Exception</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        throw new SQLException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/**********************假设上面的代码是允许的（实质是错误的）***********************/</span><br><span class=\"line\">class Test</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public static void main(String[] args)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Father[] objs = new Father[2];</span><br><span class=\"line\">        objs[0] = new Father();</span><br><span class=\"line\">        objs[1] = new Son();</span><br><span class=\"line\"></span><br><span class=\"line\">        for(Father obj:objs)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        //因为Son类抛出的实质是SQLException，而IOException无法处理它。</span><br><span class=\"line\">        //那么这里的try。。catch就不能处理Son中的异常。</span><br><span class=\"line\">        //多态就不能实现了。</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                 obj.start();</span><br><span class=\"line\">            &#125;catch(IOException)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                 //处理IOException</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"异常是线程独立的\"><a href=\"#异常是线程独立的\" class=\"headerlink\" title=\"异常是线程独立的\"></a>异常是线程独立的</h3><p>Java 程序可以是多线程的。每一个线程都是一个独立的执行流，独立的函数调用栈。如果程序只有一个线程，那么没有被任何代码处理的异常会导致程序终止。如果是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。</p>\n<p>也就是说，Java中的异常是线程独立的，线程的问题应该由线程自己来解决，而不要委托到外部，也不会直接影响到其它线程的执行。</p>\n<h3 id=\"finally-执行不受-try-块中的-return-影响\"><a href=\"#finally-执行不受-try-块中的-return-影响\" class=\"headerlink\" title=\"finally 执行不受 try 块中的 return 影响\"></a>finally 执行不受 try 块中的 return 影响</h3><p>在 try 块中即便有 return，break，continue 等改变执行流的语句，finally 也会执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int re = bar();</span><br><span class=\"line\">    System.out.println(re);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">private static int bar()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        return 5;</span><br><span class=\"line\">    &#125; finally&#123;</span><br><span class=\"line\">        System.out.println(&quot;finally&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*输出：</span><br><span class=\"line\">finally</span><br><span class=\"line\">5</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<p>很多人面对这个问题时，总是在归纳执行的顺序和规律，不过我觉得还是很难理解。我自己总结了一个方法。用如下GIF图说明。</p>\n<p><img src=\"/.com//return.gif\" alt=\"return\"></p>\n<p>也就是说：try…catch…finally中的return 只要能执行，就都执行了，他们共同向同一个内存地址（假设地址是0x80）写入返回值，后执行的将覆盖先执行的数据，而真正被调用者取的返回值就是最后一次写入的。那么，按照这个思想，下面的这个例子也就不难理解了。</p>\n<h3 id=\"finally-中的-return-会覆盖-try-或者-catch-中的返回值。\"><a href=\"#finally-中的-return-会覆盖-try-或者-catch-中的返回值。\" class=\"headerlink\" title=\"finally 中的 return 会覆盖 try 或者 catch 中的返回值。\"></a>finally 中的 return 会覆盖 try 或者 catch 中的返回值。</h3><p>不管 try 和 catch 里面 return 什么值，都会被 finally 的 return 值所覆盖。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    int result;</span><br><span class=\"line\"></span><br><span class=\"line\">    result = foo();</span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\"></span><br><span class=\"line\">    result = bar();</span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@SuppressWarnings(&quot;finally&quot;)</span><br><span class=\"line\">public static int foo() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        int a = 5 / 0;</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        return 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@SuppressWarnings(&quot;finally&quot;)</span><br><span class=\"line\">public static int bar() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        return 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">最终输入结果</span><br><span class=\"line\">2</span><br><span class=\"line\">2</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"finally-中的-return-会抑制（消灭）前面-try-或者-catch-块中的异常\"><a href=\"#finally-中的-return-会抑制（消灭）前面-try-或者-catch-块中的异常\" class=\"headerlink\" title=\"finally 中的 return 会抑制（消灭）前面 try 或者 catch 块中的异常\"></a>finally 中的 return 会抑制（消灭）前面 try 或者 catch 块中的异常</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int result;</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        result = foo();</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125; catch (Exception e)&#123;</span><br><span class=\"line\">        System.out.println(e.getMessage()); //没有捕捉到异常</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        result  = bar();</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125; catch (Exception e)&#123;</span><br><span class=\"line\">        System.out.println(e.getMessage()); //没有捕捉到异常</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//catch中的异常被抑制</span><br><span class=\"line\">@SuppressWarnings(&quot;finally&quot;)</span><br><span class=\"line\">public static int foo() throws Exception</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        int a = 5/0;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;catch(ArithmeticException amExp) &#123;</span><br><span class=\"line\">        throw new Exception(&quot;我将被忽略，因为下面的finally中使用了return&quot;);</span><br><span class=\"line\">    &#125;finally &#123;</span><br><span class=\"line\">        return 100;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//try中的异常被抑制</span><br><span class=\"line\">@SuppressWarnings(&quot;finally&quot;)</span><br><span class=\"line\">public static int bar() throws Exception</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        int a = 5/0;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;finally &#123;</span><br><span class=\"line\">        return 100;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">最终输出：</span><br><span class=\"line\">100</span><br><span class=\"line\">100</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"finally-中的异常会覆盖（消灭）前面-try-或者-catch-中的异常\"><a href=\"#finally-中的异常会覆盖（消灭）前面-try-或者-catch-中的异常\" class=\"headerlink\" title=\"finally 中的异常会覆盖（消灭）前面 try 或者 catch 中的异常\"></a>finally 中的异常会覆盖（消灭）前面 try 或者 catch 中的异常</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int result;</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        result = foo();</span><br><span class=\"line\">    &#125; catch (Exception e)&#123;</span><br><span class=\"line\">        System.out.println(e.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        result  = bar();</span><br><span class=\"line\">    &#125; catch (Exception e)&#123;</span><br><span class=\"line\">        System.out.println(e.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//catch中的异常被抑制</span><br><span class=\"line\">@SuppressWarnings(&quot;finally&quot;)</span><br><span class=\"line\">public static int foo() throws Exception</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        int a = 5/0;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;catch(ArithmeticException amExp) &#123;</span><br><span class=\"line\">        throw new Exception(&quot;我将被忽略，因为下面的finally中抛出了新的异常&quot;);</span><br><span class=\"line\">    &#125;finally &#123;</span><br><span class=\"line\">        throw new Exception(&quot;我是finaly中的Exception，覆盖了catch的异常&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//try中的异常被抑制</span><br><span class=\"line\">@SuppressWarnings(&quot;finally&quot;)</span><br><span class=\"line\">public static int bar() throws Exception</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        int a = 5/0; //这里产生的异常被下面finally抛出的异常覆盖</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;finally &#123;</span><br><span class=\"line\">        throw new Exception(&quot;我是finaly中的Exception，覆盖了try的异常&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">最终输出：</span><br><span class=\"line\">我是finaly中的Exception，覆盖了catch的异常</span><br><span class=\"line\">我是finaly中的Exception，覆盖了try的异常</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n\n<p>上面的3个例子都异于常人的编码思维，因此我建议：</p>\n<ul>\n<li>不要在fianlly中使用return。</li>\n<li>不要在finally中抛出异常。</li>\n<li>减轻finally的任务，不要在finally中做一些其它的事情，finally块仅仅用来释放资源是最合适的。</li>\n<li>将尽量将所有的return写在函数的最后面，而不是try … catch … finally中。</li>\n</ul>\n","categories":["Java","Java异常"],"tags":["Java","异常处理"]},{"title":"Java集合框架总结","url":"/2018/07/12/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/","content":"<blockquote>\n<p>之前对 Java 集合框架的了解仅仅停留在知道怎么使用一些常见集合，对集合框架的使用也没有做深一步的研究，经常被种类繁多的集合框架弄得云里雾里。现在对 Java 集合框架的设计思想和原理进行进一步学习，希望更加熟练灵活地掌握集合框架进而提高我们的开发效率。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在 Java 2 之前，Java 是没有完整的集合框架的。它只有一些简单的可以自扩展的容器类，比如 Vector，Stack，Hashtable 等。这些容器类在使用的过程中由于效率问题饱受诟病，因此在 Java 2 中，Java 设计者们进行了大刀阔斧的整改，重新设计，于是就有了现在的集合框架。需要注意的是，之前的那些容器类库并没有被弃用而是进行了保留，主要是为了向下兼容的目的，但我们在平时使用中还是应该尽量少用。</p>\n<p><img src=\"/.com//jihe.gif\" alt=\"jihe\"></p>\n<p>从上面我们可以看到 Java 集合框架主要有 <strong>Collection</strong> 和 <strong>Map</strong> 两种类型的容器接口，再下面是一些子接口或者抽象类，最后是具体实现类。：</p>\n<ul>\n<li>Collection 集合接口：存储单个元素数据，下面有 3 个经典的子接口类型 <strong>List</strong>、<strong>Set</strong> 和 <strong>Queue</strong>。</li>\n<li>List 代表有序、可重复的集合，常用的实现类有 ArrayList、LinkedList。</li>\n<li>Set 代表无序、不可重复的集合，常用的实现类有 HashSet、TreeSet。</li>\n<li>Queue 代表先进先出的队列集合，常用的实现类有 ArrayDeque、LinkedList。  </li>\n<li>Map 映射接口：存储 key-value 对元素数据，其中 key 是不可重复的。常用的实现类有 HashMap、TreeMap 等。</li>\n</ul>\n<h2 id=\"Collection-接口\"><a href=\"#Collection-接口\" class=\"headerlink\" title=\"Collection 接口\"></a>Collection 接口</h2><p>Collection 接口是集合的根接口，定义对集合元素进行操作的通用方法。Collection 的框架图如下所示：</p>\n<p><img src=\"/.com//collection.png\" alt=\"collection\"></p>\n<p>Collection 接口定义的所有方法如下所示：</p>\n<div style=\"width: 60%\">![colfunc](colfunc.jpeg)</div>\n常用的方法有 `add()` 添加一个元素到集合中，`addAll()` 将指定集合中的所有元素添加到另外一个集合中，`contains()` 方法检测集合中是否包含指定的元素，`toArray()` 方法返回一个表示集合的数组，`iterator()` 获取集合的迭代器来遍历集合。\n\n<h3 id=\"遍历-Collection\"><a href=\"#遍历-Collection\" class=\"headerlink\" title=\"遍历 Collection\"></a>遍历 Collection</h3><p>由上图可见 Collection 接口包含 Iterator 变量，且继承了 Iterable 接口，根据官方文档</p>\n<blockquote>\n<p>Implementing this interface allows an object to be the target of the “for-each loop” statement.</p>\n</blockquote>\n<p>所以 Collection 接口下的所有集合都可以通过 <strong>for-each 循环</strong> 或者 <strong>Iterator 迭代器</strong> 两种方法进行遍历。对于 List 类集合还可以通过 <strong>索引值</strong> 来遍历或者获取指定位置的元素。</p>\n<ul>\n<li>for-each 循环遍历</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">//往list里面添加元素</span><br><span class=\"line\">for(String item : list)&#123; //每一次循环把元素放到item变量里面</span><br><span class=\"line\">    //对取出的元素进行操作</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Iterator 迭代器遍历</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">//往list里面添加元素</span><br><span class=\"line\">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class=\"line\">while(iterator.hasNext())&#123; //判断是否有下一个元素</span><br><span class=\"line\">    String item = iterator.next(); //取出该元素放到item变量里面</span><br><span class=\"line\">    //对取出的元素进行操作</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>索引值获取元素</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">//往list里面添加元素</span><br><span class=\"line\">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">   String item = list.get(i); //取出该元素放到item变量里面   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Collection-元素比较\"><a href=\"#Collection-元素比较\" class=\"headerlink\" title=\"Collection 元素比较\"></a>Collection 元素比较</h3><p>Collection 集合的元素比较大小可以通过实现 Comparable 接口 ，然后 覆盖 compareTo(Object obj) 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public int compare(Integer o1, Integer o2) &#123;</span><br><span class=\"line\">    return o1 - o2; //从小到大排序</span><br><span class=\"line\">    //return o2 - o1; //从大到小排序</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>部分 Collection 集合例如 TreeSet、PriorityQueue 等类已经实现了 Comparable 接口，默认从小到大的自然排序。</p>\n<p>如果我们不想用自然排序，像用其他方式进行排序，我们可以新建一个 Comparator 比较器，在创建集合的时候提供 Comparator。</p>\n<p>例如下面对 PriorityQueue 中的元素进行比较，并且也可以覆盖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void defaultCompareQueue() &#123;</span><br><span class=\"line\">    //实现 Comparable 接口的 PriorityQueue 类，默认从小到大的自然排序</span><br><span class=\"line\">    PriorityQueue&lt;Integer&gt; q1 = new PriorityQueue&lt;&gt;();</span><br><span class=\"line\">    q1.add(2);</span><br><span class=\"line\">    q1.add(4);</span><br><span class=\"line\">    q1.add(9);</span><br><span class=\"line\">    q1.add(1);</span><br><span class=\"line\">    while (!q1.isEmpty()) &#123;</span><br><span class=\"line\">        System.out.print(q1.poll() + &quot;,&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void defineCompareQueue1() &#123;</span><br><span class=\"line\">    //自定义一个 Comparator，采用从大到小的降序排序</span><br><span class=\"line\">    Comparator&lt;Integer&gt; cmp = new Comparator&lt;Integer&gt;() &#123;</span><br><span class=\"line\">        public int compare(Integer e1, Integer e2) &#123;</span><br><span class=\"line\">            return e2 - e1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    //在新建集合时候提供上面的 Comparator</span><br><span class=\"line\">    PriorityQueue&lt;Integer&gt; q2 = new PriorityQueue&lt;&gt;(5, cmp);</span><br><span class=\"line\">    q2.add(2);</span><br><span class=\"line\">    q2.add(4);</span><br><span class=\"line\">    q2.add(9);</span><br><span class=\"line\">    q2.add(1);</span><br><span class=\"line\">    while (!q2.isEmpty()) &#123;</span><br><span class=\"line\">        System.out.print(q2.poll() + &quot;,&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void defineCompareQueue2() &#123;</span><br><span class=\"line\">    //初始化集合时直接提供自定义的 Comparator，采用从小到大的降序排序</span><br><span class=\"line\">    PriorityQueue&lt;Integer&gt; q3 = new PriorityQueue&lt;&gt;(</span><br><span class=\"line\">            new Comparator&lt;Integer&gt;() &#123;</span><br><span class=\"line\">                @Override</span><br><span class=\"line\">                public int compare(Integer o1, Integer o2) &#123;</span><br><span class=\"line\">                    return o2 - o1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    q3.add(2);</span><br><span class=\"line\">    q3.add(4);</span><br><span class=\"line\">    q3.add(9);</span><br><span class=\"line\">    q3.add(1);</span><br><span class=\"line\">    while (!q3.isEmpty()) &#123;</span><br><span class=\"line\">        System.out.print(q3.poll() + &quot;,&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"一、List\"><a href=\"#一、List\" class=\"headerlink\" title=\"一、List\"></a>一、List</h3><p>List 是一个可重复的有序集合。元素会增加到容器中的特定位置。除了常规的 Iterator 迭代器，还增加了能够双向遍历线性表的列表迭代器 ListIterator。List 可以通过 <strong>for-each 循环</strong>、<strong>Iterator 迭代器</strong> 和 <strong>索引值</strong> 三种方法进行访问。</p>\n<p>下面介绍 List 接口的两个重要的具体实现类，也是我们可能最常用的类，<strong>ArrayList</strong> 和 <strong>LinkedList</strong>。</p>\n<h4 id=\"1、ArrayList\"><a href=\"#1、ArrayList\" class=\"headerlink\" title=\"1、ArrayList\"></a>1、ArrayList</h4><p><em><strong>ArrayList 是一个动态扩展的数组</strong></em>。它用数组存储元素，这个数组可以动态创建，如果元素个数超过了数组的容量，那么就创建一个更大的新数组，并将当前数组中的所有元素都复制到新数组中。因为基于数组的结构，所以 ArrayList 通过索引值来获取指定元素的效率很高。</p>\n<p>下面是 ArrayList 初始化的源码部分，从中我们可以看到 ArrayList 创建动态数组的过程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">private static final int DEFAULT_CAPACITY = 10; //默认容量</span><br><span class=\"line\"></span><br><span class=\"line\">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //空数组</span><br><span class=\"line\"></span><br><span class=\"line\">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; //默认容量空数组</span><br><span class=\"line\"></span><br><span class=\"line\">transient Object[] elementData; //用非序列化的数组临时存储元素</span><br><span class=\"line\"></span><br><span class=\"line\">private int size; //数组长度</span><br><span class=\"line\"></span><br><span class=\"line\">public ArrayList(int initialCapacity) &#123; //传入容量参数创建 ArrayList，如果容量为0就用默认容量</span><br><span class=\"line\">    if (initialCapacity &gt; 0) &#123;</span><br><span class=\"line\">        this.elementData = new Object[initialCapacity];</span><br><span class=\"line\">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class=\"line\">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public ArrayList() &#123; //没有传入容量就创建默认容量数组</span><br><span class=\"line\">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public boolean add(E e) &#123; //向集合中添加指定元素。</span><br><span class=\"line\">    ensureCapacityInternal(size + 1);</span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void ensureCapacityInternal(int minCapacity) &#123; //比较所需要的最小容量和目前数组的长度length(不管数组上是否有元素)，如果前者比后者大就新建更大容量的数组</span><br><span class=\"line\">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    if (minCapacity - elementData.length &gt; 0)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void grow(int minCapacity) &#123; //创建更大容量的数组，然后将旧数组的元素复制到新数组中。</span><br><span class=\"line\">    // overflow-conscious code</span><br><span class=\"line\">    int oldCapacity = elementData.length;</span><br><span class=\"line\">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class=\"line\">    if (newCapacity - minCapacity &lt; 0)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    // minCapacity is usually close to size, so this is a win:</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ArrayList-和-Vector-比较\"><a href=\"#ArrayList-和-Vector-比较\" class=\"headerlink\" title=\"ArrayList 和 Vector 比较\"></a>ArrayList 和 Vector 比较</h4><p>ArrayList 和 Vector 的功能非常类似，区别是 ArrayList 是线程不安全的，Vector 是线程安全的，且 Vector 比 Arraylist 的性能要差，尽量少用 Vector类。如果对线程安全没有要求就用 Arraylist，如果有要求可以参考 java.util.concurrent 并发编程包里面的类。</p>\n<p>Stack 是 Vector 的子类，用户模拟 “栈” 这种数据结构，“栈” 通常是指 “后进先出” (LIFO) 的容器。最后 “push” 进栈的元素，将被最先 “pop” 出栈。Stack 与 Vector 一样，是线程安全的，但是性能较差，尽量少用 Stack 类。如果要实现栈这种数据结构，可以考虑使用 LinkedList。</p>\n<h4 id=\"2、LinkedList\"><a href=\"#2、LinkedList\" class=\"headerlink\" title=\"2、LinkedList\"></a>2、LinkedList</h4><p><em><strong>LinkedList 是以链表的形式来保存元素</strong></em>。除此之外，LinkedList 还实现了 Deque 接口，可以被当作成双端队列来使用，因此既可以被当成栈来使用（实现 Stack 类），也可以当成队列来使用（实现 Queue 类）。</p>\n<p>虽然 LinkedList 也是 List 集合，可以根据索引来随机访问集合中的元素。但是通过索引来访问链表的第 n 个元素，必须从头开始遍历完前面的 n-1 个元素才能访问到目标元素，没有捷径可走，所以 LinkedList 随机访问的性能非常差。</p>\n<p>下面是 LinkedList 初始化的源码部分，我们可以看到 LinkedList 的数据结构和创建过程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">transient int size = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">transient Node&lt;E&gt; first; //链表保存开始节点和最后节点，用于双向修改链表</span><br><span class=\"line\"></span><br><span class=\"line\">transient Node&lt;E&gt; last;</span><br><span class=\"line\"></span><br><span class=\"line\">private static class Node&lt;E&gt; &#123; //每个节点包含元素内容，前驱节点和后驱节点</span><br><span class=\"line\">    E item;</span><br><span class=\"line\">    Node&lt;E&gt; next;</span><br><span class=\"line\">    Node&lt;E&gt; prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        this.item = element;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">        this.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public boolean add(E e) &#123; //添加元素</span><br><span class=\"line\">    linkLast(e);</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void linkLast(E e) &#123; //默认在链表最后添加元素</span><br><span class=\"line\">    final Node&lt;E&gt; l = last;</span><br><span class=\"line\">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class=\"line\">    last = newNode;</span><br><span class=\"line\">    if (l == null)</span><br><span class=\"line\">        first = newNode;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        l.next = newNode;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ArrayList-和-LinkedList-比较\"><a href=\"#ArrayList-和-LinkedList-比较\" class=\"headerlink\" title=\"ArrayList 和 LinkedList 比较\"></a>ArrayList 和 LinkedList 比较</h4><ul>\n<li>ArrayList 随机访问效率高，随机插入、随机删除效率低；LinkedList则反之，随机访问效率低，随机插入、随机删除效率高。</li>\n<li>ArrayList 使用随机访问来遍历效率高，LinkedList 使用逐个遍历效率高。</li>\n<li>如果需要经常随机插入、删除元素，应使用 LinkedList；如果需要随机快速访问元素，应使用 ArrayList。</li>\n</ul>\n<h3 id=\"二、Set\"><a href=\"#二、Set\" class=\"headerlink\" title=\"二、Set\"></a>二、Set</h3><p>Set 是无序的不允许重复的集合。如果试图把两个相同的元素加入同一个 Set 集合中，则添加操作失败，add() 方法返回 false，且新元素不会被加入。</p>\n<h4 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h4><p>在介绍 Set 集合之前我们先来认识一下哈希表。</p>\n<h5 id=\"什么是散列表\"><a href=\"#什么是散列表\" class=\"headerlink\" title=\"什么是散列表\"></a>什么是散列表</h5><p>当我们用数组来存储元素，然后通过把元素的关键字通过某个函数映射到数组中的某个位置，然后把元素存储在该位置上。这样我们通过关键字就可以迅速查找到元素的数组位置，然后访问该位置上的元素。这种方式实现的数组就叫做 <strong>哈希表</strong> (hash table)，把关键字映射成存储位置的函数就叫做 <strong>哈希函数</strong> (hash function)，映射后得到一个整数值叫做 <strong>哈希码</strong> (hash code)。如下图所示</p>\n<p><img src=\"/.com//hash.png\" alt=\"hash\"></p>\n<h5 id=\"哈希冲突\"><a href=\"#哈希冲突\" class=\"headerlink\" title=\"哈希冲突\"></a>哈希冲突</h5><p>当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的 <strong>哈希冲突</strong>。解决哈希冲突的方法有</p>\n<ul>\n<li>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）</li>\n<li>再哈希法</li>\n<li>拉链法</li>\n<li>建立一个公共溢出区</li>\n</ul>\n<p>例如最常用的 <strong>拉链法</strong> 也被称为 <strong>链表的数组</strong>。散列表的主干是数组，每一个数组元素都叫做 <strong>桶</strong> (bucket)，每个桶存储一个链表，整体看起来就像链表组成的数组。同一个链表上的元素的哈希码相同，不同链表之间的元素的哈希码都不相同。</p>\n<p>要插入一个元素，先计算该元素的散列码，然后与桶的总数取余，得到余数 n 就是该元素应插入到第 n 个桶，然后把元素插入到该桶所在位置。如果该位置没有元素就直接插入，如果该位置已经有元素了，遍历该元素所在的链表，通过 equals 方法进行对比，存在即覆盖，不存在就插入到链表末尾。</p>\n<p>hashCode 方法和 equals 方法的单方面兼容：</p>\n<ul>\n<li>如果 a.equals(b) 为 true，a 和 b 必须有相同的散列码。</li>\n<li>如果 a 和 b 有相同的散列码，a.equals(b) 不一定为 true。</li>\n</ul>\n<p><img src=\"/.com//hashmap.png\" alt=\"hashmap\"></p>\n<p>Set 有三个常见实现类 <strong>TreeSet</strong>、<strong>HashSet</strong>(下面有子类 <strong>LinkedHashSet</strong>)和 <strong>EnumSet</strong>。</p>\n<h4 id=\"1、HashSet\"><a href=\"#1、HashSet\" class=\"headerlink\" title=\"1、HashSet\"></a>1、HashSet</h4><p><em><strong>HashSet 是基于散列表实现的无序 Set 集合</strong></em>。HashSet 中的元素的排序顺序随机分配，所以访问顺序也是随机。</p>\n<p>HashSet 的底层是基于 HashMap 实现的，使用 HashMap 来保存所有元素。因此 HashSet  的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成的。参考 <a href=\"http://zhangshixi.iteye.com/blog/673143\">深入Java集合学习系列：HashSet的实现原理</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public HashSet() &#123;</span><br><span class=\"line\">    map = new HashMap&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、TreeSet\"><a href=\"#2、TreeSet\" class=\"headerlink\" title=\"2、TreeSet\"></a>2、TreeSet</h4><p><em><strong>TreeSet 和 HashSet 类似，但是它是一个不允许重复的有序 Set 集合</strong></em>。可以将任意顺序将元素插入到集合中，在遍历的时候每个值将自动按照排序后的顺序显示。</p>\n<p>TreeSet 使用红黑树的结构来实现排序，每次添加新元素的时候都会从根节点开始跟其他元素进行比较，最终将其放在正确的排序位置上。实际上 TreeSet 的底层是根据 TreeMap 来实现的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public TreeSet() &#123;</span><br><span class=\"line\">    this(new TreeMap&lt;E,Object&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HashSet-和-TreeSet-比较\"><a href=\"#HashSet-和-TreeSet-比较\" class=\"headerlink\" title=\"HashSet 和 TreeSet 比较\"></a>HashSet 和 TreeSet 比较</h4><p>将元素添加到树中比添加到散列表中的速度要慢，所以如果对排序有要求就可以选择 TreeSet，如果无要求就可以选择 HashSet。</p>\n<h3 id=\"三、Queue\"><a href=\"#三、Queue\" class=\"headerlink\" title=\"三、Queue\"></a>三、Queue</h3><p>Queue 用于模拟队列这种数据结构，队列通常是指 <strong>先进先出</strong>（FIFO）的容器。新元素插入到队列的尾部，访问元素操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。</p>\n<p>Queue 常用的实现类有 <strong>PriorityQueue</strong>、<strong>Deque</strong> 接口下的 <strong>ArrayDeque</strong> 和 <strong>LinkedList</strong>。</p>\n<h4 id=\"1、PriorityQueue\"><a href=\"#1、PriorityQueue\" class=\"headerlink\" title=\"1、PriorityQueue\"></a>1、PriorityQueue</h4><p><em><strong>PriorityQueue 是使用 堆(heap) 结构的实现的队列</strong></em>。堆是一种可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花时间对元素进行排序。</p>\n<p>PriorityQueue 中的元素可以按照任意的顺序插入，但是会按队列元素的大小进行重新排序。因此当取出队列中头部的元素时，并不是取出最先进入队列的元素，而是取出队列中的最小的元素。</p>\n<p>PriorityQueue 本质也是一个动态数组，在这一方面与ArrayList是一致的。PriorityQueue 调用默认的构造方法时，使用默认的初始容量（DEFAULT_INITIAL_CAPACITY&#x3D;11）创建一个 PriorityQueue，并根据其自然顺序来排序其元素（使用加入其中的集合元素实现的 Comparable ）。</p>\n<p>另外注意：</p>\n<ul>\n<li>PriorityQueue 不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue 实例，这时请使用线程安全的 PriorityBlockingQueue 类。</li>\n<li>不允许插入 null 元素。</li>\n<li>方法 iterator() 中提供的迭代器并不保证以有序的方式遍历优 PriorityQueue 中的元素。</li>\n</ul>\n<h4 id=\"2、ArrayDeque\"><a href=\"#2、ArrayDeque\" class=\"headerlink\" title=\"2、ArrayDeque\"></a>2、ArrayDeque</h4><p>Deque 接口是 Queue 接口的子接口，它代表一个双端队列。LinkedList 是以链表实现的双端队列，ArrayDeque 是用数组实现的双端队列。两者都维护表示头尾的两个节点。</p>\n<p>ArrayDeque 为了满足可以同时在数组两端插入或删除元素的需求，其内部的动态数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。</p>\n<p>ArrayDeque 不是线程安全的。当作为栈使用时，性能比 Stack 好；当作为队列使用时，性能比 LinkedList 好。</p>\n<h2 id=\"Map-接口\"><a href=\"#Map-接口\" class=\"headerlink\" title=\"Map 接口\"></a>Map 接口</h2><p><em><strong>Map 是用于保存具有映射关系的数据集合</strong></em>。Map 集合里保存着 key 和 value 两组值，key 和 value 都可以是任何引用类型的数据。Map 的 key 不允许重复，同一个 Map 对象的任何两个 key 通过 equals 方法比较总是返回 false。key 和 value 之间存在单向一对一关系，即通过指定的 key，总能找到唯一的、确定的 value。</p>\n<p><img src=\"/.com//map.png\" alt=\"map\"></p>\n<p>Map 接口定义的所有方法如下所示：</p>\n<div style=\"width: 60%\">![mapfunc](mapfunc.jpeg)</div>\n从上面我们可以看到 key、value 和 key-value 对应的成员变量如下所示：\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set&lt;K&gt; keySet();</span><br><span class=\"line\"></span><br><span class=\"line\">Collection&lt;V&gt; values();</span><br><span class=\"line\"></span><br><span class=\"line\">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>values</code> 是一个 Collection 集合，<code>keySet</code> 和 <code>entrySet</code> 是一个 Set 集合。但是注意这个 Set 集合也不是 HashSet 或者 TreeSet。这里的 Collection 和 Set 集合被称为 <strong>视图</strong> (views)，是其他实现了 Collection 接口和 Set 接口 的类返回的对象。这个视图并没有创建一个新集合，而是返回一个类对象来对原来的映射进行操作。</p>\n<p>另外我们还可以看到 Map 接口 比 Collection 接口多提供了一个 Entry 子接口，一般用 <code>Map.Entry&lt;&gt;</code> 来表示 Map 集合 key-value 对元素类型。</p>\n<h3 id=\"遍历-Map\"><a href=\"#遍历-Map\" class=\"headerlink\" title=\"遍历 Map\"></a>遍历 Map</h3><p>遍历 Map 有三种常用方式</p>\n<ul>\n<li>遍历 keySet()</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">//1.for-each 循环遍历 keySet()</span><br><span class=\"line\">for (String item : map.keySet()) &#123;</span><br><span class=\"line\">    //对取出来的每个key进行下一步操作</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//2.iterator 迭代器遍历 keySet()</span><br><span class=\"line\">Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class=\"line\">while (iterator.hasNext()) &#123;</span><br><span class=\"line\">    String item = iterator.next();</span><br><span class=\"line\">    //对取出来的每个key进行下一步操作</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>遍历 values()</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"> Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">//1.for-each 循环遍历 values()</span><br><span class=\"line\">for (Integer item : map.values()) &#123;</span><br><span class=\"line\">    //对取出来的每个value进行下一步操作</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//2.iterator 迭代器遍历 values()</span><br><span class=\"line\">Iterator&lt;Integer&gt; iterator = map.values().iterator();</span><br><span class=\"line\">while (iterator.hasNext()) &#123;</span><br><span class=\"line\">    Integer item = iterator.next();</span><br><span class=\"line\">    //对取出来的每个value进行下一步操作</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>遍历 entrySet()</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">//1.for-each 循环遍历 entrySet()</span><br><span class=\"line\">for (Map.Entry&lt;String, Integer&gt; item : map.entrySet()) &#123;</span><br><span class=\"line\">    //对取出来的每个entry进行下一步操作</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//2.iterator 迭代器遍历 entrySet()</span><br><span class=\"line\">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator2 = map.entrySet().iterator();</span><br><span class=\"line\">while (iterator2.hasNext()) &#123;</span><br><span class=\"line\">    Map.Entry&lt;String, Integer&gt; item = iterator2.next();</span><br><span class=\"line\">    //对取出来的每个entry进行下一步操作</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：</p>\n<ul>\n<li>如果同时需要 key 和 value 的值就用直接遍历 entrySet()，这是最常用的遍历方法。</li>\n<li>如果只需要 key 或者 value 的值，就遍历 keySet() 或者 values()，性能上比遍历 entrySet() 要快 10%～20%。</li>\n<li>通过遍历 keySet()，根据 key 值来获取对应的 value 值的方式性能最低，应尽量避免使用。</li>\n</ul>\n<p>Map 接口下最常用的实现类是 <strong>HashMap</strong> 和 <strong>TreeMap</strong>。</p>\n<h3 id=\"1、HashMap\"><a href=\"#1、HashMap\" class=\"headerlink\" title=\"1、HashMap\"></a>1、HashMap</h3><p><em><strong>HashMap 是基于散列表实现的无序的 Map 集合</strong></em>。实际上 HashMap 是通过 <strong>拉链法</strong> 也就是数组+链表实现的。数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">transient Node&lt;K,V&gt;[] table; //HashMap 的主干是一个 Node 类型的数组</span><br><span class=\"line\"></span><br><span class=\"line\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; //Node节点包含下一个 Node 节点的索引，实际上构成一个链表</span><br><span class=\"line\">    final int hash;</span><br><span class=\"line\">    final K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在访问 HashMap 的时候</p>\n<ul>\n<li>如果定位到的数组位置不含链表（当前 entry 的 next 指向 null ）,那么对于查找，添加等操作很快，仅需一次寻址即可</li>\n<li>如果定位到的数组包含链表，对于添加操作，其时间复杂度为 O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过 key 对象的 equals 方法逐一比对查找。</li>\n</ul>\n<p>所以，性能考虑，HashMap中的链表出现越少，性能才会越好。具体可以参考 <a href=\"https://www.cnblogs.com/chengxiao/p/6059914.html\">HashMap实现原理及源码分析</a></p>\n<h3 id=\"HashMap-与-Hashtable-的区别\"><a href=\"#HashMap-与-Hashtable-的区别\" class=\"headerlink\" title=\"HashMap 与 Hashtable 的区别\"></a>HashMap 与 Hashtable 的区别</h3><p>HashMap 和 Hashtable 的功能和实现机制非常类似，Hashtable 是更早期实现的，现在已经很少用了。两者的区别如下，具体可参考 <a href=\"https://www.cnblogs.com/xinzhao/p/5644175.html\">HashMap和HashTable到底哪不同？</a></p>\n<ul>\n<li>Hashtable 是线程安全的，HashMap 是线程不安全的，因此 HashMap 比 Hashtable 的性能更好一些。</li>\n<li>HashMap 允许 key 或者 value 的值为 null，而 HashTable 的 key 或者 value 不允许为 null，否则会抛出 NullPointerException 异常。</li>\n<li>根据官方注释，HashTable已经被淘汰了，不要在新的代码中再使用它。如果你不需要线程安全，那么使用 HashMap，如果需要线程安全，那么使用 ConcurrentHashMap。</li>\n</ul>\n<h3 id=\"2、TreeMap\"><a href=\"#2、TreeMap\" class=\"headerlink\" title=\"2、TreeMap\"></a>2、TreeMap</h3><p>TreeMap 是基于散列表实现的有序的 Map 集合。TreeMap 会对插入的 key-value 对的 key<br>值进行排序。实际上TreeMap 是基于 <strong>红黑树</strong> (Red-Black Tree) 结构实现的，其排序是通过调整树结构来实现的，红黑树的具体知识参考 <a href=\"http://www.cnblogs.com/skywang12345/p/3245399.html#!comments\">红黑树(一)之 原理和算法详细介绍</a>。</p>\n<p>因为在插入删除元素的时候设计树结构的调整，所以红黑树的插入删除元素性能比较差。</p>\n<h3 id=\"HashMap-和-TreeMap-比较\"><a href=\"#HashMap-和-TreeMap-比较\" class=\"headerlink\" title=\"HashMap 和 TreeMap 比较\"></a>HashMap 和 TreeMap 比较</h3><p>一般的应用场景，尽可能多考虑使用HashMap，因为其为快速查询设计的。如果需要特定的排序时，考虑使用TreeMap。</p>\n<h2 id=\"其他参考\"><a href=\"#其他参考\" class=\"headerlink\" title=\"其他参考\"></a>其他参考</h2><p><a href=\"https://www.jianshu.com/p/63e76826e852\">Java - 集合框架完全解析</a><br><a href=\"https://www.jianshu.com/p/589d58033841\">由浅入深理解java集合(一)——集合框架 Collection、Map</a><br><a href=\"https://www.jianshu.com/p/9081017a2d67\">由浅入深理解java集合(二)——集合 Set</a><br><a href=\"https://www.jianshu.com/p/d436b4cf6b94\">由浅入深理解java集合(三)——集合 List</a><br><a href=\"https://www.jianshu.com/p/35760d7bac0d\">由浅入深理解java集合(四)——集合 Queue</a><br><a href=\"https://www.jianshu.com/p/0580eb808eea\">由浅入深理解java集合(五)——集合 Map</a>  </p>\n","categories":["Java","Java集合"],"tags":["Java","集合"]},{"title":"Java泛型理解","url":"/2018/07/25/java%E6%B3%9B%E5%BD%A2%E7%90%86%E8%A7%A3/","content":"<blockquote>\n<p>泛型在 Java 中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。在这里简单介绍个人学习 Java 泛型设计过程中的心得总结，如有错误希望大佬们指出。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"1、什么是泛型\"><a href=\"#1、什么是泛型\" class=\"headerlink\" title=\"1、什么是泛型\"></a>1、什么是泛型</h3><p>泛型的本质是 <strong>类型参数</strong>（type parameter），即把类型当一个参数来定义和传递使用。</p>\n<p>我们平时最熟悉的参数是变量参数，即是在方法头声明里面定义变量形参，在使用的时候再传递实参。</p>\n<p>类似于变量参数，<em><strong>类型参数化即把类型由具体的类型参数化（类型形参），在使用的时候再传入具体的类型（类型实参）</strong></em>。这样我们通过传入不同的类型参数就可以创建功能相同，仅仅类型不同的各种类或者方法。这种参数类型可以用在类、接口和方法中，分别被称为 <strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>\n<h3 id=\"2、为什么要用泛型\"><a href=\"#2、为什么要用泛型\" class=\"headerlink\" title=\"2、为什么要用泛型\"></a>2、为什么要用泛型</h3><p>假如我们想要实现一个 String 数组，并且要求它可以动态改变大小，这时我们都会想到用 ArrayList 来聚合 String 对象。然而，过了一阵，我们想要实现一个大小可以改变的 Date 对象数组，这时我们当然希望能够重用之前写过的那个针对 String 对象的 ArrayList 实现。</p>\n<p>在Java 5之前，ArrayList的实现大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class ArrayList &#123;</span><br><span class=\"line\">    public Object get(int i) &#123; ... &#125;</span><br><span class=\"line\">    public void add(Object o) &#123; ... &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    private Object[] elementData;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从以上代码我们可以看到，用于向 ArrayList 中添加元素的 add 函数接收一个 Object 型的参数，从 ArrayList 获取指定元素的 get 方法也返回一个 Object 类型的对象，Object 对象数组 elementData 存放这 ArrayList 中的对象， 也就是说，无论你向 ArrayList 中放入什么类型的类型，到了它的内部，都是一个 Object 对象。</p>\n<p>基于继承的泛型实现会带来两个问题：第一个问题是有关 get 方法的，我们每次调用 get 方法都会返回一个 Object 对象，每一次都要强制类型转换为我们需要的类型，这样会显得很麻烦；第二个问题是有关 add 方法的，假如我们往聚合了 String 对象的 ArrayList 中加入一个 File 对象，编译器不会产生任何错误提示，而这不是我们想要的。</p>\n<p>所以，从 Java 5 开始，ArrayList 在使用时可以加上一个类型参数（type parameter），这个类型参数用来指明 ArrayList 中的元素类型。类型参数的引入解决了以上提到的两个问题，如以下代码所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;String&gt; s = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">s.add(&quot;abc&quot;);</span><br><span class=\"line\">String s = s.get(0); //无需进行强制转换</span><br><span class=\"line\">s.add(123);  //编译错误，只能向其中添加String对象</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>在以上代码中，编译器“获知” ArrayList 的类型参数 String 后，便会替我们完成强制类型转换以及类型检查的工作。</p>\n<h2 id=\"泛型的分类\"><a href=\"#泛型的分类\" class=\"headerlink\" title=\"泛型的分类\"></a>泛型的分类</h2><h3 id=\"1、泛型类\"><a href=\"#1、泛型类\" class=\"headerlink\" title=\"1、泛型类\"></a>1、泛型类</h3><h4 id=\"1）定义\"><a href=\"#1）定义\" class=\"headerlink\" title=\"1）定义\"></a>1）定义</h4><p>泛型类（generic class）是具有一个或多个类型变量的类。<em><strong>类型变量用尖括号 <code>&lt;&gt;</code> 括起来，并放在类名后面</strong></em>。泛型类可以有多个类型变量，多个类型变量之前用逗号 <code>,</code> 隔开。</p>\n<p>泛型类中可以用定义的泛型变量指定 <strong>方法的返回类型</strong> 或者 <strong>类变量和局部变量</strong> 的类型等。</p>\n<blockquote>\n<p>类型变量命名常用 E 表示集合的元素类型，K 和 V 表示关键字和值类型，T（或者 U、S ）表示任意类型。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class=\"line\">//在实例化泛型类时，必须指定T的具体类型</span><br><span class=\"line\">public class Pair&lt;T, U&gt; &#123;</span><br><span class=\"line\">    private T first;</span><br><span class=\"line\">    private U second;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Pair(T first, U second) &#123;</span><br><span class=\"line\">        this.first = first;</span><br><span class=\"line\">        this.second = second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public T getFirst() &#123;</span><br><span class=\"line\">        return first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public U getSecond() &#123;</span><br><span class=\"line\">        return second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setFirst(T newValue) &#123;</span><br><span class=\"line\">        first = newValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setSecond(U newValue) &#123;</span><br><span class=\"line\">        second = newValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码中我们可以看到，泛型类 Pair 的类型参数为 T、U，放在类名后的尖括号中。类中可以使用 T 和 U 表示类变量类型或者方法返回类型等如 <code>private T first</code>。</p>\n<h4 id=\"2）使用\"><a href=\"#2）使用\" class=\"headerlink\" title=\"2）使用\"></a>2）使用</h4><p>在实例化泛型类时，我们需要把具体类型当作实参传递进来。<em><strong>注意泛型的参数类型只能是类类型，不能是简单类型</strong></em>。如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Pair&lt;String, Integer&gt; pair = new Pair&lt;String, Integer&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>在 Java 7 版本以后，编译器可以根据变量声明里面的具体类型自动推断出构造函数的具体类型，也就是说构造函数可以省略具体类型，我们可以这样写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Pair&lt;String, Integer&gt; pair = new Pair&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<h4 id=\"3）继承\"><a href=\"#3）继承\" class=\"headerlink\" title=\"3）继承\"></a>3）继承</h4><p>泛型类也可以被继承，但是使用效果不是很好。一般用 <strong>泛型通配符</strong> 代替使用，后面详细介绍。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class PairChild&lt;T, U, S&gt; extends Pair&lt;T, U&gt; &#123; //可以继承父类的泛型类型并添加新的泛型类型，但是不经常用</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、泛型接口\"><a href=\"#2、泛型接口\" class=\"headerlink\" title=\"2、泛型接口\"></a>2、泛型接口</h3><h4 id=\"1）定义-1\"><a href=\"#1）定义-1\" class=\"headerlink\" title=\"1）定义\"></a>1）定义</h4><p><strong>泛型接口</strong> (generic interface)和泛型类的使用基本类似，<em><strong>在接口名后加 <code>&lt;&gt;</code> 括起来的类型变量</strong></em>，例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public interface Generator&lt;T&gt; &#123;</span><br><span class=\"line\">    public T next();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2）实现\"><a href=\"#2）实现\" class=\"headerlink\" title=\"2）实现\"></a>2）实现</h4><p>未传入泛型实参</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span><br><span class=\"line\"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class=\"line\"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public T next() &#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>传入泛型实参</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 传入泛型实参时：</span><br><span class=\"line\"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span><br><span class=\"line\"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span><br><span class=\"line\"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span><br><span class=\"line\"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class FruitGenerator implements Generator&lt;String&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public String next() &#123;</span><br><span class=\"line\">        Random rand = new Random();</span><br><span class=\"line\">        return fruits[rand.nextInt(3)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、泛型方法\"><a href=\"#3、泛型方法\" class=\"headerlink\" title=\"3、泛型方法\"></a>3、泛型方法</h3><h4 id=\"1）定义-2\"><a href=\"#1）定义-2\" class=\"headerlink\" title=\"1）定义\"></a>1）定义</h4><p><strong>泛型方法</strong> 是指 <em><strong><code>&lt;&gt;</code> 括起来的类型变量放在修饰符（如 public static）后面，返回类型前面的方法</strong></em>。泛型方法可以定义在普通类中，也可以定义在泛型类中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class ArrayAlg &#123;</span><br><span class=\"line\">    public static &lt;T&gt; T getMiddle(T... a) &#123; //传入个数未知的 T 类型变量，T 类型必须为前面 &lt;&gt; 内定义的类型</span><br><span class=\"line\">        return a[a.length / 2];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面 <code>getMiddle </code> 就是一个在普通类 ArrayAlg 里面声明的泛型方法。在方法内可以使用定义的类型变量 T 来作为返回类型或者变量类型。</p>\n<p>注意，方法头在返回值前面没有<code>&lt;&gt;</code> 括起来的类型变量都不是泛型方法。例如下面这个方法不是泛型方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void getMiddle(Pair&lt;String, Integer&gt; param) &#123; //该方法只是使用了泛型类型的参数的普通方法，不是泛型方法</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2）使用-1\"><a href=\"#2）使用-1\" class=\"headerlink\" title=\"2）使用\"></a>2）使用</h4><p>我们可以在方法名前传入具体类型来调用，如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ArrayAlg.&lt;String&gt;getMiddle(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;); // 编译器提示 Explicit type arguments can be inferred</span><br></pre></td></tr></table></figure>\n\n<p>上面警告实际上是由于 Java 7 以后编译器可以通过传入的变量实参推断出所需要的具体类型，所以我们可以简化成这样的写法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ArrayAlg.getMiddle(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>但是这种写法有一种弊端就是如果传入了不符合要求的类型，编译器也不会报错，在运行阶段才会抛出异常。解决办法是采用第一种调用方法，即在方法名前加具体类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ArrayAlg.getMiddle(&quot;aa&quot;, &quot;bb&quot;, 111); //编译器通过，但是如果我们希望传入的都是 String 类型的参数，最后一个整形参数可能会产生异常</span><br><span class=\"line\"></span><br><span class=\"line\">ArrayAlg.&lt;String&gt;getMiddle(&quot;aa&quot;, &quot;bb&quot;, 111); //编译器提示错误，可以在编译阶段就发现错误</span><br></pre></td></tr></table></figure>\n\n<p>可以看下这个具体一点的例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class GenericFruit &#123;</span><br><span class=\"line\">    class Fruit&#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;fruit&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Apple extends Fruit&#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;apple&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class Person&#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String toString() &#123;</span><br><span class=\"line\">            return &quot;Person&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    class GenerateTest&lt;T&gt;&#123;</span><br><span class=\"line\">        public void show_1(T t)&#123;</span><br><span class=\"line\">            System.out.println(t.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span><br><span class=\"line\">        //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span><br><span class=\"line\">        public &lt;E&gt; void show_3(E t)&#123;</span><br><span class=\"line\">            System.out.println(t.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span><br><span class=\"line\">        public &lt;T&gt; void show_2(T t)&#123;</span><br><span class=\"line\">            System.out.println(t.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Apple apple = new Apple();</span><br><span class=\"line\">        Person person = new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">        GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;();</span><br><span class=\"line\">        //apple是Fruit的子类，所以这里可以</span><br><span class=\"line\">        generateTest.show_1(apple);</span><br><span class=\"line\">        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span><br><span class=\"line\">        //generateTest.show_1(person);</span><br><span class=\"line\"></span><br><span class=\"line\">        //使用这两个方法都可以成功</span><br><span class=\"line\">        generateTest.show_2(apple);</span><br><span class=\"line\">        generateTest.show_2(person);</span><br><span class=\"line\"></span><br><span class=\"line\">        //使用这两个方法也都可以成功</span><br><span class=\"line\">        generateTest.show_3(apple);</span><br><span class=\"line\">        generateTest.show_3(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、泛型限定-extends\"><a href=\"#4、泛型限定-extends\" class=\"headerlink\" title=\"4、泛型限定 extends\"></a>4、泛型限定 extends</h3><p>在有些情况下，泛型类或者泛型方法想要对自己的类型参数进一步加一些限制。比如，我们想要限定类型参数只能为某个类的子类或者只能为实现了某个接口的类。我们可以用到 <strong>边界限定符 extends</strong>。我们可以这样写</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;T extends BoundingType&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其中 BoundingType 是一个类或者接口，可以为一个或多个，多个之间用 <code>&amp;</code> 连接。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;T extends BoundingType1 &amp; BoundingType2 &amp; BoundingType3&gt;</span><br></pre></td></tr></table></figure>\n\n<p>类添加限定符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Generic&lt;T extends Number&gt;&#123;</span><br><span class=\"line\">    private T key;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Generic(T key) &#123;</span><br><span class=\"line\">        this.key = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接口添加限定符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public interface Comparable&lt;T&gt; &#123;</span><br><span class=\"line\">    public int compareTo(T o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法添加限定符</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span><br><span class=\"line\">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;</span><br><span class=\"line\">public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123;</span><br><span class=\"line\">    System.out.println(&quot;container key :&quot; + container.getKey());</span><br><span class=\"line\">    T test = container.getKey();</span><br><span class=\"line\">    return test;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、泛型通配符\"><a href=\"#5、泛型通配符\" class=\"headerlink\" title=\"5、泛型通配符\"></a>5、泛型通配符</h3><h4 id=\"1）什么是通配符\"><a href=\"#1）什么是通配符\" class=\"headerlink\" title=\"1）什么是通配符\"></a>1）什么是通配符</h4><p>假设有两个类 Manager 和 Employee，其中 Manager 是 Employee 的一个子类。那么 List&lt; Manager &gt; 是 List&lt; Employee &gt; 的一个子类吗？事实上 <strong>List&lt; Manager &gt; 和 List&lt; Employee &gt; 之间没有任何关系</strong>。这样会导致可以使用 List&lt; Employee &gt; 的地方不一定能使用 List&lt; Manager &gt;，尽管逻辑上应该是两者都可以使用的。例如下面：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Employee &#123;...&#125; //员工类</span><br><span class=\"line\"></span><br><span class=\"line\">class Manager extends Employee&#123;...&#125; //管理层类，继承员工类</span><br><span class=\"line\"></span><br><span class=\"line\">class Company &#123;</span><br><span class=\"line\">    public void traverse(List&lt;Employee&gt; list) &#123; //遍历员工，理论上应该也可以用该方法来遍历管理层</span><br><span class=\"line\">        for(Employee item : list) &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void test () &#123;</span><br><span class=\"line\">        List&lt;Employee&gt; employeeList = new ArrayList&lt;&gt;(); //员工集合</span><br><span class=\"line\">        //添加员工</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Manager&gt; managerList = new ArrayList&lt;&gt;(); //管理层集合</span><br><span class=\"line\">        //添加管理层</span><br><span class=\"line\"></span><br><span class=\"line\">        traverse(employeeList); //编译通过</span><br><span class=\"line\">        traverse(managerList); //编译不通过</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个例子中，可以用来遍历 List&lt; Employee &gt; 的方法却不能用来遍历 List&lt; Manager &gt;。难道我们要为 List&lt; Manager &gt; 再写一个功能相同，只是类型不同的遍历方法吗？Java 的开发人员想出通过 <strong>通配符</strong> 来解决这个问题。</p>\n<p><strong>通配符是指用 ? 来代替具体的类型</strong>。这里的 ？相当于一个类型实参，也就是说不需要事先在方法头的返回值前面通过 <code>&lt;&gt;</code> 来说明，可以直接使用。**&lt;? extends Class&gt;** 表示 Class 类本身和其所有子类型，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;? extends Employee&gt;</span><br></pre></td></tr></table></figure>\n\n<p>表示类型参数是 Employee 本身及其子类的所有 List 类型，包括 List&lt; Manager &gt;。<em>通过通配符 List&lt; Employee &gt; 和 List&lt; Manager &gt; 形成了类似于父子关系</em>，这样可以使用 List&lt; Employee &gt; 的地方也可以使用 List&lt; Manager &gt; 了。在上面的例子中我们只需要把遍历方法改一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void traverse(List&lt;? extends Employee&gt; list) &#123; //可同时遍历员工和管理层</span><br><span class=\"line\">    for(Employee item : list) &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时候我们调用 <code>traverse(employeeList)</code> 和 <code>traverse(managerList)</code> 都会编译通过。</p>\n<p>&lt; T extends Class &gt; 和 &lt; ? extends Class &gt; 这两个有什么区别呢？最主要的区别是 <em><strong>T 是类型形参，? 是类型实参</strong></em>。使用 T 的话需要在方法头的返回值前面通过 <code>&lt;T&gt;</code> 声明才能在后面使用，使用 ? 的话可以跟 Integer 等实参一样不需要声明随时使用，下面两个方法可以实现相同的效果。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void traverse1(List&lt;? extends Employee&gt; list) &#123; //使用通配符 ?</span><br><span class=\"line\">    for(Employee item : list) &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public &lt;T extends Employee&gt; void traverse2(List&lt;T&gt; list) &#123;  使用泛型 T</span><br><span class=\"line\">    for(Employee item : list) &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2）超类型限定-super\"><a href=\"#2）超类型限定-super\" class=\"headerlink\" title=\"2）超类型限定 super\"></a>2）超类型限定 super</h4><p>通配符比类型变量还多了一个功能：通过关键字 <strong>super</strong> 可以指定超类型限定(supertype bound)。这个功能跟 extends 恰好相反。**&lt;? super Class&gt;** 表示 Class 类本身和其所有超类型。<em><strong>注意没有 &lt; T super Class &gt; 这样的写法</strong></em>。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;? super Manager&gt;</span><br></pre></td></tr></table></figure>\n\n<p>表示所有 Manager 本身及其所有父类类型。</p>\n<h4 id=\"3）PECS-原则\"><a href=\"#3）PECS-原则\" class=\"headerlink\" title=\"3）PECS 原则\"></a>3）PECS 原则</h4><h5 id=\"通配符上界-extends\"><a href=\"#通配符上界-extends\" class=\"headerlink\" title=\"通配符上界 extends\"></a>通配符上界 extends</h5><p>假如有一个 list 的类型为 <em><strong>List&lt;? extends Class&gt;，Class 相当于类型上界</strong></em>。</p>\n<ul>\n<li>当我们从 list 获取元素时，因为 Class 是父类型，我们可以用父类型来转换所有的子类型对象，这是符合 Java 继承规则的。</li>\n<li>当我们往 list 添加元素时，因为 list 里面每个对象的类型是未知的，有的可能是顶级父类类型 Class，有的可能是其他的子孙类型 ClassChild。ClassChild 一般会在 Class 的基础上扩展增加了很多其他方法。假设我们可以添加成功，那么当我们再取出 list 元素的时候，我们只能知道该元素的顶级父类类型是 Class，但是我们没办法知道该元素在添加前是什么类型以及有哪些方法可以调用。<em><strong>所以禁止向 &lt;? extends Class&gt; 类型添加对象</strong></em> ，除了 null。</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void modify1 (List&lt;? extends Employee&gt; list) &#123;</span><br><span class=\"line\">    list.add(new Employee()); //编译失败</span><br><span class=\"line\">    Employee employee = list.get(0); //编译通过</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"通配符下界-super\"><a href=\"#通配符下界-super\" class=\"headerlink\" title=\"通配符下界 super\"></a>通配符下界 super</h5><p>假如有一个 list 的类型为 <em><strong>List&lt;? super Class&gt;，Class 相当于类型下界</strong></em>。</p>\n<ul>\n<li>当我们从 list 获取元素时，因为 Class 是最底层的子孙类型，list 里面的元素可能会存在父类类型的元素。在 Java 继承规则里面，子类类型变量不能表示父类类型对象，因此我们不能用 Class 类型来表示任意 list 元素。<em><strong>所以禁止从 &lt;? super Class&gt;类型获取对象</strong></em>，除了 null。</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void modify2 (List&lt;? super Manager&gt; list) &#123;</span><br><span class=\"line\">    list.add(new Manager()); //编译通过</span><br><span class=\"line\">    Manager manager = list.get(0); //编译失败</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当我们向 list 添加元素时，因为 Class 是最底层的子类类型，其包括了本身和父类的所有变量和方法。假设可以添加成功，我们可以获取任意元素转换成子类 Class 类型，然后任意调用其本身和父类的变量和方法，这是符合 Java 继承规则的。所以允许向 list 添加元素。</li>\n</ul>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>根据上面的例子，extends 定义了类型的上界，super 定义了类型的下界，我们可以总结出一条规律，”Producer Extends, Consumer Super”，也就是常说的 <strong>PECS 原则</strong>：</p>\n<ul>\n<li>“Producer Extends”：如果你需要一个只读 List，用它来 produce T，那么使用 &lt; ? extends T &gt;。</li>\n<li>“Consumer Super”：如果你需要一个只写 List，用它来 consume T，那么使用 &lt; ? super T &gt;。</li>\n<li>如果需要同时读取以及写入，那么我们就不能使用通配符了。</li>\n</ul>\n<p>阅读过一些Java集合类的源码，可以发现通常我们会将两者结合起来一起用，比如像下面这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Collections &#123;</span><br><span class=\"line\">    public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;</span><br><span class=\"line\">        for (int i=0; i&lt;src.size(); i++)</span><br><span class=\"line\">            dest.set(i, src.get(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4）无限定通配符\"><a href=\"#4）无限定通配符\" class=\"headerlink\" title=\"4）无限定通配符\"></a>4）无限定通配符</h4><p>无限定通配符就是没有上下界限定，只有单独的 **<?>**。如 List<?>，? 可以表示任何类型。无界通配符通常会用在下面两种情况：</p>\n<ol>\n<li>当方法是使用原始的Object类型作为参数时，如下：</li>\n</ol>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void printList(List&lt;Object&gt; list) &#123;</span><br><span class=\"line\">   for (Object elem : list)</span><br><span class=\"line\">       System.out.println(elem + &quot;&quot;);</span><br><span class=\"line\">   System.out.println();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//上面方法可以选择改为如下所示，这样就可以兼容更多的输出，而不单纯是 List&lt;Object&gt;</span><br><span class=\"line\">public static void printList(List&lt;?&gt; list) &#123;</span><br><span class=\"line\">   for (Object elem: list)</span><br><span class=\"line\">       System.out.print(elem + &quot;&quot;);</span><br><span class=\"line\">   System.out.println();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>在定义的方法体的业务逻辑与泛型类型无关，如 List.size()，List.clear() 等这些方法。实际上，最常用的就是 Class&lt;?&gt;。</li>\n</ol>\n<p>最后提醒一下的就是，List<Object> 与 List<?> 并不等同，List<Object> 是 List<?> 的子类。不能往 List&lt;?&gt; 里面获取和添加任何元素，除了 null。</Object></Object></p>\n<h2 id=\"深入理解泛型\"><a href=\"#深入理解泛型\" class=\"headerlink\" title=\"深入理解泛型\"></a>深入理解泛型</h2><h3 id=\"1、类型擦除\"><a href=\"#1、类型擦除\" class=\"headerlink\" title=\"1、类型擦除\"></a>1、类型擦除</h3><p><strong>类型擦除</strong> 就是说 Java 泛型只能用于在编译期间的静态类型检查，然后编译器生成的代码会擦除相应的类型信息，把所有类型参数替换为 BoundingType（若未加限定就替换为 Object ）。</p>\n<p>这样到了运行期间实际上 JVM 根本不知道泛型所代表的具体类型。这样做的目的是因为 Java 泛型是 1.5 之后才被引入的，为了保持向下的兼容性，所以只能做类型擦除来兼容以前的非泛型代码。</p>\n<p>例如下面这段代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Node&lt;T&gt; &#123;</span><br><span class=\"line\">    private T data;</span><br><span class=\"line\">    private Node&lt;T&gt; next;</span><br><span class=\"line\">    public Node(T data, Node&lt;T&gt; next) &#123;</span><br><span class=\"line\">        this.data = data;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public T getData() &#123; return data; &#125;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译器做完相应的类型检查之后会把类型进行擦除，因为没有限定类型，所以替换为 Object 类型。实际上到了运行期间上面这段代码会变成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Node &#123;</span><br><span class=\"line\">    private Object data;</span><br><span class=\"line\">    private Node next;</span><br><span class=\"line\">    public Node(Object data, Node next) &#123;</span><br><span class=\"line\">        this.data = data;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public T getData() &#123; return data; &#125;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们设置了限定类型，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Node&lt;T extends Comparable&lt;T&gt;&gt; &#123;</span><br><span class=\"line\">    private T data;</span><br><span class=\"line\">    private Node&lt;T&gt; next;</span><br><span class=\"line\">    public Node(T data, Node&lt;T&gt; next) &#123;</span><br><span class=\"line\">        this.data = data;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public T getData() &#123; return data; &#125;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样编译器就会将 T 出现的地方替换成 Comparable 而不再是默认的 Object 了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Node &#123;</span><br><span class=\"line\">    private Comparable data;</span><br><span class=\"line\">    private Node next;</span><br><span class=\"line\">    public Node(Comparable data, Node next) &#123;</span><br><span class=\"line\">        this.data = data;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public Comparable getData() &#123; return data; &#125;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不管原来声明的是 List&lt; String &gt; 还是 List&lt; Integer &gt;，类型擦除之后都会变成 List&lt; Object &gt;，所以两者在编译完成后的 Class 类型是相同的，看下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">Class classStringArrayList = stringArrayList.getClass();</span><br><span class=\"line\">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(classStringArrayList.equals(classIntegerArrayList)) //输出 true，证明类型擦除后两者的 class 类型相同。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、桥方法\"><a href=\"#2、桥方法\" class=\"headerlink\" title=\"2、桥方法\"></a>2、桥方法</h3><p><strong>桥方法</strong>（Bridge Method）是用来解决继承泛型类型中的多态问题的。我们先来看下面这个例子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Pair&lt;T&gt; &#123;</span><br><span class=\"line\">\tprivate T first;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setFirst(T first)&#123;  </span><br><span class=\"line\">\t\tthis.first = first;  </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Object getFirst()&#123;  </span><br><span class=\"line\">\t\treturn this.first;  </span><br><span class=\"line\">\t&#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class SonPair extends Pair&lt;String&gt;&#123;</span><br><span class=\"line\">\tpublic void setFirst(String first)&#123;...&#125;</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>在这里程序猿传入类型 String 来继承 Pair 类并想覆盖父类中的 <code>setFirst()</code> 方法，但事实上子类没有办法覆盖这个方法。因为父类 Pair 在编译阶段已经被类型擦除，变成了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class Pair &#123;</span><br><span class=\"line\">\tprivate Object first;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setFirst(Object first)&#123;  </span><br><span class=\"line\">\t\tthis.first = first;  </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>子类中的 <code>setFirst(String first)</code> 方法不能覆盖父类的 <code>setFirst(Object first)</code> 方法。为了解决这个问题，就需要用到桥方法。桥方法简单来说就是 <em><strong>生成一个跟父类方法头相同的方法，该方法把参数转换类型后再调用子类的方法</strong></em>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//实际上子类生成了两个方法</span><br><span class=\"line\">class SonPair extends Pair&lt;String&gt;&#123;</span><br><span class=\"line\">\tpublic void setFirst(Object first)&#123;</span><br><span class=\"line\">\t\tsetFirst((String) first)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic void setFirst(String first)&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样可以解决泛型继承的多态问题。对于 <code>getFirst()</code> 方法，子类也生成了两个方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class SonPair extends Pair&lt;String&gt;&#123;</span><br><span class=\"line\">\tpublic Object getFirst()&#123;  </span><br><span class=\"line\">\t\treturn this.first;  </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String getFirst()&#123;  </span><br><span class=\"line\">\t\treturn this.first;  </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根据 Java 的多态继承规则，在同一个类里面不能定义两个方法名和参数完全相同的方法，所以我们在写代码的时候写两个这样的方法，编译器肯定是不能通过的。但是注意：JVM 会用参数类型和返回类型来确定一个方法。 一旦编译器通过某种方式自己编译出方法签名一样的两个方法(只能编译器自己来创造这种奇迹，我们程序员却不能人为的编写这种代码)。JVM 还是能够分清楚这些方法的，前提是需要返回类型不一样。</p>\n<h3 id=\"3、注意事项\"><a href=\"#3、注意事项\" class=\"headerlink\" title=\"3、注意事项\"></a>3、注意事项</h3><h4 id=\"1）不允许创建泛型数组\"><a href=\"#1）不允许创建泛型数组\" class=\"headerlink\" title=\"1）不允许创建泛型数组\"></a>1）不允许创建泛型数组</h4><p>Java 不支持创建泛型数组。假设如果允许创建泛型数组，会出现下面这种情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object[] stringLists = new List&lt;String&gt;[];  // compiler error, but pretend it&#x27;s allowed</span><br><span class=\"line\"></span><br><span class=\"line\">stringLists[0] = new ArrayList&lt;String&gt;();  // OK</span><br><span class=\"line\"></span><br><span class=\"line\">stringLists[1] = new ArrayList&lt;Integer&gt;(); // An ArrayStoreException should be thrown, but the runtime can&#x27;t detect it.</span><br><span class=\"line\"></span><br><span class=\"line\">String s = stringLists[1].get(0); // Run-time error: ClassCastException.</span><br></pre></td></tr></table></figure>\n\n<p>假设我们支持泛型数组的创建，由于运行时期类型信息已经被擦除，JVM实际上根本就不知道 new ArrayList&lt; String &gt;() 和 new ArrayList&lt; Integer &gt;() 的区别，他们可以被添加到同一个数组里面 List<String>[] 里面。只有当运行时取出元素的时候进行类型转换时才会报 <code>ClassCastException</code> 的异常。为了避免这种情况我们不允许创建泛型数组，让编译器去帮助我们检查就可以避免这种情况。</String></p>\n<h4 id=\"2）不能利用类型参数创建实例\"><a href=\"#2）不能利用类型参数创建实例\" class=\"headerlink\" title=\"2）不能利用类型参数创建实例\"></a>2）不能利用类型参数创建实例</h4><p>Java 不允许类型类型参数创建实例，例如下面这种情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static &lt;E&gt; void append(List&lt;E&gt; list) &#123;</span><br><span class=\"line\">    E elem = new E();  // compile-time error</span><br><span class=\"line\">    list.add(elem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要还是由于类型擦除的问题，在运行阶段实际上我们会创建一个 Object 对象，违背了我们只想创建特定类型的对象的初衷。但是如果某些场景我们想要需要利用类型参数创建实例，我们应该怎么做呢？可以利用反射解决这个问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123;</span><br><span class=\"line\">    E elem = cls.newInstance();   // OK</span><br><span class=\"line\">    list.add(elem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3）不能用基本类型实例化类型参数\"><a href=\"#3）不能用基本类型实例化类型参数\" class=\"headerlink\" title=\"3）不能用基本类型实例化类型参数\"></a>3）不能用基本类型实例化类型参数</h4><p>对于数据类型，类型参数只支持 Integer 等包装类型，不支持 int 等基本类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); //OK</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;int&gt; list2 = new ArrayList&lt;&gt;(); //compile error, Type argument cannot be of primitive type</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4）不能抛出也不能捕获泛型类实例\"><a href=\"#4）不能抛出也不能捕获泛型类实例\" class=\"headerlink\" title=\"4）不能抛出也不能捕获泛型类实例\"></a>4）不能抛出也不能捕获泛型类实例</h4><p>泛型类扩展 Throwable 即为不合法，因此无法抛出或捕获泛型类实例。但在异常声明中使用类型参数是合法的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static &lt;T extends Throwable&gt; void doWork(T t) throws T &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125; catch (T e) &#123; //compile error, cannot catch type parameters</span><br><span class=\"line\">        Logger.global.info(e.getMessage());</span><br><span class=\"line\">    &#125; catch (Throwable realCause) &#123; //OK</span><br><span class=\"line\">        t.initCause(realCause);</span><br><span class=\"line\">        throw t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5）泛型类的静态上下文中不能使用类型变量\"><a href=\"#5）泛型类的静态上下文中不能使用类型变量\" class=\"headerlink\" title=\"5）泛型类的静态上下文中不能使用类型变量\"></a>5）泛型类的静态上下文中不能使用类型变量</h4><p>泛型类里面的静态变量和方法不能直接使用类上定义的类型变量，如果静态方法要使用泛型，必须将静态方法也定义成泛型方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class StaticGenerator&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static T name; //compilr error</span><br><span class=\"line\"></span><br><span class=\"line\">    public static T getName()&#123; return null;&#125;; //compilr error</span><br><span class=\"line\"></span><br><span class=\"line\">    public static &lt;T&gt; T getNamebyGeneric() &#123;return null;&#125; //OK</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6）不能对泛型使用-instanceof\"><a href=\"#6）不能对泛型使用-instanceof\" class=\"headerlink\" title=\"6）不能对泛型使用 instanceof\"></a>6）不能对泛型使用 instanceof</h4><p>不能对泛型代码直接使用 instanceof 关键字，因为编译器在生成代码的时候会擦除所有相关泛型的类型信息，正如我们上面验证过的 JVM 在运行时期无法识别出 ArrayList&lt; Integer &gt; 和 ArrayList&lt; String &gt;的之间的区别：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123;</span><br><span class=\"line\">    if (list instanceof ArrayList&lt;Integer&gt;) &#123;  // compile error</span><br><span class=\"line\">        // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>泛型的本质是类型参数，即把类型当作一个参数来使用。在实例化泛型时再把具体类型当作实参传递进来。泛型的用途有泛型类、泛型接口和泛型方法等。</li>\n<li>泛型的用途是在编译阶段限制对象类型，这样可以避免在运行阶段出现类型转换异常。</li>\n<li>泛型类是具有一个或多个类型变量的类。类型变量用尖括号 <code>&lt;&gt;</code> 括起来，并放在类名后面。泛型类可以有多个类型变量，多个类型变量之前用逗号 <code>,</code> 隔开。</li>\n<li>泛型接口和泛型类的使用基本类似，在接口名后加 <code>&lt;&gt;</code> 括起来的类型变量。</li>\n<li>泛型方法是指 <code>&lt;&gt;</code> 括起来的类型变量放在修饰符（如 public static）后面，返回类型前面的方法。泛型方法可以定义在普通类中，也可以定义在泛型类中。</li>\n<li>子类型限定符 <code>extends</code> 用于限制类型上界。</li>\n<li>通配符 <code>?</code> 用于实现两个泛型集合之间的父子关系。通配符有 PECS 原则。</li>\n<li>超类型限定符 super 是通配符特有的，用于限制类型下界。</li>\n<li>类型擦除是指编译器生成的代码会擦除相应的类型信息，把所有类型参数替换为 BoundingType（若未加限定就替换为 Object ）。</li>\n<li>桥方法是用来解决继承泛型类型中的多态问题的。</li>\n<li>不允许创建泛型数组。</li>\n<li>不能利用类型参数创建实例。</li>\n<li>不能用基本类型实例化类型参数。</li>\n<li>不能抛出也不能捕获泛型类实例。</li>\n<li>泛型类的静态上下文中不能使用类型变量。</li>\n<li>不能对泛型使用 instanceof。</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/s10461/article/details/53941091\">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a><br><a href=\"http://www.importnew.com/24029.html\">Java泛型详解</a><br><a href=\"https://www.cnblogs.com/ggjucheng/p/3352519.html\">JVM如何理解Java泛型类(转)</a><br><a href=\"http://www.cnblogs.com/absfree/p/5270883.html\">Java核心技术点之泛型</a><br><a href=\"https://www.linuxidc.com/Linux/2013-10/90928.htm\">Java 通配符解惑</a></p>\n","categories":["Java","Java基础"],"tags":["Java"]},{"title":"js时间操作","url":"/2018/07/23/js%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/","content":"<blockquote>\n<p>总结了 js 中常用的时间操作和格式化的方法，在这里记录一下以供日后查阅。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"js-时间初始化和常用方法\"><a href=\"#js-时间初始化和常用方法\" class=\"headerlink\" title=\"js 时间初始化和常用方法\"></a>js 时间初始化和常用方法</h2><h3 id=\"初始化时间\"><a href=\"#初始化时间\" class=\"headerlink\" title=\"初始化时间\"></a>初始化时间</h3><h4 id=\"1、获取系统当前时间\"><a href=\"#1、获取系统当前时间\" class=\"headerlink\" title=\"1、获取系统当前时间\"></a>1、获取系统当前时间</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var date = new Date() //获取当前系统时间</span><br></pre></td></tr></table></figure>\n\n<p>返回一个表示系统当前时间的 Date 对象。</p>\n<h4 id=\"2、根据整数参数初始化\"><a href=\"#2、根据整数参数初始化\" class=\"headerlink\" title=\"2、根据整数参数初始化\"></a>2、根据整数参数初始化</h4><p>格式： <code>new Date(year, month, date, hour, minute, second) </code><br>说明： 按给定的参数创建 Date 对象，参数范围如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>year</td>\n<td>四位整数表示年份，如果提供两位整数默认补全 19 开头</td>\n</tr>\n<tr>\n<td>month</td>\n<td>0-11 表示 1到12月份</td>\n</tr>\n<tr>\n<td>date</td>\n<td>1-31 表示 1到31日</td>\n</tr>\n<tr>\n<td>hour</td>\n<td>0-23 表示 1到24小时</td>\n</tr>\n<tr>\n<td>minute</td>\n<td>0-59 表示 1到60分钟</td>\n</tr>\n<tr>\n<td>second</td>\n<td>0-59 表示 1到60秒</td>\n</tr>\n</tbody></table>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var date = new Date(2018, 01, 01) //Thu Feb 01 2018 00:00:00 GMT+0800 (中国标准时间)</span><br><span class=\"line\"></span><br><span class=\"line\">var date = new Date(2018, 01, 01, 01) //Thu Feb 01 2018 01:00:00 GMT+0800 (中国标准时间)</span><br><span class=\"line\"></span><br><span class=\"line\">var date = new Date(2018, 01, 01, 01, 01, 01, 01) //Thu Feb 01 2018 01:01:01 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、根据字符串参数初始化\"><a href=\"#3、根据字符串参数初始化\" class=\"headerlink\" title=\"3、根据字符串参数初始化\"></a>3、根据字符串参数初始化</h4><p>格式： <code>new Date(&#39;year-month-day hour:minute:second&#39;)</code><br>说明： 通过字符串内容来创建 Date 对象，日期部分可以写成 <code>&#39;year-month-day&#39;</code>，<code>&#39;year month day&#39;</code>，<code>&#39;year/month/day&#39;</code> 和 <code>&#39;year.month.day&#39;</code>等格式，时间部分写成 <code>&#39;hour:minute:second&#39;</code>，两部分以空格隔开，最常用的写法是 <code>&#39;year-month-day hour:minute:second&#39;</code><br>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var date = new Date(&#x27;2018-02-02&#x27;) //Fri Feb 02 2018 08:00:00 GMT+0800 (中国标准时间)</span><br><span class=\"line\"></span><br><span class=\"line\">var date = new Date(&#x27;2018/02/02&#x27;) //Fri Feb 02 2018 08:00:00 GMT+0800 (中国标准时间)</span><br><span class=\"line\"></span><br><span class=\"line\">var date = new Date(&#x27;2018-02-02 02:02:02&#x27;) //Fri Feb 02 2018 02:02:02 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4、根据时间戳参数初始化\"><a href=\"#4、根据时间戳参数初始化\" class=\"headerlink\" title=\"4、根据时间戳参数初始化\"></a>4、根据时间戳参数初始化</h4><blockquote>\n<p>时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。时间戳唯一地标识某一刻的时间。</p>\n</blockquote>\n<p>格式： <code>new Date(timestamp)</code><br>说明： 通过时间戳来创建 Date 对象，时间戳可以为负数，表示 1970 年以前的时间<br>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var date = new Date(1520017383000) //Sat Mar 03 2018 03:03:03 GMT+0800 (中国标准时间)</span><br><span class=\"line\"></span><br><span class=\"line\">var date = new Date(-1520017383000) //Tue Nov 01 1921 12:56:57 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h3><h4 id=\"1、set-方法\"><a href=\"#1、set-方法\" class=\"headerlink\" title=\"1、set 方法\"></a>1、set 方法</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">date.setTime()  -------以毫秒设置时间</span><br><span class=\"line\">date.setDate()  -------设置月中某一天(1-31)</span><br><span class=\"line\">date.setMonth() -------设置年中某一月(0-11)</span><br><span class=\"line\">date.setFullYear() ----设置年份(4位数,2位数不支持了)</span><br><span class=\"line\">date.setHours() -------设置某一天中小时(0-23)</span><br><span class=\"line\">date.setMinutes()   ---设置某一小时中分钟(0-59)</span><br><span class=\"line\">date.setSeconds()   ---设置某一小时中秒数(0-59)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、get-方法\"><a href=\"#2、get-方法\" class=\"headerlink\" title=\"2、get 方法\"></a>2、get 方法</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">date.getDate()  -------获取月中某一天(1-31)</span><br><span class=\"line\">date.getMonth() -------获取年中某一月(0-11)</span><br><span class=\"line\">date.getDay()   -------获取星期中某一天的编号(0-6),星期天为0</span><br><span class=\"line\">date.getFullYear()  ---获取四位数年份(2位数被代替了)</span><br><span class=\"line\">date.getHours() -------获取天中的小时(0-23)</span><br><span class=\"line\">date.getMinutes()   ---获取小时中分钟(0-59)</span><br><span class=\"line\">date.getSeconds()   ---获取分钟中秒(0-59)</span><br><span class=\"line\">date.getMillSeconds() -获取毫秒值(0-999)</span><br><span class=\"line\">date.getTime()  -------获取时间戳</span><br><span class=\"line\">Date.parse(&#x27;str&#x27;)   ---解析 str 字符串返回时间戳</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、toString-类方法\"><a href=\"#3、toString-类方法\" class=\"headerlink\" title=\"3、toString 类方法\"></a>3、toString 类方法</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">date.toString()  ----------返回日期时间，如 Mon Jul 24 2017 14:47:31 GMT+0800 (中国标准时间)</span><br><span class=\"line\">date.toTimeString() -------返回时间，如 14:49:06 GMT+0800 (中国标准时间)</span><br><span class=\"line\">date.toDateString() -------返回日期，如 Mon Jul 24 2017</span><br><span class=\"line\">date.toLocaleString() -----返回本地化的日期时间，如 2017/7/24 下午2:51:34</span><br><span class=\"line\">date.toLocaleDateString() -返回本地化的日期，如 2017/7/24</span><br><span class=\"line\">date.toLocaleTimeString() -返回本地化的时间，如 下午2:52:32</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日期时间格式化\"><a href=\"#日期时间格式化\" class=\"headerlink\" title=\"日期时间格式化\"></a>日期时间格式化</h2><p>原生 js 并没有格式化日期时间的方法，需要发开人员自己写方法来格式化日期。</p>\n<h3 id=\"最简单的写法\"><a href=\"#最简单的写法\" class=\"headerlink\" title=\"最简单的写法\"></a>最简单的写法</h3><p>思路是获取需要格式化日期的 Date 对象，调用该对象的 get 类方法获取单独部分，最后再把单独部分拼装成完整的日期时间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//昨天的时间</span><br><span class=\"line\">var day1 = new Date();</span><br><span class=\"line\">day1.setTime(day1.getTime()-24*60*60*1000); //1、时间戳</span><br><span class=\"line\">day1.setDate(day1.getDate() - 1); //2、通过 get、set 方法</span><br><span class=\"line\">var s1 = day1.getFullYear()+&quot;-&quot; + (day1.getMonth()+1) + &quot;-&quot; + day1.getDate();</span><br><span class=\"line\"></span><br><span class=\"line\">//今天的时间</span><br><span class=\"line\">var day2 = new Date();</span><br><span class=\"line\">var s2 = day2.getFullYear()+&quot;-&quot; + (day2.getMonth()+1) + &quot;-&quot; + day2.getDate();</span><br><span class=\"line\"></span><br><span class=\"line\">//明天的时间</span><br><span class=\"line\">var day3 = new Date();</span><br><span class=\"line\">day3.setTime(day3.getTime()+24*60*60*1000); //1、时间戳</span><br><span class=\"line\">day3.setDate(day3.getDate() + 1); //2、通过 get、set 方法</span><br><span class=\"line\">var s3 = day3.getFullYear()+&quot;-&quot; + (day3.getMonth()+1) + &quot;-&quot; + day3.getDate();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"封装格式化方法\"><a href=\"#封装格式化方法\" class=\"headerlink\" title=\"封装格式化方法\"></a>封装格式化方法</h3><p>封装格式化方法，传入格式化字符串参数如 <code>yyyy-MM-dd HH:mm:ss</code> 可返回格式化后的日期。在网上找到两个方法，记录一下。</p>\n<h4 id=\"1、第一个方法\"><a href=\"#1、第一个方法\" class=\"headerlink\" title=\"1、第一个方法\"></a>1、第一个方法</h4><p>为 Date 原型添加方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Date.prototype.format = function(fmt) &#123; </span><br><span class=\"line\">     var o = &#123; </span><br><span class=\"line\">        &quot;M+&quot; : this.getMonth()+1,                 //月份 </span><br><span class=\"line\">        &quot;d+&quot; : this.getDate(),                    //日 </span><br><span class=\"line\">        &quot;h+&quot; : this.getHours(),                   //小时 </span><br><span class=\"line\">        &quot;m+&quot; : this.getMinutes(),                 //分 </span><br><span class=\"line\">        &quot;s+&quot; : this.getSeconds(),                 //秒 </span><br><span class=\"line\">        &quot;q+&quot; : Math.floor((this.getMonth()+3)/3), //季度 </span><br><span class=\"line\">        &quot;S&quot;  : this.getMilliseconds()             //毫秒 </span><br><span class=\"line\">    &#125;; </span><br><span class=\"line\">    if(/(y+)/.test(fmt)) &#123;</span><br><span class=\"line\">            fmt=fmt.replace(RegExp.$1, (this.getFullYear()+&quot;&quot;).substr(4 - RegExp.$1.length)); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     for(var k in o) &#123;</span><br><span class=\"line\">        if(new RegExp(&quot;(&quot;+ k +&quot;)&quot;).test(fmt))&#123;</span><br><span class=\"line\">             fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((&quot;00&quot;+ o[k]).substr((&quot;&quot;+ o[k]).length)));</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    return fmt; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var time1 = new Date().format(&quot;yyyy-MM-dd hh:mm:ss&quot;); //2018-07-23 12:13:14</span><br><span class=\"line\"></span><br><span class=\"line\">var time2 = new Date().format(&quot;yyyy-MM-dd&quot;); ////2018-07-23</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、第二个方法\"><a href=\"#2、第二个方法\" class=\"headerlink\" title=\"2、第二个方法\"></a>2、第二个方法</h4><p>传入需要被格式化的日期 date 和格式化字符串 datestr，其中 datestr 必须为以下格式</p>\n<ul>\n<li>yyyy-MM-dd </li>\n<li>yyyy&#x2F;MM&#x2F;dd </li>\n<li>yyyy-MM-dd hh:mm:ss </li>\n<li>yyyy&#x2F;MM&#x2F;dd hh:mm:ss </li>\n<li>hh:mm:ss</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function formateDate (date, dateStr) &#123;</span><br><span class=\"line\">    if(typeof date === &quot;number&quot;)&#123;</span><br><span class=\"line\">        var d=new Date();</span><br><span class=\"line\">        d.setTime(date);</span><br><span class=\"line\">        date=d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var arr=dateStr.split(/\\/|-|:| /);  //分割字符串,- / : 空格</span><br><span class=\"line\">    var timeArr=[];</span><br><span class=\"line\">    for (var i = 0; i &lt; arr.length; i++) &#123; //按照需要将日期放入数组timeArr</span><br><span class=\"line\">        switch (arr[i]) &#123;</span><br><span class=\"line\">            case &quot;yyyy&quot;:</span><br><span class=\"line\">                timeArr.push(date.getFullYear());           </span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &quot;MM&quot;:</span><br><span class=\"line\">                timeArr.push(date.getMonth()+1);            </span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &quot;dd&quot;:</span><br><span class=\"line\">                timeArr.push(date.getDate());           </span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &quot;hh&quot;:</span><br><span class=\"line\">                timeArr.push(date.getHours());          </span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &quot;mm&quot;:</span><br><span class=\"line\">                timeArr.push(date.getMinutes());        </span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &quot;ss&quot;:</span><br><span class=\"line\">                timeArr.push(date.getSeconds());</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (var i = 0; i &lt;arr.length; i++) &#123;</span><br><span class=\"line\">        dateStr = dateStr.replace(arr[i],timeArr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return dateStr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/sxxjyj/p/6093326.html\">js获取当前时间(昨天、今天、明天)</a><br><a href=\"https://www.cnblogs.com/tugenhua0707/p/3776808.html\">JS日期格式化转换方法</a><br><a href=\"https://blog.csdn.net/guxiansheng1991/article/details/76020091\">JavaScript 时间操作</a><br><a href=\"https://blog.csdn.net/LavanSum/article/details/72875454\">js 初始化日期对象 new Date() 常用方式</a></p>\n","categories":["前端","javascript"],"tags":["javascript"]},{"title":"java封装、继承和多态","url":"/2018/08/12/java%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/","content":"<blockquote>\n<p>封装、继承和多态是 java 面向对象的三大特性，其中封装是面向对象编程的基础，继承在封装的基础上简化类编程和提高类的可复用性，并为多态的实现提供了前提，三大特性体现了面向对象编程的思想。在这里简单介绍一些基础知识，转载请说明出处。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><h3 id=\"封装是什么\"><a href=\"#封装是什么\" class=\"headerlink\" title=\"封装是什么\"></a>封装是什么</h3><p><em><strong>封装把方法和数据包围起来，控制方法和数据的访问级别，隐藏了类的内部实现机制，只向外界暴露特定的访问接口</strong></em>。外界只能通过这些公开的接口来访问数据。</p>\n<p>封装的作用：对于类内部，保护私有数据不被轻易破坏，提高了类调用的安全性；对于类外部，调用者不需要了解类内部的具体实现细节，只需要根据接口的规则进行调用，简化编程过程，提高了模块的可复用性和可维护性。</p>\n<h3 id=\"深入封装\"><a href=\"#深入封装\" class=\"headerlink\" title=\"深入封装\"></a>深入封装</h3><h4 id=\"1、访问权限\"><a href=\"#1、访问权限\" class=\"headerlink\" title=\"1、访问权限\"></a>1、访问权限</h4><p>java 通过访问权限修饰符来控制类、属性和方法的可见范围，访问权限修饰符一共有四种，可见范围从大到小排列如下：</p>\n<ul>\n<li>public: 所有类都可访问</li>\n<li>无修饰符(default): 同一个包的类可访问（包括子类和非子类）</li>\n<li>protected: 子类可访问（包括直接子类和间接子类）</li>\n<li>private: 只有本身内部可访问</li>\n</ul>\n<p>在这里需要注意的是，<em><strong>子类继承父类时会继承父类的所有域和方法（包括 private 域和 private 方法），但是子类不能访问这些私有域和方法，看起来相当于没有继承一样</strong></em>。</p>\n<p>属性和方法可以使用以上四种修饰符，类只能使用 public 和 default 两种修饰符。</p>\n<h4 id=\"2、构造器\"><a href=\"#2、构造器\" class=\"headerlink\" title=\"2、构造器\"></a>2、构造器</h4><p>当创建一个对象时，系统会为这个对象的实例进行默认的初始化，例如把基本类型数值类型的属性设为 0，把布尔类型的属性设为 false，把引用属性设为 null 等等。通过构造器我们可以改变这种默认的初始化，把指定属性初始化为指定值。</p>\n<p>构造器有以下特点：</p>\n<ul>\n<li>构造器必须和类同名。</li>\n<li>构造器不是方法，不能被继承。</li>\n<li>构造器没有返回值，也不允许出现返回值。如果出现返回值编译器不会报错，但是就不是构造器了，只是一个跟类同名的普通方法。</li>\n<li>构造器只能用 public、default、protected 或 private 四种访问限制修饰符，不能用其他的修饰符。例如 static（构造器总是关联具体对象使用，没必要使用 static）、final（构造器不会被继承，没必要使用 final 限制继承）、abstract（抽象类不能直接实例化）。</li>\n<li>可以在一个构造器里面通过 this 关键字来调用另一个构造器，<em><strong>该调用必须写在第一行</strong></em>，不能在普通方法里面调用构造器。</li>\n</ul>\n<p>参考 <a href=\"http://www.cnblogs.com/aademeng/articles/6188323.html\">java中构造器（Constructor）</a></p>\n<h4 id=\"3、this\"><a href=\"#3、this\" class=\"headerlink\" title=\"3、this\"></a>3、this</h4><p><em><strong>this 关键字用来表示当前对象本身</strong></em>。this 关键字的用法如下：</p>\n<ul>\n<li>在构造方法中通过 this 关键字来调用其他构造方法，该调用必须放在第一行。</li>\n<li>通过 this 关键字来访问类中的所有成员变量和方法，<em><strong>不受访问权限的控制</strong></em>，包括 private 成员和 static 成员。不过由于 static 成员可以通过类名直接访问，如果通过 this 来访问会有 “The static field ××× should be accessed in a static way” 的警告信息。<em><strong>不能在类的 static 成员或 static 块中使用 this</strong></em>。</li>\n<li>表示当前类对象的引用，可作为参数传递。</li>\n</ul>\n<p>参考 <a href=\"https://blog.csdn.net/ccpat/article/details/44515335\">Java this 关键字用法</a></p>\n<h4 id=\"4、static\"><a href=\"#4、static\" class=\"headerlink\" title=\"4、static\"></a>4、static</h4><p><em><strong>被 static 关键字修饰的属性和方法不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问</strong></em>。static 的作用是在没有创建对象的情况下来进行调用属性或方法。static 可以用来修饰类的成员方法、类的成员变量，另外可以编写 static 代码块来优化程序性能。</p>\n<h5 id=\"1）static-方法\"><a href=\"#1）static-方法\" class=\"headerlink\" title=\"1）static 方法\"></a>1）static 方法</h5><p>static 方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有 this 的，因为它不依附于任何对象，既然都没有对象，就谈不上 this 了。并且由于这个特性，<em><strong>在静态方法中不能访问类的非静态成员变量和非静态成员方法</strong></em>，因为非静态成员方法&#x2F;变量都是必须依赖具体的对象才能够被调用。</p>\n<p>但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法&#x2F;变量的。</p>\n<p>如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为 static。我们最常见的 static 方法就是 main 方法，至于为什么 main 方法必须是 static 的，现在就很清楚了。因为程序在执行 main 方法的时候没有创建任何对象，因此只有通过类名来访问。</p>\n<h5 id=\"2）static-变量\"><a href=\"#2）static-变量\" class=\"headerlink\" title=\"2）static 变量\"></a>2）static 变量</h5><p>static 变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p>\n<p>static 成员变量的初始化顺序按照定义的顺序进行初始化，也就是说静态代码块和静态变量的级别是相同的，按照出现的顺序初始化。</p>\n<h5 id=\"3）static-代码块\"><a href=\"#3）static-代码块\" class=\"headerlink\" title=\"3）static 代码块\"></a>3）static 代码块</h5><p>static 代码块（包括静态方法）可以置于类中的任何地方，类中可以有多个 static 块。在类初次被加载的时候，会按照 static 块的顺序来执行每个 static 块，并且只会执行一次。因为这个特性可以将一些只需要进行一次的初始化操作都放在 static 代码块中进行，可以优化程序性能。</p>\n<p>参考 <a href=\"https://www.cnblogs.com/dolphin0520/p/3799052.html\">Java中的static关键字解析</a></p>\n<h4 id=\"5、类初始化和类实例化\"><a href=\"#5、类初始化和类实例化\" class=\"headerlink\" title=\"5、类初始化和类实例化\"></a>5、类初始化和类实例化</h4><p><strong>类初始化</strong>：类第一次加载到内存，虚拟机将类变量（static 修饰的变量）分配内存并设置零值的过程。在类初始化阶段，执行类构造器 <code>&lt;cinit&gt;()</code> 方法。<code>&lt;cinit&gt;()</code> 类初始化方法有如下特点：</p>\n<ol>\n<li>编译器会在将 .java 文件编译成 .class 文件时，收集所有类初始化代码和 static {} 域的代码，收集在一起成为 <code>&lt;cinit&gt;()</code> 方法；</li>\n<li>子类初始化时会首先调用父类的 <code>&lt;cinit&gt;()</code> 方法；</li>\n<li>JVM 会保证 <code>&lt;cinit&gt;()</code> 方法的线程安全，保证同一时间只有一个线程执行；</li>\n</ol>\n<p><strong>类实例化</strong>：类完全加载到内存之后创建对象的过程。在类实例化阶段会调用 <code>&lt;init&gt;()</code> 方法，过程如下：</p>\n<ol>\n<li>JVM 收集实例初始化变量和 {} 域组合成实例初始化方法 <code>&lt;init&gt;()</code>；</li>\n<li>实例初始化时首先执行 <code>&lt;init&gt;()</code> 方法，然后执行构造函数；</li>\n<li>子类通过构造函数构造实例时会首先调用父类的 <code>&lt;init&gt;()</code> 方法和父类的构造函数，如果没有显示调用父类的构造函数，那么 JVM 会自动调用父类的无参构造函数，保证父类构造函数一定被调用，然后再是子类自己的 <code>&lt;init&gt;()</code> 方法和构造函数；</li>\n<li>至此，实例就构造完毕了；</li>\n</ol>\n<p>所以类初始化和类实例化的过程是：</p>\n<ol>\n<li>父类类初始化 <code>&lt;cinit&gt;()</code>；</li>\n<li>子类类初始化 <code>&lt;cinit&gt;()</code>；</li>\n<li>父类 <code>&lt;init&gt;()</code> + 父类构造器；</li>\n<li>子类 <code>&lt;init&gt;()</code> + 子类构造器；</li>\n</ol>\n<p>最后，具体执行顺序可以总结为 <em><strong>“先静态后非静态，先父类后子类”</strong></em>：</p>\n<ol>\n<li>父类静态变量和静态代码块（先声明的先执行）；</li>\n<li>子类静态变量和静态代码块（先声明的先执行）；</li>\n<li>父类的变量和代码块（先声明的先执行）；</li>\n<li>父类的构造函数；</li>\n<li>子类的变量和代码块（先声明的先执行）；</li>\n<li>子类的构造函数。</li>\n</ol>\n<p>这个执行顺序在面试题里面经常会看到，可以记一下。</p>\n<p>参考 <a href=\"https://blog.csdn.net/w1196726224/article/details/56529615\">Java 类初始化（详解）</a><br><a href=\"https://www.cnblogs.com/jj-chenjunjie/p/5331107.html\">Java（静态）变量和（静态）代码块的执行顺序</a></p>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><h3 id=\"继承是什么\"><a href=\"#继承是什么\" class=\"headerlink\" title=\"继承是什么\"></a>继承是什么</h3><p>继承是当两个类存在 IS-A 关系的时候，例如人类和男人&#x2F;女人，学生和小学生&#x2F;中学生&#x2F;大学生，后者属于前者的一个特殊分类的时候，就可以在父类的基础上定义一个子类来继承它，子类会自动继承父类的所有属性和方法（会继承但是不一定有权限访问，例如父类的私有域和私有方法）。如下图所示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Human &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Man extends Human &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Woman extends Human &#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>子类 Man 和 Woman 分别通过关键字 <code>extends</code> 继承父类 Human，这样子类就可以访问父类的有权限访问的属性和方法了。</p>\n<p>继承的作用：提高了代码的可复用性，大大减少代码量，并且使类之间产生强依赖关系，为多态的实现提供前提。</p>\n<h3 id=\"深入继承\"><a href=\"#深入继承\" class=\"headerlink\" title=\"深入继承\"></a>深入继承</h3><h4 id=\"1、子类构造器\"><a href=\"#1、子类构造器\" class=\"headerlink\" title=\"1、子类构造器\"></a>1、子类构造器</h4><p>在调用子类构造器之前会自动调用父类的构造器。在这里有两种情况：</p>\n<ul>\n<li>子类构造器里显示调用父类构造器。通过 <code>super()</code> 调用父类无参构造器或者 super(arg1…) 调用父类有参构造器。<em><strong>使用 super 调用父类构造器必须写在子类构造器的第一行</strong></em>，否则编译器会报错。因为上面说过通过 this 调用本类的其他构造器也必须写在第一行，<em><strong>所以不能在同一个构造器里面同时通过 super 和 this 调用构造器</strong></em>。</li>\n<li>子类构造器没有显示调用父类构造器。这时编译器会自动调用父类的无参构造器，即会自动在第一行调用 <code>super()</code>。如果父类没有无参构造器，编译报错。</li>\n</ul>\n<p>所以为了防止子类编译报错，我们在写父类的时候最好都加上无参构造器，就算是空方法体也行。</p>\n<h4 id=\"2、super\"><a href=\"#2、super\" class=\"headerlink\" title=\"2、super\"></a>2、super</h4><p><em><strong>super 是用来访问父类的成员</strong></em>，作用和 this 类似：</p>\n<ul>\n<li>在构造器里面通过 super 来调用父类的构造方法，该调用必须写在子类构造器的第一行。</li>\n<li>访问有可见权限的父类的成员变量和方法，不能访问父类的 private 成员。例如当子类中出现和父类同名的成员变量或方法时，父类的成员会被隐藏，这时候可以通过 super 来访问父类中隐藏的成员。如果子类中没有重写父类的成员变量和成员方法，则子类会继承父类的所有非 private 的成员变量和成员方法。这时在子类中无论通过 this 来访问成员和通过 super 来访问成员，结果都是一样的。</li>\n</ul>\n<p>请注意 super 和 this 的区别：<br>this 是当前对象的一个引用，所以可以直接把 this 赋值给另外一个对象引用，例如 <code>Object o = this</code>，但是 <em><strong>super 只是一个指示编译器访问父类成员的特殊关键字，不是一个对象引用</strong></em>，<code>Object o = super</code> 这样的写法是错误的。</p>\n<h4 id=\"3、final\"><a href=\"#3、final\" class=\"headerlink\" title=\"3、final\"></a>3、final</h4><p>在 Java 中，final 关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。</p>\n<ol>\n<li>修饰类，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用 final 进行修饰。final 类中的成员变量可以根据需要设为 final，但是要注意 final 类中的所有成员方法都会被隐式地指定为 final 方法。</li>\n<li>修饰方法，表明方法不能被覆盖。类的 private方 法会隐式地被指定为 final 方法。</li>\n<li>修饰变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li>\n</ol>\n<p>参考 <a href=\"http://www.cnblogs.com/dolphin0520/p/3736238.html\">浅析Java中的final关键字</a></p>\n<h4 id=\"4、抽象类\"><a href=\"#4、抽象类\" class=\"headerlink\" title=\"4、抽象类\"></a>4、抽象类</h4><p><em><strong>抽象类是指 abstract 关键字修饰的类</strong></em>，子类通过 extends 关键字继承抽象类。</p>\n<p>抽象类是对普通类的抽象，我们可以把只有概念但是没有具体实现的信息添加到抽象类里面，然后再让继承类来具体实现这些信息。注意抽象类有以下特点：</p>\n<ul>\n<li>不能用抽象类来实例化对象。但是可以用抽象类来声明变量，然后用该抽象类的实现子类来实例化对象。</li>\n<li>抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。</li>\n<li>抽象类里面可以不包含任何 abstract 方法。（这样的抽象类其实没有什么意义，暂且当作概念来记住），但是只要包含一个以上 abstract 方法，该类就必须定义为抽象类。</li>\n<li>抽象方法必须为 public 或者 protected（因为如果为 private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为 public。</li>\n<li>抽象类可以包含普通的成员变量和方法，即变量可以定义为任何类型，方法可以有具体实现。</li>\n<li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为 abstract 类。</li>\n</ul>\n<p>例如下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">abstract class AbstractClass &#123; //父类抽象类</span><br><span class=\"line\">    private String name; //可以包含普通成员变量</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CommonMethod() &#123; //可以包含有具体实现的普通方法</span><br><span class=\"line\">        //some method</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    abstract public void AbstractMethod1(); //没有实现的抽象方法（注意后面没有中括号）</span><br><span class=\"line\"></span><br><span class=\"line\">    abstract public void AbstractMethod2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">abstract class NonImplementClass extends AbstractClass &#123; //没有完全实现父类抽象方法的类也必须定义为抽象类</span><br><span class=\"line\">    public void AbstractMethod1() &#123;</span><br><span class=\"line\">        System.out.println(&quot;实现了父类的第一个抽象方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ImplementClass extends AbstractClass &#123; //实现了父类所有抽象方法的类不用定义为抽象类</span><br><span class=\"line\">    public void AbstractMethod1() &#123;</span><br><span class=\"line\">        System.out.println(&quot;实现了父类的第一个抽象方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void AbstractMethod2() &#123;</span><br><span class=\"line\">        System.out.println(&quot;实现了父类的第二个抽象方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5、接口\"><a href=\"#5、接口\" class=\"headerlink\" title=\"5、接口\"></a>5、接口</h4><p>接口是对抽象类的进一步抽象，但是接口不是类。接口用 interface 来修饰，实现类通过 implements 来实现接口，子接口通过 extends 来继承父接口。</p>\n<p>接口有以下特点：</p>\n<ul>\n<li><p>接口可以定义成员变量，但是所有的成员变量都会隐式指定为 public static final 变量（并且只能是 public static final 变量，用 private 修饰会报编译错误），所以我们一般不在接口定义成员变量。</p>\n</li>\n<li><p>接口的方法都会隐式指定为 public abstract 方法且只能是 public abstract 方法（用其他关键字，比如 private、protected、static、 final 等修饰会报编译错误），并且接口中所有的方法不能有具体的实现。</p>\n</li>\n<li><p>实现接口的非抽象类必须要实现该接口的所有方法，如果没有完全实现接口的所有方法就要被定义为抽象类。</p>\n</li>\n</ul>\n<p>例如下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Interface &#123; //父接口</span><br><span class=\"line\">    String name = &quot;这是一个常量&quot;; //变量隐式用public static final修饰，所以必须赋初值</span><br><span class=\"line\"></span><br><span class=\"line\">    void method(); //方法隐式用public abstract修饰</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface ChildInterface extends Interface &#123; //子接口通过extends继承父接口</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">abstract class ImplementClass1 implements Interface &#123; //没有实现接口所有方法的类必须定义为抽象类</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ImplementClass2 implements Interface &#123; //实现接口所有方法的类不用定义为抽象类</span><br><span class=\"line\">    public void method() &#123; //因为接口方法隐式用public abstract修饰，所以这里必须加上public修饰符</span><br><span class=\"line\">        System.out.println(&quot;实现接口的方法&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6、抽象类和接口的区别\"><a href=\"#6、抽象类和接口的区别\" class=\"headerlink\" title=\"6、抽象类和接口的区别\"></a>6、抽象类和接口的区别</h4><h5 id=\"1）语法层面上的区别\"><a href=\"#1）语法层面上的区别\" class=\"headerlink\" title=\"1）语法层面上的区别\"></a>1）语法层面上的区别</h5><ol>\n<li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li>\n<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li>\n<li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li>\n<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>\n</ol>\n<h5 id=\"2）设计层面上的区别\"><a href=\"#2）设计层面上的区别\" class=\"headerlink\" title=\"2）设计层面上的区别\"></a>2）设计层面上的区别</h5><ol>\n<li><p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口 Fly，包含方法 fly( )，然后 Airplane和 Bird 分别根据自己的需要实现 Fly 这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承 Airplane 即可，对于鸟也是类似的，不同种类的鸟直接继承 Bird 类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>\n</li>\n<li><p>设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过 ppt 里面的模板，如果用模板A设计了 ppt B和ppt C，ppt B和ppt C公共的部分就是模板 A 了，如果它们的公共部分需要改动，则只需要改动模板 A 就可以了，不需要重新对 ppt B 和 ppt C 进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>\n</li>\n</ol>\n<p>下面看一个网上流传最广泛的例子：门和警报的例子：门都有 open( ) 和 close( ) 两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">abstract class Door &#123;</span><br><span class=\"line\">    public abstract void open();</span><br><span class=\"line\">    public abstract void close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Door &#123;</span><br><span class=\"line\">    public abstract void open();</span><br><span class=\"line\">    public abstract void close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>\n<ol>\n<li>将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</li>\n<li>将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</li>\n</ol>\n<p>从这里可以看出， Door 的 open() 、close() 和 alarm() 根本就属于两个不同范畴内的行为，open() 和 close() 属于门本身固有的行为特性，而 alarm() 属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含 alarm() 行为,Door 设计为单独的一个抽象类，包含 open 和 close 两种行为。再设计一个报警门继承 Door 类和实现 Alarm 接口。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface Alram &#123;</span><br><span class=\"line\">    void alarm();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">abstract class Door &#123;</span><br><span class=\"line\">    void open();</span><br><span class=\"line\">    void close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class AlarmDoor extends Door implements Alarm &#123;</span><br><span class=\"line\">    void oepn() &#123;</span><br><span class=\"line\">      //....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void close() &#123;</span><br><span class=\"line\">      //....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void alarm() &#123;</span><br><span class=\"line\">      //....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上参考 <a href=\"https://www.cnblogs.com/dolphin0520/p/3811437.html\">深入理解Java的接口和抽象类</a><br><a href=\"https://blog.csdn.net/chenssy/article/details/12858267\">java提高篇（四）—–抽象类与接口</a></p>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><h3 id=\"多态是什么\"><a href=\"#多态是什么\" class=\"headerlink\" title=\"多态是什么\"></a>多态是什么</h3><p><em><strong>多态是指当当一个变量用父类类型声明，但用子类类型实例化，该变量在编译阶段会表现为父类类型，在运行阶段会表现为子类类型，会使用子类类型的方法</strong></em>。例如下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Human &#123;</span><br><span class=\"line\">  public void eat() &#123; //父类的 eat 方法</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Woman extends Human &#123;</span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public void eat() &#123; //Human 类重写 eat() 方法</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Man extends Human &#123;</span><br><span class=\"line\">  public void eat() &#123; //Man 类重写 eat() 方法</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class HumanTest &#123;</span><br><span class=\"line\">  public static void main(String[] args) &#123;</span><br><span class=\"line\">    Human human = new Woman();</span><br><span class=\"line\">    human.eat(); //会调用 Woman 类的 eat() 方法</span><br><span class=\"line\"></span><br><span class=\"line\">    human = new Man();</span><br><span class=\"line\">    human.eat(); //会调用 Man 类的 eat() 方法</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面例子我们可以看到，一个用父类类型 Human 声明的变量 human 调用 eat() 方法，当该变量用子类 Woman 实例化时会调用 Woman 的 eat() 方法，用子类 Man 实例化时会调用 Man 的 eat() 方法，同一个类型声明的变量可以调用不同子类型的方法，具体调用哪个类的方法要等运行阶段实例化对象的时候才能确定，这就是多态性。</p>\n<h3 id=\"深入多态\"><a href=\"#深入多态\" class=\"headerlink\" title=\"深入多态\"></a>深入多态</h3><h4 id=\"1、动态绑定和静态绑定\"><a href=\"#1、动态绑定和静态绑定\" class=\"headerlink\" title=\"1、动态绑定和静态绑定\"></a>1、动态绑定和静态绑定</h4><p>绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来。对 java 来说，绑定分为 <strong>静态绑定</strong> 和 <strong>动态绑定</strong>；或者叫做前期绑定和后期绑定。</p>\n<p><strong>静态绑定</strong>：</p>\n<p>在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。例如：C。<br>针对 Java 简单的可以理解为程序编译期的绑定。<em><strong>java 当中的方法只有 final，static，private 和构造方法是前期绑定</strong></em>。</p>\n<p><strong>动态绑定</strong>：</p>\n<p>在运行时根据具体对象的类型进行绑定。<br>若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。</p>\n<p><strong>java 方法的调用过程：</strong></p>\n<ol>\n<li>编译器查看对象的声明类型和方法名（对象变量的声明类型），通过声明类型找到方法列表。</li>\n<li>编译器查看调用方法时提供的参数类型。如果方法是 private、static、final或者构造器，编译器就可以确定调用那个方法。这是静态绑定。</li>\n<li>如果不是上述情况，就要使用运行时（动态）绑定。在程序运行时，采用动态绑定意味着：<em><strong>虚拟机将调用对象实际类型所限定的方法</strong></em>。具体过程如下：</li>\n</ol>\n<p><strong>动态绑定的过程：</strong></p>\n<ol>\n<li>虚拟机提取对象的实际类型的方法表；</li>\n<li>虚拟机搜索方法签名；</li>\n<li>调用方法。</li>\n</ol>\n<p><strong>总结：</strong></p>\n<p>在 java 中，几乎所有的 方法（不是字段属性）都是后期绑定（动态绑定），除了 private、static、final 修饰的方法。</p>\n<ul>\n<li>对于 static 方法和 final 方法由于不能被继承，因此在编译时就可以确定他们的值，他们是属于前期绑定（静态绑定）的。</li>\n<li>对于 private 声明的方法和成员变量不能被子类继承，所有的 private 方法都被隐式的指定为 final。由此我们也可以知道：将方法声明为 final 类型的一是为了防止方法被覆盖，二是为了有效的关闭 java 中的动态绑定。</li>\n</ul>\n<p>参考 <a href=\"https://my.oschina.net/u/566345/blog/81235\">java的动态绑定与静态绑定(彻底理解多态与重载)</a></p>\n<h4 id=\"2、向上转型和向下转型\"><a href=\"#2、向上转型和向下转型\" class=\"headerlink\" title=\"2、向上转型和向下转型\"></a>2、向上转型和向下转型</h4><p><strong>向上转型</strong>：父类引用指向子类对象</p>\n<p>好处：父类声明的变量（包括实参和形参）引用子类对象，可以直接调用子类对象中的方法，这样用一种类型声明的变量就可以调用其所有子类的方法，代码比较简介灵活。否则要调用子类的方法，有多少个子类就要声明多少种类型的变量。</p>\n<p>坏处：父类声明的对象只能调用子类重写父类的方法，子类内其他自定义的方法会丢失。</p>\n<p><strong>向下转型</strong>：父类引用指向子类对象后，再把父类引用类型转换类型后赋值给子类引用</p>\n<p>好处：可以调用子类中所有的方法</p>\n<p>坏处：可能会存在类型转换失败，在编译时能通过，但是运行会出错，为了安全的类型转换，最好先用 if(A instanceof  B) 判断一下。</p>\n<h4 id=\"3、重载和重写\"><a href=\"#3、重载和重写\" class=\"headerlink\" title=\"3、重载和重写\"></a>3、重载和重写</h4><p><strong>重载（OverLoad）</strong> ：一个类中定义了多个方法名相同，参数的类型或者数量不同的方法</p>\n<ul>\n<li>参数列表必须改变(参数个数或类型不一样)；</li>\n<li>返回类型可以改变；</li>\n<li>访问修饰符可以改变；</li>\n<li>可以声明新的或更广的检查异常；</li>\n<li>返回值类型不能作为重载函数的区分标准。</li>\n<li>方法能够在同一个类中或者在一个子类中被重载。</li>\n</ul>\n<p><strong>重写（Override）</strong> ：子类定义了和父类方法名相同、参数个数类型相同、返回值相同的方法。</p>\n<ul>\n<li>参数列表必须完全与被重写方法的相同；</li>\n<li>返回类型必须完全与被重写方法的返回类型相同；</li>\n<li>访问修饰符可以改变，但是不能做更严格的限制（可以降低限制）</li>\n<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>\n<li>父类的成员方法只能被它的子类重写。</li>\n<li>声明为 final 的方法不能被重写。</li>\n<li>声明为 static 的方法不能被重写，但是能够被再次声明。</li>\n<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li>\n<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li>\n<li>构造方法不能被重写。</li>\n<li>如果不能继承一个方法，则不能重写这个方法。</li>\n</ul>\n<p>总结：方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</p>\n<p> | 方法名 | 参数列表 | 返回类型 | 访问修饰符 | 异常</p>\n<ul>\n<li>| - | - | - | - | -<br>重写 | 必须相同 | 必须相同 | 必须相同 | 可以不同（不能做更严格的限制） | 可以减少或删除，一定不能抛出新的或者更广的异常<br>重载 | 必须相同 | 必须不同（类型或个数不同）| 可以不同 | 可以不同 | 可以不同</li>\n</ul>\n<p>简单来说，重写靠方法名、参数列表和返回值三个相同的判断，重载只靠方法名相同来判断，访问修饰符和异常均不能作为判断依据。</p>\n<h4 id=\"3、多态的三个必要条件\"><a href=\"#3、多态的三个必要条件\" class=\"headerlink\" title=\"3、多态的三个必要条件\"></a>3、多态的三个必要条件</h4><ol>\n<li><strong>存在继承关系</strong></li>\n<li><strong>子类要重写父类的方法</strong></li>\n<li><strong>父类类型的引用指向子类对象（向上转型）</strong></li>\n</ol>\n<p>看下面这个例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">    int num = 10;</span><br><span class=\"line\">    static int age = 20;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;动物吃饭&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void sleep() &#123;</span><br><span class=\"line\">        System.out.println(&quot;动物在睡觉&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(&quot;动物在奔跑&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Cat extends Animal &#123;</span><br><span class=\"line\">    int num = 80;</span><br><span class=\"line\">    static int age = 90;</span><br><span class=\"line\">    String name = &quot;tomCat&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void eat() &#123;</span><br><span class=\"line\">        System.out.println(&quot;猫吃饭&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void sleep() &#123;</span><br><span class=\"line\">        System.out.println(&quot;猫在睡觉&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void catchMouse() &#123;</span><br><span class=\"line\">        System.out.println(&quot;猫在抓老鼠&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class AnimalTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Animal am = new Cat();</span><br><span class=\"line\">        am.eat();</span><br><span class=\"line\">        am.sleep();</span><br><span class=\"line\">        am.run();</span><br><span class=\"line\">        //am.catchMouse(); //这里需要注释掉，因为am不能调用子类特有的方法catchMouse()</span><br><span class=\"line\">        //System.out.println(am.name); //这里需要注释掉，因为am不能调用子类特有的属性name</span><br><span class=\"line\">        System.out.println(am.num);</span><br><span class=\"line\">        System.out.println(am.age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上的三段代码充分体现了多态的三个前提，即：</p>\n<ol>\n<li>存在继承关系<br>Cat 类继承了 Animal 类</li>\n<li>子类要重写父类的方法<br>子类重写(override)了父类的两个成员方法 eat()，sleep()。其中 eat() 是非静态的，sleep() 是静态的<br>（static）。</li>\n<li>父类数据类型的引用指向子类对象。（向上转型）<br>测试类 Demo_Test1 中 Animal am &#x3D; new Cat();语句在堆内存中开辟了子类 (Cat) 的对象，并把栈内存中的<br>父类 (Animal) 的引用指向了这个 Cat 对象。<br>到此，满足了 Java 多态的的必要三个前提。</li>\n</ol>\n<p>输出结果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">猫吃饭</span><br><span class=\"line\">动物在睡觉</span><br><span class=\"line\">动物在奔跑</span><br><span class=\"line\">10</span><br><span class=\"line\">20</span><br></pre></td></tr></table></figure>\n\n<p>可以看出来<br>子类 Cat 重写了父类 Animal 的非静态成员方法 am.eat() 的输出结果为：猫吃饭。<br>子类重写了父类 (Animal) 的静态成员方法 am.sleep() 的输出结果为：动物在睡觉<br>未被子类（Cat）重写的父类（Animal）方法 am.run() 输出结果为：动物在奔跑</p>\n<p>总结：<br>成员变量（包括静态和非静态）和静态方法，编译看父类，运行看父类<br>只有非静态的成员方法，编译看父类，运行看子类</p>\n<p>但是多态有一个弊端：<em><strong>多态后不能使用子类特有的成员属性和成员方法</strong></em>。例如上面的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">am.catchMouse();</span><br><span class=\"line\">System.out.println(am.name);</span><br></pre></td></tr></table></figure>\n\n<p>在编译器期间会报错，因为 am 对象不能去获取子类特有的方法 catchMouse() 和属性 am.name。如果一定要调用子类特有的方法和方法，需要把父类引用转成子类类型，也就是向下转型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">((Cat)am).catchMouse(); //强转成 Cat 类型再调用编译就不会报错了</span><br><span class=\"line\">System.out.println(((Cat)am).name); //强转成 Cat 类型再调用编译就不会报错了</span><br></pre></td></tr></table></figure>\n\n<p>参考 <a href=\"https://www.zhihu.com/question/30082151\">JAVA的多态用几句话能直观的解释一下吗？</a></p>\n","categories":["Java","Java基础"],"tags":["Java"]},{"title":"log4j详解","url":"/2019/08/02/log4j%E8%AF%A6%E8%A7%A3/","content":"<blockquote>\n<p> Log4j是Apache的一个开源的日志框架，通过使用Log4j，可以控制将应用日志信息输送到指定的地方。下面学习log4j的简单入门和相关的配置文件。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"log4j是什么\"><a href=\"#log4j是什么\" class=\"headerlink\" title=\"log4j是什么\"></a>log4j是什么</h1><p>Log4j是Apache的一个开源的日志框架，通过使用Log4j，可以控制将应用日志信息输送到：</p>\n<p>控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程、数据库等；</p>\n<p>可以控制每一条日志的输出格式；</p>\n<p>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</p>\n<p>最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p>\n<h1 id=\"配置使用log4j\"><a href=\"#配置使用log4j\" class=\"headerlink\" title=\"配置使用log4j\"></a>配置使用log4j</h1><h2 id=\"1、引入依赖\"><a href=\"#1、引入依赖\" class=\"headerlink\" title=\"1、引入依赖\"></a>1、引入依赖</h2><ul>\n<li>非springboot项目</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>maven路径：<a href=\"https://mvnrepository.com/artifact/log4j/log4j\">https://mvnrepository.com/artifact/log4j/log4j</a></p>\n<ul>\n<li>springboot项目</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.3.8.RELEASE&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>可以不加版本号，使用 spring-boot-starter-parent 的版本好，maven仓库地址：<a href=\"https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-log4j\">https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-log4j</a></p>\n<h2 id=\"2、添加配置文件\"><a href=\"#2、添加配置文件\" class=\"headerlink\" title=\"2、添加配置文件\"></a>2、添加配置文件</h2><p>log4j支持properties和xml格式的配置文件，一般情况下用<code>log4j.properties</code>比较多。添加<code>log4j.properties</code>配置文件到类路径下面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger = debug,stdout,D,E</span><br><span class=\"line\"></span><br><span class=\"line\">### 输出信息到控制抬</span><br><span class=\"line\">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.stdout.Target = System.out</span><br><span class=\"line\">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><br><span class=\"line\"></span><br><span class=\"line\">### 输出DEBUG 级别以上的日志到=/home/duqi/logs/debug.log</span><br><span class=\"line\">log4j.appender.D = org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">log4j.appender.D.File = /home/duqi/logs/debug.log</span><br><span class=\"line\">log4j.appender.D.Append = true</span><br><span class=\"line\">log4j.appender.D.Threshold = DEBUG </span><br><span class=\"line\">log4j.appender.D.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br><span class=\"line\"></span><br><span class=\"line\">### 输出ERROR 级别以上的日志到=/home/admin/logs/error.log</span><br><span class=\"line\">log4j.appender.E = org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">log4j.appender.E.File =/home/admin/logs/error.log </span><br><span class=\"line\">log4j.appender.E.Append = true</span><br><span class=\"line\">log4j.appender.E.Threshold = ERROR </span><br><span class=\"line\">log4j.appender.E.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3、使用log4j打印\"><a href=\"#3、使用log4j打印\" class=\"headerlink\" title=\"3、使用log4j打印\"></a>3、使用log4j打印</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package com.javadu.log;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.slf4j.Logger;</span><br><span class=\"line\">import org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class Log4JTest &#123;</span><br><span class=\"line\">    private static final Logger logger = LoggerFactory.getLogger(Log4JTest.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        // 记录debug级别的信息</span><br><span class=\"line\">        logger.debug(&quot;This is debug message.&quot;);</span><br><span class=\"line\">        // 记录info级别的信息</span><br><span class=\"line\">        logger.info(&quot;This is info message.&quot;);</span><br><span class=\"line\">        // 记录error级别的信息</span><br><span class=\"line\">        logger.error(&quot;This is error message.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"log4j配置文件\"><a href=\"#log4j配置文件\" class=\"headerlink\" title=\"log4j配置文件\"></a>log4j配置文件</h1><p>Log4j支持两种配置文件格式，一种是XML（标准通用标记语言下的一个应用）格式的文件，一种是Java特性文件log4j.properties（键&#x3D;值）。下面主要介绍log4j.properties配置文件。</p>\n<p>Log4j有三个主要的组件：</p>\n<ul>\n<li>Logger(记录器):收集指定级别或指定包的日志 </li>\n<li>Appender (输出源):日志要输出的地方</li>\n<li>Layout(布局):日志以何种形式输出</li>\n</ul>\n<p>其中Logger和Appender的关系是：</p>\n<ol>\n<li>Logger类似于收集器，可以指定多个收集器，每个收集器收集指定级别或者指定包下面的日志。Appender负责把Logger收集到的日志输出到指定位置。</li>\n<li>一个Logger输出到多个Appender</li>\n</ol>\n<h2 id=\"1、Logger\"><a href=\"#1、Logger\" class=\"headerlink\" title=\"1、Logger\"></a>1、Logger</h2><p>Logger定义了所收集的日志的级别或者包位置。</p>\n<p>Logger的日志级别分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别。</p>\n<p>Log4j建议只使用四个级别，优先级从高到低分别是<strong>ERROR、WARN、INFO、DEBUG</strong>。通过在这里定义的级别，可以控制<strong>只有等于或高于该级别的日志才会被打印</strong>。比如在这里定义了INFO级别，只有等于及高于这个级别的才进行打印，则应用程序中所有DEBUG级别的日志信息将不被打印出来。</p>\n<p>Logger分为根Logger和非根Logger。</p>\n<h3 id=\"根Logger\"><a href=\"#根Logger\" class=\"headerlink\" title=\"根Logger\"></a>根Logger</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger = [ level ] , appenderName, appenderName, ...</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"非根Logger\"><a href=\"#非根Logger\" class=\"headerlink\" title=\"非根Logger\"></a>非根Logger</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.logger.loggerName1 = [ level ], appendName1,…appendNameN</span><br></pre></td></tr></table></figure>\n\n<p><code>loggerName1</code>可以自己随便定义，在代码里面通过 <code>public static final Logger log = LoggerFactory.getLogger(&quot;loggerName1&quot;);</code> 的方式调用该Logger。</p>\n<p>所有的非根Logger打印的日志默认都会追加到根Logger，也就是日志信息会在两个日志文件各打印一份。如果想禁止追加到根Logger，可以在非根Logger输出的Appender配置属性<code>Append=false</code></p>\n<p>非根Logger有多种用法</p>\n<ol>\n<li><p>例如我们想定义一个Logger专门用来收集sql语句，在properties定义</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.logger.sql=DEBUG,sql_log</span><br></pre></td></tr></table></figure>\n\n<p>然后我们在代码里面使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static final Logger log = LoggerFactory.getLogger(&quot;sql&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>日志信息全部打印到<code>sql_log</code>指定的appender里面。</p>\n</li>\n<li><p>例如某个依赖包打印的INFO以下的日志信息太多，我们只想收集ERROR以上的日志，可以定义</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger=INFO,api_stdout</span><br><span class=\"line\">log4j.logger.com.mchange.v2.resourcepool.BasicResourcePool=ERROR,api_stdout</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>使用根Logger打印，其他包都打印INFO及以上的日志，这个包只会打印ERROR及以上的信息。</p>\n</li>\n<li><p>同一个类输出多个日志文件。首先在properties定义</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.logger.myTest1= DEBUG, test1</span><br><span class=\"line\">log4j.logger.myTest2= DEBUG, test2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后在代码里面使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">private static Log logger1 = LogFactory.getLog(&quot;myTest1&quot;); </span><br><span class=\"line\">private static Log logger2 = LogFactory.getLog(&quot;myTest2&quot;); </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2、Appender\"><a href=\"#2、Appender\" class=\"headerlink\" title=\"2、Appender\"></a>2、Appender</h2><p>Appender把日志输出到不同的地方，如控制台（Console）、文件（Files）等，可以根据天数或者文件大小产生新的文件，可以以流的形式发送到其它地方等等。</p>\n<p>配置语法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.appender.appenderName = Appender完整类名</span><br><span class=\"line\">log4j.appender.appenderName.layout = Layout完整类名</span><br><span class=\"line\">log4j.appender.appenderName.Option1 = value1</span><br><span class=\"line\">…</span><br><span class=\"line\">log4j.appender.appenderName.OptionN = valueN</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Layout\"><a href=\"#Layout\" class=\"headerlink\" title=\"Layout\"></a>Layout</h3><p>Layouts提供四种日志输出样式，如根据<strong>HTML样式</strong>、<strong>自由指定样式</strong>、<strong>包含日志级别与信息的样式</strong>和<strong>包含日志时间、线程、类别等信息的样式</strong>。</p>\n<ul>\n<li>org.apache.log4j.HTMLLayout（以HTML表格形式布局）</li>\n<li>org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</li>\n<li>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</li>\n<li>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）</li>\n</ul>\n<p>HTMLLayout和PatternLayout有一些配置选项，其他的都是默认格式。</p>\n<h4 id=\"1-HTMLLayout\"><a href=\"#1-HTMLLayout\" class=\"headerlink\" title=\"1. HTMLLayout\"></a>1. HTMLLayout</h4><ul>\n<li>LocationInfo&#x3D;true：输出java文件名称和行号，默认值是false。</li>\n<li>Title&#x3D;My Logging： 默认值是Log4J Log Messages。</li>\n</ul>\n<h4 id=\"2-PatternLayout\"><a href=\"#2-PatternLayout\" class=\"headerlink\" title=\"2. PatternLayout\"></a>2. PatternLayout</h4><ul>\n<li>ConversionPattern&#x3D;%m%n：设定以怎样的格式显示消息。参数解释如下：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n<th><strong>例子</strong></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%c</td>\n<td>列出logger名字空间的全称，如果加上{&lt;层数&gt;}表示列出从最内层算起的指定层数的名字空间</td>\n<td>log4j配置文件参数举例</td>\n<td>输出显示媒介</td>\n</tr>\n<tr>\n<td>假设当前logger名字空间是”a.b.c”</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%c</td>\n<td>a.b.c</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%c{2}</td>\n<td>b.c</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%20c</td>\n<td>（若名字空间长度小于20，则左边用空格填充）</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%-20c</td>\n<td>（若名字空间长度小于20，则右边用空格填充）</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%.30c</td>\n<td>（若名字空间长度超过30，截去多余字符）</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%20.30c</td>\n<td>（若名字空间长度小于20，则左边用空格填充；若名字空间长度超过30，截去多余字符）</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%-20.30c</td>\n<td>（若名字空间长度小于20，则右边用空格填充；若名字空间长度超过30，截去多余字符）</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%C</td>\n<td>列出调用logger的类的全名（包含包路径）</td>\n<td>假设当前类是”org.apache.xyz.SomeClass”</td>\n<td></td>\n</tr>\n<tr>\n<td>%C</td>\n<td>org.apache.xyz.SomeClass</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%C{1}</td>\n<td>SomeClass</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%d</td>\n<td>显示日志记录时间，{&lt;日期格式&gt;}使用ISO8601定义的日期格式</td>\n<td>%d{yyyy&#x2F;MM&#x2F;dd HH:mm:ss,SSS}</td>\n<td>2005&#x2F;10&#x2F;12 22:23:30,117</td>\n</tr>\n<tr>\n<td>%d{ABSOLUTE}</td>\n<td>22:23:30,117</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%d{DATE}</td>\n<td>12 Oct 2005 22:23:30,117</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%d{ISO8601}</td>\n<td>2005-10-12 22:23:30,117</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%F</td>\n<td>显示调用logger的源文件名</td>\n<td>%F</td>\n<td>MyClass.java</td>\n</tr>\n<tr>\n<td>%l</td>\n<td>输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数</td>\n<td>%l</td>\n<td>MyClass.main(MyClass.java:129)</td>\n</tr>\n<tr>\n<td>%L</td>\n<td>显示调用logger的代码行</td>\n<td>%L</td>\n<td>129</td>\n</tr>\n<tr>\n<td>%m</td>\n<td>显示输出消息</td>\n<td>%m</td>\n<td>This is a message for debug.</td>\n</tr>\n<tr>\n<td>%M</td>\n<td>显示调用logger的方法名</td>\n<td>%M</td>\n<td>main</td>\n</tr>\n<tr>\n<td>%n</td>\n<td>当前平台下的换行符</td>\n<td>%n</td>\n<td>Windows平台下表示rnUNIX平台下表示n</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>显示该条日志的优先级</td>\n<td>%p</td>\n<td>INFO</td>\n</tr>\n<tr>\n<td>%r</td>\n<td>显示从程序启动时到记录该条日志时已经经过的毫秒数</td>\n<td>%r</td>\n<td>1215</td>\n</tr>\n<tr>\n<td>%t</td>\n<td>输出产生该日志事件的线程名</td>\n<td>%t</td>\n<td>MyClass</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>按NDC（Nested Diagnostic Context，线程堆栈）顺序输出日志</td>\n<td>假设某程序调用顺序是MyApp调用com.foo.Bar</td>\n<td></td>\n</tr>\n<tr>\n<td>%c %x - %m%n</td>\n<td>MyApp - Call com.foo.Bar.com.foo.Bar - Log in BarMyApp - Return to MyApp.</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>%X</td>\n<td>按MDC（Mapped Diagnostic Context，线程映射表）输出日志。通常用于多个客户端连接同一台服务器，方便服务器区分是那个客户端访问留下来的日志。</td>\n<td>%X{5}</td>\n<td>（记录代号为5的客户端的日志）</td>\n</tr>\n<tr>\n<td>%%</td>\n<td>显示一个百分号</td>\n<td>%%</td>\n<td>%</td>\n</tr>\n</tbody></table>\n<p>实例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%p] (%F:%L) %t %m%n</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>打印结果为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">2019-08-02 17:50:08 101 [INFO] (Slf4JLogger.java:101) nioEventLoopGroup-2-1 [id: 0x9fc7d7b5] REGISTERED</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Appender\"><a href=\"#Appender\" class=\"headerlink\" title=\"Appender\"></a>Appender</h3><p>常用的Appender如下：</p>\n<ul>\n<li>org.apache.log4j.ConsoleAppender（控制台）</li>\n<li>org.apache.log4j.FileAppender（文件）</li>\n<li>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</li>\n<li>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</li>\n<li>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</li>\n</ul>\n<p>每个Appender都有一些配置选项。</p>\n<h4 id=\"1-ConsoleAppender\"><a href=\"#1-ConsoleAppender\" class=\"headerlink\" title=\"1. ConsoleAppender\"></a>1. ConsoleAppender</h4><p>ConsoleAppender会把消息全部输出到控制台</p>\n<p>配置选项</p>\n<ul>\n<li>Threshold&#x3D;WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>\n<li>ImmediateFlush&#x3D;true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</li>\n<li>Target&#x3D;System.err：默认值是System.out。</li>\n</ul>\n<p>实例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger=info,console_log</span><br><span class=\"line\"></span><br><span class=\"line\">log4j.appender.console_log= org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.console_log.layout=org.apache.log4j.PatternLayout </span><br><span class=\"line\">log4j.appender.console_log.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%p] (%F:%L) %t %m%n</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-FileAppender\"><a href=\"#2-FileAppender\" class=\"headerlink\" title=\"2. FileAppender\"></a>2. FileAppender</h4><p>FileAppender会一直把日志输出到一个文件，容易发生文件过大导致读写缓慢的问题，不推荐使用。</p>\n<p>配置选项</p>\n<ul>\n<li>Threshold&#x3D;WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>\n<li>ImmediateFlush&#x3D;true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</li>\n<li>Append&#x3D;false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</li>\n<li>File&#x3D;D:&#x2F;logs&#x2F;logging.log4j：指定消息输出到logging.log4j文件中。</li>\n</ul>\n<p>实例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger=info,file_log</span><br><span class=\"line\"></span><br><span class=\"line\">log4j.appender.file_log=org.apache.log4j.RollingFileAppender </span><br><span class=\"line\">log4j.appender.file_log.File= $&#123;api.logs.dir&#125;/file.log </span><br><span class=\"line\">log4j.appender.file_log.Append = true </span><br><span class=\"line\">log4j.appender.file_log.MaxFileSize=100MB</span><br><span class=\"line\">log4j.appender.file_log.MaxBackupIndex=15</span><br><span class=\"line\">log4j.appender.file_log.layout=org.apache.log4j.PatternLayout </span><br><span class=\"line\">log4j.appender.file_log.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%p] (%F:%L) %t %m%n</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-RollingFileAppender\"><a href=\"#3-RollingFileAppender\" class=\"headerlink\" title=\"3. RollingFileAppender\"></a>3. RollingFileAppender</h4><p>达到指定文件大小的时候，会把当前的日志文件重命名，作为备份文件保存，并生成新的日志文件用来接收日志。</p>\n<p>配置选项</p>\n<ul>\n<li>Threshold&#x3D;WARN：指定日志信息的最低输出级别，默认为DEBUG。</li>\n<li>ImmediateFlush&#x3D;true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</li>\n<li>Append&#x3D;false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</li>\n<li>File&#x3D;D:&#x2F;logs&#x2F;logging.log4j：指定消息输出到logging.log4j文件中。</li>\n<li>MaxFileSize&#x3D;100KB：后缀可以是KB, MB 或者GB。当日志文件到达该大小时，文件被重命名为logging.log4j.1，作为备份文件保存起来，并生成一个新的logging.log4j用来接收日志。</li>\n<li>MaxBackupIndex&#x3D;2：指定可以备份文件的最大数。</li>\n</ul>\n<p>实例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger=DEBUG,sql_log</span><br><span class=\"line\"></span><br><span class=\"line\">log4j.appender.sql_log=org.apache.log4j.RollingFileAppender </span><br><span class=\"line\">log4j.appender.sql_log.File= $&#123;api.logs.dir&#125;/sql.log </span><br><span class=\"line\">log4j.appender.sql_log.Append = true </span><br><span class=\"line\">log4j.appender.sql_log.MaxFileSize=100MB</span><br><span class=\"line\">log4j.appender.sql_log.MaxBackupIndex=15</span><br><span class=\"line\">log4j.appender.sql_log.layout=org.apache.log4j.PatternLayout </span><br><span class=\"line\">log4j.appender.sql_log.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%p] (%F:%L) %t %m%n</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-DailyRollingFileAppender\"><a href=\"#4-DailyRollingFileAppender\" class=\"headerlink\" title=\"4. DailyRollingFileAppender\"></a>4. DailyRollingFileAppender</h4><p>每隔一段时间生成一个日志文件，时间间隔和备份文件命名由<code>DatePattern</code>配置。但是不能指定备份文件的大小的个数，也就是说RollingFileAppender的<code>MaxFileSize</code>和<code>MaxBackupIndex</code>在这里不起作用，如果想控制备份文件的大小可以参考[<a href=\"https://www.cnblogs.com/rembau/p/5201001.html\">Log4j的扩展-支持设置最大日志数量的DailyRollingFileAppender</a>]</p>\n<p>配置选项</p>\n<ul>\n<li><p>Threshold&#x3D;WARN：指定日志信息的最低输出级别，默认为DEBUG。</p>\n</li>\n<li><p>ImmediateFlush&#x3D;true：表示所有消息都会被立即输出，设为false则不输出，默认值是true。</p>\n</li>\n<li><p>Append&#x3D;false：true表示消息增加到指定文件中，false则将消息覆盖指定的文件内容，默认值是true。</p>\n</li>\n<li><p>File&#x3D;D:&#x2F;logs&#x2F;logging.log4j：指定当前消息输出到logging.log4j文件中。</p>\n</li>\n<li><p>DatePattern&#x3D;’.’yyyy-MM：每月滚动一次日志文件，即每月产生一个新的日志文件。当前月的日志文件名为logging.log4j，前一个月的日志文件名为logging.log4j.yyyy-MM。</p>\n<p>另外，也可以指定按周、天、时、分等来滚动日志文件，对应的格式如下：</p>\n<ol>\n<li>‘.’yyyy-MM：每月</li>\n<li>‘.’yyyy-ww：每周</li>\n<li>‘.’yyyy-MM-dd：每天</li>\n<li>‘.’yyyy-MM-dd-a：每天两次</li>\n<li>‘.’yyyy-MM-dd-HH：每小时</li>\n<li>‘.’yyyy-MM-dd-HH-mm：每分钟</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger=info,api_stdout</span><br><span class=\"line\"></span><br><span class=\"line\">log4j.appender.api_stdout=org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">log4j.appender.api_stdout.File= $&#123;api.logs.dir&#125;/api_stdout.log</span><br><span class=\"line\">log4j.appender.api_stdout.Append = true</span><br><span class=\"line\">log4j.appender.api_stdout.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.api_stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss SSS&#125; [%p] (%F:%L) %c %t %m%n</span><br><span class=\"line\">log4j.appender.api_stdout.DatePattern = &#x27;.&#x27;yyyy-MM-dd_HH</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"完整实例\"><a href=\"#完整实例\" class=\"headerlink\" title=\"完整实例\"></a>完整实例</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log4j.rootLogger=DEBUG,console,dailyFile,im</span><br><span class=\"line\">log4j.additivity.org.apache=true</span><br><span class=\"line\"># 控制台(console)</span><br><span class=\"line\">log4j.appender.console=org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.console.Threshold=DEBUG</span><br><span class=\"line\">log4j.appender.console.ImmediateFlush=true</span><br><span class=\"line\">log4j.appender.console.Target=System.err</span><br><span class=\"line\">log4j.appender.console.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.console.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"># 日志文件(logFile)</span><br><span class=\"line\">log4j.appender.logFile=org.apache.log4j.FileAppender</span><br><span class=\"line\">log4j.appender.logFile.Threshold=DEBUG</span><br><span class=\"line\">log4j.appender.logFile.ImmediateFlush=true</span><br><span class=\"line\">log4j.appender.logFile.Append=true</span><br><span class=\"line\">log4j.appender.logFile.File=D:/logs/log.log4j</span><br><span class=\"line\">log4j.appender.logFile.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.logFile.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"># 回滚文件(rollingFile)</span><br><span class=\"line\">log4j.appender.rollingFile=org.apache.log4j.RollingFileAppender</span><br><span class=\"line\">log4j.appender.rollingFile.Threshold=DEBUG</span><br><span class=\"line\">log4j.appender.rollingFile.ImmediateFlush=true</span><br><span class=\"line\">log4j.appender.rollingFile.Append=true</span><br><span class=\"line\">log4j.appender.rollingFile.File=D:/logs/log.log4j</span><br><span class=\"line\">log4j.appender.rollingFile.MaxFileSize=200KB</span><br><span class=\"line\">log4j.appender.rollingFile.MaxBackupIndex=50</span><br><span class=\"line\">log4j.appender.rollingFile.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.rollingFile.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"># 定期回滚日志文件(dailyFile)</span><br><span class=\"line\">log4j.appender.dailyFile=org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">log4j.appender.dailyFile.Threshold=DEBUG</span><br><span class=\"line\">log4j.appender.dailyFile.ImmediateFlush=true</span><br><span class=\"line\">log4j.appender.dailyFile.Append=true</span><br><span class=\"line\">log4j.appender.dailyFile.File=D:/logs/log.log4j</span><br><span class=\"line\">log4j.appender.dailyFile.DatePattern=&#x27;.&#x27;yyyy-MM-dd</span><br><span class=\"line\">log4j.appender.dailyFile.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.dailyFile.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"># 应用于socket</span><br><span class=\"line\">log4j.appender.socket=org.apache.log4j.RollingFileAppender</span><br><span class=\"line\">log4j.appender.socket.RemoteHost=localhost</span><br><span class=\"line\">log4j.appender.socket.Port=5001</span><br><span class=\"line\">log4j.appender.socket.LocationInfo=true</span><br><span class=\"line\"># Set up for Log Factor 5</span><br><span class=\"line\">log4j.appender.socket.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.socket.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"># Log Factor 5 Appender</span><br><span class=\"line\">log4j.appender.LF5_APPENDER=org.apache.log4j.lf5.LF5Appender</span><br><span class=\"line\">log4j.appender.LF5_APPENDER.MaxNumberOfRecords=2000</span><br><span class=\"line\"># 发送日志到指定邮件</span><br><span class=\"line\">log4j.appender.mail=org.apache.log4j.net.SMTPAppender</span><br><span class=\"line\">log4j.appender.mail.Threshold=FATAL</span><br><span class=\"line\">log4j.appender.mail.BufferSize=10</span><br><span class=\"line\">log4j.appender.mail.From = xxx@mail.com</span><br><span class=\"line\">log4j.appender.mail.SMTPHost=mail.com</span><br><span class=\"line\">log4j.appender.mail.Subject=Log4J Message</span><br><span class=\"line\">log4j.appender.mail.To= xxx@mail.com</span><br><span class=\"line\">log4j.appender.mail.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.mail.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"># 应用于数据库</span><br><span class=\"line\">log4j.appender.database=org.apache.log4j.jdbc.JDBCAppender</span><br><span class=\"line\">log4j.appender.database.URL=jdbc:mysql://localhost:3306/test</span><br><span class=\"line\">log4j.appender.database.driver=com.mysql.jdbc.Driver</span><br><span class=\"line\">log4j.appender.database.user=root</span><br><span class=\"line\">log4j.appender.database.password=</span><br><span class=\"line\">log4j.appender.database.sql=INSERT INTO LOG4J (Message) VALUES(&#x27;=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n&#x27;)</span><br><span class=\"line\">log4j.appender.database.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.database.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"></span><br><span class=\"line\"># 自定义Appender</span><br><span class=\"line\">log4j.appender.im = net.cybercorlin.util.logger.appender.IMAppender</span><br><span class=\"line\">log4j.appender.im.host = mail.cybercorlin.net</span><br><span class=\"line\">log4j.appender.im.username = username</span><br><span class=\"line\">log4j.appender.im.password = password</span><br><span class=\"line\">log4j.appender.im.recipient = corlin@cybercorlin.net</span><br><span class=\"line\">log4j.appender.im.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.im.layout.ConversionPattern=[%-5p] %d(%r) --&gt; [%t] %l: %m %x %n</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>参考</p>\n<p><a href=\"https://github.com/digoal/blog/blob/master/201701/20170126_01.md\">https://github.com/digoal/blog/blob/master/201701/20170126_01.md</a></p>\n<p><a href=\"https://www.jianshu.com/p/c6c543e4975e\">https://www.jianshu.com/p/c6c543e4975e</a></p>\n<p><a href=\"https://www.jianshu.com/p/ccafda45bcea\">https://www.jianshu.com/p/ccafda45bcea</a></p>\n","categories":["javax","log4j"],"tags":["日志"]},{"title":"Hexo部署到个人服务器","url":"/2020/01/14/Hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"<blockquote>\n<p>之前一直把 Hexo 博客托管在 github page 上，但是最近发现 github page 的打开速度越来越慢，有时候不翻墙甚至打不开，严重影响我写博客的心情，所以考虑把 Hexo 博客部署到个人服务器上，可以提高访问速度。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h2><ul>\n<li>本地已经安装好 Hexo 环境</li>\n<li>一台云服务器</li>\n<li>一个注册域名（可跳过）</li>\n</ul>\n<p>基本思路：</p>\n<ol>\n<li><p>在服务器上安装 nginx 和 git ，用 nginx 来托管 Hexo 静态文件，用 git 搭建个人仓库用于存储本地提交，git 仓库和 nginx 托管目录使用钩子关联，保证每次本地 git 提交后都能更新 nginx 托管目录。</p>\n</li>\n<li><p>本地设置 Hexo 的部署目录为服务器的个人仓库地址，保证每次部署的时候都能自动 git 提交</p>\n</li>\n<li><p>设置域名解析指向服务器</p>\n</li>\n</ol>\n<p>最终达到的效果：本地编辑文章完成后，使用一个部署命令即可更新服务器资源，使用域名访问可以实时看到更新后的资源。</p>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><h3 id=\"安装配置nginx\"><a href=\"#安装配置nginx\" class=\"headerlink\" title=\"安装配置nginx\"></a>安装配置nginx</h3><h4 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y nginx</span><br></pre></td></tr></table></figure>\n\n<p>yum 安装的 nginx 默认安装目录为 <code>/etc/nginx</code>，nginx 全局配置文件路径为 <code>/etc/nginx/nginx.conf</code></p>\n<p>如果安装失败可以尝试加上 <code>sudo</code> 命令</p>\n<h4 id=\"2、检查nginx是否安装成功\"><a href=\"#2、检查nginx是否安装成功\" class=\"headerlink\" title=\"2、检查nginx是否安装成功\"></a>2、检查nginx是否安装成功</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx -v</span><br></pre></td></tr></table></figure>\n\n<p>显示nginx版本号例如 <code>nginx version: nginx/1.16.1</code> 表示安装成功</p>\n<h4 id=\"3、修改nginx配置\"><a href=\"#3、修改nginx配置\" class=\"headerlink\" title=\"3、修改nginx配置\"></a>3、修改nginx配置</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen <span class=\"number\">80</span>;</span><br><span class=\"line\">    listen [::]:<span class=\"number\">80</span>;</span><br><span class=\"line\">    root /data/hexo; <span class=\"comment\"># 设置为hexo静态文件存放的目录，也是git钩子指向的目录</span></span><br><span class=\"line\">    server_name laoyuyu.me www.laoyuyu.me; <span class=\"comment\"># 如果需要改域名访问，修改server_name 为域名便可</span></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>保存后我们可以使用下面命令检查配置有没问题</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br></pre></td></tr></table></figure>\n\n<p>输出以下内容表示配置没问题，如果有错误会打印详细信息</p>\n<figure class=\"highlight text\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4、启动\"><a href=\"#4、启动\" class=\"headerlink\" title=\"4、启动\"></a>4、启动</h4><p>启动nginx</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl start nginx.service</span><br></pre></td></tr></table></figure>\n\n<p>下面为nginx相关命令，如果你的系统版本是 centos 7 以上，可以使用 <code>Systemd</code> 相关命令进行操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 设置开机启动</span><br><span class=\"line\">systemctl enable nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止开机启动</span><br><span class=\"line\">systemctl disable nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 启动</span><br><span class=\"line\">systemctl start nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止</span><br><span class=\"line\">systemctl stop nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 重启</span><br><span class=\"line\">systemctl restart nginx</span><br></pre></td></tr></table></figure>\n\n<p>如果系统是旧版本，可以使用 <code>SysVinit</code> 相关命令进行操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 设置开机启动</span><br><span class=\"line\">chkconfig nginx on</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止开机启动</span><br><span class=\"line\">chkconfig nginx off</span><br><span class=\"line\"></span><br><span class=\"line\"># 启动</span><br><span class=\"line\">service nginx start</span><br><span class=\"line\"></span><br><span class=\"line\"># 停止</span><br><span class=\"line\">service nginx stop</span><br><span class=\"line\"></span><br><span class=\"line\"># 重启</span><br><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装配置git\"><a href=\"#安装配置git\" class=\"headerlink\" title=\"安装配置git\"></a>安装配置git</h3><h4 id=\"1、安装-1\"><a href=\"#1、安装-1\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install git -y</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、查看是否安装成功\"><a href=\"#2、查看是否安装成功\" class=\"headerlink\" title=\"2、查看是否安装成功\"></a>2、查看是否安装成功</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git —version</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、创建git用户，用来运行git服务\"><a href=\"#3、创建git用户，用来运行git服务\" class=\"headerlink\" title=\"3、创建git用户，用来运行git服务\"></a>3、创建git用户，用来运行git服务</h4><p>创建系统用户git</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">adduser git</span><br></pre></td></tr></table></figure>\n\n<p>设置密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">passwd git</span><br></pre></td></tr></table></figure>\n\n<p>切换到 git 用户，这步很重要</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">su git</span><br></pre></td></tr></table></figure>\n\n<p>创建 hexo 静态文件存放目录，对应上面 nginx 的 root 目录</p>\n<p>注意这一步如果显示没有权限创建目录，可以以 root 用户执行 <code>chmod 777 /data</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir /data/hexo</span><br></pre></td></tr></table></figure>\n\n<p>创建 git 私人仓库目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir /data/repo</span><br></pre></td></tr></table></figure>\n\n<p>在私人仓库下创建一个裸露仓库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd /data/repo</span><br><span class=\"line\"></span><br><span class=\"line\">git init --bare blog.git</span><br></pre></td></tr></table></figure>\n\n<p>创建 git 钩子，把裸露仓库和 hexo 静态文件存放目录关联起来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>\n\n<p>添加以下内容，其中 <code>/data/hexo</code> 为 hexo 静态文件存放目录，<code>/data/repo/blog.git</code> 为裸露仓库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git --work-tree=/data/hexo --git-dir=/data/repo/blog.git checkout -f</span><br></pre></td></tr></table></figure>\n\n<p>保存后添加权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod +x post-receive</span><br><span class=\"line\"></span><br><span class=\"line\">exit // 退出到 root 登录</span><br><span class=\"line\"></span><br><span class=\"line\">chown -R git:git /data/repo/blog.git // 添加权限</span><br></pre></td></tr></table></figure>\n\n<p>测试 git 仓库是否可用，在本地执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone git@server_ip:/data/repo/blog.git</span><br></pre></td></tr></table></figure>\n\n<p>如果能把空仓库拉下来说明 git 仓库搭建成功了，<strong>注意这时候执行这个命令需要输入密码的</strong>。</p>\n<h4 id=\"4、设置-git-仓库安全控制\"><a href=\"#4、设置-git-仓库安全控制\" class=\"headerlink\" title=\"4、设置 git 仓库安全控制\"></a>4、设置 git 仓库安全控制</h4><p>找到本地创建的 <code>id_rsa.pub</code> 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">open ~/.ssh</span><br></pre></td></tr></table></figure>\n\n<p>本地电脑和 git 仓库建立 ssh 联系</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-copy-id -i C:/Users/yourname/.ssh/id_rsa.pub git@server_ip</span><br></pre></td></tr></table></figure>\n\n<p>测试能否登陆，<strong>注意这个时候登陆是不需要密码的，再执行 <code>git clone</code> 命令也不需要密码</strong>，否则就有问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh git@server_ip</span><br></pre></td></tr></table></figure>\n\n<p>为了安全起见禁用 git 用户的 shell 登录权限，从而只能用 git clone，git push 等登录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 查看 git-shell 是否在登录方式里面</span><br><span class=\"line\">cat /etc/shells</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看 git-shell 目录</span><br><span class=\"line\">which git-shell</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加第2步显示的路径</span><br><span class=\"line\">vim /etc/shells</span><br></pre></td></tr></table></figure>\n\n<p>修改 <code>/etc/passwd</code> 中的权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 将原来的</span><br><span class=\"line\">git:x:1000:1000::/home/git:/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">// 修改为</span><br><span class=\"line\">git:x:1000:1000:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"本地配置\"><a href=\"#本地配置\" class=\"headerlink\" title=\"本地配置\"></a>本地配置</h2><h3 id=\"配置-config-yml文件\"><a href=\"#配置-config-yml文件\" class=\"headerlink\" title=\"配置_config.yml文件\"></a>配置_config.yml文件</h3><p>进入 hexo 安装目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim _config.yml</span><br></pre></td></tr></table></figure>\n\n<p>设置 deploy 属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@server_ip:/data/repo/blog.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置package-json文件\"><a href=\"#配置package-json文件\" class=\"headerlink\" title=\"配置package.json文件\"></a>配置package.json文件</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;start&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;,</span><br><span class=\"line\">  &quot;debug&quot;: &quot;hexo clean &amp;&amp; hexo g&quot;,</span><br><span class=\"line\">  &quot;deploy&quot;: &quot;hexo clean &amp;&amp; hexo g -d&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们可以快速本地启动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm run start</span><br></pre></td></tr></table></figure>\n\n<p>本地调试</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm run debug</span><br></pre></td></tr></table></figure>\n\n<p>部署到远程服务器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm run deploy</span><br></pre></td></tr></table></figure>\n\n<p>至此我们的本地环境和服务器环境已经搭建完毕。</p>\n<h2 id=\"域名配置\"><a href=\"#域名配置\" class=\"headerlink\" title=\"域名配置\"></a>域名配置</h2><p>如果你有个人域名，可以设置个人域名指向你的服务器ip</p>\n<p>以阿里云域名为例，登陆域名控制台，域名列表——操作——解析——添加记录</p>\n<p><img src=\"/.com//domain1.png\" alt=\"domain1\"></p>\n<p>可以添加 <code>www</code> 和 <code>@</code> 两条主机记录，这样可以同时支持 <a href=\"http://www.domain.cn/\">www.domain.cn</a> 和 domain.cn 两种访问方式。</p>\n<p><img src=\"/.com//domain2.png\" alt=\"domain2\"></p>\n<p>保存 10 分钟后即生效。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://juejin.im/post/5b70d68ae51d45665d383281\">带你跳过各种坑，一次性把 Hexo 博客部署到自己的服务器</a></p>\n<p><a href=\"https://www.jianshu.com/p/70bf58c48010\">HEXO 部署到云服务器详细指南</a></p>\n<p><a href=\"https://blog.csdn.net/u012486840/article/details/52610320\">CentOS 7 yum 安装 Nginx</a></p>\n","categories":["工具","Hexo"],"tags":["Hexo"]},{"title":"js正则表达式","url":"/2018/09/05/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"<blockquote>\n<p>正则表达式具有复杂字符串搜寻，替换，验证等强大功能，最近接触了 js 的正则表达式顺便学习了一下基础，在这里记录一下学习相关资料。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>下面有两篇文章较为详细地介绍了 js 正则表达式的基础内容和一些实践例子，先直接贴链接，以后有时间再详细介绍内容：</p>\n<p><a href=\"https://www.jianshu.com/p/67e3bcafdd46\">JavaScript 正则表达式（实例）</a></p>\n<p><a href=\"http://imweb.io/topic/56e804ef1a5f05dc50643106\">玩转JavaScript正则表达式</a></p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"RexExp-对象\"><a href=\"#RexExp-对象\" class=\"headerlink\" title=\"RexExp 对象\"></a>RexExp 对象</h3><h4 id=\"RexExp-对象是什么\"><a href=\"#RexExp-对象是什么\" class=\"headerlink\" title=\"RexExp 对象是什么\"></a>RexExp 对象是什么</h4><p>RexExp 对象是一个全局对象，用于存储模式匹配期间找到的对象。</p>\n<ul>\n<li>RexExp 对象的写法是 <strong>RexExp.$n</strong>，RexExp.$1，RexExp.$2……RexExp.$99，一共可以存储 99 个对象。</li>\n<li>每次在调用 <strong>非全局的</strong>（没有 g 修饰）文本匹配方法，例如<code>RegExp.prototype.exec(str)</code>、 <code>String.prototype.match(reg)</code> 或者 <code>String.prototype.replace(reg)</code> 时，当找到匹配项时，<em><strong>RexExp.$1 对应匹配项中第一个括号中的内容，RexExp.$2 对应匹配项中第二个括号中的内容，以此类推</strong></em>。也就是说 RexExp 对象只储存括号里面的内容。</li>\n<li>每次找到匹配项都会 <em><strong>更新所有 RexExp 对象</strong></em>，也就是说 RexExp.$1，RexExp.$2……这些对象全都会被更新。</li>\n</ul>\n<p>这么说可能有点抽象，看下下面的例子就明白了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var reg1 = /\\d(\\w)/;</span><br><span class=\"line\">var reg2 = /\\d(\\w)/g;</span><br><span class=\"line\">var str = &#x27;$1a2b3c4d5e&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">//非全局匹配</span><br><span class=\"line\">var rs1 = str.match(reg1)</span><br><span class=\"line\">console.log(rs1) //[&quot;1a&quot;, &quot;a&quot;, index: 1, input: &quot;$1a2b3c4d5e&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">//全局匹配</span><br><span class=\"line\">var rs2 = str.match(reg2)</span><br><span class=\"line\">console.log(rs2) //[&quot;1a&quot;, &quot;2b&quot;, &quot;3c&quot;, &quot;4d&quot;, &quot;5e&quot;]</span><br></pre></td></tr></table></figure>\n\n<p>在上面非全局匹配中返回的数组信息有</p>\n<ul>\n<li>第一个元素 1a 是找到的第一个匹配项。</li>\n<li>第二个元素对应 RegExp.$1 存储的内容。因为正则表达式<code>\\d(\\w)</code> 有一个括号 <code>(\\w)</code>，对应匹配项 1a 里面的 a，所以 a 会被存储在 RegExp.$1 中。</li>\n<li>index: 1 表示找到匹配项首字符的位置。</li>\n<li>input: “1a2b3c4d5e” 表示输入的查找字符串。</li>\n</ul>\n<p>但是在全局匹配返回的数组里面，就只有所有的匹配项信息，RegExp对象、index 和 input 这些信息都没有保存。</p>\n<h4 id=\"RexExp-对象怎么用\"><a href=\"#RexExp-对象怎么用\" class=\"headerlink\" title=\"RexExp 对象怎么用\"></a>RexExp 对象怎么用</h4><p>那么这些 RexExp 对象有什么作用呢？其中最重要的一个作用是用子匹配项 RexExp.$n 来替换原来的文本内容。比如我们想把 ‘2016-11-25’ 变成 ‘11&#x2F;25&#x2F;2016’，这时候用 RexExp 对象就会非常方便</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x27;2016-11-25&#x27;.replace(/(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/g,&#x27;$2/$3/$1&#x27;) //&#x27;11/25/2016&#x27;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>下面收集了在工作中常用到的一些正则表达式的例子，在这里记录一下以供日后查阅</p>\n<h3 id=\"控制输入框金额的正确性\"><a href=\"#控制输入框金额的正确性\" class=\"headerlink\" title=\"控制输入框金额的正确性\"></a>控制输入框金额的正确性</h3><p>思路是通过动态修改输入框的内容来控制输入金额的合法性，这里的合法性包括</p>\n<ul>\n<li>输入的必须数字或者小数点.</li>\n<li>整数部分不能是0开头的两位以上数字</li>\n<li>小数部分不能超过两位数字</li>\n<li>不能包含两个以上小数点</li>\n</ul>\n<p>做法是输入框绑定动态输入事件，每次输入内容时候都把内容传进来检查一遍，如果存在不合法的地方进行替换修改，最后把检查完的内容返回输入框显示。这里假设传进来的内容是 <code>value</code>，代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var regStrs = [</span><br><span class=\"line\">  [&#x27;^0(\\\\d+)$&#x27;, &#x27;$1&#x27;], //禁止录入整数部分两位以上，但首位为0</span><br><span class=\"line\">  [&#x27;[^\\\\d\\\\.]+$&#x27;, &#x27;&#x27;], //禁止录入任何非数字和点</span><br><span class=\"line\">  [&#x27;\\\\.(\\\\d?)\\\\.+&#x27;, &#x27;.$1&#x27;], //禁止录入两个以上的点</span><br><span class=\"line\">  [&#x27;^(\\\\d+\\\\.\\\\d&#123;2&#125;).+&#x27;, &#x27;$1&#x27;] //禁止录入小数点后两位以上</span><br><span class=\"line\">]</span><br><span class=\"line\">for (var i = 0; i &lt; regStrs.length; i++) &#123;</span><br><span class=\"line\">  var reg = new RegExp(regStrs[i][0]);</span><br><span class=\"line\">  value = value.replace(reg, regStrs[i][1]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["前端","javascript"],"tags":["javascript"]},{"title":"Netty系列（一）：IO模型","url":"/2020/01/17/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AIO%E6%A8%A1%E5%9E%8B/","content":"<blockquote>\n<p>Netty 是目前比较火的网络编程框架，是 java 进阶的必备知识点，特此记录 Netty 学习过程中的一些知识点用于日后翻阅。本章介绍 Netty 的一些入门准备知识，包括同步和异步、阻塞和非阻塞的区别，还有常见的 IO 模型。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"同步、异步、阻塞和非阻塞\"><a href=\"#同步、异步、阻塞和非阻塞\" class=\"headerlink\" title=\"同步、异步、阻塞和非阻塞\"></a>同步、异步、阻塞和非阻塞</h1><p>这四个概念都是针对一次调用发生的，我们可以这么理解，在一次调用里面存在<code>调用者</code>、<code>被调用者</code>和<code>调用结果</code>这三个概念。</p>\n<h2 id=\"一、同步和异步\"><a href=\"#一、同步和异步\" class=\"headerlink\" title=\"一、同步和异步\"></a>一、同步和异步</h2><p>同步和异步是从<code>调用结果通知机制</code>这个角度来区分的。</p>\n<ul>\n<li><p>同步：调用发生后，<code>调用者</code> 主动去获取 <code>调用结果</code>，这就是同步调用。</p>\n</li>\n<li><p>异步：调用发生后，<code>调用者</code>被动等待 <code>被调用者</code> 通知 <code>调用结果</code>，这就是异步调用。通常过程是，调用发生后，<code>调用者</code>收到一个来自 <code>被调用者</code> 的回执，这个回执内容通常是是 <code>被调用者</code> 告诉 <code>调用者</code> 我已经收到这个任务了，但是这个任务具体什么时候执行，什么时候能得到执行结果，<code>调用者</code> 不需要管。等到执行完成后，<code>被调用者</code> 主动把 <code>调用结果</code> 通知给 <code>调用者</code>，整个调用过程才算完成。</p>\n</li>\n</ul>\n<h2 id=\"二、阻塞和非阻塞\"><a href=\"#二、阻塞和非阻塞\" class=\"headerlink\" title=\"二、阻塞和非阻塞\"></a>二、阻塞和非阻塞</h2><p>阻塞和非阻塞是从 <code>调用者在获取到调用结果前的行为</code> 这个角度进行区分的。</p>\n<ul>\n<li>阻塞：<code>调用者 </code>在获取到 <code>调用结果</code> 前什么都不干，线程整个挂起一直等待 <code>调用结果</code>，这就是阻塞调用。</li>\n<li>非阻塞：<code>调用者</code> 在获取 <code>调用结果 </code>前可以做自己的事情，这就是非阻塞调用。</li>\n</ul>\n<h2 id=\"三、四种概念组合\"><a href=\"#三、四种概念组合\" class=\"headerlink\" title=\"三、四种概念组合\"></a>三、四种概念组合</h2><p>综上所述，同步和异步、阻塞和非阻塞是两套完全不同而且并不矛盾的概念，所以产生以下四种概念组合：</p>\n<ul>\n<li>同步阻塞：<code>调用者</code> 一直挂起什么都不做，主动去获取 <code>调用结果</code>。</li>\n<li>同步非阻塞：<code>调用者 </code>拿到回执后继续做自己的事情，然后通过轮询机制，每隔一段时间去询问<code>调用结果</code>，直到最终获取 <code>调用结果</code>，调用才算完成。</li>\n<li>异步阻塞：<code>调用者</code> 一直挂起什么都不做，直到 <code>被调用者</code> 通知 <code>调用结果</code>。</li>\n<li>异步非阻塞：调用者拿到回执后继续做自己的事情，等到 <code>被调用者</code> 通知<code>调用结果</code>后，调用才算完成。</li>\n</ul>\n<p>这四种概念，是下面常见IO模型的基础。</p>\n<h1 id=\"IO模型\"><a href=\"#IO模型\" class=\"headerlink\" title=\"IO模型\"></a>IO模型</h1><h2 id=\"一、基础概念\"><a href=\"#一、基础概念\" class=\"headerlink\" title=\"一、基础概念\"></a>一、基础概念</h2><p>在进行解释之前，首先要说明几个概念：</p>\n<ul>\n<li>用户空间和内核空间</li>\n<li>进程切换</li>\n<li>进程的阻塞</li>\n<li>文件描述符</li>\n<li>缓存 IO</li>\n</ul>\n<h3 id=\"用户空间与内核空间\"><a href=\"#用户空间与内核空间\" class=\"headerlink\" title=\"用户空间与内核空间\"></a>用户空间与内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间&#96;。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>\n<h3 id=\"进程切换\"><a href=\"#进程切换\" class=\"headerlink\" title=\"进程切换\"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>\n<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>\n<ol>\n<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>\n<li>更新PCB信息。</li>\n<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>\n<li>选择另一个进程执行，并更新其PCB。</li>\n<li>更新内存管理的数据结构。</li>\n<li>恢复处理机上下文。</li>\n</ol>\n<h3 id=\"进程的阻塞\"><a href=\"#进程的阻塞\" class=\"headerlink\" title=\"进程的阻塞\"></a>进程的阻塞</h3><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</p>\n<h3 id=\"文件描述符fd\"><a href=\"#文件描述符fd\" class=\"headerlink\" title=\"文件描述符fd\"></a>文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>\n<p>文件描述符在形式上是一个非负整数。实际上，<code>它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表</code>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>\n<h3 id=\"缓存-IO\"><a href=\"#缓存-IO\" class=\"headerlink\" title=\"缓存 IO\"></a>缓存 IO</h3><p>缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，<code>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</code>。这个概念非常重要！</p>\n<h3 id=\"linux-IO-的过程\"><a href=\"#linux-IO-的过程\" class=\"headerlink\" title=\"linux IO 的过程\"></a>linux IO 的过程</h3><p>结合以上的基础概念，linux IO 的整体流程是 <code>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</code></p>\n<p>对于本地 read IO，分为以下两个阶段：</p>\n<ul>\n<li><p>第一阶段：等待数据准备 (Waiting for the data to be ready)。</p>\n</li>\n<li><p>第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。</p>\n</li>\n</ul>\n<p>对于网络 IO，<code>网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作</code>。对于socket流而言，</p>\n<ul>\n<li>第一阶段：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li>\n<li>第二阶段：把数据从内核缓冲区复制到应用进程缓冲区。</li>\n</ul>\n<h2 id=\"二、五种常见IO模型\"><a href=\"#二、五种常见IO模型\" class=\"headerlink\" title=\"二、五种常见IO模型\"></a>二、五种常见IO模型</h2><p>根据以上基础知识，我们可以得到这样网络 IO 关系：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">网络数据 —&gt; 内核空间 —&gt; 拷贝到用户空间 —&gt; 应用程序收到结果</span><br></pre></td></tr></table></figure>\n\n<p><code>阻塞/非阻塞</code> 概念可以发生在 <code>网络数据—&gt;内核空间</code> 和 <code>内核空间—&gt;拷贝到用户空间</code> 这两个阶段。如果应用程序什么事都不做直到本阶段完成就称作 <code>阻塞</code>，如果应用程序在阶段完成前可以做自己的事情就称作 <code>非阻塞</code>。</p>\n<p><code>同步/异步</code> 概念发生在 <code>应用程序怎么收到结果</code> 这个阶段。如果应用程序主动去获取结果就称作 <code>同步</code>，如果应用程序被动等待内核通知结果就称作 <code>异步</code>。</p>\n<p>这些概念是下面 IO 模型的基础。</p>\n<h3 id=\"1、同步阻塞-IO（blocking-IO）\"><a href=\"#1、同步阻塞-IO（blocking-IO）\" class=\"headerlink\" title=\"1、同步阻塞 IO（blocking IO）\"></a>1、同步阻塞 IO（blocking IO）</h3><h4 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h4><p>同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型。在这个 IO 模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据。</p>\n<p>在等待数据到处理数据的两个阶段，整个进程都被阻塞。不能处理别的网络 IO。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。流程图如下：</p>\n<p><img src=\"/.com//blockingIO.png\" alt=\"blockingIO\"></p>\n<h4 id=\"流程描述\"><a href=\"#流程描述\" class=\"headerlink\" title=\"流程描述\"></a>流程描述</h4><ul>\n<li>第一个阶段：准备数据。当用户进程调用了 <code>recv()/recvfrom()</code> 这个系统调用之后，用户进程就开始阻塞等待数据。对于网络 IO 来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候 kernel 就要等待足够的数据到来。这个过程也需要等待。也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。</li>\n<li>第二个阶段：当kernel 一直等到数据准备好了，它就会将数据从 kernel 中拷贝到用户内存。然后 kernel 返回结果，用户进程才解除 block 的状态，重新运行起来。</li>\n</ul>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p><strong>特点</strong></p>\n<p>在 IO 执行的两个阶段都被阻塞。</p>\n<p><strong>优点</strong></p>\n<ul>\n<li>能够及时返回数据，无延迟。</li>\n<li>对内核开发者来说这是省事了。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<p>性能差，不能支持高并发的应用场景。</p>\n<h3 id=\"2、同步非阻塞-IO（nonblocking-IO）\"><a href=\"#2、同步非阻塞-IO（nonblocking-IO）\" class=\"headerlink\" title=\"2、同步非阻塞 IO（nonblocking IO）\"></a>2、同步非阻塞 IO（nonblocking IO）</h3><h4 id=\"网络模型-1\"><a href=\"#网络模型-1\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h4><p>同步非阻塞就是「每隔一会儿瞄一眼进度条」的轮询方式。在这种模型中，非阻塞也会调用 <code>recvform</code> 系统调用，不管数据是否准备好，内核都会马上返回给进程。如果数据还没准备好，就会返回一个错误代码（EAGAIN 或 EWOULDBLOCK），说明这个命令不能立即满足。进程在返回之后，可以干点别的事情，过一段时间再发起<code>recvform</code> 系统调用，重复上面的过程。这个过程通常被称之为轮询。直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。流程如图所示：</p>\n<p><img src=\"/.com//nonblockingIO.png\" alt=\"nonblockingIO\"></p>\n<h4 id=\"流程描述-1\"><a href=\"#流程描述-1\" class=\"headerlink\" title=\"流程描述\"></a>流程描述</h4><ul>\n<li>用户进程发出 read 操作时，马上就得到了一个结果。<ul>\n<li>kernel中的数据还没有准备好，返回一个 error 信号。</li>\n<li>用户进程接收到一个 error 信号时，就知道数据还没有准备好，这时候用户进程可以去做自己的事情。</li>\n<li>过一段时间再进行 read 操作。一直等到 kernel 中的数据准备好，返回一个数据已经准备好的信号。</li>\n</ul>\n</li>\n<li>用户进程收到数据准备好的信号后，开始阻塞自己，将 kernel 的数据拷到用户进程空间。</li>\n</ul>\n<h4 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p><strong>特点</strong></p>\n<p>nonblocking IO 的特点是用户进程需要不断的主动询问 kernel 数据好了没有。</p>\n<p>同步非阻塞方式相比同步阻塞方式：</p>\n<p><strong>优点</strong></p>\n<p>能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。</p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>任务完成的响应延迟增大了，因为每过一段时间才去轮询一次 read 操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</li>\n<li>由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间</li>\n</ul>\n<h3 id=\"3、IO-多路复用（-IO-multiplexing）\"><a href=\"#3、IO-多路复用（-IO-multiplexing）\" class=\"headerlink\" title=\"3、IO 多路复用（ IO multiplexing）\"></a>3、IO 多路复用（ IO multiplexing）</h3><h4 id=\"网络模型-2\"><a href=\"#网络模型-2\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h4><p>IO 多路复用就是用一个单独的非用户态的进程去完成同步非阻塞的轮询工作。和同步非阻塞 IO 的区别是，同步非阻塞 IO使用用户态的进程去完成这个轮询工作，而 IO多路复用使用 UNIX&#x2F;Linux 下的内核函数 <code>select、poll、epoll</code> 都可以完成这个轮询工作（epoll 比 poll、select 效率高，做的事情是一样的）。我们可以把这类函数的工作称为 select 轮询。</p>\n<p>select 轮询是内核级别的，可以监听多个 socket，能实现同时对多个IO端口进行监听，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用 I&#x2F;O 操作函数。然后进程再进行 recvform 系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。流程图如下：</p>\n<p><img src=\"/.com//IOmultiplexing.png\" alt=\"IOmultiplexing\"></p>\n<h4 id=\"流程描述-2\"><a href=\"#流程描述-2\" class=\"headerlink\" title=\"流程描述\"></a>流程描述</h4><ul>\n<li>当用户进程调用了 select，整个进程会被 block，而同时，kernel 会监视所有 select 负责的 socket</li>\n<li>当任何一个 socket 中的数据准备好了，select 就会返回。</li>\n<li>用户进程开始阻塞，将数据从 kernel 拷贝到用户进程。</li>\n</ul>\n<p>上面的图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。<code>因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)</code>。但是，<code>用select的优势在于它可以同时处理多个connection</code>。</p>\n<h4 id=\"分析-2\"><a href=\"#分析-2\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>如果处理的连接数不是很高的话，使用 select&#x2F;epoll 不一定比使用 multi-threading + blocking IO 性能更好，可能延迟还更大。<strong>select&#x2F;epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</strong>I&#x2F;O 多路复用技术通过把多个 I&#x2F;O 的阻塞复用到同一个 select 的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求，大大降低系统开销小，节省了系统资源。</p>\n<p>I&#x2F;O多路复用的主要应用场景如下：</p>\n<ul>\n<li><p>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。</p>\n</li>\n<li><p>服务器需要同时处理多种网络协议的套接字。</p>\n</li>\n</ul>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>前面三种IO模式，在用户进程进行系统调用的两个阶段：</p>\n<ul>\n<li>第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。</li>\n<li>第二个阶段可以阻塞又可以不阻塞。</li>\n</ul>\n<p><strong>从整个IO过程来看，他们都是同步模型，因为都属于应用程序主动等待且向内核检查状态。</strong></p>\n<h3 id=\"4、异步非阻塞-IO（asynchronous-IO）\"><a href=\"#4、异步非阻塞-IO（asynchronous-IO）\" class=\"headerlink\" title=\"4、异步非阻塞 IO（asynchronous IO）\"></a>4、异步非阻塞 IO（asynchronous IO）</h3><h4 id=\"网络模型-3\"><a href=\"#网络模型-3\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h4><p>相对于同步IO，异步IO不是顺序执行。用户进程进行 aio_read 系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。</p>\n<p>Linux 提供了 AIO 库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如 libevent、libev、libuv。异步过程如下图所示：</p>\n<p><img src=\"/.com//asynchronousIO.png\" alt=\"asynchronousIO\"></p>\n<h4 id=\"流程描述-3\"><a href=\"#流程描述-3\" class=\"headerlink\" title=\"流程描述\"></a>流程描述</h4><ul>\n<li>用户进程发起 aio_read 操作之后，立刻就可以开始去做其它的事。从 kernel 的角度，当它受到一个asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。</li>\n<li>kernel 会等待数据准备完成，然后将数据拷贝到用户内存。</li>\n<li>kernel 会给用户进程发送一个 signal 或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它 read 操作完成了。如果这个进程正在处理别的事情，就看情况进行处理。<ul>\n<li>如果用户态忙着做别的事（例如在计算两个矩阵的乘积），那就强行打断之，调用事先注册的信号处理函数，这个函数可以决定何时以及如何处理这个异步任务。由于信号处理函数是突然闯进来的，因此跟中断处理程序一样，有很多事情是不能做的，因此保险起见，一般是把事件 “登记” 一下放进队列，然后返回该进程原来在做的事。</li>\n<li>如果这个进程正在内核态忙着做别的事，例如以同步阻塞方式读写磁盘，那就只好把这个通知挂起来了，等到内核态的事情忙完了，快要回到用户态的时候，再触发信号通知。</li>\n<li>如果这个进程现在被挂起了，例如无事可做 sleep 了，那就把这个进程唤醒，下次有 CPU 空闲的时候，就会调度到这个进程，触发信号通知。</li>\n</ul>\n</li>\n</ul>\n<p>Linux 的异步 IO（AIO）支持是 2.6.22 才引入的，还有很多系统调用不支持异步 IO。Linux 的异步 IO 最初是为数据库设计的，因此通过异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制。</p>\n<h4 id=\"分析-3\"><a href=\"#分析-3\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>IO 多路复用和 AIO 都适合高并发的应用场景，两者的区别是：</p>\n<ul>\n<li><p>IO多路复用：IO 多路复用是同步非阻塞模式。select 函数所提供的功能（异步阻塞 IO）与 AIO 类似。不过，它是对通知事件进行阻塞，而不是对 IO 调用进行阻塞。当内核数据在准备过程中，select 函数一直被阻塞，等到数据准备完成后会通知应用程序数据准备好了，然后 select 函数的任务就完成了，至于后面把数据从内核空间复制到用户空间（通过阻塞&#x2F;非阻塞形式都可以）这部分工作由应用程序本身完成。</p>\n</li>\n<li><p>AIO：AIO 是异步模式。内核准备数据和把数据从内核空间复制到用户空间这两部分工作都由系统完成，也就是 IO 过程全部由系统控制，当应用程序收到通知的时候用户空间已经准备好数据了。</p>\n</li>\n</ul>\n<h3 id=\"5、信号驱动式IO（signal-driven-IO）\"><a href=\"#5、信号驱动式IO（signal-driven-IO）\" class=\"headerlink\" title=\"5、信号驱动式IO（signal-driven IO）\"></a>5、信号驱动式IO（signal-driven IO）</h3><p>信号驱动式I&#x2F;O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I&#x2F;O操作函数处理数据。过程如下图所示：</p>\n<p><img src=\"/.com//signal-drivenIO.png\" alt=\"signal-drivenIO\"></p>\n<p>信号驱动IO实际使用得不多，所以在这里不做深入介绍。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本章介绍了同步&#x2F;异步、阻塞&#x2F;非阻塞的概念、linux IO的基础概念和五种常见的 IO 模型：</p>\n<ol>\n<li><p>同步和异步是从<code>调用结果通知机制</code>这个角度来区分的。同步调用是指调用发生后，<code>调用者</code>主动去获取<code>调用结果</code>；异步调用是指调用发生后，<code>调用者</code>被动等待<code>被调用者</code>通知<code>调用结果</code>。</p>\n</li>\n<li><p>阻塞和非阻塞是从<code>调用者在获取到调用结果前的行为</code>这个角度进行区分的。阻塞调用是指调用者<code>在获取到</code>调用结果前什么都不干，线程整个挂起一直等待<code>调用结果</code>；非阻塞调用是指<code>调用者</code>在获取<code>调用结果</code>前可以做自己的事情。</p>\n</li>\n<li><p>系统空间分为用户空间和内核空间，内核空间供系统内核使用，用户空间供各个进程使用。</p>\n</li>\n<li><p>进程被挂起，新的进程或者以前被挂起的某个进程恢复执行，这种过程被称作进程切换。进程从运行态转换成阻塞态，这种过程被称作进程阻塞，进程阻塞后不占用cpu资源。</p>\n</li>\n<li><p>文件描述符fd是指向文件的引用的抽象化概念。</p>\n</li>\n<li><p>linux IO的过程：数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>\n</li>\n<li><p>五种常见的 IO 模型：</p>\n<ul>\n<li>同步阻塞 IO（blocking IO）</li>\n<li>同步非阻塞 IO（nonblocking IO）</li>\n<li>IO 多路复用（ IO multiplexing）</li>\n<li>异步非阻塞 IO（asynchronous IO）</li>\n<li>信号驱动式IO（signal-driven IO）</li>\n</ul>\n<p>其中 IO 多路复用模型是 netty IO 模型的基础，必须要掌握，五种 IO 模型流程简单总结如下：</p>\n<p><img src=\"/.com//fiveIO.png\" alt=\"fiveIO\"></p>\n</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.jianshu.com/p/486b0965c296\">聊聊Linux 五种IO模型</a></p>\n<p><a href=\"https://www.jianshu.com/p/aed6067eeac9\">聊聊同步、异步、阻塞与非阻塞</a></p>\n","categories":["Netty"],"tags":["Netty"]},{"title":"Netty系列（二）：Netty是什么","url":"/2020/01/18/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ANetty%E6%98%AF%E4%BB%80%E4%B9%88/","content":"<blockquote>\n<p>上一篇文章介绍了 netty 的同步&#x2F;异步&#x2F;阻塞&#x2F;非阻塞的概念和四种常用 IO 模型。本文介绍网络编程的发展，从 bio 发展到 nio 最后到 netty，我们可以感受到 netty 给网络编程带来的极大便利性。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>网络编程，简单来说就是实现一个客户端与服务端进行网络通信的程序。我们从最传统的 BIO 开始介绍，本章只做简单介绍，不涉及深入原理。</p>\n<h2 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h2><p>BIO 全称是 Blocking IO，是 JDK1.4 之前的传统 IO 模型，本身是同步阻塞模式。 </p>\n<p>BIO分为 ServerSocket 和 Socket 两种类，分别对应服务端和客户端。</p>\n<h3 id=\"ServerSocket\"><a href=\"#ServerSocket\" class=\"headerlink\" title=\"ServerSocket\"></a>ServerSocket</h3><p>ServerSocket 对象在服务端运行，负责接收客户端连接。</p>\n<ol>\n<li><p>服务端调用 <code>ServerSocket serverSocket = new ServerSocket(600);</code> 绑定一个本地端口用于接收客户端请求。</p>\n</li>\n<li><p>然后调用 <code>serverSocket.accept()</code> ，这个方法的执行将使 Server 端一直阻塞，直到捕捉到一个来自 Client 端的请求，并返回一个用于与该 Client 通信的 Socket 对象 Link-Socket。此后 Server 程序只要向这个 Socket 对象读写数据，就可以实现向远端的 Client 读写数据。</p>\n</li>\n<li><p><code>serverSocket</code> 可以接收多次客户端请求，当需要结束服务端程序时调用 <code>serverSocket.close()</code>。</p>\n</li>\n</ol>\n<p>ServerSocket 一般仅用于设置端口号和监听，真正进行通信的是服务器端的 Socket 与客户端的 Socket，在ServerSocket 进行 accept 之后，就将主动权转让了。</p>\n<h3 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h3><p>客户端通过创建 Socket 对象，向服务端发起连接。</p>\n<ol>\n<li>客户端调用 <code>Socket socket = new Socket(“127.0.0.1”，600);</code>，创建到服务端的连接。第一个参数是 Server 的主机地址，第二个参数是 Server 绑定的端口号。</li>\n<li>在服务端和客户端之间创建连接后，调用 <code>OutputStream outputStream = socket.getOutputStream()</code> 和 <code>InputStream inputStream = socket.getInputStream()</code> 获取输出&#x2F;输出流，然后可以调用 <code>outputStream.write()</code> 和 <code>inputStream.read()</code> 向服务器端写&#x2F;读数据。</li>\n<li>客户端活动完成调用 <code>socket.close()</code> 结束客户端程序。</li>\n</ol>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p><strong>服务端代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class BIOServer &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException &#123;</span><br><span class=\"line\">        // 服务端绑定本地端口并启动</span><br><span class=\"line\">        ServerSocket serverSocket = new ServerSocket(7000);</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            // accept() 会阻塞服务端，直到获取到一个客户端的请求</span><br><span class=\"line\">            Socket socket = serverSocket.accept();</span><br><span class=\"line\">            // 接收到客户端请求后，开始读取数据</span><br><span class=\"line\">            byte[] data = new byte[1024];</span><br><span class=\"line\">            InputStream inputStream = socket.getInputStream();</span><br><span class=\"line\">            while (true) &#123;</span><br><span class=\"line\">                int len;</span><br><span class=\"line\">                // 按字节流方式读取数据</span><br><span class=\"line\">                while ((len = inputStream.read(data)) != -1) &#123;</span><br><span class=\"line\">                    System.out.println(new String(data, 0, len) + &quot; receive&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是最简单的服务端代码，服务端代码创建一个 <code>ServerSocket</code> 用于监听本地 7000 端口，然后在死循环里面调用 serverSocket.accept() 阻塞服务端直到获取到一个客户端连接，最后以字节流方式读取客户端数据并打印。</p>\n<p><strong>客户端代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class BIOClient &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class=\"line\">        Socket socket = new Socket(&quot;127.0.0.1&quot;, 7000);</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            String str = new Date() + &quot;: hello world&quot;;</span><br><span class=\"line\">            socket.getOutputStream().write(str.getBytes());</span><br><span class=\"line\">            socket.getOutputStream().flush();</span><br><span class=\"line\">            System.out.println(str + &quot; send&quot;);</span><br><span class=\"line\">            Thread.sleep(2000);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>服务端代码连接本地 7000 端口，每隔两秒向服务端发送 “hello world” 的数据。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>BIO 编程模型在客户端较少的情况下运行良好，但是对于客户端比较多的业务来说，单机服务端可能需要支撑成千上万的连接，BIO 模型可能就不太合适了。</p>\n<p>从服务端代码中我们可以看到，在传统的 BIO 模型中，每个连接创建成功之后都需要一个线程来维护，每个线程包含一个 while 死循环，那么 1w 个连接对应 1w 个线程，继而 1w 个 while 死循环，这就带来如下几个问题：</p>\n<ol>\n<li>线程资源受限：线程是操作系统中非常宝贵的资源，同一时刻有大量的线程处于阻塞状态是非常严重的资源浪费，操作系统耗不起</li>\n<li>线程切换效率低下：单机 cpu 核数固定，线程爆炸之后操作系统频繁进行线程切换，应用性能急剧下降。</li>\n<li>数据读写是以字节流为单位，效率不高。</li>\n</ol>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><p>为了解决 BIO 存在的问题，在 Java 1.4 中引入了 NIO 框架。 NIO 可以理解为 Non-blocking。</p>\n<p>在传统的 BIO 模型中一个连接对应一个 while 死循环，死循环的目的就是不断监测这条连接上是否有数据可以读，大多数情况下，1w个连接里面同一时刻只有少量的连接有数据可读，因此，很多个while死循环都白白浪费掉了，因为读不出啥数据。</p>\n<div style=\"width: 80%; margin: auto\">![bio](bio.png)</div>\n而在NIO模型中，他把这么多 while 死循环变成一个死循环，这个死循环由一个线程控制。这个线程就是 NIO 模型中的 selector。一条连接来了直接把这条连接注册到 selector 上，通过检查这个selector，就可以批量监测出有数据可读的连接，进而读取数据。这样导致线程数量大大减少。\n\n<div style=\"width: 80%; margin: auto\">![nio](nio.png)</div>\nNIO 提供了 Channel、Buffer 和 Selector 三个核心组件。BIO 基于字节流和字符流进行操作，而 NIO 基于Channel 和 Buffer 进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector 用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。整体流程大致如下：\n\n<div style=\"width: 80%; margin: auto\">![component](component.png)</div>\n### Channel\n\n<p>Channel 类似于 BIO 中的 Stream。只不过 Stream 是单向的，譬如：InputStream, OutputStream.而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。</p>\n<p>NIO 中的 Channel 的主要实现有：</p>\n<ul>\n<li>FileChannel</li>\n<li>DatagramChannel</li>\n<li>SocketChannel</li>\n<li>ServerSocketChannel</li>\n</ul>\n<p>分别可以对应文件 IO、UDP 和 TCP（Client 和 Server）</p>\n<h3 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h3><p>BIO 模型中，每次都是从操作系统底层一个字节一个字节地读取数据，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。</p>\n<p>而 NIO 维护一个缓冲区 Buffer，在读取数据时，它是直接读到缓冲区中的；在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p>\n<p>与Java基本类型相对应，NIO 提供了多种 Buffer 类型，如 ByteBuffer、CharBuffer、IntBuffer等，区别就是读写缓冲区时的单位长度不一样（以对应类型的变量为单位进行读写）。</p>\n<p>Buffer 中有三个很重要的变量：</p>\n<ul>\n<li>capacity：缓冲区数组的总长度</li>\n<li>position：下一个要操作的数据元素的位置</li>\n<li>limit：读&#x2F;写边界位置，limit&lt;&#x3D;capacity</li>\n</ul>\n<p>我们读写 buffer 的流程一般如下：</p>\n<ol>\n<li>通过 <code>ByteBuffer.allocate(11)</code> 方法创建了一个 11 个 byte 的数组的缓冲区，初始状态如上图，position 的位置为 0，capacity 和 limit 默认都是数组长度。这个时候 ByteBuffer 处于写模式，等待 Channel 数据写入。</li>\n</ol>\n<div style=\"width: 50%; margin: auto\">![buffer1](buffer1.png)</div>\n2. 写入 5 个字节，postion 移动了 5 个位置，limit 和 capacity 保持不变。\n\n<div style=\"width: 50%; margin: auto\">![buffer2](buffer2.png)</div>\n3. 调用 `ByteBuffer.flip()` 方法，将写模式改成读模式，position 设回 0，并将 limit 设成之前的 position 的值。这时 position 到 limit 这个区间内的就是可读数据。\n\n<div style=\"width: 50%; margin: auto\">![buffer3](buffer3.png)</div>\n4. 在下一次写数据之前我们调用 `ByteBuffer.clear()` 方法，将读模式改成写模式。缓冲区的索引位置又回到了初始位置。注意这个时候 Buffer 中的数据并未被清除，只是这些标记告诉我们可以从哪里开始往 Buffer 里写数据。\n5. 如果 Buffer 中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用 `ByteBuffer.compact()` 方法。将所有未读的数据拷贝到 Buffer 起始处，然后将 position 设到最后一个未读元素正后面。limit 属性依然像 clear() 方法一样，设置成 capacity。现在 Buffer 准备好写数据了，但是不会覆盖未读的数据。\n6. 如果你有一部分数据需要重复读写，调用 `ByteBuffer.mark()` 方法，可以标记 Buffer 中的一个特定的 position，之后可以通过调用 `ByteBuffer.reset()` 方法恢复到这个position。\n7. 如果你需要将同一个 Buffer 的数据写入多个通道时，在第一次读取完 Buffer 后，调用 `ByteBuffer.rewind()` 方法，将 position 设回 0，limit 保持不变，这样就可以重读 Buffer 中的所有数据。\n\n<h3 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h3><p>Selector 可以理解为一个单线程管理器，管理多个 Channel。我们将 Channel 注册到 Selector 上，然后设置关注的事件，然后调用 Selector.select() 方法，等待事件发生。</p>\n<p>Selector 可以监听以下四种事件，并对应 SelectionKey 的四个常量：</p>\n<ul>\n<li><p>Connect：连接就绪事件，客户端 channel 成功连接到服务器上，对应 SelectionKey.OP_CONNECT</p>\n</li>\n<li><p>Accept：接收就绪事件，服务端 socket channel 准备好接收客户端的连接，对应 SelectionKey.OP_ACCEPT</p>\n</li>\n<li><p>Read：读就绪事件，channel 有数据可读，对应 SelectionKey.OP_READ</p>\n</li>\n<li><p>Write：写就绪事件，准备写数据到 channel，对应 SelectionKey.OP_WRITE</p>\n</li>\n</ul>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p><strong>服务端代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class NIOServer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void initServer() throws IOException &#123;</span><br><span class=\"line\">        // 创建 serverSelector</span><br><span class=\"line\">        Selector serverSelector = Selector.open();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建 serverSocketChannel，设置为非阻塞，并绑定本地端口</span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        serverSocketChannel.configureBlocking(false);</span><br><span class=\"line\">        serverSocketChannel.socket().bind(new InetSocketAddress(7000));</span><br><span class=\"line\"></span><br><span class=\"line\">        // 把 serverSocketChannel 注册到 selector 上并设置关心事件为 ON_ACCEPT 事件，ACCEPT 事件表明这是一个服务器 channel</span><br><span class=\"line\">        SelectionKey selectionKey = serverSocketChannel.register(serverSelector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">        //轮询</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            // select() 会一直阻塞，直到有事件发生</span><br><span class=\"line\">            serverSelector.select();</span><br><span class=\"line\">            // 运行到这一步说明已经有事件发生，获取并遍历的所有事件key集合</span><br><span class=\"line\">            Set keys = serverSelector.selectedKeys();</span><br><span class=\"line\">            Iterator iterator = keys.iterator();</span><br><span class=\"line\">            while (iterator.hasNext()) &#123;</span><br><span class=\"line\">                // 获取 key 示例</span><br><span class=\"line\">                SelectionKey key = (SelectionKey) iterator.next();</span><br><span class=\"line\">                // 删除 key 实例，因为 selector 不会删除 key 实例，需要手动删除</span><br><span class=\"line\">                iterator.remove();</span><br><span class=\"line\">                if (key.isAcceptable()) &#123;</span><br><span class=\"line\">                    // 服务端待连接就绪事件</span><br><span class=\"line\">                    doAccept(key);</span><br><span class=\"line\">                &#125; else if (key.isReadable()) &#123;</span><br><span class=\"line\">                    // 读就绪事件</span><br><span class=\"line\">                    doRead(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void doAccept(SelectionKey key) throws IOException &#123;</span><br><span class=\"line\">        // 当 accept 事件发生的时候，创建 clientChannel 注册到 serverSelector 上并注册关心事件为 OP_READ 和 OP_WRITE，等待读/写事件发生</span><br><span class=\"line\">        System.out.println(&quot;服务端等待客户端连接就绪&quot;);</span><br><span class=\"line\">        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();</span><br><span class=\"line\">        SocketChannel clientChannel = serverChannel.accept();</span><br><span class=\"line\">        clientChannel.configureBlocking(false);</span><br><span class=\"line\">        clientChannel.register(key.selector(), SelectionKey.OP_READ);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void doRead(SelectionKey key) throws IOException &#123;</span><br><span class=\"line\">        System.out.println(&quot;服务端开始读取数据&quot;);</span><br><span class=\"line\">        SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class=\"line\">        // 初始化，设置postition=0，limit=capacity</span><br><span class=\"line\">        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);</span><br><span class=\"line\">        // 写模式，设置position=可读字节数，limit=capacity</span><br><span class=\"line\">        long bytesRead = clientChannel.read(byteBuffer);</span><br><span class=\"line\">        while (bytesRead &gt; 0) &#123;</span><br><span class=\"line\">            // 写模式转成读模式，设置postition=0，limit=可读字节数</span><br><span class=\"line\">            byteBuffer.flip();</span><br><span class=\"line\">            byte[] data = byteBuffer.array();</span><br><span class=\"line\">            String info = new String(data).trim();</span><br><span class=\"line\">            System.out.println(&quot;服务端接收的消息是： &quot; + info);</span><br><span class=\"line\">            // 读模式转成写模式，设置position=0，limit=capacity</span><br><span class=\"line\">            byteBuffer.clear();</span><br><span class=\"line\">            // 继续开始下一次读入</span><br><span class=\"line\">            bytesRead = clientChannel.read(byteBuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        clientChannel.close(); //关闭channel</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws IOException &#123;</span><br><span class=\"line\">        NIOServer nioServer = new NIOServer();</span><br><span class=\"line\">        nioServer.initServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>服务端代码简单解析</p>\n<ol>\n<li>服务端创建 serverSelector。</li>\n<li>服务端创建 serverSocketChannel，绑定一个本地端口，然后注册到 serverSelector，并设置关心事件为  OP_ACCEPT。调用 <code>serverSelector.select()</code> 方法等待事件发生。</li>\n<li>事件发生，获取并遍历 selectedKeys，对事件类型为 Accept 和 Read 的事件进行相应操作。</li>\n</ol>\n<p><strong>客户端代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class NIOClient &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void initClient() throws IOException &#123;</span><br><span class=\"line\">        Selector clientSelector = Selector.open();</span><br><span class=\"line\"></span><br><span class=\"line\">        SocketChannel clientChannel = SocketChannel.open();</span><br><span class=\"line\">        clientChannel.configureBlocking(false);</span><br><span class=\"line\">        clientChannel.connect(new InetSocketAddress(7000));</span><br><span class=\"line\">        clientChannel.register(clientSelector, SelectionKey.OP_CONNECT);</span><br><span class=\"line\"></span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            clientSelector.select();</span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; iterator = clientSelector.selectedKeys().iterator();</span><br><span class=\"line\">            while (iterator.hasNext()) &#123;</span><br><span class=\"line\">                SelectionKey key = iterator.next();</span><br><span class=\"line\">                iterator.remove();</span><br><span class=\"line\">                if (key.isConnectable()) &#123;</span><br><span class=\"line\">                    doConnect(key);</span><br><span class=\"line\">                &#125; else if (key.isWritable() &amp;&amp; key.isValid()) &#123;</span><br><span class=\"line\">                    doWrite(key);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void doConnect(SelectionKey key) throws IOException &#123;</span><br><span class=\"line\">        System.out.println(&quot;客户端连接成功&quot;);</span><br><span class=\"line\">        SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class=\"line\">        if (clientChannel.isConnectionPending()) &#123;</span><br><span class=\"line\">            clientChannel.finishConnect();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        clientChannel.configureBlocking(false);</span><br><span class=\"line\">        clientChannel.register(key.selector(), SelectionKey.OP_WRITE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void doWrite(SelectionKey key) throws IOException &#123;</span><br><span class=\"line\">        System.out.println(&quot;客户端开始向服务端写数据&quot;);</span><br><span class=\"line\">        SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class=\"line\">        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);</span><br><span class=\"line\">        String info = &quot;hello world&quot;;</span><br><span class=\"line\">        byteBuffer.clear();</span><br><span class=\"line\">        byteBuffer.put(info.getBytes());</span><br><span class=\"line\">        byteBuffer.flip();</span><br><span class=\"line\">        while (byteBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">            clientChannel.write(byteBuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;客户端发送的消息是： &quot; + info);</span><br><span class=\"line\">        clientChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws IOException &#123;</span><br><span class=\"line\">        NIOClient nioClient = new NIOClient();</span><br><span class=\"line\">        nioClient.initClient();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端代码类似于服务端代码，区别是对事件类型为 Connect 和 Write 的事件做了相应处理。在这里不再做详细介绍。</p>\n<h3 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>由此我们可以看出来虽然 NIO 虽然解决了 BIO 的一些痛点，但是 NIO 的原生编程也带来了新的问题：</p>\n<ol>\n<li>JDK的NIO编程需要了解很多的概念，编程复杂，对 NIO 入门非常不友好，编程模型不友好，ByteBuffer 的 api 简直反人类</li>\n<li>对 NIO 编程来说，一个比较合适的线程模型能充分发挥它的优势，而 JDK 没有给你实现，你需要自己实现，就连简单的自定义协议拆包都要你自己实现</li>\n<li>JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮训 bug 会导致 cpu 飙升100%</li>\n<li>项目庞大之后，自行实现的 NIO 很容易出现各类bug，维护成本较高</li>\n</ol>\n<p>下面我们就看下 Netty 是怎么解决 NIO 带来的各种问题的。</p>\n<h2 id=\"Netty\"><a href=\"#Netty\" class=\"headerlink\" title=\"Netty\"></a>Netty</h2><p>Netty 是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端。简单来说就是 Netty 封装了 JDK 的 NIO，可以简化开发流程。</p>\n<p>相比起 NIO，Netty 的优势有：</p>\n<ol>\n<li>使用JDK自带的NIO需要了解太多的概念，编程复杂，一不小心bug横飞</li>\n<li>Netty底层IO模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从NIO模型变身为IO模型</li>\n<li>Netty自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑</li>\n<li>Netty解决了JDK的很多包括空轮询在内的bug</li>\n<li>Netty底层对线程，selector做了很多细小的优化，精心设计的reactor线程模型做到非常高效的并发处理</li>\n<li>自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手</li>\n<li>Netty社区活跃，遇到问题随时邮件列表或者issue</li>\n<li>Netty已经历各大rpc框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大</li>\n</ol>\n<p>Netty 的具体内容我们后面再详细介绍，这里简单介绍一下 Netty 的使用，感受一下 Netty 给开发带来的便利性。</p>\n<p><strong>引入 Maven 依赖</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;<span class=\"number\">4.1</span><span class=\"number\">.6</span>.Final&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>服务端代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class NettyServer &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class=\"line\">        NioEventLoopGroup boos = new NioEventLoopGroup();</span><br><span class=\"line\">        NioEventLoopGroup worker = new NioEventLoopGroup();</span><br><span class=\"line\">        serverBootstrap</span><br><span class=\"line\">                .group(boos, worker)</span><br><span class=\"line\">                .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">                    protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class=\"line\">                        ch.pipeline().addLast(new StringDecoder());</span><br><span class=\"line\">                        ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;</span><br><span class=\"line\">                            @Override</span><br><span class=\"line\">                            protected void channelRead0(ChannelHandlerContext ctx, String msg) &#123;</span><br><span class=\"line\">                                System.out.println(msg);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .bind(8000);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>客户端代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class NettyClient &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">        Bootstrap bootstrap = new Bootstrap();</span><br><span class=\"line\">        NioEventLoopGroup group = new NioEventLoopGroup();</span><br><span class=\"line\">        bootstrap.group(group)</span><br><span class=\"line\">                .channel(NioSocketChannel.class)</span><br><span class=\"line\">                .handler(new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    protected void initChannel(Channel ch) &#123;</span><br><span class=\"line\">                        ch.pipeline().addLast(new StringEncoder());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        Channel channel = bootstrap.connect(&quot;127.0.0.1&quot;, 8000).channel();</span><br><span class=\"line\">        while (true) &#123;</span><br><span class=\"line\">            channel.writeAndFlush(new Date() + &quot;: hello world!&quot;);</span><br><span class=\"line\">            Thread.sleep(2000);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码的具体内容在这里先不做分析，但是我们可以看到，这两段简单的代码，就可以完成 NIO 原生编程那一大段代码的功能，代码非常清晰易于维护。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文简单介绍了 BIO、NIO 的一些基本原理，认识到 NIO 相对于 BIO 在性能和资源管理方面带来的巨大提升，但 NIO 的原生编程过于复杂，难以维护。Netty 通过对 NIO 进行封装，大大降低了开发的复杂性。如果涉及到网络编程，Netty 将是你是不二选择。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href>Netty实战</a></p>\n<p><a href=\"https://www.jianshu.com/p/a4e03835921a\">《跟闪电侠学Netty》开篇：Netty是什么？</a></p>\n<p><a href=\"https://blog.csdn.net/forezp/article/details/88414741\">Java NIO？看这一篇就够了！</a></p>\n","categories":["Netty"],"tags":["Netty"]},{"title":"Netty系列（三）：Netty原理和组件简介","url":"/2020/01/20/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ANetty%E5%8E%9F%E7%90%86%E5%92%8C%E7%BB%84%E4%BB%B6%E7%AE%80%E4%BB%8B/","content":"<blockquote>\n<p>在上一篇文章我们了解到网络编程的相关知识以及 Netty 给网络编程开发带来的便利性，本文我们介绍 Netty 的基础线程模型 Reactor 模型、Netty 组件和基于这两者的 Netty 线程模型，有助于理解 Netty 整体原理结构。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>本文首先介绍 Reactor 模型的发展历史，该线程模型是 Netty 组件设计和线程模型的基础。然后介绍 Netty 基于 Reactor 模型设计的各种组件，最后介绍 Netty 组件组成的 Netty 线程模型。</p>\n<h1 id=\"Reactor-模型\"><a href=\"#Reactor-模型\" class=\"headerlink\" title=\"Reactor 模型\"></a>Reactor 模型</h1><p>Reactor 模型是一个 IO 设计模式，Java 中的 NIO 就对  Reactor 模式提供了很好的支持，比较著名的就是 [Doung Lea](<a href=\"https://baike.baidu.com/item/Doug\">https://baike.baidu.com/item/Doug</a> Lea&#x2F;6319404) 大神在 <a href=\"http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf\">《Scalable IO in Java》</a>演示如何使用 NIO 实现Reactor模式。</p>\n<p>在维基百科上对  Reactor 模式定义如下：</p>\n<blockquote>\n<p>The reactor design pattern is an <strong>event handling pattern</strong> for handling service requests <strong>delivered concurrently to a service handler</strong> by one or more inputs. The service handler then <strong>demultiplexes</strong> the incoming requests and dispatches them synchronously to the associated request handlers</p>\n</blockquote>\n<p>从这段定义我们可以得到三个关键点：</p>\n<ul>\n<li>事件驱动（event handling）</li>\n<li>可以处理一个或多个输入源（one or more inputs）</li>\n<li>通过 Service Handler 同步的将输入事件（Event）采用多路复用分发给相应的 Request Handler（多个）处理</li>\n</ul>\n<p>基本流程图如下：</p>\n<div style=\"width: 80%; margin: auto\">![base](base.png)</div>\n对流程图进行进一步抽象，得到 Reactor 模型的 OMT 类图如下：\n\n<div style=\"width: 80%; margin: auto\">![omt](omt.png)</div>\n五种类解释如下：\n\n<ul>\n<li><p>Handle(描述符)：表示触发事件，是触发所有操作的发源地。在 Linux 中 Handle 就是文件描述符 fd。</p>\n</li>\n<li><p>Synchronous Event Demultiplexer(同步事件分离器)：事件发生后通知 Initiation Dispatcher，对于 Linux 来说，同步事件分离器指的就是常用的 I&#x2F;O 多路复用机制，比如说 select、poll、epoll 等。在 Java NIO 领域中，同步事件分离器对应的组件就是 Selector，对应的阻塞方法就是 select 方法。</p>\n</li>\n<li><p>Initiation Dispatcher(初始分发器)：相当于 Reactor 的角色，Initiation Dispatcher 会通过 Synchronous Event Demultiplexer 来等待事件的发生。一旦事件发生，Initiation Dispatcher 会调用 Event Handler 来处理事件。</p>\n</li>\n<li><p>Event Handler(事件处理器)：事件产生时实现相应的回调方法进行业务逻辑，类似于接口。</p>\n</li>\n<li><p>Concrete Event Handler(具体事件处理器)： Event Handler的实现。</p>\n</li>\n</ul>\n<p>对 OMT 类图进行简化后，Reactor 模型定义了三种角色：</p>\n<ul>\n<li><strong>Reactor</strong>: 负责监听和响应事件，将事件分发绑定了该事件的 Handler 处理</li>\n<li><strong>Handler</strong>: 事件处理器，绑定了某类事件，负责对事件进行处理</li>\n<li><strong>Acceptor</strong>：Handler 的一种，绑定了 connect 事件，当客户端发起 connect 请求时，Reactor 会将 accept 事件分发给 Acceptor 处理</li>\n</ul>\n<p>这三种角色也是我们下面介绍的三种模型的基础。</p>\n<h2 id=\"Reactor-单线程模型\"><a href=\"#Reactor-单线程模型\" class=\"headerlink\" title=\"Reactor 单线程模型\"></a>Reactor 单线程模型</h2><div style=\"width: 80%; margin: auto\">![reactor1](reactor1.png)</div>\n**处理流程**\n\n<ol>\n<li>Reactor 对象通过 select 监控连接事件，收到事件后通过 dispatch 进行分发</li>\n<li>如果是连接建立的事件，则交由 Acceptor 通过 accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理</li>\n<li>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应</li>\n<li>Handler 会完成 read -&gt; 业务处理 -&gt; send 的完整业务流程</li>\n</ol>\n<p><strong>特点分析</strong></p>\n<ul>\n<li>优点：模型简单，没有多线程，进程通信，竞争的问题，全部都在一个线程中完成。Redis 就是使用 Reactor 单进程的模型。</li>\n<li>缺点：所有的 IO 操作（read、send）和非 IO 操作（decode、compute、encode）都在一个线程里面完成，当非 IO 操作处理速度较慢时，会导致 IO 响应速度严重下降。</li>\n</ul>\n<h2 id=\"Reactor-多线程模型\"><a href=\"#Reactor-多线程模型\" class=\"headerlink\" title=\"Reactor 多线程模型\"></a>Reactor 多线程模型</h2><div style=\"width: 80%; margin: auto\">![reactor2](reactor2.png)</div>\n**处理流程**\n\n<ol>\n<li>主线程中，Reactor 对象通过 select  监听连接事件，收到事件后通过 dispatch 进行分发。</li>\n<li>如果是连接建立的事件，则由 Acceptor 处理，Acceptor 通过 accept 接受连接，并创建一个 Handler 来处理连接后续的各种事件。</li>\n<li>如果不是连接建立事件，则 Reactor 会调用连接对应的 Handler 来进行相应。</li>\n<li>Handler 只负责请求响应事件，不进行业务处理。Handler 通过 read 读取到数据后，会发给业务线程池 Thread Pool 进行业务处理。</li>\n<li>Thread Pool 会在独立的子线程中完成真正的业务处理，然后将响应结果返回给 Handler。</li>\n<li>Handler 收到响应后通过 send 将响应结果返回给 client。</li>\n</ol>\n<p><strong>特点分析</strong></p>\n<ul>\n<li>优点：和单线程模型相比，多线程模型最大的特点就是把非 IO 操作（decode、compute、encode）抽取出来放到专门的业务线程池去进行处理，Handler 只需要负责 IO 操作（read、send），这样会大大提升系统的 IO 响应速度。</li>\n<li>缺点：这个模型仍然把管理连接的 acceptor 和负责 IO 的 Handler 放在同一个 Reactor 中。在瞬间高并发的场景中，系统可能会因为忙于处理新的连接，导致 IO 响应速度瞬间下降。</li>\n</ul>\n<h2 id=\"主从-Reactor-多线程模型\"><a href=\"#主从-Reactor-多线程模型\" class=\"headerlink\" title=\"主从 Reactor 多线程模型\"></a>主从 Reactor 多线程模型</h2><div style=\"width: 80%; margin: auto\">![reactor3](reactor3.png)</div>\n**处理流程**\n\n<ol>\n<li>主进程中 mainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 接收，将新的连接分配给子进程 subReactor（可以有多个）。</li>\n<li>子进程中的 subReactor 将 mainReactor 分配的连接加入队列进行监听，并把该连接从 mainReactor 的管理队列中移除，然后创建一个 Handler 用于处理连接的各种事件</li>\n<li>当有新的事件发生时，subReactor 会调用里连接对应的 Handler 来进行处理。</li>\n<li>Handler 通过 Read 读取数据后，会分发给后面的 Thread Pool 线程池进行业务处理。</li>\n<li>Thread Pool 线程池会分配独立的线程完成真正的业务处理，然后将响应结果返回给 Handler。</li>\n<li>Handler 收到响应结果后通过 send 将响应结果返回给 client。</li>\n</ol>\n<p><strong>特点分析</strong></p>\n<p>和多线程模型相比，该模型将 Reactor 分成两部分，mainReactor 只负责管理连接（accept），subReactor 负责管理除了连接外的其他操作（read、decode、compute、encode、send）。mainReactor 和 subReactor 相互独立，之间的交互非常简单，mainReactor 只需要把连接传给 subReactor 就完成任务了。Reactor 具有以下特点：</p>\n<ul>\n<li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的</li>\n<li>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程&#x2F;进程的切换开销</li>\n<li>可扩展性，可以方便地通过增加 Reactor 实例个数来充分利用 CPU 资源；</li>\n<li>可复用性，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性。</li>\n</ul>\n<p>主从 Reactor 多线程模型是 Netty 线程模型的基础，Netty 的主要组件都是围绕该模型进行设计的。</p>\n<h1 id=\"Netty-组件\"><a href=\"#Netty-组件\" class=\"headerlink\" title=\"Netty 组件\"></a>Netty 组件</h1><h2 id=\"Bootstrap\"><a href=\"#Bootstrap\" class=\"headerlink\" title=\"Bootstrap\"></a>Bootstrap</h2><p>Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件。Bootstrap 分为 Bootstrap 和，ServerBootstrapNetty， Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p>\n<h2 id=\"EventLoop、EventLoopGroup\"><a href=\"#EventLoop、EventLoopGroup\" class=\"headerlink\" title=\"EventLoop、EventLoopGroup\"></a>EventLoop、EventLoopGroup</h2><p>一个 EventLoop 对应一个线程，可以绑定多个 Channel，内部会维护一个 selector 和 taskQueue。</p>\n<ul>\n<li>selector：处理 IO 任务，即 selectionKey 中 ready 的事件，如 accept、connect、read、write 等。</li>\n<li>taskQueue：处理非 IO 任务，如 register0、bind0 等任务。</li>\n</ul>\n<p>两种任务的执行时间比由变量 ioRatio 控制，默认为 50，则表示允许非 IO 任务执行的时间与 IO 任务的执行时间相等。</p>\n<p>一个 EventLoopGroup 可以理解为一个线程池，包含一到多个 EventLoop。</p>\n<h2 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><p>Channel 是 Netty 网络操作的基础组件，可以把他理解为 BIO 的 Socket 类和 NIO 的 Channel 的升级版，把相关 api 进行进一步封装，提供了基本的 I&#x2F;O 操作如 bind、connect、read、write 等，并且将 Netty 的相关功能类（例如 EventLoop）聚合在 Channel 中，由 Channel 统一负责和调度（例如可以通过 channel.eventLoop() 获取 channel 所在的 EventLoop 实例），可以功能实现更加灵活。</p>\n<p>一个 Channel 会注册到一个 EventLoop 上，然后在它的整个生命周期过程中，都会用这个 EventLoop。</p>\n<p>用 Netty 编写网络程序的时候，我们一般不会直接操纵 Channel，而是直接操作 Channel 的组件例如最常用的 ChannelHandler。</p>\n<p>Channel 涉及的组件有 ChannelHandler、ChannelHandlerContext、ChannelPipline 和 ChannelFuture。这些组件的关系如下：</p>\n<div style=\"width: 80%; margin: auto\">![channel](channel.png)</div>\n### ChannelHandler\n\n<p>ChannelHandler 是 Netty 的核心组件，用来处理各种事件，例如连接、接收、数据转换、异常处理以及我们的业务逻辑逻辑。ChannelHandler 包括两个核心子类：</p>\n<ul>\n<li>ChannelInboundHandler：用于接收、处理入站数据和事件</li>\n<li>ChannelOutboundHandler：用于接收、处理出站数据和事件</li>\n</ul>\n<p>一个 Channel 可以包含多个 ChannelHandler，这些 ChannelHandler 呈流水线式处理事件。一个 ChannelHandler 也可以被多个 Channel 复用。</p>\n<h3 id=\"ChannelHandlerContext\"><a href=\"#ChannelHandlerContext\" class=\"headerlink\" title=\"ChannelHandlerContext\"></a>ChannelHandlerContext</h3><p>Channel 的上下文，一个 ChannelHandlerContext 对应一个 ChannelHandler，并且与前后的 ChannelHandler 的 ChannelHandlerContext 产生关联。可以把一些数据放到 ChannelHandlerContext 中进行上下文传递。</p>\n<h3 id=\"ChannelPipline\"><a href=\"#ChannelPipline\" class=\"headerlink\" title=\"ChannelPipline\"></a>ChannelPipline</h3><p>ChannelPipline 是 ChannelHandler 的链表，负责把多个 ChannelHandler 串行起来，提供了一种截取过滤模式（类似 serverlet 中的 filter 功能），拦截处理 Channel 的输入输出 event。</p>\n<p>当一个数据流进入 ChannlePipeline 时，它会从 ChannelPipeline 头部开始传给第一个 ChannelInboundHandler ，当第一个处理完后再传给下一个，一直传递到管道的尾部。与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的 “最后” 一个ChannelOutboundHandler，当它处理完成后会传递给前一个 ChannelOutboundHandler 。</p>\n<p>一个 Channel 包含一个 ChannelPipline。当 ChannelHandler 被添加到 ChannelPipeline 时，它将会被分配一个 ChannelHandlerContext，它代表了 ChannelHandler 和 ChannelPipeline 之间的绑定。ChannelPipeline 通过 ChannelHandlerContext 来间接管理 ChannelHandler。</p>\n<h3 id=\"ChannelFuture、ChannelPromise\"><a href=\"#ChannelFuture、ChannelPromise\" class=\"headerlink\" title=\"ChannelFuture、ChannelPromise\"></a>ChannelFuture、ChannelPromise</h3><p>在 Netty 中所有的 IO 操作都是异步的，不能立刻得知消息的处理处理。这时候我们通过 ChannelFuture 或 ChannelPromise，对结果注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。ChannelPromise 是 ChannelFuture 的扩展，可以设置结果。</p>\n<h2 id=\"ByteBuf\"><a href=\"#ByteBuf\" class=\"headerlink\" title=\"ByteBuf\"></a>ByteBuf</h2><p>ByteBuf 是 Netty 的数据容器，本质是一个由不同索引分别控制读访问和写访问的字节数组。Netty 的 ByteBuf 对 NIO 的 ByteBuffer 进行封装，提供更友好的 api 和更强大的功能。</p>\n<h2 id=\"组件关系\"><a href=\"#组件关系\" class=\"headerlink\" title=\"组件关系\"></a>组件关系</h2><p>以上我们介绍的组件有以下关系：</p>\n<ul>\n<li>一个 EventLoopGroup 包含一个或多个 EventLoop。</li>\n<li>一个 EventLoop 在它的生命周期内只能与一个 Thread 绑定。</li>\n<li>所有有 EnventLoop 处理的 I&#x2F;O 事件都将在它专有的 Thread 上被处理。</li>\n<li>一个 Channel 在它的生命周期内只能注册与一个 EventLoop。</li>\n<li>一个 EventLoop 可被分配至一个或多个 Channel 。</li>\n<li>一个 Channel 对应一个 ChannelPipline，一个 ChannelPipline 包含多个 ChannelHandler，每个 ChannelHandler 对应一个 ChannelHandlerContext，与前后 ChannelHandler 的 ChannelHandlerContext 产生关联。</li>\n</ul>\n<h1 id=\"Netty-线程模型\"><a href=\"#Netty-线程模型\" class=\"headerlink\" title=\"Netty 线程模型\"></a>Netty 线程模型</h1><p>根据 Reactor 模型和 Netty 的基本组件，我们可以得到 Netty Server 端的线程模型如下：</p>\n<div style=\"width: 80%; margin: auto\">![netty](netty.png)</div>\n**线程模型分析**\n\n<ul>\n<li>Server 端包含 1 个 Boss NioEventLoopGroup 和 1 个 Worker NioEventLoopGroup。</li>\n<li>每个 Boss NioEventLoopGroup 通常包含 1 个 NioEventLoop，1 个 NioEventLoop 包含 1 个 Selector 和 1 个事件循环线程。Boss NioEventLoopGroup 的工作过程如下：<ul>\n<li>轮询 Accept 事件。</li>\n<li>处理 Accept I&#x2F;O 事件，与 Client 建立连接，生成 NioSocketChannel，并将 NioSocketChannel 注册到某个 Worker NioEventLoop 的 Selector 上。</li>\n<li>处理任务队列中的任务，runAllTasks。任务队列中的任务包括用户调用 eventloop.execute 或 schedule 执行的任务，或者其他线程提交到该 eventloop 的任务。</li>\n</ul>\n</li>\n<li>每个 Worker NioEventLoopGroup 通常包含多个 NioEventLoop。Worker NioEventLoopGroup 的工作过程如下：<ul>\n<li>轮询 Read、Write 事件。</li>\n<li>处理 I&#x2F;O 事件，即 Read、Write 事件，在 NioSocketChannel 可读、可写事件发生时进行处理。</li>\n<li>处理任务队列中的任务，runAllTasks。</li>\n</ul>\n</li>\n</ul>\n<p>该线程模型是 netty 框架的基础，能清晰地认识该模型，对理解 netty 的整体结构设计非常重要。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Reactor 模型是一个 IO 设计模式，发展衍生出三种模型：</p>\n<ul>\n<li>Reactor 单线程模型</li>\n<li>Reactor 多线程模型</li>\n<li>主从 Reactor 多线程模型</li>\n</ul>\n<p>Netty 根据主从 Reactor 多线程模型设计出多种基础组件：</p>\n<ul>\n<li>Bootstrap</li>\n<li>EventLoop、EventLoopGroup</li>\n<li>Channel<ul>\n<li>ChannelHandler</li>\n<li>ChannelHandlerContext</li>\n<li>ChannelPipline</li>\n<li>ChannelFuture、ChannelPromise</li>\n</ul>\n</li>\n<li>ByteBuf</li>\n</ul>\n<p>Netty 的线程模型就是基于主从 Reactor 多线程模型和 Netty 基础组件进行设计的，该线程模型是 Netty 整体结构的基础。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href>《Netty In Action》</a></p>\n<p><a href=\"http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf\">Scalable IO in Java</a></p>\n<p><a href=\"https://juejin.im/post/5ba3845e6fb9a05cdd2d03c0\">Java NIO 系列文章之 浅析Reactor模式</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1488120\">彻底搞懂Reactor模型和Proactor模型</a></p>\n","categories":["Netty"],"tags":["Netty"]},{"title":"Netty系列（四）：Bootstrap","url":"/2020/05/27/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ABootstrap/","content":"<blockquote>\n<p>上篇文章我们简单介绍了 Netty 的线程模型和基本组件，后面我们开始详细介绍 Netty 每个基本组件。本文先介绍 Netty 的启动器 Bootstrap，包括 Bootstrap 的简介、类分析和实战。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"Bootstrap是什么\"><a href=\"#Bootstrap是什么\" class=\"headerlink\" title=\"Bootstrap是什么\"></a>Bootstrap是什么</h1><p>Bootstrap 是 Netty 的启动器，负责把 Netty 的组件例如 EventLoopGroup 等组装起来，并配置系统属性，然后启动 Netty 服务。例如下面是 Bootstrap 的常用用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 新建Bootstrap</span><br><span class=\"line\">Bootstrap b = new Bootstrap();</span><br><span class=\"line\"></span><br><span class=\"line\">try &#123;   </span><br><span class=\"line\">    //1 设置reactor 线程</span><br><span class=\"line\">    b.group(bossLoopGroup, workerLoopGroup);</span><br><span class=\"line\">    //2 设置nio类型的channel</span><br><span class=\"line\">    b.channel(NioServerSocketChannel.class);</span><br><span class=\"line\">    //3 设置监听端口</span><br><span class=\"line\">    b.localAddress(new InetSocketAddress(port));</span><br><span class=\"line\">    //4 设置通道选项</span><br><span class=\"line\">    b.option(ChannelOption.SO_KEEPALIVE, true);</span><br><span class=\"line\">    b.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);</span><br><span class=\"line\"></span><br><span class=\"line\">    //5 装配流水线</span><br><span class=\"line\">    b.childHandler(new ChannelInitializer&lt;SocketChannel&gt;()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //有连接到达时会创建一个channel</span><br><span class=\"line\">        protected void initChannel(SocketChannel ch) throws Exception</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(new ProtobufDecoder());</span><br><span class=\"line\">            ch.pipeline().addLast(new ProtobufEncoder());</span><br><span class=\"line\">            // pipeline管理channel中的Handler</span><br><span class=\"line\">            // 在channel队列中添加一个handler来处理业务</span><br><span class=\"line\">            ch.pipeline().addLast(&quot;serverHandler&quot;, serverHandler);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // 6 开始绑定server</span><br><span class=\"line\">    // 通过调用sync同步方法阻塞直到绑定成功</span><br><span class=\"line\"></span><br><span class=\"line\">    ChannelFuture channelFuture = b.bind().sync();</span><br><span class=\"line\">    LOGGER.info(ChatServer.class.getName() +</span><br><span class=\"line\">            &quot; started and listen on &quot; +</span><br><span class=\"line\">            channelFuture.channel().localAddress());</span><br><span class=\"line\"></span><br><span class=\"line\">    // 7 监听通道关闭事件</span><br><span class=\"line\">    // 应用程序会一直等待，直到channel关闭</span><br><span class=\"line\">    ChannelFuture closeFuture=  channelFuture.channel().closeFuture();</span><br><span class=\"line\">    closeFuture.sync();</span><br><span class=\"line\">&#125; catch (Exception e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">    // 8 优雅关闭EventLoopGroup，</span><br><span class=\"line\">    // 释放掉所有资源包括创建的线程</span><br><span class=\"line\">    workerLoopGroup.shutdownGracefully();</span><br><span class=\"line\">    bossLoopGroup.shutdownGracefully();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了更清楚地了解 Bootstrap 的用法，我们先介绍  Bootstrap 的类继承关系。</p>\n<h1 id=\"Bootstrap-类分析\"><a href=\"#Bootstrap-类分析\" class=\"headerlink\" title=\"Bootstrap 类分析\"></a>Bootstrap 类分析</h1><h2 id=\"类分析\"><a href=\"#类分析\" class=\"headerlink\" title=\"类分析\"></a>类分析</h2><p><img src=\"/.com//inherit.png\" alt=\"inherit\"></p>\n<p>AbstractBootstrap 中定义了一系列属性供子类使用，每个属性都有 setter 和 getter 方法，另外还有用于验证、启动等其他方法。</p>\n<p>ServerBootstrap 和 Bootstrap 都继承自抽象类 AbstractBootstrap，都能使用父类中的属性。其中 ServerBootstrap 是服务器端的启动类，Bootstrap 是客户端的系统类。两者在类方法上的区别有：</p>\n<ul>\n<li>ServerBootstrap 的 group 的 setter 方法可以设置两个 eventLoopGroup：一个 bossLoopGroup 和一个 workerLoopGroup（也可以只设置一个 eventLoopGroup 同时完成 bossLoopGroup 和 workerLoopGroup 两个线程组的工作）。Bootstrap 的 group 的 setter 方法只需要设置一个 eventLoopGroup，用于与服务端的所有交互。<ul>\n<li>bossLoopGroup 用于监听连接，专门 accept 新的客户端连接。</li>\n<li>workerLoopGroup 用于处理与客户端除了 accept 之外的其他交互。</li>\n</ul>\n</li>\n<li>ServerBootstrap 有 child 前缀的一些属性，用于配置 ServerSocketChannel 的相关属性，而 Bootstrap 没有 child 前缀的属性。</li>\n<li>Bootstrap 的 remoteAddress 属性可以设置远程主机的地址和端口，ServerBootstrap 没有该属性。</li>\n<li>ServerBootstrap 使用父类的 <code>bind</code> 方法进行启动，Bootstrap 使用自定义的 <code>connect</code> 方法进行启动。</li>\n</ul>\n<p>ServerBootstrap 和 Bootstrap 都使用 Builder 链式模式设置属性，例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">bootstrap.group(group)</span><br><span class=\"line\">\t.channel(NioSocketChannel.class)</span><br><span class=\"line\">\t.option(ChannelOption.TCP_NODELAY, true);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"属性介绍\"><a href=\"#属性介绍\" class=\"headerlink\" title=\"属性介绍\"></a>属性介绍</h2><h3 id=\"group-属性\"><a href=\"#group-属性\" class=\"headerlink\" title=\"group 属性\"></a>group 属性</h3><p>设置 EventLoopGroup。服务端使用 ServerBootstrap 的 group 的 setter 方法可以设置两个 eventLoopGroup：一个 bossLoopGroup 和一个 workerLoopGroup。</p>\n<ul>\n<li><strong>bossLoopGroup</strong>：用于监听连接，专门 accept 新的客户端连接。</li>\n<li><strong>workerLoopGroup</strong>：用于处理与客户端除了 accept 之外的其他交互。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">EventLoopGroup bossGroup = new NioEventLoopGroup();</span><br><span class=\"line\">EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class=\"line\">serverBootstrap.group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure>\n\n<p>上面这种模型对应上篇介绍的主从 Reactor 多线程模型，也可以只设置一个 eventLoopGroup 同时完成 bossLoopGroup 和 workerLoopGroup 两个线程组的工作，对应单 Reactor 多线程模型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">EventLoopGroup eventGroup = new NioEventLoopGroup();</span><br><span class=\"line\">serverBootstrap.group(eventGroup);</span><br></pre></td></tr></table></figure>\n\n<p>客户端一般只需要设置一个 eventLoopGroup 就可以完成和服务端的所有交互。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">EventLoopGroup eventGroup = new NioEventLoopGroup();</span><br><span class=\"line\">bootstrap.group(eventGroup);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"channelFactory-属性\"><a href=\"#channelFactory-属性\" class=\"headerlink\" title=\"channelFactory 属性\"></a>channelFactory 属性</h3><p>设置 Channel 属性，ServerBootstrap 和 Bootstrap 通用，例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">serverBootstrap.channel(NioServerSocketChannel.class);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们使用 NioServerSocketChannel.class，看似是直接创建了 ServerSocketChannel 实例，但实际上是调用工厂类 BootstrapChannelFactory 来创建实例，这就是属性名称 channelFactory 的由来。从源码可以看到：</p>\n<pre><code>public B channel(Class&lt;? extends C&gt; channelClass) &#123;\n    if (channelClass == null) &#123;\n        throw new NullPointerException(&quot;channelClass&quot;);\n    &#125;\n    // 调用 BootstrapChannelFactory 获取 Channel 实例\n    return channelFactory(new BootstrapChannelFactory&lt;C&gt;(channelClass));\n&#125;\n\nprivate static final class BootstrapChannelFactory&lt;T extends Channel&gt; implements ChannelFactory&lt;T&gt; &#123;\n    private final Class&lt;? extends T&gt; clazz;\n\n    BootstrapChannelFactory(Class&lt;? extends T&gt; clazz) &#123;\n        this.clazz = clazz;\n    &#125;\n    \n    // 通过 newInstance 创建实例\n    @Override\n    public T newChannel() &#123;\n        try &#123;\n            return clazz.newInstance();\n        &#125; catch (Throwable t) &#123;\n            throw new ChannelException(&quot;Unable to create Channel from class &quot; + clazz, t);\n        &#125;\n    &#125;\n&#125; \n</code></pre>\n<p>serverBootstrap.channel() 方法可配置的常用类有：</p>\n<ul>\n<li><strong>NioDatagramChannel</strong>：基于 NIO，服务端和客户端通用</li>\n<li><strong>NioServerSocketChannel</strong>：基于 NIO，服务端 channel() 方法使用</li>\n<li><strong>NioSocketChannel</strong>：基于 NIO，服务端 childChannel() 和客户端 channel() 方法使用</li>\n<li><strong>OioDatagramChannel</strong>：基于 BIO，同 NioDatagramChannel</li>\n<li><strong>OioServerSocketChannel</strong>：基于 BIO，同 NioServerSocketChannel</li>\n<li><strong>OioSocketChannel</strong>：基于 BIO，同 NioSocketChannel</li>\n</ul>\n<p>我们看到除了可以使用 NIO 的相关 Channel 外，还可以使用 OIO（BIO）的相关 Channel，只需要修改一下类名称即可在 NIO 和 OIO 之间进行切换，对开发非常友好。一般情况下我们只使用 NIO 的相关 Channel。</p>\n<h3 id=\"localAddress、remoteAddress-属性\"><a href=\"#localAddress、remoteAddress-属性\" class=\"headerlink\" title=\"localAddress、remoteAddress 属性\"></a>localAddress、remoteAddress 属性</h3><p>localAddress 用于设置本地端口，一般用于服务端。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 直接使用端口</span><br><span class=\"line\">serverBootstrap.localAddress(8000);</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者使用 InetSocketAddress 对象</span><br><span class=\"line\">serverBootstrap.localAddress(new InetSocketAddress(8000));</span><br></pre></td></tr></table></figure>\n\n<p>也可以不通过 localAddress 来设置端口，在服务端调用 <code>bind</code> 方法的时候再设置端口，两者效果一致。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">serverBootstrap.bind(8000).sync();</span><br><span class=\"line\">// 或</span><br><span class=\"line\">serverBootstrap.bind(new InetSocketAddress(8000)).sync();</span><br></pre></td></tr></table></figure>\n\n<p>remoteAddress 用于设置远程主机地址和端口，一般用于客户端。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 直接使用地址端口</span><br><span class=\"line\">bootstrap.remoteAddress(&quot;192.168.10.1&quot;, 8000);</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者使用 InetSocketAddress 对象</span><br><span class=\"line\">bootstrap.remoteAddress(new InetSocketAddress(&quot;192.168.10.1&quot;, 8000));</span><br></pre></td></tr></table></figure>\n\n<p>也可以不通过 remoteAddress 来设置远程主机地址和端口，在客户点调用 <code>connect</code> 方法的时候再设置，两者效果一致。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">bootstrap.connect(&quot;192.168.10.1&quot;, 8000).sync();</span><br><span class=\"line\">// 或</span><br><span class=\"line\">bootstrap.connect(new InetSocketAddress(&quot;192.168.10.1&quot;, 8000)).sync();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"options-属性\"><a href=\"#options-属性\" class=\"headerlink\" title=\"options 属性\"></a>options 属性</h3><p>设置 Channel 的 options 属性，ServerBootstrap 和 Bootstrap 通用，options 对服务端而言是设置 ServerSocketChannel 的属性，对客户端而言是设置 SocketChannel 的属性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">serverBootstrap.option(ChannelOption.TCP_NODELAY, true);</span><br></pre></td></tr></table></figure>\n\n<p>options 可设置的属性有：</p>\n<p><strong>通用参数</strong></p>\n<ul>\n<li><strong>CONNECT_TIMEOUT_MILLIS</strong>：Netty 参数，连接超时毫秒数，默认值30000毫秒即30。</li>\n<li><strong>MAX_MESSAGES_PER_READ</strong>：Netty 参数，一次 Loop 读取的最大消息数，对于 ServerChannel或者NioByteChannel，默认值为16，其他 Channel 默认值为1。默认值这样设置，是因为：ServerChannel 需要接受足够多的连接，保证大吞吐量，NioByteChannel 可以减少不必要的系统调用 select。</li>\n<li><strong>WRITE_SPIN_COUNT</strong>：Netty 参数，一个 Loop 写操作执行的最大次数，默认值为16。也就是说，对于大数据量的写操作至多进行16次，如果16次仍没有全部写完数据，此时会提交一个新的写任务给 EventLoop，任务将在下次调度继续执行。这样，其他的写请求才能被响应不会因为单个大数据量写请求而耽误。</li>\n<li><strong>ALLOCATOR</strong>：Netty 参数，ByteBuf 的分配器，默认值为 ByteBufAllocator.DEFAULT，4.0版本为 UnpooledByteBufAllocator，4.1版本为 PooledByteBufAllocator。该值也可以使用系统参数io.netty.allocator.type 配置，使用字符串值：”unpooled”，”pooled”。</li>\n<li><strong>RCVBUF_ALLOCATOR</strong>：Netty 参数，用于 Channel 分配接受 Buffer 的分配器，默认值为 AdaptiveRecvByteBufAllocator.DEFAULT，是一个自适应的接受缓冲区分配器，能根据接受到的数据自动调节大小。可选值为 FixedRecvByteBufAllocator，固定大小的接受缓冲区分配器。</li>\n<li><strong>AUTO_READ</strong>：Netty 参数，自动读取，默认值为 True。Netty 只在必要的时候才设置关心相应的I&#x2F;O事件。对于读操作，需要调用 channel.read() 设置关心的 I&#x2F;O 事件为 OP_READ，这样若有数据到达才能读取以供用户处理。该值为 True 时，每次读操作完毕后会自动调用 channel.read()，从而有数据到达便能读取；否则，需要用户手动调用 channel.read()。需要注意的是：当调用 config.setAutoRead(boolean) 方法时，如果状态由 false 变为 true，将会调用 channel.read() 方法读取数据；由 true 变为 false，将调用 config.autoReadCleared()方法终止数据读取。</li>\n<li><strong>WRITE_BUFFER_HIGH_WATER_MARK</strong>：Netty 参数，写高水位标记，默认值 64KB。如果Netty的写缓冲区中的字节超过该值，Channel的isWritable() 返回False。</li>\n<li><strong>WRITE_BUFFER_LOW_WATER_MARK</strong>：Netty 参数，写低水位标记，默认值 32KB。当 Netty 的写缓冲区中的字节超过高水位之后若下降到低水位，则 Channel 的isWritable()返回True。写高低水位标记使用户可以控制写入数据速度，从而实现流量控制。推荐做法是：每次调用 channl.write(msg) 方法首先调用 channel.isWritable() 判断是否可写。</li>\n<li><strong>MESSAGE_SIZE_ESTIMATOR</strong>：Netty 参数，消息大小估算器，默认为 DefaultMessageSizeEstimator.DEFAULT。估算 ByteBuf、ByteBufHolder 和 FileRegion 的大小，其中 ByteBuf和ByteBufHolder 为实际大小，FileRegion 估算值为0。该值估算的字节数在计算水位时使用，FileRegion 为 0 可知 FileRegion 不影响高低水位。</li>\n<li><strong>SINGLE_EVENTEXECUTOR_PER_GROUP</strong>：Netty 参数，单线程执行 ChannelPipeline 中的事件，默认值为 True。该值控制执行 ChannelPipeline 中执行 ChannelHandler 的线程。如果为 Trye，整个 pipeline 由一个线程执行，这样不需要进行线程切换以及线程同步，是 Netty4 的推荐做法；如果为 False，ChannelHandler 中的处理过程会由 Group 中的不同线程执行。</li>\n</ul>\n<p><strong>SocketChannel 参数</strong></p>\n<ul>\n<li><strong>SO_RCVBUF</strong>：Socket 参数，TCP 数据接收缓冲区大小。该缓冲区即 TCP 接收滑动窗口，linux 操作系统可使用命令：cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_rmem 查询其大小。一般情况下，该值可由用户在任意时刻设置，但当设置值超过 64KB 时，需要在连接到远端之前设置。</li>\n<li><strong>SO_SNDBUF</strong>：Socket 参数，TCP 数据发送缓冲区大小。该缓冲区即 TCP 发送滑动窗口，linux 操作系统可使用命令：cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_smem 查询其大小。</li>\n<li><strong>TCP_NODELAY</strong>：TCP 参数，立即发送数据，默认值为 Ture（Netty 默认为 True 而操作系统默认为 False）。该值设置 Nagle 算法的启用，改算法将小的碎片数据连接成更大的报文来最小化所发送的报文的数量，如果需要发送一些较小的报文，则需要禁用该算法。Netty 默认禁用该算法，从而最小化报文传输延时。注意这个参数与是否开启 Nagle 算法是反着来的，true 表示关闭，false 表示开启。通俗地说，如果要求高实时性，有数据发送时就马上发送，就设置为 true；如果需要减少发送次数减少网络交互，就设置为 false。</li>\n<li><strong>SO_KEEPALIVE</strong>：Socket 参数，连接保活，默认值为 False。启用该功能时，TCP 会主动探测空闲连接的有效性。可以将此功能视为 TCP 的心跳机制，需要注意的是：默认的心跳间隔是 7200s 即 2 小时。Netty 默认关闭该功能。</li>\n<li><strong>SO_REUSEADDR</strong>：Socket 参数，地址复用，默认值 False。有四种情况可以使用<ul>\n<li>当有一个有相同本地地址和端口的 socket1 处于 TIME_WAIT 状态时，而你希望启动的程序的 socket2 要占用该地址和端口，比如重启服务且保持先前端口。</li>\n<li>有多块网卡或用 IP Alias 技术的机器在同一端口启动多个进程，但每个进程绑定的本地IP地址不能相同。</li>\n<li>单个进程绑定相同的端口到多个 socket 上，但每个 socket 绑定的 ip 地址不同。</li>\n<li>完全相同的地址和端口的重复绑定。但这只用于 UDP 的多播，不用于 TCP。</li>\n</ul>\n</li>\n<li><strong>SO_LINGER</strong>：Socket 参数，关闭 Socket 的延迟时间，默认值为 -1，表示禁用该功能。-1 表示 socket.close() 方法立即返回，但 OS 底层会将发送缓冲区全部发送到对端。0 表示 socket.close() 方法立即返回，OS 放弃发送缓冲区的数据直接向对端发送 RST 包，对端收到复位错误。非 0 整数值表示调用 socket.close() 方法的线程被阻塞直到延迟时间到或发送缓冲区中的数据发送完毕，若超时，则对端会收到复位错误。</li>\n<li><strong>IP_TOS</strong>：IP 参数，设置 IP 头部的 Type-of-Service 字段，用于描述 IP 包的优先级和 QoS 选项。</li>\n<li><strong>ALLOW_HALF_CLOSURE</strong>：Netty 参数，一个连接的远端关闭时本地端是否关闭，默认值为 False。值为 False 时，连接自动关闭；为 True 时，触发 ChannelInboundHandler 的 userEventTriggered() 方法，事件为 ChannelInputShutdownEvent。</li>\n</ul>\n<p><strong>ServerSocketChannel 参数</strong></p>\n<ul>\n<li><strong>SO_RCVBUF</strong>：已说明，需要注意的是：当设置值超过 64KB 时，需要在绑定到本地端口前设置。该值设置的是由 ServerSocketChannel 使用 accept 接受的 SocketChannel 的接收缓冲区。</li>\n<li><strong>SO_REUSEADDR</strong>：已说明</li>\n<li><strong>SO_BACKLOG</strong>：Socket 参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值， Windows 为 200，其他为 128。</li>\n</ul>\n<p><strong>DatagramChannel参数</strong></p>\n<ul>\n<li><strong>SO_BROADCAST</strong>：Socket 参数，设置广播模式。</li>\n<li><strong>SO_RCVBUF</strong>：已说明</li>\n<li><strong>SO_SNDBUF</strong>：已说明</li>\n<li><strong>SO_REUSEADDR</strong>：已说明</li>\n<li><strong>IP_MULTICAST_LOOP_DISABLED</strong>：对应 IP 参数 IP_MULTICAST_LOOP，设置本地回环接口的多播功能。由于 IP_MULTICAST_LOOP 返回 True 表示关闭，所以 Netty 加上后缀 _DISABLED 防止歧义。</li>\n<li><strong>IP_MULTICAST_ADDR</strong>：对应 IP 参数 IP_MULTICAST_IF，设置对应地址的网卡为多播模式。</li>\n<li><strong>IP_MULTICAST_IF</strong>：对应 IP 参数 IP_MULTICAST_IF2，同上但支持 IPV6。</li>\n<li><strong>IP_MULTICAST_TTL</strong>：IP 参数，多播数据报的 time-to-live 即存活跳数。</li>\n<li><strong>IP_TOS</strong>：已说明</li>\n<li><strong>DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION</strong>：Netty 参数，DatagramChannel 注册的 EventLoop 即表示已激活。</li>\n</ul>\n<h3 id=\"attrs-属性\"><a href=\"#attrs-属性\" class=\"headerlink\" title=\"attrs 属性\"></a>attrs 属性</h3><p>设置 Channel 的 attrs 属性，attrs 是用户自定义的 key-value 对，ServerBootstrap 和 Bootstrap 通用，对服务端而言会把 key-value 添加到 ServerSocketChannel，对客户端而言会把 key-value 添加到 SocketChannel。</p>\n<blockquote>\n<p>Bootstrap 在启动过程中会调用 initAndRegister() 方法创建 Channel，然后把 options 和 attrs 属性设置到 Channel 上。</p>\n</blockquote>\n<p>使用 Bootstrap 的 attrs 属性添加的自定义 key-value 作为全局变量，被和该 Bootstrap 关联的所有 Channel 共用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">serverBootstrap.attr(AttributeKey.valueOf(&quot;key&quot;), &quot;value&quot;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"handler-属性\"><a href=\"#handler-属性\" class=\"headerlink\" title=\"handler 属性\"></a>handler 属性</h3><p>把 handler 添加到 Channel 上，ServerBootstrap 和 Bootstrap 通用，对服务端而言会把 handler 添加到 ServerSocketChannel，对客户端而言会把 handler 添加到 SocketChannel。</p>\n<p>如果只有单个 handler，可以直接添加</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">serverBootstrap.handler(new PacketDecoder());</span><br></pre></td></tr></table></figure>\n\n<p>如果有多个 handler，可以借助 NettyClientInitializer 类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">serverBootstrap.handler(new ChannelInitializer&lt;ServerSocketChannel&gt;() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected void initChannel(ServerSocketChannel ch) throws Exception &#123;</span><br><span class=\"line\">        // 解密</span><br><span class=\"line\">        ch.pipeline().addLast(&quot;packetDecoder&quot;, new PacketDecoder());</span><br><span class=\"line\">        // 子命令解码器</span><br><span class=\"line\">        ch.pipeline().addLast(&quot;subPacketDecoder&quot;, new SubPacketDecoder());</span><br><span class=\"line\">        // 返回封包</span><br><span class=\"line\">        ch.pipeline().addLast(&quot;packetEncoder&quot;, new PacketEncoder());</span><br><span class=\"line\">        // 子命令封包</span><br><span class=\"line\">        ch.pipeline().addLast(&quot;subPacketEncoder&quot;, new SubPacketEncoder());</span><br><span class=\"line\">        // 登陆</span><br><span class=\"line\">        ch.pipeline().addLast(&quot;loginSendHandler&quot;, new LoginSenderhandler());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>ChannelInitializer 是一种特殊的 ChannelHandler，负责把多个 Handler 和自己添加到 Channel 对应的 pipeline 中，最后把自己移除，这部分看源码可以看出来</p>\n<pre><code>private boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;\n    if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) &#123; // Guard against re-entrance.\n        try &#123;\n            // 这个是抽象方法，我们在实例化 ChannelInitializer 类时必须实现的就是这个方法\n            initChannel((C) ctx.channel());\n        &#125; catch (Throwable cause) &#123;\n            exceptionCaught(ctx, cause);\n        &#125; finally &#123;\n            // 移除多余的 ChannelHandler，具体见下\n            remove(ctx);\n        &#125;\n        return true;\n    &#125;\n    return false;\n&#125;\n\nprivate void remove(ChannelHandlerContext ctx) &#123;\n    try &#123;\n        ChannelPipeline pipeline = ctx.pipeline();\n        if (pipeline.context(this) != null) &#123;\n            // 把本实例也就是 ChannelInitializer 实例从 pipeline 中移除\n            pipeline.remove(this);\n        &#125;\n    &#125; finally &#123;\n        initMap.remove(ctx);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"childOptions、childAttrs、childHandler-属性\"><a href=\"#childOptions、childAttrs、childHandler-属性\" class=\"headerlink\" title=\"childOptions、childAttrs、childHandler 属性\"></a>childOptions、childAttrs、childHandler 属性</h3><p>这四个属性是用来设置服务端的 workerLoopGroup 的属性，具体设置方法和没有带 child 前缀的属性基本相同，两者的区别是：不带 child 前缀的属性在程序初始化时就会执行，带 child 前缀的属性在客户端 connect 成功后才会执行。</p>\n<h1 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h1><p>下面我们开始使用上面介绍的属性创建一个 Bootstrap 对象，示例化方式分为服务端 ServerBootstrap 和客户端 Bootstrap。</p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">NioEventLoopGroup bossGroup = new NioEventLoopGroup();</span><br><span class=\"line\">NioEventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class=\"line\">// 服务端启动类使用ServerBootstrap</span><br><span class=\"line\">ServerBootstrap bootstrap = new ServerBootstrap();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">   // 设置eventLoopGroup，服务端一般情况下会使用bossGroup和workerGroup两组NioEventLoopGroup</span><br><span class=\"line\">   bootstrap.group(bossGroup, workerGroup)</span><br><span class=\"line\">         // 设置channelFactory，服务端设置NioServerSocketChannel，表示这是NIO模式的TCP连接</span><br><span class=\"line\">         .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">         // 设置localAddress，也可以不在这里设置，在下面的bind方法里面设置</span><br><span class=\"line\">         .localAddress(8000)</span><br><span class=\"line\">         // 设置option，SO_BACKLOG表示服务端接受连接的队列长度为100，如果队列已满，客户端连接将被拒绝。</span><br><span class=\"line\">         .option(ChannelOption.SO_BACKLOG, 100)</span><br><span class=\"line\">         // 设置attr</span><br><span class=\"line\">         .attr(AttributeKey.valueOf(&quot;key&quot;), &quot;value&quot;)</span><br><span class=\"line\">         // 设置handler，使用Netty自带的LoggingHandler作为acceptor</span><br><span class=\"line\">         .handler(new LoggingHandler())</span><br><span class=\"line\">         // 设置childOption，TCP_NODELAY表示不管数据大小有数据就发送，SO_KEEPALIVE表示开启心跳探测</span><br><span class=\"line\">         .childOption(ChannelOption.TCP_NODELAY, true)</span><br><span class=\"line\">         .childOption(ChannelOption.SO_KEEPALIVE, true)</span><br><span class=\"line\">         // 设置childAttr</span><br><span class=\"line\">         .childAttr(AttributeKey.valueOf(&quot;childKey&quot;), &quot;childValue&quot;)</span><br><span class=\"line\">         // 设置childHandler，因为有多个ChannelHandler，所以使用ChannelInitializer</span><br><span class=\"line\">         .childHandler(new ChannelInitializer&lt;ServerSocketChannel&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            protected void initChannel(ServerSocketChannel ch) throws Exception &#123;</span><br><span class=\"line\">               // 解密</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;packetDecoder&quot;, new PacketDecoder());</span><br><span class=\"line\">               // 子命令解码器</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;subPacketDecoder&quot;, new SubPacketDecoder());</span><br><span class=\"line\">               // 返回封包</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;packetEncoder&quot;, new PacketEncoder());</span><br><span class=\"line\">               // 子命令封包</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;subPacketEncoder&quot;, new SubPacketEncoder());</span><br><span class=\"line\">               // 登陆</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;loginSendHandler&quot;, new LoginSenderhandler());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 调用bind()启动服务器，并对启动结果增加回调监听</span><br><span class=\"line\">   ChannelFuture future = bootstrap.bind().sync().addListener(f -&gt; &#123;</span><br><span class=\"line\">      if(f.isSuccess()) &#123;</span><br><span class=\"line\">         log.info(&quot;服务端启动成功&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 对服务端关闭增加回调监听</span><br><span class=\"line\">   future.channel().closeFuture().sync().addListener(f -&gt; &#123;</span><br><span class=\"line\">      if(f.isSuccess()) &#123;</span><br><span class=\"line\">         log.info(&quot;服务端关闭服务&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">   // 销毁资源</span><br><span class=\"line\">   bossGroup.shutdownGracefully();</span><br><span class=\"line\">   workerGroup.shutdownGracefully();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>服务端启动流程代码解析</strong></p>\n<ol>\n<li>创建两组 NioEventLoopGroup 实例：bossGroup 和 workerGroup。</li>\n<li>创建 ServerBootstrap 实例。</li>\n<li>把 bossGroup 和 workerGroup 注册到 ServerBootstrap 实例。下面 4 ～ 8 为设置 bossGroup 实例属性，9 ～ 11 为设置 workerGroup 实例属性。</li>\n<li>设置 channelFactory，服务端一般配置为 NioServerSocketChannel.class。</li>\n<li>设置 localAddress，绑定本地端口 8000。</li>\n<li>设置 option，SO_BACKLOG 是服务端属性，表示服务端接受连接的队列长度为100，如果队列已满，客户端连接将被拒绝。</li>\n<li>设置 attr。</li>\n<li>设置 handler，直接使用 Netty 自带的 LoggingHandler 作为 acceptor。</li>\n<li>设置 childOption，TCP_NODELAY 表示不管数据大小有数据就发送，SO_KEEPALIVE 表示开启心跳探测。</li>\n<li>设置 childAttr。</li>\n<li>设置 childHandler，因为有多个 ChannelHandler，所以使用 ChannelInitializer。</li>\n<li>ServerBootstrap 实例调用 <code>bind()</code> 启动服务器，并对启动结果增加回调监听。</li>\n<li>对服务端关闭增加回调监听</li>\n<li>服务端关闭后销毁资源</li>\n</ol>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">NioEventLoopGroup group = new NioEventLoopGroup();</span><br><span class=\"line\">// 客户端启动类使用Bootstrap</span><br><span class=\"line\">Bootstrap bootstrap = new Bootstrap();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">   // 设置eventLoopGroup，客户端只需要设置一组</span><br><span class=\"line\">   bootstrap.group(group)</span><br><span class=\"line\">         // 设置channelFactory，客户端设置NioSocketChannel，表示这是NIO模式的TCP连接</span><br><span class=\"line\">         .channel(NioSocketChannel.class)</span><br><span class=\"line\">         // 设置remoteAddress，也可以不在这里设置，在下面的connect方法里面设置</span><br><span class=\"line\">         .remoteAddress(&quot;192.168.10.1&quot;, 8000)</span><br><span class=\"line\">         // 设置option，TCP_NODELAY 表示不管数据大小有数据就发送，SO_KEEPALIVE表示开启心跳探测</span><br><span class=\"line\">         .option(ChannelOption.TCP_NODELAY, true)</span><br><span class=\"line\">         .option(ChannelOption.SO_KEEPALIVE, true)</span><br><span class=\"line\">         // 设置attr</span><br><span class=\"line\">         .attr(AttributeKey.valueOf(&quot;key&quot;), &quot;value&quot;)</span><br><span class=\"line\">         // 设置handler，因为有多个ChannelHandler，所以使用ChannelInitializer</span><br><span class=\"line\">         .handler(new ChannelInitializer&lt;ServerSocketChannel&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            protected void initChannel(ServerSocketChannel ch) throws Exception &#123;</span><br><span class=\"line\">               // 解密</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;packetDecoder&quot;, new PacketDecoder());</span><br><span class=\"line\">               // 子命令解码器</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;subPacketDecoder&quot;, new SubPacketDecoder());</span><br><span class=\"line\">               // 返回封包</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;packetEncoder&quot;, new PacketEncoder());</span><br><span class=\"line\">               // 子命令封包</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;subPacketEncoder&quot;, new SubPacketEncoder());</span><br><span class=\"line\">               // 登陆</span><br><span class=\"line\">               ch.pipeline().addLast(&quot;loginSendHandler&quot;, new LoginSenderhandler());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 客户端调用connect()开始连接服务器，并增加回调监听</span><br><span class=\"line\">   ChannelFuture future = bootstrap.connect().sync().addListener(f -&gt; &#123;</span><br><span class=\"line\">      if(f.isSuccess()) &#123;</span><br><span class=\"line\">         log.info(&quot;客户端连接成功&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">   // 断开服务器增加回调监听</span><br><span class=\"line\">   future.channel().closeFuture().sync().addListener(f -&gt; &#123;</span><br><span class=\"line\">      if(f.isSuccess()) &#123;</span><br><span class=\"line\">         log.info(&quot;客户端连接断开&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">   // 销毁资源</span><br><span class=\"line\">   group.shutdownGracefully();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>客户端启动流程代码解析</strong></p>\n<p>客户端的启动代码相对于服务端就简单很多</p>\n<ol>\n<li>创建一个 NioEventLoopGroup 实例：group</li>\n<li>创建 Bootstrap 实例。</li>\n<li>把 group 注册到 Bootstrap 实例，下面 4 ～ 8 为设置 group 实例属性。</li>\n<li>设置 channelFactory，客户端一般设置 NioSocketChannel.class。</li>\n<li>设置 remoteAddress，设置远程主机地址和端口。</li>\n<li>设置 option，TCP_NODELAY 表示不管数据大小有数据就发送，SO_KEEPALIVE 表示开启心跳探测。</li>\n<li>设置 attr。</li>\n<li>设置 handler，因为有多个 ChannelHandler，所以使用 ChannelInitializer。</li>\n<li>Bootstrap 实例使用 <code>connect()</code> 连接远程服务器，并对连接结果增加回调监听。</li>\n<li>对客户端连接关闭增加回调监听。</li>\n<li>客户端关闭后销毁资源。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文介绍了 Netty 的启动类 Bootstrap。Bootstrap 按用途分为 ServerBootstrap 和 Bootstrap，分别对应服务端和客户端。Bootstrap 的常用属性有：</p>\n<ul>\n<li>group</li>\n<li>channelFactory</li>\n<li>localAddress、remoteAddress</li>\n<li>options</li>\n<li>attrs</li>\n<li>handler</li>\n<li>childOptions、childAttrs、childHandler</li>\n</ul>\n<p>其中 localAddress、childOptions、childAttrs 和 childHandler是服务端属性，remoteAddress 是客户端属性，其他两者通用。最后通过实战例子分别分析 ServerBootstrap 和 Bootstrap 的具体启动过程。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href>《Netty In Action》</a></p>\n<p><a href=\"http://www.kancloud.cn:8080/ssj234/netty-source/433213\"> Netty服务器启动过程</a></p>\n","categories":["Netty"],"tags":["Netty"]},{"title":"Netty系列（五）：EventLoop和EventLoopGroup","url":"/2020/05/28/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AEventLoop%E5%92%8CEventLoopGroup/","content":"<blockquote>\n<p>上一篇文章介绍了 Netty 的启动器 Bootstrap，这篇开始介绍 Netty 的线程机制 EventLoop 和 EventLoopGroup，包括 EventLoop 和 EventLoopGroup 的简介、类继承结构和实例化过程。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"EventLoop-和-EventLoopGroup-是什么\"><a href=\"#EventLoop-和-EventLoopGroup-是什么\" class=\"headerlink\" title=\"EventLoop 和 EventLoopGroup 是什么\"></a>EventLoop 和 EventLoopGroup 是什么</h1><p>Netty 的非阻塞线程模型的实现基于 NIO Reactor 模型，其中 EventLoop 和 EventLoopGroup 是该线程模型的核心组件。当然 Netty 也提供了阻塞线程模型的实现，在这里对阻塞模型不做介绍。</p>\n<p>一个 EventLoop 只包含一个死循环的线程，用于处理绑定到该 EventLoop 的所有 Channel 的 IO 操作和业务操作。一个 EventLoop 包含一到多个 Channel。</p>\n<p>一个 EventLoopGroup 包含一到多个 EventLoop，EventLoopGroup 负责将 EventLoop 分配给每个新创建的 Channel。</p>\n<p>EventLoop、EventLoopGroup 和 Channel 的整体关系图如下：</p>\n<div style=\"width: 80%; margin: auto\">![relation](relation.png)</div>\n# EventLoop\n\n<p>EventLoop 是用来执行任务的单线程，任务包括周期性的 IO 任务（accept、read、write等）和用户自定义任务（decode、compute、encode）等。为了清晰了解 EventLoop 的内部结构，下面我们从 EventLoop 接口的继承结构开始介绍。</p>\n<h2 id=\"EventLoop-继承结构\"><a href=\"#EventLoop-继承结构\" class=\"headerlink\" title=\"EventLoop 继承结构\"></a>EventLoop 继承结构</h2><div style=\"width: 50%; margin: auto\">![Eventloop](Eventloop.png)</div>\n在这个类图里面，EventExecutorGroup 上层是  JDK 提供的并发包接口，下层是 Netty 提供的抽象类和实现。EventLoop 的继承结构这么复杂，有一部分原因是为了使用父接口或父类里面的部分特性或者方法而已，和父接口或父类的用途定位并没有太多的关联。下面我们按接口用途分组介绍：\n\n<ul>\n<li>Executor、ExecutorService、ScheduledExecutorService</li>\n<li>Iterable</li>\n<li>EventExecutorGroup</li>\n<li>EventExecutor、OrderedEventExecutor</li>\n<li>EventLoopGroup、EventLoop</li>\n</ul>\n<h3 id=\"Executor、ExecutorService、ScheduledExecutorService\"><a href=\"#Executor、ExecutorService、ScheduledExecutorService\" class=\"headerlink\" title=\"Executor、ExecutorService、ScheduledExecutorService\"></a>Executor、ExecutorService、ScheduledExecutorService</h3><p>这三个都是 java.util.concurrent 里面提供的接口，是 Java5 之后引进的，基本定义了 Java 的线程池机制，用来控制线程的启动、执行和关闭。</p>\n<p>Executor 是最基础的父接口，只定义了一个方法 <code>execute(Runnable command)</code>，用来执行一个 Runable 实例。</p>\n<p>ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法。例如 <code>submit(Runnable task)</code> 用于提交任务并返回异步执行结果 Future，<code>shutdown()</code> 用于平滑地关闭线程池（先拒绝接收新的任务，然后等待已接收的任务全部执行完毕，再关闭线程池）。</p>\n<p>ScheduledExecutorService 接口继承自 ExecutorService 接口，是一种用于延时和定期执行任务的特殊线程池。EventLoop 继承这个接口是为了继承这里面的延时或周期执行的方法，在 Netty 中，有可能用户线程和 I&#x2F;O 线程同时操作网络资源，而为了减少并发锁竞争，Netty 将用户线程的任务包装成 task，然后像 Netty 的 I&#x2F;O 任务一样延期执行，另外有些时候需要周期性执行任务例如心跳检测。</p>\n<h3 id=\"Iterable\"><a href=\"#Iterable\" class=\"headerlink\" title=\"Iterable\"></a>Iterable</h3><p>上面我们谈到 EventLoopGroup 包含一到多个 EventLoop，实现 Iterable 接口可以对所有 EventLoop 进行遍历。</p>\n<h3 id=\"EventExecutorGroup\"><a href=\"#EventExecutorGroup\" class=\"headerlink\" title=\"EventExecutorGroup\"></a>EventExecutorGroup</h3><p>EventExecutorGroup 是 Netty 自定义线程模型的基础接口，下面是接口方法定义</p>\n<div style=\"width: 50%; margin: auto\">![EventExecutorGroup](EventExecutorGroup.png)</div>\n我们可以看到 EventExecutorGroup 是对继承的接口的大部分方法进行 Override，并自定义了部分方法。EventExecutorGroup 提供的功能有：\n\n<ul>\n<li>提供线程池的基础功能，例如 <code>submit</code> 提交任务功能，并废弃了原始的关闭线程池接口 <code>shutdown()</code>，自定义了关闭线程池接口 <code>shutdownGracefully()</code>。</li>\n<li>提供延时和周期执行的功能。</li>\n<li>提供迭代功能。</li>\n</ul>\n<h3 id=\"EventExecutor、OrderedEventExecutor\"><a href=\"#EventExecutor、OrderedEventExecutor\" class=\"headerlink\" title=\"EventExecutor、OrderedEventExecutor\"></a>EventExecutor、OrderedEventExecutor</h3><p>EventExecutor 相当于 EventExecutorGroup 的扩展，提供了 <code>next()</code>、<code>parent()</code> 等判断集合关系的方法。</p>\n<div style=\"width: 50%; margin: auto\">![EventExecutor](EventExecutor.png)</div>\nOrderedEventExecutor 是一个空接口，作用是为了说明继承这个接口就可以使用顺序执行任务等功能。\n\n<h3 id=\"EventLoopGroup、EventLoop\"><a href=\"#EventLoopGroup、EventLoop\" class=\"headerlink\" title=\"EventLoopGroup、EventLoop\"></a>EventLoopGroup、EventLoop</h3><p>EventLoopGroup 提供了把 Channel 注册到具体 EventLoop 的方法。</p>\n<div style=\"width: 50%; margin: auto\">![EventLoopGroup](EventLoopGroup.png)</div>\nEventLoop 只提供一个 `parent()` 方法，用于判断 EventLoop 所属的 EventLoopGroup。\n\n<p>NioEventLoop 是 EventLoop 接口最常用的实现类。下面我们简单分析下 NioEventLoop 类。</p>\n<h2 id=\"NioEventLoop-继承结构\"><a href=\"#NioEventLoop-继承结构\" class=\"headerlink\" title=\"NioEventLoop 继承结构\"></a>NioEventLoop 继承结构</h2><div style=\"width: 80%; margin: auto\">![NioEventLoop](NioEventLoop.png)</div>\n我们可以看到 NioEventLoop 的继承结构更复杂，右侧是上面介绍 EventLoop 的接口的继承结构，左侧是抽象类的继承关系。下面我们简单介绍几个抽象类：\n\n<ul>\n<li>AbstractExecutorService</li>\n<li>AbstractEventExecutor</li>\n<li>SingleThreadEventExecutor</li>\n<li>SingleThreadEventLoop</li>\n</ul>\n<h3 id=\"AbstractExecutorService\"><a href=\"#AbstractExecutorService\" class=\"headerlink\" title=\"AbstractExecutorService\"></a>AbstractExecutorService</h3><p>AbstractExecutorService 也是 java.util.concurrent 包里面的抽象类，实现了 ExecutorService 接口的部分方法。</p>\n<div style=\"width: 50%; margin: auto\">![AbstractExecutorService](AbstractExecutorService.png)</div>\nAbstractExecutorService 主要实现了执行任务的相关方法，例如 `submit`、`invokeAny` 等，把返回结果封装为 FutureTask 实例。\n\n<h3 id=\"AbstractEventExecutor\"><a href=\"#AbstractEventExecutor\" class=\"headerlink\" title=\"AbstractEventExecutor\"></a>AbstractEventExecutor</h3><p>AbstractEventExecutor 以下是 Netty 定义的类，继承了 AbstractExecutorService 类，增加了 group 的概念。</p>\n<div style=\"width: 50%; margin: auto\">![AbstractEventExecutor](AbstractEventExecutor.png)</div>\n### AbstractScheduledEventExecutor\n\n<p>AbstractScheduledEventExecutor 继承了 AbstractEventExecutor，增加了可以延时或周期执行的任务队列 scheduledTaskQueue，并实现了 <code>schedule</code> 延时执行以及 <code>scheduleAtFixedRate</code> 周期执行等方法。</p>\n<div style=\"width: 50%; margin: auto\">![AbstractScheduledEventExecutor](AbstractScheduledEventExecutor.png)</div>\n### SingleThreadEventExecutor\n\n<p>SingleThreadEventExecutor 继承了 AbstractScheduledEventExecutor，实现了 EventLoop 的大部分功能，基本上算是最终 EventLoop 的一个雏型了。这个类的功能非常丰富，我们看下最关键的几个属性和方法。</p>\n<div style=\"width: 50%; margin: auto\">![SingleThreadEventExecutor](SingleThreadEventExecutor.png)</div>\n**关键属性**\n\n<ul>\n<li>thread：每个 EventLoop 和一个死循环的线程进行绑定，这个线程就是在这里定义的。</li>\n<li>taskQueue：除了 IO 操作之外的其他任务，都放在这个队列里面依次执行。</li>\n<li>executor：在这里可以把这个理解为只有一个线程的线程池，可通过 executor 执行任务或获取执行线程的状态等。</li>\n</ul>\n<p>这个类里面实现 EventLoop 在生命周期中的大部分工作：启动、添加任务、执行任务和关闭等。</p>\n<p><strong>启动</strong></p>\n<pre><code>private void doStartThread() &#123;\n    assert thread == null;\n    executor.execute(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            // 新建一个线程，并把线程和当前实例的thread对象绑定，这个thread就是NioEventLoop绑定的线程\n            thread = Thread.currentThread();\n            if (interrupted) &#123;\n                thread.interrupt();\n            &#125;\n\n            boolean success = false;\n            updateLastExecutionTime();\n            try &#123;\n                // 启动NioEventLoop的run方法\n                SingleThreadEventExecutor.this.run();\n                success = true;\n            &#125; catch (Throwable t) &#123;\n                logger.warn(&quot;Unexpected exception from an event executor: &quot;, t);\n            &#125; finally &#123;\n                // 循环判断线程状态，如果是关闭中状态就进行下一步操作\n                for (;;) &#123;\n                    int oldState = state;\n                    if (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(\n                            SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) &#123;\n                        break;\n                    &#125;\n                &#125;\n\n                ......\n            &#125;\n        &#125;\n    &#125;);\n&#125;\n</code></pre>\n<p>启动代码里面新建一个线程，并把线程和当前实例的 thread 对象绑定，这个 thread 就是 NioEventLoop 实例绑定的线程，然后再启动 NioEventLoop 实例。</p>\n<p><strong>添加任务</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">protected void addTask(Runnable task) &#123;</span><br><span class=\"line\">    if (task == null) &#123;</span><br><span class=\"line\">        throw new NullPointerException(&quot;task&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!offerTask(task)) &#123;</span><br><span class=\"line\">        reject(task);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">final boolean offerTask(Runnable task) &#123;</span><br><span class=\"line\">    if (isShutdown()) &#123;</span><br><span class=\"line\">        reject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return taskQueue.offer(task);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>添加任务过程很简单，就是把新的 task 添加到 taskQueue。</p>\n<p><strong>执行任务</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">protected final boolean runAllTasksFrom(Queue&lt;Runnable&gt; taskQueue) &#123;</span><br><span class=\"line\">    Runnable task = pollTaskFrom(taskQueue);</span><br><span class=\"line\">    if (task == null) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        //安全执行任务</span><br><span class=\"line\">        safeExecute(task);</span><br><span class=\"line\">        //继续执行剩余任务</span><br><span class=\"line\">        task = pollTaskFrom(taskQueue);</span><br><span class=\"line\">        if (task == null) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">protected final Runnable pollTaskFrom(Queue&lt;Runnable&gt; taskQueue) &#123;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        Runnable task = taskQueue.poll();</span><br><span class=\"line\">        //忽略WAKEUP_TASK类型任务</span><br><span class=\"line\">        if (task == WAKEUP_TASK) &#123;</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return task;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">protected boolean runAllTasks(long timeoutNanos) &#123;</span><br><span class=\"line\">    //先执行周期任务</span><br><span class=\"line\">    fetchFromScheduledTaskQueue();</span><br><span class=\"line\">    //从taskQueue提一个任务，如果为空执行所有tailTasks</span><br><span class=\"line\">    Runnable task = pollTask();</span><br><span class=\"line\">    //如果taskQueue没有任务，立即执行子类的tailTasks</span><br><span class=\"line\">    if (task == null) &#123;</span><br><span class=\"line\">         afterRunningAllTasks();</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //计算出超时时间 = 当前 nanoTime + timeoutNanos</span><br><span class=\"line\">    final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</span><br><span class=\"line\">    long runTasks = 0;</span><br><span class=\"line\">    long lastExecutionTime;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        safeExecute(task);</span><br><span class=\"line\"></span><br><span class=\"line\">        runTasks ++;</span><br><span class=\"line\">        //当执行任务次数大于64判断是否超时，防止长时间独占CPU</span><br><span class=\"line\">        if ((runTasks &amp; 0x3F) == 0) &#123;</span><br><span class=\"line\">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class=\"line\">            if (lastExecutionTime &gt;= deadline) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        task = pollTask();</span><br><span class=\"line\">        if (task == null) &#123;</span><br><span class=\"line\">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    afterRunningAllTasks();</span><br><span class=\"line\">    this.lastExecutionTime = lastExecutionTime;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里包含安全执行执行单个任务、取出任务和执行所有任务。所有任务包括 taskQueue 和 下面提到到的 tailTasks。</p>\n<h3 id=\"SingleThreadEventLoop\"><a href=\"#SingleThreadEventLoop\" class=\"headerlink\" title=\"SingleThreadEventLoop\"></a>SingleThreadEventLoop</h3><p>SingleThreadEventLoop 继承了 SingleThreadEventExecutor 类，主要增加了 tailTasks 属性。</p>\n<div style=\"width: 50%; margin: auto\">![SingleThreadEventLoop](SingleThreadEventLoop.png)</div>\ntailTasks 中是用户自定义的一些列在本次事件循环遍历结束后会执行的任务，我们可以通过类似如下的方式来添加 tailTask。\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">((NioEventLoop)ctx.channel().eventLoop()).executeAfterEventLoopIteration(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// add some task to execute after eventLoop iteration</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NioEventLoop\"><a href=\"#NioEventLoop\" class=\"headerlink\" title=\"NioEventLoop\"></a>NioEventLoop</h3><p>NioEventLoop 是最终实现类，这里定义了较多的方法和属性，其中最重要的有三个属性：</p>\n<ul>\n<li>SELECTOR_AUTO_REBUILD_THRESHOLD：用于解决 NIO 空轮询导致 cpu 飙升到 100% 的 bug。</li>\n<li>selector：选择器。</li>\n<li>selectorProvider：选择器的生产类。</li>\n<li>ioRatio：在事件循环中期待用于处理 I&#x2F;O 操作时间的百分比。</li>\n</ul>\n<div style=\"width: 50%; margin: auto\">![NioEventLoop1](NioEventLoop1.png)</div>\n**selector**\n\n<p>netty 的 selector 对 NIO 的 selector 进行进一步封装，解决了空轮询导致 cpu 100% 的问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">private void select(boolean oldWakenUp) throws IOException &#123;</span><br><span class=\"line\">    Selector selector = this.selector;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        // select操作计数</span><br><span class=\"line\">        int selectCnt = 0;</span><br><span class=\"line\">        // 记录当前系统时间</span><br><span class=\"line\">        long currentTimeNanos = System.nanoTime();</span><br><span class=\"line\">        // delayNanos方法用于计算定时任务队列，最近一个任务的截止时间</span><br><span class=\"line\">        // selectDeadLineNanos 表示当前select操作所不能超过的最大截止时间</span><br><span class=\"line\">        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (;;) &#123;</span><br><span class=\"line\">            // 计算超时时间，判断是否超时</span><br><span class=\"line\">            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;</span><br><span class=\"line\">            // 如果 timeoutMillis &lt;= 0， 表示超时，进行一个非阻塞的 select 操作。设置 selectCnt 为 1. 并终止本次循环。</span><br><span class=\"line\">            if (timeoutMillis &lt;= 0) &#123;</span><br><span class=\"line\">                if (selectCnt == 0) &#123;</span><br><span class=\"line\">                    selector.selectNow();</span><br><span class=\"line\">                    selectCnt = 1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            // 如果当前任务队列为空，并且超时时间未到，则进行一个阻塞式的selector操作。timeoutMillis 为最大的select时间</span><br><span class=\"line\">            int selectedKeys = selector.select(timeoutMillis);</span><br><span class=\"line\">            // 操作计数 +1</span><br><span class=\"line\">            selectCnt ++;</span><br><span class=\"line\">            </span><br><span class=\"line\">            // 记录当前时间</span><br><span class=\"line\">            long time = System.nanoTime();</span><br><span class=\"line\">            // 如果time &gt; currentTimeNanos + timeoutMillis(超时时间)，则表明已经执行过一次select操作</span><br><span class=\"line\">            if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class=\"line\">                // timeoutMillis elapsed without anything selected.</span><br><span class=\"line\">                selectCnt = 1;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            // 如果 time &lt;= currentTimeNanos + timeoutMillis，表示触发了空轮训</span><br><span class=\"line\">            // 如果空轮训的次数超过 SELECTOR_AUTO_REBUILD_THRESHOLD (512)，则重建一个新的selctor，避免空轮训</span><br><span class=\"line\">            else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;</span><br><span class=\"line\">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class=\"line\">                logger.warn(</span><br><span class=\"line\">                        &quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;,</span><br><span class=\"line\">                        selectCnt, selector);</span><br><span class=\"line\">    </span><br><span class=\"line\">                // 重建创建一个新的selector</span><br><span class=\"line\">                rebuildSelector();</span><br><span class=\"line\">                selector = this.selector;</span><br><span class=\"line\">    </span><br><span class=\"line\">                // Select again to populate selectedKeys.</span><br><span class=\"line\">                // 对重建后的selector进行一次非阻塞调用，用于获取最新的selectedKeys</span><br><span class=\"line\">                selector.selectNow();</span><br><span class=\"line\">                // 设置select计数</span><br><span class=\"line\">                selectCnt = 1;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            currentTimeNanos = time;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125; catch (CancelledKeyException e) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>selectorProvider</strong></p>\n<p>我们调用 <code>Selector selector = Selector.open()</code> 创建 selector 的时候，内部会调用到 SelectorProvider。而在创建 SelectorProvider 对象本身的时候，不同系统会调用各自版本的 JDK 里自带的 sun.nio.ch.DefaultSelectorProvider。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 实际上调用SelectorProvider来创建Selector</span><br><span class=\"line\">public static Selector open() throws IOException &#123;</span><br><span class=\"line\">    return SelectorProvider.provider().openSelector();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// windows版本下SelectorProvider的创建</span><br><span class=\"line\">public class DefaultSelectorProvider &#123;</span><br><span class=\"line\">    public static SelectorProvider create() &#123;</span><br><span class=\"line\">        return new WindowsSelectorProvider();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// mac版本下SelectorProvider的创建</span><br><span class=\"line\">public class DefaultSelectorProvider &#123;</span><br><span class=\"line\">    public static SelectorProvider create() &#123;</span><br><span class=\"line\">        return new KQueueSelectorProvider();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// linux版本下SelectorProvider的创建</span><br><span class=\"line\">public class DefaultSelectorProvider &#123;</span><br><span class=\"line\">    public static SelectorProvider create() &#123;</span><br><span class=\"line\">        String str1 = (String) AccessController.doPrivileged(new GetPropertyAction(</span><br><span class=\"line\">                    &quot;os.name&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">        if (&quot;SunOS&quot;.equals(str1)) &#123;</span><br><span class=\"line\">            return new DevPollSelectorProvider();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (&quot;Linux&quot;.equals(str1)) &#123;</span><br><span class=\"line\">            String str2 = (String) AccessController.doPrivileged(new GetPropertyAction(</span><br><span class=\"line\">                        &quot;os.version&quot;));</span><br><span class=\"line\">            String[] arrayOfString = str2.split(&quot;\\\\.&quot;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">            if (arrayOfString.length &gt;= 2) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    int i = Integer.parseInt(arrayOfString[0]);</span><br><span class=\"line\">                    int j = Integer.parseInt(arrayOfString[1]);</span><br><span class=\"line\"></span><br><span class=\"line\">                    if ((i &gt; 2) || ((i == 2) &amp;&amp; (j &gt;= 6))) &#123;</span><br><span class=\"line\">                        return new EPollSelectorProvider();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; catch (NumberFormatException localNumberFormatException) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return new PollSelectorProvider();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>ioRatio</strong></p>\n<p>当 ioRatio 变量为100的时候（默认50），处理 select 事件，处理完之后执行任务队列中的所有任务。 反之当不是 100 的时候，处理 select 事件，之后给定一个时间内执行任务队列中的任务。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">final int ioRatio = this.ioRatio;</span><br><span class=\"line\">if (ioRatio == 100) &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        processSelectedKeys();</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        // Ensure we always run tasks.</span><br><span class=\"line\">        runAllTasks();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    final long ioStartTime = System.nanoTime();</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        processSelectedKeys();</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        // Ensure we always run tasks.</span><br><span class=\"line\">        final long ioTime = System.nanoTime() - ioStartTime;</span><br><span class=\"line\">        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"EventLoop-总结\"><a href=\"#EventLoop-总结\" class=\"headerlink\" title=\"EventLoop 总结\"></a>EventLoop 总结</h2><ul>\n<li>EventLoop 可以理解为只有一个死循环线程的线程池。</li>\n<li>EventLoop 归属某个 EventLoopGroup，可以获取在同一个 EventLoopGroup 下的其他 EventLoop 实例。</li>\n<li>EventLoop 可以执行线程池的各种功能，例如启动、提交任务、执行任务和关闭等</li>\n<li>EventLoop 可以执行普通任务、延时任务或者周期性任务等，任务全部放到任务队列里面，按照 FIFO 规则执行，任务队列分类有：<ol>\n<li>scheduledTaskQueue，周期任务队列，例如 IO 操作等。scheduledTaskQueue 中的任务都会取出来先放入 taskQueue，再从 taskQueue 取出来执行。</li>\n<li>taskQueue，用户任务队列</li>\n<li>tailTasks，也是用户任务队列，但优先级比 taskQueue 低，用于存储当前或下一次事件循环(eventloop)迭代结束后需要执行的任务。</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"EventLoopGroup\"><a href=\"#EventLoopGroup\" class=\"headerlink\" title=\"EventLoopGroup\"></a>EventLoopGroup</h1><p>EventLoopGroup 是用来管理 EventLoop 的，负责把 Channel 绑定到 EventLoop 上，并返回其管理的 EventLoop 的各种状态。</p>\n<p>EventLoopGroup 接口的继承结构已经包含在 EventLoop 的继承结构里面，下面我们介绍 EventLoopGroup 接口最常用的实现类 NioEventLoopGroup 的继承结构。</p>\n<h2 id=\"NioEventLoopGroup-继承结构\"><a href=\"#NioEventLoopGroup-继承结构\" class=\"headerlink\" title=\"NioEventLoopGroup 继承结构\"></a>NioEventLoopGroup 继承结构</h2><div style=\"width: 50%; margin: auto\">![NioEventLoopGroup](NioEventLoopGroup.png)</div>\nEventLoopGroup 接口及以上的继承结构在上面已经介绍过，下面我们简单介绍下几个抽象类：\n\n<ul>\n<li>AbstractEventExecutorGroup</li>\n<li>MultithreadEventExecutorGroup</li>\n<li>MultithreadEventLoopGroup</li>\n</ul>\n<h3 id=\"AbstractEventExecutorGroup\"><a href=\"#AbstractEventExecutorGroup\" class=\"headerlink\" title=\"AbstractEventExecutorGroup\"></a>AbstractEventExecutorGroup</h3><p>AbstractEventExecutorGroup 对应 AbstractEventExecutor 的集合，我们看下具体的类方法</p>\n<div style=\"width: 50%; margin: auto\">![AbstractEventExecutorGroup](AbstractEventExecutorGroup.png)</div>\n可以看到和 AbstractEventExecutor 类里面实现的方法基本一致，实际上最终也是调用到 AbstractEventExecutor 类里面的方法。\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class=\"line\">\t\t// next()返回下一个EventExecutor实例，最终会调到AbstractEventExecutor类的submit方法</span><br><span class=\"line\">    return next().submit(task);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MultithreadEventExecutorGroup\"><a href=\"#MultithreadEventExecutorGroup\" class=\"headerlink\" title=\"MultithreadEventExecutorGroup\"></a>MultithreadEventExecutorGroup</h3><p>MultithreadEventExecutorGroup 继承了 AbstractEventExecutorGroup，增加了 children 队列存储 EventExecutor 实例，以及选择器 chooser 负责从 children 里面选择 EventExecutor 实例来执行任务。</p>\n<div style=\"width: 50%; margin: auto\">![MultithreadEventExecutorGroup](MultithreadEventExecutorGroup.png)</div>\nMultithreadEventExecutorGroup 的构造方法会初始化包含 n 个 Executor 元素的 children 数组。\n\n<pre><code>protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args) &#123;\n\n    children = new EventExecutor[nThreads];\n\n    for (int i = 0; i &lt; nThreads; i ++) &#123;\n        boolean success = false;\n        try &#123;\n            children[i] = newChild(executor, args);\n            success = true;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>MultithreadEventExecutorGroup 也包含关闭线程池的方法，看源码我们可以看到实际上是遍历 children 数组，逐个调用 Executor 元素的 <code>shutdownGracefully</code> 方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public Future&lt;?&gt; shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) &#123;</span><br><span class=\"line\">    for (EventExecutor l: children) &#123;</span><br><span class=\"line\">        l.shutdownGracefully(quietPeriod, timeout, unit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return terminationFuture();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MultithreadEventLoopGroup\"><a href=\"#MultithreadEventLoopGroup\" class=\"headerlink\" title=\"MultithreadEventLoopGroup\"></a>MultithreadEventLoopGroup</h3><p>MultithreadEventLoopGroup 继承了 MultithreadEventExecutorGroup 类，增加了 DEFAULT_EVENT_LOOP_THREADS 属性，这个属性定义了 children 数组的初始化大小。</p>\n<div style=\"width: 50%; margin: auto\">![MultithreadEventLoopGroup](MultithreadEventLoopGroup.png)</div>\nMultithreadEventLoopGroup 包含一个 static 块，定义 DEFAULT_EVENT_LOOP_THREADS 的值为 CPU 逻辑核数的两倍。\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">static &#123;</span><br><span class=\"line\">    DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(</span><br><span class=\"line\">            &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));</span><br><span class=\"line\"></span><br><span class=\"line\">    if (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">        logger.debug(&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;, DEFAULT_EVENT_LOOP_THREADS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在构造方法里面传入 DEFAULT_EVENT_LOOP_THREADS 参数，然后会调用父类 MultithreadEventExecutorGroup 的构造方法，设置 children 数组的长度为 DEFAULT_EVENT_LOOP_THREADS 的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) &#123;</span><br><span class=\"line\">    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外 MultithreadEventLoopGroup 也会负责完成把 Channel 注册到某一个 EventLoop 上。所以假如一共有 n 个 EventLoop，请求过来的第一个 Channel 被注册到第一个 EventLoop 上，第二个 Channel 被注册到下一个也就是第二个 EventLoop 上…..第 n + 1 个 Channel 又注册到第一个 EventLoop 上，如此循环。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public ChannelFuture register(Channel channel) &#123;</span><br><span class=\"line\">\t\t// 这里的next()最终会调用到chooser.next()，由chooser来选择下一个EventLoop</span><br><span class=\"line\">    return next().register(channel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"EventLoopGroup-总结\"><a href=\"#EventLoopGroup-总结\" class=\"headerlink\" title=\"EventLoopGroup 总结\"></a>EventLoopGroup 总结</h2><ul>\n<li>一个 EventLoopGroup 包含多个 EventLoop，使用 children 数组存放 EventLoop 对象，children 的长度初始化为 cpu 逻辑核数 * 2。</li>\n<li>调用 EventLoopGroup 的某个方法时，EventLoopGroup 会通过 chooser 选择策略获取到某个具体的 EventLoop，然后调用该 EventLoop 里面的具体方法，例如注册 Channel。</li>\n</ul>\n<h1 id=\"EventLoopGroup-和-EventLoop-实例化过程\"><a href=\"#EventLoopGroup-和-EventLoop-实例化过程\" class=\"headerlink\" title=\"EventLoopGroup 和 EventLoop 实例化过程\"></a>EventLoopGroup 和 EventLoop 实例化过程</h1><p>下面我们结合 EventLoop 和 EventLoopGroup 的继承结构涉及的接口和类，通过时序图的方式介绍 EventLoop 和 EventLoopGroup 的实例化和启动过程。</p>\n<h2 id=\"NioEventLoopGroup-实例化过程\"><a href=\"#NioEventLoopGroup-实例化过程\" class=\"headerlink\" title=\"NioEventLoopGroup 实例化过程\"></a>NioEventLoopGroup 实例化过程</h2><p>EventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children 数组, 其大小是 nThreads, 这样就构成了一个线程池。如果我们在实例化 NioEventLoopGroup 时, 如果指定线程池大小, 则 nThreads 就是指定的值, 反之是处理器核心数 * 2。MultithreadEventExecutorGroup 中会调用 newChild 抽象方法来初始化 children 数组，抽象方法 newChild 是在 NioEventLoopGroup 中实现的, 它返回一个 NioEventLoop 实例。</p>\n<p><img src=\"/.com//NioEventLoopGroupInstance.png\" alt=\"NioEventLoopGroupInstance\"></p>\n<h2 id=\"NioEventLoop-实例化过程\"><a href=\"#NioEventLoop-实例化过程\" class=\"headerlink\" title=\"NioEventLoop 实例化过程\"></a>NioEventLoop 实例化过程</h2><p>NioEventLoop 的实例化过程比较简单，主要是向上调用构造函数初始化 parent 等属性。</p>\n<p><img src=\"/.com//NioEventLoopInstance.png\" alt=\"NioEventLoopInstance\"></p>\n<h2 id=\"NioEventLoop-和-Channel-绑定过程\"><a href=\"#NioEventLoop-和-Channel-绑定过程\" class=\"headerlink\" title=\"NioEventLoop 和 Channel 绑定过程\"></a>NioEventLoop 和 Channel 绑定过程</h2><p>channel 关联 Eventloop 有三种情况</p>\n<ul>\n<li><p>客户端SocketChannel关联EventLoop。</p>\n</li>\n<li><p>服务端ServerSocketChannel关联EventLoop。</p>\n</li>\n<li><p>由服务端ServerSocketChannel创建的SocketChannel关联EventLoop。</p>\n</li>\n</ul>\n<p>Netty 厉害的就是把这三种情况都都能复用 Multithread EventLoopGroup 中的 register 方法</p>\n<p><img src=\"/.com//NioEventLoopChannel.png\" alt=\"NioEventLoopChannel\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文介绍了 EventLoop 和 EventLoopGroup 的继承结构，最后结合继承结构涉及的类介绍了 EventLoop 和 EventLoopGroup 的实例化过程。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href>netty源码</a></p>\n<p><a href=\"https://www.jianshu.com/p/f94f7005c2cd\">netty系列之（三）——EventLoop和EventLoopGroup</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000007403873\">Netty 源码分析之 三 我就是大名鼎鼎的 EventLoop(一)</a></p>\n<p><a href=\"https://juejin.im/entry/5c0908ee6fb9a049d131efa7\">Netty进阶：Netty核心NioEventLoop原理解析</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000016875286\"><a href=\"https://segmentfault.com/a/1190000016875286\">Netty NioEventLoop 启动过程源码分析</a></a></p>\n<p><a href=\"https://www.jianshu.com/p/84412c2c34f1\">netty补充NIO的SelectableChannel和SelectorProvider</a></p>\n","categories":["Netty"],"tags":["Netty"]},{"title":"Netty系列（七）：ByteBuf","url":"/2020/06/11/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AByteBuf/","content":"<blockquote>\n<p>上一节我们介绍了 Netty 的通讯通道 Channel，这一节我们开始介绍 Netty 的数据容器 ByteBuf，包括 ByteBuf 的原理、内存管理和常用方法等。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"ByteBuf是什么\"><a href=\"#ByteBuf是什么\" class=\"headerlink\" title=\"ByteBuf是什么\"></a>ByteBuf是什么</h2><p>ByteBuf 是 Netty 的数据容器，简单来说就是申请一块内存，后续可以在这块内存中执行读写数据等操作。相比起 NIO 原生的数据容器 ByteBuffer，ByteBuf 做了许多优化和改进：</p>\n<ul>\n<li>Bytebuffer 只有一个 index，读写公用，写模式到读模式转换需要调用 flip()，设置 index 值；Bytebuf 有读写两个 index,模式转换不用调用 flip()。</li>\n<li>Bytebuffer 不能扩容，每次 put 操作时，都会对可用空间进行校检，如果剩余空间不足，需要重新创建一个新的 ByteBuffer，然后将旧的 ByteBuffer 复制到新的 ByteBuffer 中去；而 ByteBuf 支持自动扩容。</li>\n<li>ByteBuf 用其内置的复合缓冲区可实现透明的零拷贝。</li>\n<li>ByteBuf 支持方法链接调用。</li>\n<li>ByteBuf 支持引用计数。</li>\n<li>ByteBuf 支持池技术(比如：线程池、数据库连接池)。</li>\n</ul>\n<h2 id=\"ByteBuf的工作原理\"><a href=\"#ByteBuf的工作原理\" class=\"headerlink\" title=\"ByteBuf的工作原理\"></a>ByteBuf的工作原理</h2><h3 id=\"ByteBuf的结构\"><a href=\"#ByteBuf的结构\" class=\"headerlink\" title=\"ByteBuf的结构\"></a>ByteBuf的结构</h3><p><strong>ByteBuf 本质是一个由不同的索引分别控制读访问和写访问的字节数组</strong>。以下是官方提供的 ByteBuf 的结构图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">+-------------------+------------------+------------------+</span><br><span class=\"line\">| discardable bytes |  readable bytes  |  writable bytes  |</span><br><span class=\"line\">|                   |     (CONTENT)    |                  |</span><br><span class=\"line\">+-------------------+------------------+------------------+</span><br><span class=\"line\">|                   |                  |                  |</span><br><span class=\"line\">0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span><br></pre></td></tr></table></figure>\n\n<p>ByteBuf 包含三个参数：</p>\n<ul>\n<li>readerIndex：读索引，不超过 writerIndex，调用 <code>readXXX()</code> 或 <code>skipBytes()</code> 方法会移动该索引，调用 <code>getXXX()</code> 方法则不会移动。</li>\n<li>writerIndex：写索引，不超过 capacity，调用 <code>writeXXX()</code> 方法会移动该索引，调用 <code>setXXX()</code> 则不会移动。</li>\n<li>capacity：容量，超过 capacity 后会自动扩容，最大容量不超过 Integer.MAX_VALUE。</li>\n</ul>\n<p>ByteBuf 被起始索引和这三个参数所在的索引分成三部分：</p>\n<ul>\n<li>discardable bytes（可丢弃字节）：范围为 0 ~ readerIndex，这部分字节数据已经被读取完，空间等待回收。</li>\n<li>readable bytes（可读字节）：范围为 readerIndex ~ writerIndex，这部分字节数据已经准备好，等待用户读取。</li>\n<li>writable bytes（可写字节）：范围为 writerIndex ~ capacity，这部分空闲空间可写入字节。</li>\n</ul>\n<h3 id=\"ByteBuf的的工作过程\"><a href=\"#ByteBuf的的工作过程\" class=\"headerlink\" title=\"ByteBuf的的工作过程\"></a>ByteBuf的的工作过程</h3><h4 id=\"1、初始化\"><a href=\"#1、初始化\" class=\"headerlink\" title=\"1、初始化\"></a>1、初始化</h4><p><img src=\"/.com//work1.png\" alt=\"work1\"></p>\n<p>ByteBuf 初始化后 readerIndex 和 writeIndex 的取值一开始都是 0。</p>\n<h4 id=\"2、写入数据\"><a href=\"#2、写入数据\" class=\"headerlink\" title=\"2、写入数据\"></a>2、写入数据</h4><p><img src=\"/.com//work2.png\" alt=\"work2\"></p>\n<p>写入 N 个数据后（N &lt; capacity），writerIndex &#x3D; N。</p>\n<h4 id=\"3、读取数据\"><a href=\"#3、读取数据\" class=\"headerlink\" title=\"3、读取数据\"></a>3、读取数据</h4><p><img src=\"/.com//work3.png\" alt=\"work3\"></p>\n<p>读取 M 个数据后（M &lt; writerIndex），readerIndex &#x3D; M。</p>\n<h4 id=\"4、丢弃数据\"><a href=\"#4、丢弃数据\" class=\"headerlink\" title=\"4、丢弃数据\"></a>4、丢弃数据</h4><p><img src=\"/.com//work4.png\" alt=\"work4\"></p>\n<p>读取完数据后，我们调用 <code>discardReadBytes()</code> 丢弃 0 ~ readerIndex 间的数据，相当于 readerIndex 和 writerIndex 同时向前移动 M 个字节，最后 readerIndex &#x3D; 0，writerIndex &#x3D; N - M。</p>\n<h4 id=\"5、清空数据\"><a href=\"#5、清空数据\" class=\"headerlink\" title=\"5、清空数据\"></a>5、清空数据</h4><p><img src=\"/.com//work5.png\" alt=\"work5\"></p>\n<p>当我们已经读取完所有的数据后，可以调用 <code>clear()</code> 使 ByteBuf 恢复到初始状态，这时候 readerIndex &#x3D; writerIndex &#x3D; 0。</p>\n<h4 id=\"6、注意\"><a href=\"#6、注意\" class=\"headerlink\" title=\"6、注意\"></a>6、注意</h4><ul>\n<li>调用 <code>clear() </code>的开销没有 <code>discardReadBytes() </code>那么大，因为它不需要任何内存复制。</li>\n<li>readerIndex 和 writerIndex 超过边界值，会发生 IndexOutOfBoundException 异常。</li>\n</ul>\n<h2 id=\"ByteBuf的内存管理\"><a href=\"#ByteBuf的内存管理\" class=\"headerlink\" title=\"ByteBuf的内存管理\"></a>ByteBuf的内存管理</h2><h3 id=\"ByteBuf内存类型\"><a href=\"#ByteBuf内存类型\" class=\"headerlink\" title=\"ByteBuf内存类型\"></a>ByteBuf内存类型</h3><p>ByteBuf 按照数据的存储位置，可以分为 <strong>堆缓冲区(HEAP BUFFER)<strong>、</strong>直接缓冲区(DIRECT BUFFER)</strong> 和 **复合缓冲区(COMPOSITE BUFFER)**。</p>\n<ul>\n<li><p>堆缓冲区(HEAP BUFFER)：将数据存储在 JVM 的堆内存中，这些内存需要被 jvm 管理。</p>\n</li>\n<li><p>直接缓冲区(DIRECT BUFFER)：将数据存在  JVM 的堆内存外面，这些内存不需要被 jvm 管理。</p>\n</li>\n<li><p>复合缓冲区(COMPOSITE BUFFER)：以上两种方式的混合。</p>\n</li>\n</ul>\n<h4 id=\"1-1、堆缓冲区\"><a href=\"#1-1、堆缓冲区\" class=\"headerlink\" title=\"1.1、堆缓冲区\"></a>1.1、堆缓冲区</h4><p>最常用的模式，这种模式直接将数据存储在 JVM 的堆空间中，这种情况下 ByteBuf 数组被称为支撑数组（backing array）。</p>\n<blockquote>\n<p>优点：能在没有使用池化的情况下提供快速的分配和释放，非常适合于有遗留的数据需要处理的情况。</p>\n<p>缺点：在 socket 发送前，需要先把数据拷贝到直接缓冲区，导致 IO 效率不高。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 创建支撑数组</span><br><span class=\"line\">ByteBuf buf = new UnpooledHeapByteBuf(ByteBufAllocator.DEFAULT, initalCapacity, maxCapacity);</span><br><span class=\"line\">// 检查 ByteBuf 是否有一个支撑数组，当 hasArray()方法返回 false 时，尝试访问支撑数组将触发一个 UnsupportedOperationException。</span><br><span class=\"line\">if (buf.hasArray()) &#123; </span><br><span class=\"line\">  byte[] array = buf.array();</span><br><span class=\"line\">  // 处理</span><br><span class=\"line\">  handleArray(array);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2、直接缓冲区\"><a href=\"#1-2、直接缓冲区\" class=\"headerlink\" title=\"1.2、直接缓冲区\"></a>1.2、直接缓冲区</h4><p>将数据存储在 JVM 堆以外的内存，需要调用系统级别的 API</p>\n<blockquote>\n<p>优点：免去中间交换的内存拷贝，提高 IO 速度。</p>\n<p>缺点：分配和释放代价大，下文中池化的缓冲区可以缓解这个缺点。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 创建直接缓冲区</span><br><span class=\"line\">ByteBuf buf = new UnpooledDirectByteBuf(ByteBufAllocator.DEFAULT, initalCapacity, maxCapacity);</span><br><span class=\"line\">// buf.hasArray() 为 false表示为这是直接缓冲区</span><br><span class=\"line\">if (!buf.hasArray()) &#123; </span><br><span class=\"line\">  byte[] array = buf.array();</span><br><span class=\"line\">  // 处理</span><br><span class=\"line\">  handleArray(array);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3、复合缓冲区\"><a href=\"#1-3、复合缓冲区\" class=\"headerlink\" title=\"1.3、复合缓冲区\"></a>1.3、复合缓冲区</h4><p>Netty通过ByteBuf的子类 CompositeByteBuf，提供了将多个 buffer 虚拟成一个合并的 Buffer 的技术。CompositeByteBuf 中的 ByteBuf 实例可能同时包含堆缓冲区的和直接缓冲区的。如果 CompositeByteBuf 只含有一个实例，调用 hasArray() 方法会返回这个实例的 hasArray() 方法的值；否则总是返回 false。</p>\n<p>例如一条消息包含 header 和 body 两部分，每条消息需要使用不同的 header 搭配同一个 body，就可以使用复合缓冲区。</p>\n<p>![image-20200706211316006](&#x2F;Users&#x2F;mochuangbiao&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20200706211316006.png)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CompositeByteBuf messageBuf = Unpooled.compositeBuffer();</span><br><span class=\"line\">// header使用堆内存每次分配</span><br><span class=\"line\">ByteBuf headerBuf = new UnpooledHeapByteBuf(ByteBufAllocator.DEFAULT, initalCapacity, maxCapacity);</span><br><span class=\"line\">// body需要重复使用，所以使用直接缓冲区，省去每次复制内存导致效率下降</span><br><span class=\"line\">ByteBuf bodyBuf = new UnpooledDirectByteBuf(ByteBufAllocator.DEFAULT, initalCapacity, maxCapacity);</span><br><span class=\"line\">// 将headerBuf和bodyBuf添加到CompositeByteBuf中</span><br><span class=\"line\">messageBuf.addComponents(headerBuf, bodyBuf);</span><br><span class=\"line\">.....</span><br><span class=\"line\">//遍历messageBuf中的ByteBuf</span><br><span class=\"line\">for (ByteBuf buf : messageBuf) &#123;</span><br><span class=\"line\">    System.out.println(buf.toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>按内存对象是否可以重复利用，可以分为 <strong>池化内存(Pooled)</strong> 和 **非池化内存(Unpooled)**。</p>\n<ul>\n<li>池化内存(Pooled)：每次都从预先分配好的内存中去取出一段连续内存封装成一个 ByteBuf 给应用程序使用。</li>\n<li>非池化内存(Unpooled)：每次分配内存的时候，直接调用系统 api，向操作系统申请一块内存。</li>\n</ul>\n<h4 id=\"2-1、池化内存\"><a href=\"#2-1、池化内存\" class=\"headerlink\" title=\"2.1、池化内存\"></a>2.1、池化内存</h4><p>Netty 会先向系统申请一大块内存，通过池化算法管理这块内存，并向上层提供申请内存接口。我们需要使用内存的时候，再通过接口申请一段连续内存封装成一个 ByteBuf 给应用程序使用。</p>\n<blockquote>\n<p>优点：池对象可以回收复用，提高内存分配的效率。</p>\n<p>缺点：需要对预先申请的内存进行管理。</p>\n</blockquote>\n<h4 id=\"2-2、非池化内存\"><a href=\"#2-2、非池化内存\" class=\"headerlink\" title=\"2.2、非池化内存\"></a>2.2、非池化内存</h4><p>同 java 对象的创建销毁过程，直接向 JVM 申请内存创建 ByteBuf 对象，使用完后交给 JVM 进行 gc 回收。</p>\n<blockquote>\n<p>优点：使用简单</p>\n<p>缺点：对象不能复用，创建销毁代价很大。</p>\n</blockquote>\n<h3 id=\"创建ByteBuf实例\"><a href=\"#创建ByteBuf实例\" class=\"headerlink\" title=\"创建ByteBuf实例\"></a>创建ByteBuf实例</h3><h4 id=\"1、ByteBufAllocator\"><a href=\"#1、ByteBufAllocator\" class=\"headerlink\" title=\"1、ByteBufAllocator\"></a>1、ByteBufAllocator</h4><p>Netty 为创建 ByteBuf 实例专门提供了一个接口 <strong>ByteBufAllocator</strong>，该接口有 <strong>PooledByteBufAllocator</strong> 和 <strong>UnpooledByteBufAllocator</strong> 两种实现。前者返回池化实例，后者则直接返回非池化的新实例。</p>\n<p>Netty 默认使用了池化的 ByteBufAllocator，但我们可以在 Bootstrap 配置参数来自定义使用池化还是非池化分配器。</p>\n<p>ByteBufAllocator 适用于可以获取到 channelHandlerContext 或 channel 实例的场景。</p>\n<ul>\n<li>使用 PooledByteBufAllocator 创建 ByteBuf</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 通过 channelHandlerContext 获取 allocator</span><br><span class=\"line\">ByteBufAllocator allocator1 = ctx.alloc();</span><br><span class=\"line\">// 通过 channel 获取 allocator</span><br><span class=\"line\">ByteBufAllocator allocator2 = ctx.channel().alloc();</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回一个直接内存或者堆内存对象，具体实现由 netty 根据环境自动配置</span><br><span class=\"line\">ByteBuf buf = allocator1.buffer();</span><br><span class=\"line\">// 创建直接内存对象</span><br><span class=\"line\">ByteBuf directBuf = allocator1.directBuffer();</span><br><span class=\"line\">// 创建堆内存对象</span><br><span class=\"line\">ByteBuf heapBuf = allocator1.heapBuffer();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 UnpooledByteBufAllocator 创建 ByteBuf</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 在 bootstrap 中配置参数使用 UnpooledByteBufAllocator</span><br><span class=\"line\">bootstrap.option(ChannelOption.ALLOCATOR, UnpooledByteBufAllocator.DEFAULT)</span><br><span class=\"line\"></span><br><span class=\"line\">// 后面使用同 PooledByteBufAllocator</span><br><span class=\"line\">ByteBufAllocator allocator1 = ctx.alloc();</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、Unpooled\"><a href=\"#2、Unpooled\" class=\"headerlink\" title=\"2、Unpooled\"></a>2、Unpooled</h4><p>当没有办法获取到 channelHandlerContext 或 channel 实例的时候，推荐使用 Unpooled 类来创建 ByteBuf。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 创建堆内存对象</span><br><span class=\"line\">ByteBuf heapBuf = Unpooled.buffer();</span><br><span class=\"line\">// 创建直接内存对象</span><br><span class=\"line\">ByteBuf directBuf = Unpooled.directBuffer();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ByteBuf引用计数\"><a href=\"#ByteBuf引用计数\" class=\"headerlink\" title=\"ByteBuf引用计数\"></a>ByteBuf引用计数</h3><p>上面谈到 Netty 主要有四种类型的 ByteBuf，其中 UnpooledHeapByteBuf 能够依赖 JVM GC 回收器自动回收；UnpooledDirectByteBuf 除了等 JVM GC，最好也能主动进行回收；而 PooledHeapByteBuf 和 PooledDirectByteBuf，则必须要主动将用完的 bytebuf 放回池里，如果不释放，内存池会越来越大，直到内存溢出。所以，Netty ByteBuf 需要在 JVM 的 GC 机制之外，有自己的引用计数器和回收过程（主要是回收到netty申请的内存池）。</p>\n<p>所有 ByteBuf 的引用计数器初始值为1。可以增加&#x2F;减少 ByteBuf 的引用计数器，当 ByteBuf 的引用计数器为 0 时该对象就会被释放内存或回收到内存池。访问一个被释放的 ByteBuf 会抛 IllegalReferenceCountException 异常。</p>\n<p>ByteBuf 引用计数器的常用方法有：</p>\n<ul>\n<li><code>release()</code>：计数器减1。从 InBound 里读取的 ByteBuf 和自己创建的 ByteBuf 要自己调用 <code>release()</code> 手动释放，写入到 OutBound 的 Bytebuf 例如调用 <code>writeAndFlush()</code> 由 netty 负责释放，不需要手动调用<code>release()</code>。</li>\n<li><code>retain()</code>：计数器加1。在使用派生缓冲区的时候，为了防止源 ByteBuf 突然被释放导致派生缓冲区操作异常，需要调用 <code>retain()</code> 来显示派生缓冲区的存在。</li>\n<li><code>refCnt()</code>：返回计数器的值。</li>\n<li><code>copy()</code>：返回源 ByteBuf 的完全拷贝。该拷贝和源 ByteBuf 完全独立，在新 ByteBuf 上修改不会影响旧 ByteBuf。</li>\n</ul>\n<p>以上方法都是直接在原生内存上进行操作，ByteBuf 还提供了一种视图的方式来读写内容，这种视图被称作<strong>派生缓冲区</strong>。派生缓冲区维护单独的 readIndex、writeIndex 和 markIndex，但与原生 ByteBuf 共享数据和引用计数器，这意味着派生缓冲区的创建开销很低，但是如果修改了其他内容，也同时修改对应的原生 ByteBuf。派生缓冲区的常用方法有：</p>\n<ul>\n<li><code>duplicate()</code>：返回源 ByteBuf 的完全拷贝的派生缓冲区区。该方法内部不会调用 <code>retain()</code> 方法，所以计数器不会增加。</li>\n<li><code>slice()</code>：返回源 ByteBuf 已经写入数据区域的拷贝的派生缓冲区。该方法内部不会调用 <code>retain()</code> 方法，所以计数器不会增加。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>ByteBuf 本质是一个由不同的索引分别控制读访问和写访问的字节数组。</li>\n<li>ByteBuf 有 readerIndex、writerIndex 和 capacity 三个参数，这三个负责控制 ByteBuf 的读写操作。</li>\n<li>ByteBuf 的内存管理，按照数据的存储位置，可以分为堆缓冲区、直接缓冲区和复合缓冲区；按内存对象是否可以重复利用，可以分为池化内存和非池化内存。</li>\n<li>创建 ByteBuf 实例，可以使用 ByteBufAllocator 接口或者 Unpooled 工具类。</li>\n<li>ByteBuf 具有引用计数器的概念，当引用计数器为 0 时 ByteBuf 对象会被回收。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href>《Netty In Action》</a></p>\n<p><a href=\"https://www.jianshu.com/p/3fbf54b8e8ec\">ByteBuf：Netty的数据容器</a></p>\n<p><a href=\"https://www.dazhuanlan.com/2019/11/09/5dc5cfc71d669/\">ByteBuf工作原理</a></p>\n<p><a href=\"https://www.jianshu.com/p/175cd3644728\">ByteBuf : Netty的数据容器类</a></p>\n","categories":["Netty"],"tags":["Netty"]},{"title":"Netty系列（六）：Channel","url":"/2020/06/09/Netty%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AChannel/","content":"<blockquote>\n<p>上一篇介绍了 Netty 的线程模型 EventLoop 和 EventLoopGroup，本文开始介绍 Netty 的传输流组件 Channel 以及相关组件 ChannelHandler、ChannelHandlerContext、ChannelPipline 和 ChannelFuture 等。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><h3 id=\"Channel是什么\"><a href=\"#Channel是什么\" class=\"headerlink\" title=\"Channel是什么\"></a>Channel是什么</h3><p>Channel 是一个管道，用于连接字节缓冲区 Buf 和另一端的实体，这个实例可以是 Socket，也可以是 File，在 NIO 网络编程模型中，服务端和客户端进行 IO 数据交互(得到彼此推送的信息)的媒介就是 Channel。</p>\n<p>Netty 对 NIO 的原生的 Channel 进行了封装和增强封装成 NioXXXChannel，相对于原生的 Channel，Netty 的 Channel 增加了如下的组件：</p>\n<ul>\n<li>id 标识唯一身份信息</li>\n<li>可能存在的 parent Channel</li>\n<li>管道 pepiline</li>\n<li>用于数据读写的 unsafe 内部类</li>\n<li>关联上相伴终生的 NioEventLoop</li>\n</ul>\n<h3 id=\"Channel的工作流程\"><a href=\"#Channel的工作流程\" class=\"headerlink\" title=\"Channel的工作流程\"></a>Channel的工作流程</h3><p>Channel 本身做的事情不多，主要通过其包含的成员完成大量工作，包含的主要成员如下：</p>\n<ul>\n<li>EventLoop：每个 Channel 整个生命周期都绑定到一个特定的 EventLoop。</li>\n<li>Unsafe：承担 Channel 网络相关的功能，例如真正的网络读写操作。</li>\n<li>DefaultChannelPipeLine：每个 Channel 绑定到一个 ChannelPipeLine，Channel 在生命周期的大部分动作都通过调用 ChannelPipeLine 的方法来完成。</li>\n</ul>\n<p>Channel 通过调用成员，可以完成以下工作流程： </p>\n<ul>\n<li>一旦用户端连接成功，将新建一个 Channel 同该用户端进行绑定。</li>\n<li>Channel 从 EventLoopGroup 获得一个 EventLoop，并注册到该 EventLoop，Channel 生命周期内都和该 EventLoop 在一起（注册时获得 selectionKey）。</li>\n<li>Channel 同用户端进行网络连接、关闭和读写，生成相对应的 event（改变 selectinKey 信息），触发eventloop调度线程进行执行。</li>\n</ul>\n<h3 id=\"Channel的分类\"><a href=\"#Channel的分类\" class=\"headerlink\" title=\"Channel的分类\"></a>Channel的分类</h3><p>Netty 中的 Channel 有很多种类型。</p>\n<p>从 IO 类型来说，分为同步（Oio）和异步（Nio）两种类型。一般情况下我们都会使用异步的 Channel，特殊情况下需要切换成同步通讯时，我们只需要修改 Channel 的类型即可，所以在 Netty 通讯中同步和异步的切换非常灵活。</p>\n<p>从数据传输类型来说，分为按事件消息传递（Message）以及按字节传递（Byte）两种类型。</p>\n<p>从使用角色类型来说，分为服务器（ServerSocket）以及客户端（Socket）两种。</p>\n<p>从使用协议类型来说，分为 TCP、UDT 和 SCTP 协议等。</p>\n<p>Channel 的具体实现类如下：</p>\n<ul>\n<li>NioSocketChannel：异步的客户端 TCP Socket 连接</li>\n<li>NioServerSocketChannel：异步的服务器端 TCP Socket 连接</li>\n<li>NioDatagramChannel：异步的 UDP 连接</li>\n<li>NioSctpChannel：异步的客户端 Sctp 连接</li>\n<li>NioSctpServerChannel：异步的 Sctp 服务器端连接</li>\n<li>OioSocketChannel：同步的客户端 TCP Socket 连接</li>\n<li>OioServerSocketChannel：同步的服务器端 TCP Socket 连接</li>\n<li>OioDatagramChannel：同步的 UDP 连接</li>\n<li>OioSctpChannel：同步的 Sctp 服务器端连接</li>\n<li>OioSctpServerChannel：同步的客户端 TCP Socket 连接</li>\n</ul>\n<h3 id=\"Channel-整体结构图\"><a href=\"#Channel-整体结构图\" class=\"headerlink\" title=\"Channel 整体结构图\"></a>Channel 整体结构图</h3><p><img src=\"/.com//channel1.png\" alt=\"channel1\"></p>\n<p>一个 Channel 里面包含 ChannelPipeLine、ChannelHandler 和 ChannelHandlerContext 等组件，组件间的关系如下：</p>\n<ul>\n<li>一个 Channel 绑定到一个 ChannelPipeLine 上，Channel 的大部分功能都通过调用 ChannelPipeLine 的方法来完成。</li>\n<li>一个 ChannelPipeLine 通过 filter 的模式把一到多个 ChannelHandler 组织到一起，ChannelHandler 之间不会产生直接关联。</li>\n<li>把一个 ChannelHandler 添加到 ChannelPipeLine 的时候，会生成一个 ChannelHandlerContext 和该 ChannelHandler 对应。ChannelHandlerContext 是一个双向链表，使前后的 ChannelHandler 产生关联。</li>\n</ul>\n<p>因为 ChannelHandler 都是通过 ChannelHandlerContext 产生关联 ，所以事件在 Channel 中进行传播的过程，实际上是通过 ChannelHandlerContext 来完成的。</p>\n<p><img src=\"/.com//channel2.png\" alt=\"channel2\"></p>\n<p>下面我们简单介绍一下 Channel 的主要组件。</p>\n<h2 id=\"ChannelPipline\"><a href=\"#ChannelPipline\" class=\"headerlink\" title=\"ChannelPipline\"></a>ChannelPipline</h2><p>ChannelPipline 可以理解为拦截流经 Channel 的入站和出站事件的 <strong>ChannelHandler实例链</strong> ，ChannelPipline 的官方结构图如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                                    I/O Request  via Channel or  ChannelHandlerContext</span><br><span class=\"line\">                                                  |</span><br><span class=\"line\">+---------------------------------------------------+---------------+</span><br><span class=\"line\">|                           ChannelPipeline         |               |</span><br><span class=\"line\">|                                                  \\|/              |</span><br><span class=\"line\">|    +---------------------+            +-----------+----------+    |</span><br><span class=\"line\">|    | Inbound Handler  N  |            | Outbound Handler  1  |    |</span><br><span class=\"line\">|    +----------+----------+            +-----------+----------+    |</span><br><span class=\"line\">|              /|\\                                  |               |</span><br><span class=\"line\">|               |                                  \\|/              |</span><br><span class=\"line\">|    +----------+----------+            +-----------+----------+    |</span><br><span class=\"line\">|    | Inbound Handler N-1 |            | Outbound Handler  2  |    |</span><br><span class=\"line\">|    +----------+----------+            +-----------+----------+    |</span><br><span class=\"line\">|              /|\\                                  .               |</span><br><span class=\"line\">|               .                                   .               |</span><br><span class=\"line\">| ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class=\"line\">|        [ method call]                       [method call]         |</span><br><span class=\"line\">|               .                                   .               |</span><br><span class=\"line\">|               .                                  \\|/              |</span><br><span class=\"line\">|    +----------+----------+            +-----------+----------+    |</span><br><span class=\"line\">|    | Inbound Handler  2  |            | Outbound Handler M-1 |    |</span><br><span class=\"line\">|    +----------+----------+            +-----------+----------+    |</span><br><span class=\"line\">|              /|\\                                  |               |</span><br><span class=\"line\">|               |                                  \\|/              |</span><br><span class=\"line\">|    +----------+----------+            +-----------+----------+    |</span><br><span class=\"line\">|    | Inbound Handler  1  |            | Outbound Handler  M  |    |</span><br><span class=\"line\">|    +----------+----------+            +-----------+----------+    |</span><br><span class=\"line\">|              /|\\                                  |               |</span><br><span class=\"line\">+---------------+-----------------------------------+---------------+</span><br><span class=\"line\">              |                                  \\|/</span><br><span class=\"line\">+---------------+-----------------------------------+---------------+</span><br><span class=\"line\">|               |                                   |               |</span><br><span class=\"line\">|       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class=\"line\">|                                                                   |</span><br><span class=\"line\">|  Netty Internal I/O Threads (Transport Implementation)            |</span><br><span class=\"line\">+-------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，流经 ChannelPipline 的事件分为 Inbound 和 Outbound 两种类型，Inbound 事件的流向是从下至上，而 Outbound 刚好相反。Inbound 的传递方式是通过调用相应的 <strong>ChannelHandlerContext.fireIN_EVT()</strong> 方法，而 Outbound 方法的的传递方式是通过调用 <strong>ChannelHandlerContext.OUT_EVT()</strong> 方法。例如 <strong>ChannelHandlerContext.fireChannelRegistered()</strong> 调用会发送一个 <strong>ChannelRegistered</strong> 的 Inbound 事件给下一个ChannelHandlerContext，而 <strong>ChannelHandlerContext.bind</strong> 调用会发送一个 <strong>bind</strong> 的 Outbound 事件给 下一个 ChannelHandlerContext。</p>\n<p>在 ChannelPipeline 传播事件时，它会测试 ChannelPipeline 中的下一个 ChannelHandler 的类型是否和事件的运动方向相匹配。如果不匹配，ChannelPipeline 将跳过该 ChannelHandler 并前进到下一个，直到它找到和该事件所期望的方向相匹配的为止。</p>\n<p>DefaultChannelPipeline 是 ChannelPipeline 的默认实现类，新建 Channel 时默认，部分源码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">final class DefaultChannelPipeline implements ChannelPipeline &#123;</span><br><span class=\"line\">    private static final WeakHashMap&lt;Class&lt;?&gt;, String&gt;[] nameCaches = new WeakHashMap[Runtime.getRuntime().availableProcessors()];</span><br><span class=\"line\"></span><br><span class=\"line\">    final AbstractChannel channel;</span><br><span class=\"line\"></span><br><span class=\"line\">    final DefaultChannelHandlerContext head;</span><br><span class=\"line\">    final DefaultChannelHandlerContext tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final Map&lt;String, DefaultChannelHandlerContext&gt; name2ctx = new HashMap&lt;String, DefaultChannelHandlerContext&gt;(4);</span><br><span class=\"line\"></span><br><span class=\"line\">    final Map&lt;EventExecutorGroup, ChannelHandlerInvoker&gt; childInvokers = new IdentityHashMap&lt;EventExecutorGroup, ChannelHandlerInvoker&gt;();</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 DefaultChannelPipeline 构造器中，首先将与之关联的 Channel 保存到字段 channel 中，然后实例化两个 ChannelHandlerContext，一个是 HeadContext 实例 head，另一个是 TailContext 实例 tail。接着将 head 和 tail 互相指向，构成一个双向链表。<strong>这个链表是 Netty 实现 Pipeline 机制的关键</strong>。</p>\n<h2 id=\"ChannelHandler\"><a href=\"#ChannelHandler\" class=\"headerlink\" title=\"ChannelHandler\"></a>ChannelHandler</h2><p>ChannelHandler 是 Channel 的核心，<strong>数据编解码和所有的业务逻辑都需要通过自定义 ChannelHandler 来实现</strong>。</p>\n<p>ChannelHandler 分为 ChannelInboundHandler 和 ChannelOutboundHandler：</p>\n<ul>\n<li>ChannelInboundHandler：处理入站事件，如链路建立、链路关闭或者读完成等事件。</li>\n<li>ChannelOutboundHandler：处理出站事件，如由用户线程或者代码发起的 IO 操作事件。</li>\n</ul>\n<p>其中 ChannelOutboundHandler 用的比较少（Netty 5 后面已经有废弃的趋势），下面介绍下 ChannelInboundHandler 的生命周期：</p>\n<p><img src=\"/Users/mochuangbiao/Library/Application%20Support/typora-user-images/image-20200701181542816.png\" alt=\"image-20200701181542816\"></p>\n<ol>\n<li>handlerAdded：新建立的连接会按照初始化策略，把 handler 添加到该 channel 的 pipeline 里面，也就是 channel.pipeline.addLast(new LifeCycleInBoundHandler) 执行完成后的回调；</li>\n<li>channelRegistered：当该连接分配到具体的 worker 线程后，该回调会被调用。</li>\n<li>channelActive：channel 的准备工作已经完成，所有的 pipeline 添加完成，并分配到具体的线上上，说明该 channel 准备就绪，可以使用了。</li>\n<li>channelRead：客户端向服务端发来数据，每次都会回调此方法，表示有数据可读；</li>\n<li>channelReadComplete：服务端每次读完一次完整的数据之后，回调该方法，表示数据读取完毕；</li>\n<li>channelInactive：当连接断开时，该回调会被调用，说明这时候底层的TCP连接已经被断开了。</li>\n<li>channelUnREgistered：对应 channelRegistered，当连接关闭后，释放绑定的workder线程；</li>\n<li>handlerRemoved：对应 handlerAdded，将 handler 从该 channel 的 pipeline 移除后的回调方法。</li>\n</ol>\n<p>ChannelInboundHandler 的生命周期里面除了正常的读写流程外， 还提供了定时处理和异常处理的方法：</p>\n<ol>\n<li>userEventTriggered：处理心跳超时事件，在 IdleStateHandler 设置超时时间，达到了超时时间就会直接调用该方法。</li>\n<li>exceptionCaught：处理连接出现的异常情况。</li>\n</ol>\n<h2 id=\"ChannelHandlerContext\"><a href=\"#ChannelHandlerContext\" class=\"headerlink\" title=\"ChannelHandlerContext\"></a>ChannelHandlerContext</h2><p>ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandlerContext。<strong>ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互</strong>。</p>\n<p>我们可以通过 ChannelHandlerContext 来获取整个 Channel 的上下文属性。例如通过 ChannelHandlerContext 来访问 Channel：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//获取到与 ChannelHandlerContext相关联的 Channel 的引用</span><br><span class=\"line\">ChannelHandlerContext ctx = ..;</span><br><span class=\"line\">Channel channel = ctx.channel();</span><br><span class=\"line\">//通过 Channel 写入缓冲区</span><br><span class=\"line\">channel.write(Unpooled.copiedBuffer(&quot;Netty in Action&quot;, CharsetUtil.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p>通过 ChannelHandlerContext 访问 ChannelPipeline：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//获取到与 ChannelHandlerContext相关联的 ChannelPipeline 的引用</span><br><span class=\"line\">ChannelHandlerContext ctx = ..;</span><br><span class=\"line\">ChannelPipeline pipeline = ctx.pipeline();</span><br><span class=\"line\">//通过 ChannelPipeline写入缓冲区</span><br><span class=\"line\">pipeline.write(Unpooled.copiedBuffer(&quot;Netty in Action&quot;, CharsetUtil.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p>最开始的时候 ChannelPipeline 中含有 head 和 tail 两个 ChannelHandlerContext(同时也是 ChannelHandler)，但是这个 Pipeline并不能实现什么特殊的功能，因为我们还没有给它添加自定义的 ChannelHandler。通常来说，我们在初始化 Bootstrap，会添加我们自定义的 ChannelHandler。</p>\n<p>如果你在 Channel 或者 ChannelPipeline 实例上调用这些方法，它们的调用会穿过整个 pipeline。而在 ChannelHandlerContext 上调用的同样的方法，仅仅从当前 ChannelHandler 开始，走到 pipeline 中下一个可以处理这个 event 的 ChannelHandler。例如调用 <code>ctx.writeAndFlush</code>，是从当前 handler 直接发出这个消息，而调用 <code>channel.writeAndFlush</code> 是从整个 pipline 最后一个 outhandler 发出消息。</p>\n<h2 id=\"ChannelFuture、ChannelPromise\"><a href=\"#ChannelFuture、ChannelPromise\" class=\"headerlink\" title=\"ChannelFuture、ChannelPromise\"></a>ChannelFuture、ChannelPromise</h2><p>ChannelFuture 的作用是用来保存 Channel 异步操作的结果。</p>\n<p>在 Netty 中所有的 I&#x2F;O 操作都是异步的。这意味着任何的 I&#x2F;O 调用都将立即返回，而不保证这些被请求的 I&#x2F;O 操作在调用结束的时候已经完成。取而代之地，你会得到一个返回的 ChannelFuture 实例，这个实例将给你一些关于 I&#x2F;O 操作结果或者状态的信息。下面是官方关于 ChannelFuture 的状态迁移图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                                     +---------------------------+</span><br><span class=\"line\">                                     | Completed successfully    |</span><br><span class=\"line\">                                     +---------------------------+</span><br><span class=\"line\">                                +----&gt;      isDone() = true      |</span><br><span class=\"line\">+--------------------------+    |    |   isSuccess() = true      |</span><br><span class=\"line\">|        Uncompleted       |    |    +===========================+</span><br><span class=\"line\">+--------------------------+    |    | Completed with failure    |</span><br><span class=\"line\">|      isDone() = false    |    |    +---------------------------+</span><br><span class=\"line\">|   isSuccess() = false    |----+----&gt;      isDone() = true      |</span><br><span class=\"line\">| isCancelled() = false    |    |    |       cause() = non-null  |</span><br><span class=\"line\">|       cause() = null     |    |    +===========================+</span><br><span class=\"line\">+--------------------------+    |    | Completed by cancellation |</span><br><span class=\"line\">                                |    +---------------------------+</span><br><span class=\"line\">                                +----&gt;      isDone() = true      |</span><br><span class=\"line\">                                     | isCancelled() = true      |</span><br><span class=\"line\">                                     +---------------------------+</span><br></pre></td></tr></table></figure>\n\n<p>ChannelFuture 有 <code>Completed</code> 和 <code>Uncompleted</code> 两种父状态，父状态下分为 <code>isDone</code>、<code>isSuccess</code>、<code>isCancelled</code> 和 <code>cause</code> 四种子状态</p>\n<ul>\n<li>ChannelFuture 新创建的时候是 <code>Uncompleted</code> 状态，这个时候子状态 为<code>isDone</code>、<code>isSuccess</code> 和 <code>isCancelled</code>  都是 false，<code>cause</code> 是一个 null 值。</li>\n<li>当 ChannelFuture 变成 <code>completed</code> 状态并且结果成功，<code>isDone</code> 和 <code>isSuccess</code>  变成 true。</li>\n<li>当 ChannelFuture 变成 <code>completed</code> 状态并且结果失败，<code>isDone</code> 变成 true，<code>cause</code> 为非 null 值。</li>\n<li>当 ChannelFuture 变成 <code>completed</code> 状态并且结果取消，<code>isDone</code> 和 <code>isCancelled</code>  变成 true。</li>\n</ul>\n<p>我们创建 ChannelFuture 一般会使用 <code>addListener(GenericFutureListener)</code> 为 ChannelFuture 添加监听器，监听 ChannelFuture 的结果状态变化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ChannelFuture future = bootstrap.connect(serverIp, serverPort).sync();</span><br><span class=\"line\">future.addListener(new ChannelFutureListener() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class=\"line\">        log.info(&quot;连接服务器成功&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>ChannelPromise 是 ChannelFuture 的子类，ChannelFuture 是只读的，而 ChannelPromise 是可写的，提供了 <code>setSuccess</code> 和 <code>setFailure</code> 等方法对结果进行修改。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>Channel 是 Netty 的通讯载体，是对 NIO 原生 Channel 的二次封装，提供更完善的功能。</li>\n<li>Channel 有很多类型，比较常用的有 NioSocketChannel 和 NioServerSocketChannel。</li>\n<li>一个 Channel 在创建之后整个生命周期都绑定到一个特定的 EventLoop。</li>\n<li>一个 Channel 对应一个 ChannelPipeLine。</li>\n<li>一个 ChannelPipeLine 通过 filter 的模式把一到多个 ChannelHandler 组织到一起，ChannelHandler 之间不会产生直接关联。</li>\n<li>每个 ChannelHandler 对应一个 ChannelHandlerContext，通过 ChannelHandlerContext 使前后的 ChannelHandler 产生关联。</li>\n<li>ChannelFuture 的作用是用来保存 Channel 异步操作的结果，ChannelPromise 提供了可写的方法。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href>《Netty in Action》</a></p>\n<p><a href=\"https://jianyuan.fun/post/netty-channel-lifecycle/\">Netty Channel的生命周期</a></p>\n<p><a href=\"https://www.cnblogs.com/lighten/p/8950347.html\">Netty核心概念(5)之Channel</a></p>\n<p><a href=\"https://www.cnblogs.com/duanxz/p/3724247.html\">netty中的Channel、ChannelPipeline</a></p>\n","categories":["Netty"],"tags":["Netty"]}]